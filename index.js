var eb = Object.defineProperty;
var ib = (e,t,i)=>t in e ? eb(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: i
}) : e[t] = i;
var I = (e,t,i)=>(ib(e, typeof t != "symbol" ? t + "" : t, i),
i);
const sb = function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload"))
        return;
    for (const n of document.querySelectorAll('link[rel="modulepreload"]'))
        s(n);
    new MutationObserver(n=>{
        for (const r of n)
            if (r.type === "childList")
                for (const o of r.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && s(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function i(n) {
        const r = {};
        return n.integrity && (r.integrity = n.integrity),
        n.referrerpolicy && (r.referrerPolicy = n.referrerpolicy),
        n.crossorigin === "use-credentials" ? r.credentials = "include" : n.crossorigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin",
        r
    }
    function s(n) {
        if (n.ep)
            return;
        n.ep = !0;
        const r = i(n);
        fetch(n.href, r)
    }
};
sb();
var li = "top"
  , Ii = "bottom"
  , Mi = "right"
  , ci = "left"
  , Bc = "auto"
  , Bo = [li, Ii, Mi, ci]
  , Sr = "start"
  , xo = "end"
  , g0 = "clippingParents"
  , Yd = "viewport"
  , Kr = "popper"
  , v0 = "reference"
  , Su = Bo.reduce(function(e, t) {
    return e.concat([t + "-" + Sr, t + "-" + xo])
}, [])
  , Kd = [].concat(Bo, [Bc]).reduce(function(e, t) {
    return e.concat([t, t + "-" + Sr, t + "-" + xo])
}, [])
  , _0 = "beforeRead"
  , y0 = "read"
  , b0 = "afterRead"
  , x0 = "beforeMain"
  , w0 = "main"
  , T0 = "afterMain"
  , E0 = "beforeWrite"
  , S0 = "write"
  , C0 = "afterWrite"
  , A0 = [_0, y0, b0, x0, w0, T0, E0, S0, C0];
function Os(e) {
    return e ? (e.nodeName || "").toLowerCase() : null
}
function ps(e) {
    if (e == null)
        return window;
    if (e.toString() !== "[object Window]") {
        var t = e.ownerDocument;
        return t && t.defaultView || window
    }
    return e
}
function wo(e) {
    var t = ps(e).Element;
    return e instanceof t || e instanceof Element
}
function zi(e) {
    var t = ps(e).HTMLElement;
    return e instanceof t || e instanceof HTMLElement
}
function Zd(e) {
    if (typeof ShadowRoot > "u")
        return !1;
    var t = ps(e).ShadowRoot;
    return e instanceof t || e instanceof ShadowRoot
}
function nb(e) {
    var t = e.state;
    Object.keys(t.elements).forEach(function(i) {
        var s = t.styles[i] || {}
          , n = t.attributes[i] || {}
          , r = t.elements[i];
        !zi(r) || !Os(r) || (Object.assign(r.style, s),
        Object.keys(n).forEach(function(o) {
            var a = n[o];
            a === !1 ? r.removeAttribute(o) : r.setAttribute(o, a === !0 ? "" : a)
        }))
    })
}
function rb(e) {
    var t = e.state
      , i = {
        popper: {
            position: t.options.strategy,
            left: "0",
            top: "0",
            margin: "0"
        },
        arrow: {
            position: "absolute"
        },
        reference: {}
    };
    return Object.assign(t.elements.popper.style, i.popper),
    t.styles = i,
    t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow),
    function() {
        Object.keys(t.elements).forEach(function(s) {
            var n = t.elements[s]
              , r = t.attributes[s] || {}
              , o = Object.keys(t.styles.hasOwnProperty(s) ? t.styles[s] : i[s])
              , a = o.reduce(function(l, c) {
                return l[c] = "",
                l
            }, {});
            !zi(n) || !Os(n) || (Object.assign(n.style, a),
            Object.keys(r).forEach(function(l) {
                n.removeAttribute(l)
            }))
        })
    }
}
var qd = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: nb,
    effect: rb,
    requires: ["computeStyles"]
};
function Rs(e) {
    return e.split("-")[0]
}
var vr = Math.max
  , cc = Math.min
  , To = Math.round;
function Eo(e, t) {
    t === void 0 && (t = !1);
    var i = e.getBoundingClientRect()
      , s = 1
      , n = 1;
    if (zi(e) && t) {
        var r = e.offsetHeight
          , o = e.offsetWidth;
        o > 0 && (s = To(i.width) / o || 1),
        r > 0 && (n = To(i.height) / r || 1)
    }
    return {
        width: i.width / s,
        height: i.height / n,
        top: i.top / n,
        right: i.right / s,
        bottom: i.bottom / n,
        left: i.left / s,
        x: i.left / s,
        y: i.top / n
    }
}
function Jd(e) {
    var t = Eo(e)
      , i = e.offsetWidth
      , s = e.offsetHeight;
    return Math.abs(t.width - i) <= 1 && (i = t.width),
    Math.abs(t.height - s) <= 1 && (s = t.height),
    {
        x: e.offsetLeft,
        y: e.offsetTop,
        width: i,
        height: s
    }
}
function I0(e, t) {
    var i = t.getRootNode && t.getRootNode();
    if (e.contains(t))
        return !0;
    if (i && Zd(i)) {
        var s = t;
        do {
            if (s && e.isSameNode(s))
                return !0;
            s = s.parentNode || s.host
        } while (s)
    }
    return !1
}
function Js(e) {
    return ps(e).getComputedStyle(e)
}
function ob(e) {
    return ["table", "td", "th"].indexOf(Os(e)) >= 0
}
function Fn(e) {
    return ((wo(e) ? e.ownerDocument : e.document) || window.document).documentElement
}
function Uc(e) {
    return Os(e) === "html" ? e : e.assignedSlot || e.parentNode || (Zd(e) ? e.host : null) || Fn(e)
}
function Rp(e) {
    return !zi(e) || Js(e).position === "fixed" ? null : e.offsetParent
}
function ab(e) {
    var t = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1
      , i = navigator.userAgent.indexOf("Trident") !== -1;
    if (i && zi(e)) {
        var s = Js(e);
        if (s.position === "fixed")
            return null
    }
    var n = Uc(e);
    for (Zd(n) && (n = n.host); zi(n) && ["html", "body"].indexOf(Os(n)) < 0; ) {
        var r = Js(n);
        if (r.transform !== "none" || r.perspective !== "none" || r.contain === "paint" || ["transform", "perspective"].indexOf(r.willChange) !== -1 || t && r.willChange === "filter" || t && r.filter && r.filter !== "none")
            return n;
        n = n.parentNode
    }
    return null
}
function Wa(e) {
    for (var t = ps(e), i = Rp(e); i && ob(i) && Js(i).position === "static"; )
        i = Rp(i);
    return i && (Os(i) === "html" || Os(i) === "body" && Js(i).position === "static") ? t : i || ab(e) || t
}
function Qd(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
}
function wa(e, t, i) {
    return vr(e, cc(t, i))
}
function lb(e, t, i) {
    var s = wa(e, t, i);
    return s > i ? i : s
}
function M0() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}
function R0(e) {
    return Object.assign({}, M0(), e)
}
function k0(e, t) {
    return t.reduce(function(i, s) {
        return i[s] = e,
        i
    }, {})
}
var cb = function(t, i) {
    return t = typeof t == "function" ? t(Object.assign({}, i.rects, {
        placement: i.placement
    })) : t,
    R0(typeof t != "number" ? t : k0(t, Bo))
};
function hb(e) {
    var t, i = e.state, s = e.name, n = e.options, r = i.elements.arrow, o = i.modifiersData.popperOffsets, a = Rs(i.placement), l = Qd(a), c = [ci, Mi].indexOf(a) >= 0, h = c ? "height" : "width";
    if (!(!r || !o)) {
        var u = cb(n.padding, i)
          , d = Jd(r)
          , f = l === "y" ? li : ci
          , p = l === "y" ? Ii : Mi
          , m = i.rects.reference[h] + i.rects.reference[l] - o[l] - i.rects.popper[h]
          , g = o[l] - i.rects.reference[l]
          , y = Wa(r)
          , x = y ? l === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0
          , v = m / 2 - g / 2
          , _ = u[f]
          , C = x - d[h] - u[p]
          , k = x / 2 - d[h] / 2 + v
          , S = wa(_, k, C)
          , T = l;
        i.modifiersData[s] = (t = {},
        t[T] = S,
        t.centerOffset = S - k,
        t)
    }
}
function ub(e) {
    var t = e.state
      , i = e.options
      , s = i.element
      , n = s === void 0 ? "[data-popper-arrow]" : s;
    n != null && (typeof n == "string" && (n = t.elements.popper.querySelector(n),
    !n) || !I0(t.elements.popper, n) || (t.elements.arrow = n))
}
var P0 = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: hb,
    effect: ub,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};
function So(e) {
    return e.split("-")[1]
}
var db = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};
function fb(e) {
    var t = e.x
      , i = e.y
      , s = window
      , n = s.devicePixelRatio || 1;
    return {
        x: To(t * n) / n || 0,
        y: To(i * n) / n || 0
    }
}
function kp(e) {
    var t, i = e.popper, s = e.popperRect, n = e.placement, r = e.variation, o = e.offsets, a = e.position, l = e.gpuAcceleration, c = e.adaptive, h = e.roundOffsets, u = e.isFixed, d = o.x, f = d === void 0 ? 0 : d, p = o.y, m = p === void 0 ? 0 : p, g = typeof h == "function" ? h({
        x: f,
        y: m
    }) : {
        x: f,
        y: m
    };
    f = g.x,
    m = g.y;
    var y = o.hasOwnProperty("x")
      , x = o.hasOwnProperty("y")
      , v = ci
      , _ = li
      , C = window;
    if (c) {
        var k = Wa(i)
          , S = "clientHeight"
          , T = "clientWidth";
        if (k === ps(i) && (k = Fn(i),
        Js(k).position !== "static" && a === "absolute" && (S = "scrollHeight",
        T = "scrollWidth")),
        k = k,
        n === li || (n === ci || n === Mi) && r === xo) {
            _ = Ii;
            var L = u && k === C && C.visualViewport ? C.visualViewport.height : k[S];
            m -= L - s.height,
            m *= l ? 1 : -1
        }
        if (n === ci || (n === li || n === Ii) && r === xo) {
            v = Mi;
            var D = u && k === C && C.visualViewport ? C.visualViewport.width : k[T];
            f -= D - s.width,
            f *= l ? 1 : -1
        }
    }
    var O = Object.assign({
        position: a
    }, c && db)
      , K = h === !0 ? fb({
        x: f,
        y: m
    }) : {
        x: f,
        y: m
    };
    if (f = K.x,
    m = K.y,
    l) {
        var P;
        return Object.assign({}, O, (P = {},
        P[_] = x ? "0" : "",
        P[v] = y ? "0" : "",
        P.transform = (C.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)",
        P))
    }
    return Object.assign({}, O, (t = {},
    t[_] = x ? m + "px" : "",
    t[v] = y ? f + "px" : "",
    t.transform = "",
    t))
}
function pb(e) {
    var t = e.state
      , i = e.options
      , s = i.gpuAcceleration
      , n = s === void 0 ? !0 : s
      , r = i.adaptive
      , o = r === void 0 ? !0 : r
      , a = i.roundOffsets
      , l = a === void 0 ? !0 : a
      , c = {
        placement: Rs(t.placement),
        variation: So(t.placement),
        popper: t.elements.popper,
        popperRect: t.rects.popper,
        gpuAcceleration: n,
        isFixed: t.options.strategy === "fixed"
    };
    t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, kp(Object.assign({}, c, {
        offsets: t.modifiersData.popperOffsets,
        position: t.options.strategy,
        adaptive: o,
        roundOffsets: l
    })))),
    t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, kp(Object.assign({}, c, {
        offsets: t.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
    })))),
    t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-placement": t.placement
    })
}
var tf = {
    name: "computeStyles",
    enabled: !0,
    phase: "beforeWrite",
    fn: pb,
    data: {}
}
  , nl = {
    passive: !0
};
function mb(e) {
    var t = e.state
      , i = e.instance
      , s = e.options
      , n = s.scroll
      , r = n === void 0 ? !0 : n
      , o = s.resize
      , a = o === void 0 ? !0 : o
      , l = ps(t.elements.popper)
      , c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return r && c.forEach(function(h) {
        h.addEventListener("scroll", i.update, nl)
    }),
    a && l.addEventListener("resize", i.update, nl),
    function() {
        r && c.forEach(function(h) {
            h.removeEventListener("scroll", i.update, nl)
        }),
        a && l.removeEventListener("resize", i.update, nl)
    }
}
var ef = {
    name: "eventListeners",
    enabled: !0,
    phase: "write",
    fn: function() {},
    effect: mb,
    data: {}
}
  , gb = {
    left: "right",
    right: "left",
    bottom: "top",
    top: "bottom"
};
function jl(e) {
    return e.replace(/left|right|bottom|top/g, function(t) {
        return gb[t]
    })
}
var vb = {
    start: "end",
    end: "start"
};
function Pp(e) {
    return e.replace(/start|end/g, function(t) {
        return vb[t]
    })
}
function sf(e) {
    var t = ps(e)
      , i = t.pageXOffset
      , s = t.pageYOffset;
    return {
        scrollLeft: i,
        scrollTop: s
    }
}
function nf(e) {
    return Eo(Fn(e)).left + sf(e).scrollLeft
}
function _b(e) {
    var t = ps(e)
      , i = Fn(e)
      , s = t.visualViewport
      , n = i.clientWidth
      , r = i.clientHeight
      , o = 0
      , a = 0;
    return s && (n = s.width,
    r = s.height,
    /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = s.offsetLeft,
    a = s.offsetTop)),
    {
        width: n,
        height: r,
        x: o + nf(e),
        y: a
    }
}
function yb(e) {
    var t, i = Fn(e), s = sf(e), n = (t = e.ownerDocument) == null ? void 0 : t.body, r = vr(i.scrollWidth, i.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0), o = vr(i.scrollHeight, i.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0), a = -s.scrollLeft + nf(e), l = -s.scrollTop;
    return Js(n || i).direction === "rtl" && (a += vr(i.clientWidth, n ? n.clientWidth : 0) - r),
    {
        width: r,
        height: o,
        x: a,
        y: l
    }
}
function rf(e) {
    var t = Js(e)
      , i = t.overflow
      , s = t.overflowX
      , n = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(i + n + s)
}
function L0(e) {
    return ["html", "body", "#document"].indexOf(Os(e)) >= 0 ? e.ownerDocument.body : zi(e) && rf(e) ? e : L0(Uc(e))
}
function Ta(e, t) {
    var i;
    t === void 0 && (t = []);
    var s = L0(e)
      , n = s === ((i = e.ownerDocument) == null ? void 0 : i.body)
      , r = ps(s)
      , o = n ? [r].concat(r.visualViewport || [], rf(s) ? s : []) : s
      , a = t.concat(o);
    return n ? a : a.concat(Ta(Uc(o)))
}
function Cu(e) {
    return Object.assign({}, e, {
        left: e.x,
        top: e.y,
        right: e.x + e.width,
        bottom: e.y + e.height
    })
}
function bb(e) {
    var t = Eo(e);
    return t.top = t.top + e.clientTop,
    t.left = t.left + e.clientLeft,
    t.bottom = t.top + e.clientHeight,
    t.right = t.left + e.clientWidth,
    t.width = e.clientWidth,
    t.height = e.clientHeight,
    t.x = t.left,
    t.y = t.top,
    t
}
function Lp(e, t) {
    return t === Yd ? Cu(_b(e)) : wo(t) ? bb(t) : Cu(yb(Fn(e)))
}
function xb(e) {
    var t = Ta(Uc(e))
      , i = ["absolute", "fixed"].indexOf(Js(e).position) >= 0
      , s = i && zi(e) ? Wa(e) : e;
    return wo(s) ? t.filter(function(n) {
        return wo(n) && I0(n, s) && Os(n) !== "body"
    }) : []
}
function wb(e, t, i) {
    var s = t === "clippingParents" ? xb(e) : [].concat(t)
      , n = [].concat(s, [i])
      , r = n[0]
      , o = n.reduce(function(a, l) {
        var c = Lp(e, l);
        return a.top = vr(c.top, a.top),
        a.right = cc(c.right, a.right),
        a.bottom = cc(c.bottom, a.bottom),
        a.left = vr(c.left, a.left),
        a
    }, Lp(e, r));
    return o.width = o.right - o.left,
    o.height = o.bottom - o.top,
    o.x = o.left,
    o.y = o.top,
    o
}
function O0(e) {
    var t = e.reference, i = e.element, s = e.placement, n = s ? Rs(s) : null, r = s ? So(s) : null, o = t.x + t.width / 2 - i.width / 2, a = t.y + t.height / 2 - i.height / 2, l;
    switch (n) {
    case li:
        l = {
            x: o,
            y: t.y - i.height
        };
        break;
    case Ii:
        l = {
            x: o,
            y: t.y + t.height
        };
        break;
    case Mi:
        l = {
            x: t.x + t.width,
            y: a
        };
        break;
    case ci:
        l = {
            x: t.x - i.width,
            y: a
        };
        break;
    default:
        l = {
            x: t.x,
            y: t.y
        }
    }
    var c = n ? Qd(n) : null;
    if (c != null) {
        var h = c === "y" ? "height" : "width";
        switch (r) {
        case Sr:
            l[c] = l[c] - (t[h] / 2 - i[h] / 2);
            break;
        case xo:
            l[c] = l[c] + (t[h] / 2 - i[h] / 2);
            break
        }
    }
    return l
}
function Co(e, t) {
    t === void 0 && (t = {});
    var i = t
      , s = i.placement
      , n = s === void 0 ? e.placement : s
      , r = i.boundary
      , o = r === void 0 ? g0 : r
      , a = i.rootBoundary
      , l = a === void 0 ? Yd : a
      , c = i.elementContext
      , h = c === void 0 ? Kr : c
      , u = i.altBoundary
      , d = u === void 0 ? !1 : u
      , f = i.padding
      , p = f === void 0 ? 0 : f
      , m = R0(typeof p != "number" ? p : k0(p, Bo))
      , g = h === Kr ? v0 : Kr
      , y = e.rects.popper
      , x = e.elements[d ? g : h]
      , v = wb(wo(x) ? x : x.contextElement || Fn(e.elements.popper), o, l)
      , _ = Eo(e.elements.reference)
      , C = O0({
        reference: _,
        element: y,
        strategy: "absolute",
        placement: n
    })
      , k = Cu(Object.assign({}, y, C))
      , S = h === Kr ? k : _
      , T = {
        top: v.top - S.top + m.top,
        bottom: S.bottom - v.bottom + m.bottom,
        left: v.left - S.left + m.left,
        right: S.right - v.right + m.right
    }
      , L = e.modifiersData.offset;
    if (h === Kr && L) {
        var D = L[n];
        Object.keys(T).forEach(function(O) {
            var K = [Mi, Ii].indexOf(O) >= 0 ? 1 : -1
              , P = [li, Ii].indexOf(O) >= 0 ? "y" : "x";
            T[O] += D[P] * K
        })
    }
    return T
}
function Tb(e, t) {
    t === void 0 && (t = {});
    var i = t
      , s = i.placement
      , n = i.boundary
      , r = i.rootBoundary
      , o = i.padding
      , a = i.flipVariations
      , l = i.allowedAutoPlacements
      , c = l === void 0 ? Kd : l
      , h = So(s)
      , u = h ? a ? Su : Su.filter(function(p) {
        return So(p) === h
    }) : Bo
      , d = u.filter(function(p) {
        return c.indexOf(p) >= 0
    });
    d.length === 0 && (d = u);
    var f = d.reduce(function(p, m) {
        return p[m] = Co(e, {
            placement: m,
            boundary: n,
            rootBoundary: r,
            padding: o
        })[Rs(m)],
        p
    }, {});
    return Object.keys(f).sort(function(p, m) {
        return f[p] - f[m]
    })
}
function Eb(e) {
    if (Rs(e) === Bc)
        return [];
    var t = jl(e);
    return [Pp(e), t, Pp(t)]
}
function Sb(e) {
    var t = e.state
      , i = e.options
      , s = e.name;
    if (!t.modifiersData[s]._skip) {
        for (var n = i.mainAxis, r = n === void 0 ? !0 : n, o = i.altAxis, a = o === void 0 ? !0 : o, l = i.fallbackPlacements, c = i.padding, h = i.boundary, u = i.rootBoundary, d = i.altBoundary, f = i.flipVariations, p = f === void 0 ? !0 : f, m = i.allowedAutoPlacements, g = t.options.placement, y = Rs(g), x = y === g, v = l || (x || !p ? [jl(g)] : Eb(g)), _ = [g].concat(v).reduce(function(St, J) {
            return St.concat(Rs(J) === Bc ? Tb(t, {
                placement: J,
                boundary: h,
                rootBoundary: u,
                padding: c,
                flipVariations: p,
                allowedAutoPlacements: m
            }) : J)
        }, []), C = t.rects.reference, k = t.rects.popper, S = new Map, T = !0, L = _[0], D = 0; D < _.length; D++) {
            var O = _[D]
              , K = Rs(O)
              , P = So(O) === Sr
              , N = [li, Ii].indexOf(K) >= 0
              , W = N ? "width" : "height"
              , V = Co(t, {
                placement: O,
                boundary: h,
                rootBoundary: u,
                altBoundary: d,
                padding: c
            })
              , Q = N ? P ? Mi : ci : P ? Ii : li;
            C[W] > k[W] && (Q = jl(Q));
            var pt = jl(Q)
              , bt = [];
            if (r && bt.push(V[K] <= 0),
            a && bt.push(V[Q] <= 0, V[pt] <= 0),
            bt.every(function(St) {
                return St
            })) {
                L = O,
                T = !1;
                break
            }
            S.set(O, bt)
        }
        if (T)
            for (var ct = p ? 3 : 1, gt = function(J) {
                var wt = _.find(function(Tt) {
                    var Bt = S.get(Tt);
                    if (Bt)
                        return Bt.slice(0, J).every(function(kt) {
                            return kt
                        })
                });
                if (wt)
                    return L = wt,
                    "break"
            }, xt = ct; xt > 0; xt--) {
                var It = gt(xt);
                if (It === "break")
                    break
            }
        t.placement !== L && (t.modifiersData[s]._skip = !0,
        t.placement = L,
        t.reset = !0)
    }
}
var D0 = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: Sb,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};
function Op(e, t, i) {
    return i === void 0 && (i = {
        x: 0,
        y: 0
    }),
    {
        top: e.top - t.height - i.y,
        right: e.right - t.width + i.x,
        bottom: e.bottom - t.height + i.y,
        left: e.left - t.width - i.x
    }
}
function Dp(e) {
    return [li, Mi, Ii, ci].some(function(t) {
        return e[t] >= 0
    })
}
function Cb(e) {
    var t = e.state
      , i = e.name
      , s = t.rects.reference
      , n = t.rects.popper
      , r = t.modifiersData.preventOverflow
      , o = Co(t, {
        elementContext: "reference"
    })
      , a = Co(t, {
        altBoundary: !0
    })
      , l = Op(o, s)
      , c = Op(a, n, r)
      , h = Dp(l)
      , u = Dp(c);
    t.modifiersData[i] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c,
        isReferenceHidden: h,
        hasPopperEscaped: u
    },
    t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": h,
        "data-popper-escaped": u
    })
}
var N0 = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: Cb
};
function Ab(e, t, i) {
    var s = Rs(e)
      , n = [ci, li].indexOf(s) >= 0 ? -1 : 1
      , r = typeof i == "function" ? i(Object.assign({}, t, {
        placement: e
    })) : i
      , o = r[0]
      , a = r[1];
    return o = o || 0,
    a = (a || 0) * n,
    [ci, Mi].indexOf(s) >= 0 ? {
        x: a,
        y: o
    } : {
        x: o,
        y: a
    }
}
function Ib(e) {
    var t = e.state
      , i = e.options
      , s = e.name
      , n = i.offset
      , r = n === void 0 ? [0, 0] : n
      , o = Kd.reduce(function(h, u) {
        return h[u] = Ab(u, t.rects, r),
        h
    }, {})
      , a = o[t.placement]
      , l = a.x
      , c = a.y;
    t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l,
    t.modifiersData.popperOffsets.y += c),
    t.modifiersData[s] = o
}
var F0 = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: Ib
};
function Mb(e) {
    var t = e.state
      , i = e.name;
    t.modifiersData[i] = O0({
        reference: t.rects.reference,
        element: t.rects.popper,
        strategy: "absolute",
        placement: t.placement
    })
}
var of = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: Mb,
    data: {}
};
function Rb(e) {
    return e === "x" ? "y" : "x"
}
function kb(e) {
    var t = e.state
      , i = e.options
      , s = e.name
      , n = i.mainAxis
      , r = n === void 0 ? !0 : n
      , o = i.altAxis
      , a = o === void 0 ? !1 : o
      , l = i.boundary
      , c = i.rootBoundary
      , h = i.altBoundary
      , u = i.padding
      , d = i.tether
      , f = d === void 0 ? !0 : d
      , p = i.tetherOffset
      , m = p === void 0 ? 0 : p
      , g = Co(t, {
        boundary: l,
        rootBoundary: c,
        padding: u,
        altBoundary: h
    })
      , y = Rs(t.placement)
      , x = So(t.placement)
      , v = !x
      , _ = Qd(y)
      , C = Rb(_)
      , k = t.modifiersData.popperOffsets
      , S = t.rects.reference
      , T = t.rects.popper
      , L = typeof m == "function" ? m(Object.assign({}, t.rects, {
        placement: t.placement
    })) : m
      , D = typeof L == "number" ? {
        mainAxis: L,
        altAxis: L
    } : Object.assign({
        mainAxis: 0,
        altAxis: 0
    }, L)
      , O = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null
      , K = {
        x: 0,
        y: 0
    };
    if (!!k) {
        if (r) {
            var P, N = _ === "y" ? li : ci, W = _ === "y" ? Ii : Mi, V = _ === "y" ? "height" : "width", Q = k[_], pt = Q + g[N], bt = Q - g[W], ct = f ? -T[V] / 2 : 0, gt = x === Sr ? S[V] : T[V], xt = x === Sr ? -T[V] : -S[V], It = t.elements.arrow, St = f && It ? Jd(It) : {
                width: 0,
                height: 0
            }, J = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : M0(), wt = J[N], Tt = J[W], Bt = wa(0, S[V], St[V]), kt = v ? S[V] / 2 - ct - Bt - wt - D.mainAxis : gt - Bt - wt - D.mainAxis, re = v ? -S[V] / 2 + ct + Bt + Tt + D.mainAxis : xt + Bt + Tt + D.mainAxis, Xt = t.elements.arrow && Wa(t.elements.arrow), ce = Xt ? _ === "y" ? Xt.clientTop || 0 : Xt.clientLeft || 0 : 0, E = (P = O?.[_]) != null ? P : 0, M = Q + kt - E - ce, F = Q + re - E, $ = wa(f ? cc(pt, M) : pt, Q, f ? vr(bt, F) : bt);
            k[_] = $,
            K[_] = $ - Q
        }
        if (a) {
            var Y, rt = _ === "x" ? li : ci, dt = _ === "x" ? Ii : Mi, tt = k[C], it = C === "y" ? "height" : "width", Z = tt + g[rt], Ct = tt - g[dt], yt = [li, ci].indexOf(y) !== -1, At = (Y = O?.[C]) != null ? Y : 0, Pt = yt ? Z : tt - S[it] - T[it] - At + D.altAxis, Kt = yt ? tt + S[it] + T[it] - At - D.altAxis : Ct, me = f && yt ? lb(Pt, tt, Kt) : wa(f ? Pt : Z, tt, f ? Kt : Ct);
            k[C] = me,
            K[C] = me - tt
        }
        t.modifiersData[s] = K
    }
}
var B0 = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: kb,
    requiresIfExists: ["offset"]
};
function Pb(e) {
    return {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
    }
}
function Lb(e) {
    return e === ps(e) || !zi(e) ? sf(e) : Pb(e)
}
function Ob(e) {
    var t = e.getBoundingClientRect()
      , i = To(t.width) / e.offsetWidth || 1
      , s = To(t.height) / e.offsetHeight || 1;
    return i !== 1 || s !== 1
}
function Db(e, t, i) {
    i === void 0 && (i = !1);
    var s = zi(t)
      , n = zi(t) && Ob(t)
      , r = Fn(t)
      , o = Eo(e, n)
      , a = {
        scrollLeft: 0,
        scrollTop: 0
    }
      , l = {
        x: 0,
        y: 0
    };
    return (s || !s && !i) && ((Os(t) !== "body" || rf(r)) && (a = Lb(t)),
    zi(t) ? (l = Eo(t, !0),
    l.x += t.clientLeft,
    l.y += t.clientTop) : r && (l.x = nf(r))),
    {
        x: o.left + a.scrollLeft - l.x,
        y: o.top + a.scrollTop - l.y,
        width: o.width,
        height: o.height
    }
}
function Nb(e) {
    var t = new Map
      , i = new Set
      , s = [];
    e.forEach(function(r) {
        t.set(r.name, r)
    });
    function n(r) {
        i.add(r.name);
        var o = [].concat(r.requires || [], r.requiresIfExists || []);
        o.forEach(function(a) {
            if (!i.has(a)) {
                var l = t.get(a);
                l && n(l)
            }
        }),
        s.push(r)
    }
    return e.forEach(function(r) {
        i.has(r.name) || n(r)
    }),
    s
}
function Fb(e) {
    var t = Nb(e);
    return A0.reduce(function(i, s) {
        return i.concat(t.filter(function(n) {
            return n.phase === s
        }))
    }, [])
}
function Bb(e) {
    var t;
    return function() {
        return t || (t = new Promise(function(i) {
            Promise.resolve().then(function() {
                t = void 0,
                i(e())
            })
        }
        )),
        t
    }
}
function Ub(e) {
    var t = e.reduce(function(i, s) {
        var n = i[s.name];
        return i[s.name] = n ? Object.assign({}, n, s, {
            options: Object.assign({}, n.options, s.options),
            data: Object.assign({}, n.data, s.data)
        }) : s,
        i
    }, {});
    return Object.keys(t).map(function(i) {
        return t[i]
    })
}
var Np = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};
function Fp() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)
        t[i] = arguments[i];
    return !t.some(function(s) {
        return !(s && typeof s.getBoundingClientRect == "function")
    })
}
function Gc(e) {
    e === void 0 && (e = {});
    var t = e
      , i = t.defaultModifiers
      , s = i === void 0 ? [] : i
      , n = t.defaultOptions
      , r = n === void 0 ? Np : n;
    return function(a, l, c) {
        c === void 0 && (c = r);
        var h = {
            placement: "bottom",
            orderedModifiers: [],
            options: Object.assign({}, Np, r),
            modifiersData: {},
            elements: {
                reference: a,
                popper: l
            },
            attributes: {},
            styles: {}
        }
          , u = []
          , d = !1
          , f = {
            state: h,
            setOptions: function(y) {
                var x = typeof y == "function" ? y(h.options) : y;
                m(),
                h.options = Object.assign({}, r, h.options, x),
                h.scrollParents = {
                    reference: wo(a) ? Ta(a) : a.contextElement ? Ta(a.contextElement) : [],
                    popper: Ta(l)
                };
                var v = Fb(Ub([].concat(s, h.options.modifiers)));
                return h.orderedModifiers = v.filter(function(_) {
                    return _.enabled
                }),
                p(),
                f.update()
            },
            forceUpdate: function() {
                if (!d) {
                    var y = h.elements
                      , x = y.reference
                      , v = y.popper;
                    if (!!Fp(x, v)) {
                        h.rects = {
                            reference: Db(x, Wa(v), h.options.strategy === "fixed"),
                            popper: Jd(v)
                        },
                        h.reset = !1,
                        h.placement = h.options.placement,
                        h.orderedModifiers.forEach(function(D) {
                            return h.modifiersData[D.name] = Object.assign({}, D.data)
                        });
                        for (var _ = 0; _ < h.orderedModifiers.length; _++) {
                            if (h.reset === !0) {
                                h.reset = !1,
                                _ = -1;
                                continue
                            }
                            var C = h.orderedModifiers[_]
                              , k = C.fn
                              , S = C.options
                              , T = S === void 0 ? {} : S
                              , L = C.name;
                            typeof k == "function" && (h = k({
                                state: h,
                                options: T,
                                name: L,
                                instance: f
                            }) || h)
                        }
                    }
                }
            },
            update: Bb(function() {
                return new Promise(function(g) {
                    f.forceUpdate(),
                    g(h)
                }
                )
            }),
            destroy: function() {
                m(),
                d = !0
            }
        };
        if (!Fp(a, l))
            return f;
        f.setOptions(c).then(function(g) {
            !d && c.onFirstUpdate && c.onFirstUpdate(g)
        });
        function p() {
            h.orderedModifiers.forEach(function(g) {
                var y = g.name
                  , x = g.options
                  , v = x === void 0 ? {} : x
                  , _ = g.effect;
                if (typeof _ == "function") {
                    var C = _({
                        state: h,
                        name: y,
                        instance: f,
                        options: v
                    })
                      , k = function() {};
                    u.push(C || k)
                }
            })
        }
        function m() {
            u.forEach(function(g) {
                return g()
            }),
            u = []
        }
        return f
    }
}
var Gb = Gc()
  , Hb = [ef, of, tf, qd]
  , Vb = Gc({
    defaultModifiers: Hb
})
  , zb = [ef, of, tf, qd, F0, D0, B0, P0, N0]
  , af = Gc({
    defaultModifiers: zb
})
  , U0 = Object.freeze(Object.defineProperty({
    __proto__: null,
    popperGenerator: Gc,
    detectOverflow: Co,
    createPopperBase: Gb,
    createPopper: af,
    createPopperLite: Vb,
    top: li,
    bottom: Ii,
    right: Mi,
    left: ci,
    auto: Bc,
    basePlacements: Bo,
    start: Sr,
    end: xo,
    clippingParents: g0,
    viewport: Yd,
    popper: Kr,
    reference: v0,
    variationPlacements: Su,
    placements: Kd,
    beforeRead: _0,
    read: y0,
    afterRead: b0,
    beforeMain: x0,
    main: w0,
    afterMain: T0,
    beforeWrite: E0,
    write: S0,
    afterWrite: C0,
    modifierPhases: A0,
    applyStyles: qd,
    arrow: P0,
    computeStyles: tf,
    eventListeners: ef,
    flip: D0,
    hide: N0,
    offset: F0,
    popperOffsets: of,
    preventOverflow: B0
}, Symbol.toStringTag, {
    value: "Module"
}));
/*!
  * Bootstrap v5.2.0 (https://getbootstrap.com/)
  * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
  */
const $b = 1e6
  , jb = 1e3
  , Au = "transitionend"
  , Wb = e=>e == null ? `${e}` : Object.prototype.toString.call(e).match(/\s([a-z]+)/i)[1].toLowerCase()
  , Xb = e=>{
    do
        e += Math.floor(Math.random() * $b);
    while (document.getElementById(e));
    return e
}
  , G0 = e=>{
    let t = e.getAttribute("data-bs-target");
    if (!t || t === "#") {
        let i = e.getAttribute("href");
        if (!i || !i.includes("#") && !i.startsWith("."))
            return null;
        i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`),
        t = i && i !== "#" ? i.trim() : null
    }
    return t
}
  , H0 = e=>{
    const t = G0(e);
    return t && document.querySelector(t) ? t : null
}
  , Xs = e=>{
    const t = G0(e);
    return t ? document.querySelector(t) : null
}
  , Yb = e=>{
    if (!e)
        return 0;
    let {transitionDuration: t, transitionDelay: i} = window.getComputedStyle(e);
    const s = Number.parseFloat(t)
      , n = Number.parseFloat(i);
    return !s && !n ? 0 : (t = t.split(",")[0],
    i = i.split(",")[0],
    (Number.parseFloat(t) + Number.parseFloat(i)) * jb)
}
  , V0 = e=>{
    e.dispatchEvent(new Event(Au))
}
  , Ys = e=>!e || typeof e != "object" ? !1 : (typeof e.jquery < "u" && (e = e[0]),
typeof e.nodeType < "u")
  , Mn = e=>Ys(e) ? e.jquery ? e[0] : e : typeof e == "string" && e.length > 0 ? document.querySelector(e) : null
  , Uo = e=>{
    if (!Ys(e) || e.getClientRects().length === 0)
        return !1;
    const t = getComputedStyle(e).getPropertyValue("visibility") === "visible"
      , i = e.closest("details:not([open])");
    if (!i)
        return t;
    if (i !== e) {
        const s = e.closest("summary");
        if (s && s.parentNode !== i || s === null)
            return !1
    }
    return t
}
  , Rn = e=>!e || e.nodeType !== Node.ELEMENT_NODE || e.classList.contains("disabled") ? !0 : typeof e.disabled < "u" ? e.disabled : e.hasAttribute("disabled") && e.getAttribute("disabled") !== "false"
  , z0 = e=>{
    if (!document.documentElement.attachShadow)
        return null;
    if (typeof e.getRootNode == "function") {
        const t = e.getRootNode();
        return t instanceof ShadowRoot ? t : null
    }
    return e instanceof ShadowRoot ? e : e.parentNode ? z0(e.parentNode) : null
}
  , hc = ()=>{}
  , Xa = e=>{
    e.offsetHeight
}
  , $0 = ()=>window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null
  , Ah = []
  , Kb = e=>{
    document.readyState === "loading" ? (Ah.length || document.addEventListener("DOMContentLoaded", ()=>{
        for (const t of Ah)
            t()
    }
    ),
    Ah.push(e)) : e()
}
  , ji = ()=>document.documentElement.dir === "rtl"
  , Wi = e=>{
    Kb(()=>{
        const t = $0();
        if (t) {
            const i = e.NAME
              , s = t.fn[i];
            t.fn[i] = e.jQueryInterface,
            t.fn[i].Constructor = e,
            t.fn[i].noConflict = ()=>(t.fn[i] = s,
            e.jQueryInterface)
        }
    }
    )
}
  , $s = e=>{
    typeof e == "function" && e()
}
  , j0 = (e,t,i=!0)=>{
    if (!i) {
        $s(e);
        return
    }
    const s = 5
      , n = Yb(t) + s;
    let r = !1;
    const o = ({target: a})=>{
        a === t && (r = !0,
        t.removeEventListener(Au, o),
        $s(e))
    }
    ;
    t.addEventListener(Au, o),
    setTimeout(()=>{
        r || V0(t)
    }
    , n)
}
  , lf = (e,t,i,s)=>{
    const n = e.length;
    let r = e.indexOf(t);
    return r === -1 ? !i && s ? e[n - 1] : e[0] : (r += i ? 1 : -1,
    s && (r = (r + n) % n),
    e[Math.max(0, Math.min(r, n - 1))])
}
  , Zb = /[^.]*(?=\..*)\.|.*/
  , qb = /\..*/
  , Jb = /::\d+$/
  , Ih = {};
let Bp = 1;
const W0 = {
    mouseenter: "mouseover",
    mouseleave: "mouseout"
}
  , Qb = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);
function X0(e, t) {
    return t && `${t}::${Bp++}` || e.uidEvent || Bp++
}
function Y0(e) {
    const t = X0(e);
    return e.uidEvent = t,
    Ih[t] = Ih[t] || {},
    Ih[t]
}
function tx(e, t) {
    return function i(s) {
        return cf(s, {
            delegateTarget: e
        }),
        i.oneOff && q.off(e, s.type, t),
        t.apply(e, [s])
    }
}
function ex(e, t, i) {
    return function s(n) {
        const r = e.querySelectorAll(t);
        for (let {target: o} = n; o && o !== this; o = o.parentNode)
            for (const a of r)
                if (a === o)
                    return cf(n, {
                        delegateTarget: o
                    }),
                    s.oneOff && q.off(e, n.type, t, i),
                    i.apply(o, [n])
    }
}
function K0(e, t, i=null) {
    return Object.values(e).find(s=>s.callable === t && s.delegationSelector === i)
}
function Z0(e, t, i) {
    const s = typeof t == "string"
      , n = s ? i : t || i;
    let r = q0(e);
    return Qb.has(r) || (r = e),
    [s, n, r]
}
function Up(e, t, i, s, n) {
    if (typeof t != "string" || !e)
        return;
    let[r,o,a] = Z0(t, i, s);
    t in W0 && (o = (p=>function(m) {
        if (!m.relatedTarget || m.relatedTarget !== m.delegateTarget && !m.delegateTarget.contains(m.relatedTarget))
            return p.call(this, m)
    }
    )(o));
    const l = Y0(e)
      , c = l[a] || (l[a] = {})
      , h = K0(c, o, r ? i : null);
    if (h) {
        h.oneOff = h.oneOff && n;
        return
    }
    const u = X0(o, t.replace(Zb, ""))
      , d = r ? ex(e, i, o) : tx(e, o);
    d.delegationSelector = r ? i : null,
    d.callable = o,
    d.oneOff = n,
    d.uidEvent = u,
    c[u] = d,
    e.addEventListener(a, d, r)
}
function Iu(e, t, i, s, n) {
    const r = K0(t[i], s, n);
    !r || (e.removeEventListener(i, r, Boolean(n)),
    delete t[i][r.uidEvent])
}
function ix(e, t, i, s) {
    const n = t[i] || {};
    for (const r of Object.keys(n))
        if (r.includes(s)) {
            const o = n[r];
            Iu(e, t, i, o.callable, o.delegationSelector)
        }
}
function q0(e) {
    return e = e.replace(qb, ""),
    W0[e] || e
}
const q = {
    on(e, t, i, s) {
        Up(e, t, i, s, !1)
    },
    one(e, t, i, s) {
        Up(e, t, i, s, !0)
    },
    off(e, t, i, s) {
        if (typeof t != "string" || !e)
            return;
        const [n,r,o] = Z0(t, i, s)
          , a = o !== t
          , l = Y0(e)
          , c = l[o] || {}
          , h = t.startsWith(".");
        if (typeof r < "u") {
            if (!Object.keys(c).length)
                return;
            Iu(e, l, o, r, n ? i : null);
            return
        }
        if (h)
            for (const u of Object.keys(l))
                ix(e, l, u, t.slice(1));
        for (const u of Object.keys(c)) {
            const d = u.replace(Jb, "");
            if (!a || t.includes(d)) {
                const f = c[u];
                Iu(e, l, o, f.callable, f.delegationSelector)
            }
        }
    },
    trigger(e, t, i) {
        if (typeof t != "string" || !e)
            return null;
        const s = $0()
          , n = q0(t)
          , r = t !== n;
        let o = null
          , a = !0
          , l = !0
          , c = !1;
        r && s && (o = s.Event(t, i),
        s(e).trigger(o),
        a = !o.isPropagationStopped(),
        l = !o.isImmediatePropagationStopped(),
        c = o.isDefaultPrevented());
        let h = new Event(t,{
            bubbles: a,
            cancelable: !0
        });
        return h = cf(h, i),
        c && h.preventDefault(),
        l && e.dispatchEvent(h),
        h.defaultPrevented && o && o.preventDefault(),
        h
    }
};
function cf(e, t) {
    for (const [i,s] of Object.entries(t || {}))
        try {
            e[i] = s
        } catch {
            Object.defineProperty(e, i, {
                configurable: !0,
                get() {
                    return s
                }
            })
        }
    return e
}
const cn = new Map
  , Mh = {
    set(e, t, i) {
        cn.has(e) || cn.set(e, new Map);
        const s = cn.get(e);
        if (!s.has(t) && s.size !== 0) {
            console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`);
            return
        }
        s.set(t, i)
    },
    get(e, t) {
        return cn.has(e) && cn.get(e).get(t) || null
    },
    remove(e, t) {
        if (!cn.has(e))
            return;
        const i = cn.get(e);
        i.delete(t),
        i.size === 0 && cn.delete(e)
    }
};
function Gp(e) {
    if (e === "true")
        return !0;
    if (e === "false")
        return !1;
    if (e === Number(e).toString())
        return Number(e);
    if (e === "" || e === "null")
        return null;
    if (typeof e != "string")
        return e;
    try {
        return JSON.parse(decodeURIComponent(e))
    } catch {
        return e
    }
}
function Rh(e) {
    return e.replace(/[A-Z]/g, t=>`-${t.toLowerCase()}`)
}
const Ks = {
    setDataAttribute(e, t, i) {
        e.setAttribute(`data-bs-${Rh(t)}`, i)
    },
    removeDataAttribute(e, t) {
        e.removeAttribute(`data-bs-${Rh(t)}`)
    },
    getDataAttributes(e) {
        if (!e)
            return {};
        const t = {}
          , i = Object.keys(e.dataset).filter(s=>s.startsWith("bs") && !s.startsWith("bsConfig"));
        for (const s of i) {
            let n = s.replace(/^bs/, "");
            n = n.charAt(0).toLowerCase() + n.slice(1, n.length),
            t[n] = Gp(e.dataset[s])
        }
        return t
    },
    getDataAttribute(e, t) {
        return Gp(e.getAttribute(`data-bs-${Rh(t)}`))
    }
};
class Ya {
    static get Default() {
        return {}
    }
    static get DefaultType() {
        return {}
    }
    static get NAME() {
        throw new Error('You have to implement the static method "NAME", for each component!')
    }
    _getConfig(t) {
        return t = this._mergeConfigObj(t),
        t = this._configAfterMerge(t),
        this._typeCheckConfig(t),
        t
    }
    _configAfterMerge(t) {
        return t
    }
    _mergeConfigObj(t, i) {
        const s = Ys(i) ? Ks.getDataAttribute(i, "config") : {};
        return {
            ...this.constructor.Default,
            ...typeof s == "object" ? s : {},
            ...Ys(i) ? Ks.getDataAttributes(i) : {},
            ...typeof t == "object" ? t : {}
        }
    }
    _typeCheckConfig(t, i=this.constructor.DefaultType) {
        for (const s of Object.keys(i)) {
            const n = i[s]
              , r = t[s]
              , o = Ys(r) ? "element" : Wb(r);
            if (!new RegExp(n).test(o))
                throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${o}" but expected type "${n}".`)
        }
    }
}
const sx = "5.2.0";
class ms extends Ya {
    constructor(t, i) {
        super(),
        t = Mn(t),
        t && (this._element = t,
        this._config = this._getConfig(i),
        Mh.set(this._element, this.constructor.DATA_KEY, this))
    }
    dispose() {
        Mh.remove(this._element, this.constructor.DATA_KEY),
        q.off(this._element, this.constructor.EVENT_KEY);
        for (const t of Object.getOwnPropertyNames(this))
            this[t] = null
    }
    _queueCallback(t, i, s=!0) {
        j0(t, i, s)
    }
    _getConfig(t) {
        return t = this._mergeConfigObj(t, this._element),
        t = this._configAfterMerge(t),
        this._typeCheckConfig(t),
        t
    }
    static getInstance(t) {
        return Mh.get(Mn(t), this.DATA_KEY)
    }
    static getOrCreateInstance(t, i={}) {
        return this.getInstance(t) || new this(t,typeof i == "object" ? i : null)
    }
    static get VERSION() {
        return sx
    }
    static get DATA_KEY() {
        return `bs.${this.NAME}`
    }
    static get EVENT_KEY() {
        return `.${this.DATA_KEY}`
    }
    static eventName(t) {
        return `${t}${this.EVENT_KEY}`
    }
}
const Hc = (e,t="hide")=>{
    const i = `click.dismiss${e.EVENT_KEY}`
      , s = e.NAME;
    q.on(document, i, `[data-bs-dismiss="${s}"]`, function(n) {
        if (["A", "AREA"].includes(this.tagName) && n.preventDefault(),
        Rn(this))
            return;
        const r = Xs(this) || this.closest(`.${s}`);
        e.getOrCreateInstance(r)[t]()
    })
}
  , nx = "alert"
  , rx = "bs.alert"
  , J0 = `.${rx}`
  , ox = `close${J0}`
  , ax = `closed${J0}`
  , lx = "fade"
  , cx = "show";
class Vc extends ms {
    static get NAME() {
        return nx
    }
    close() {
        if (q.trigger(this._element, ox).defaultPrevented)
            return;
        this._element.classList.remove(cx);
        const i = this._element.classList.contains(lx);
        this._queueCallback(()=>this._destroyElement(), this._element, i)
    }
    _destroyElement() {
        this._element.remove(),
        q.trigger(this._element, ax),
        this.dispose()
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = Vc.getOrCreateInstance(this);
            if (typeof t == "string") {
                if (i[t] === void 0 || t.startsWith("_") || t === "constructor")
                    throw new TypeError(`No method named "${t}"`);
                i[t](this)
            }
        })
    }
}
Hc(Vc, "close");
Wi(Vc);
const hx = "button"
  , ux = "bs.button"
  , dx = `.${ux}`
  , fx = ".data-api"
  , px = "active"
  , Hp = '[data-bs-toggle="button"]'
  , mx = `click${dx}${fx}`;
class zc extends ms {
    static get NAME() {
        return hx
    }
    toggle() {
        this._element.setAttribute("aria-pressed", this._element.classList.toggle(px))
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = zc.getOrCreateInstance(this);
            t === "toggle" && i[t]()
        })
    }
}
q.on(document, mx, Hp, e=>{
    e.preventDefault();
    const t = e.target.closest(Hp);
    zc.getOrCreateInstance(t).toggle()
}
);
Wi(zc);
const te = {
    find(e, t=document.documentElement) {
        return [].concat(...Element.prototype.querySelectorAll.call(t, e))
    },
    findOne(e, t=document.documentElement) {
        return Element.prototype.querySelector.call(t, e)
    },
    children(e, t) {
        return [].concat(...e.children).filter(i=>i.matches(t))
    },
    parents(e, t) {
        const i = [];
        let s = e.parentNode.closest(t);
        for (; s; )
            i.push(s),
            s = s.parentNode.closest(t);
        return i
    },
    prev(e, t) {
        let i = e.previousElementSibling;
        for (; i; ) {
            if (i.matches(t))
                return [i];
            i = i.previousElementSibling
        }
        return []
    },
    next(e, t) {
        let i = e.nextElementSibling;
        for (; i; ) {
            if (i.matches(t))
                return [i];
            i = i.nextElementSibling
        }
        return []
    },
    focusableChildren(e) {
        const t = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(i=>`${i}:not([tabindex^="-"])`).join(",");
        return this.find(t, e).filter(i=>!Rn(i) && Uo(i))
    }
}
  , gx = "swipe"
  , Go = ".bs.swipe"
  , vx = `touchstart${Go}`
  , _x = `touchmove${Go}`
  , yx = `touchend${Go}`
  , bx = `pointerdown${Go}`
  , xx = `pointerup${Go}`
  , wx = "touch"
  , Tx = "pen"
  , Ex = "pointer-event"
  , Sx = 40
  , Cx = {
    endCallback: null,
    leftCallback: null,
    rightCallback: null
}
  , Ax = {
    endCallback: "(function|null)",
    leftCallback: "(function|null)",
    rightCallback: "(function|null)"
};
class uc extends Ya {
    constructor(t, i) {
        super(),
        this._element = t,
        !(!t || !uc.isSupported()) && (this._config = this._getConfig(i),
        this._deltaX = 0,
        this._supportPointerEvents = Boolean(window.PointerEvent),
        this._initEvents())
    }
    static get Default() {
        return Cx
    }
    static get DefaultType() {
        return Ax
    }
    static get NAME() {
        return gx
    }
    dispose() {
        q.off(this._element, Go)
    }
    _start(t) {
        if (!this._supportPointerEvents) {
            this._deltaX = t.touches[0].clientX;
            return
        }
        this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX)
    }
    _end(t) {
        this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX),
        this._handleSwipe(),
        $s(this._config.endCallback)
    }
    _move(t) {
        this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX
    }
    _handleSwipe() {
        const t = Math.abs(this._deltaX);
        if (t <= Sx)
            return;
        const i = t / this._deltaX;
        this._deltaX = 0,
        i && $s(i > 0 ? this._config.rightCallback : this._config.leftCallback)
    }
    _initEvents() {
        this._supportPointerEvents ? (q.on(this._element, bx, t=>this._start(t)),
        q.on(this._element, xx, t=>this._end(t)),
        this._element.classList.add(Ex)) : (q.on(this._element, vx, t=>this._start(t)),
        q.on(this._element, _x, t=>this._move(t)),
        q.on(this._element, yx, t=>this._end(t)))
    }
    _eventIsPointerPenTouch(t) {
        return this._supportPointerEvents && (t.pointerType === Tx || t.pointerType === wx)
    }
    static isSupported() {
        return "ontouchstart"in document.documentElement || navigator.maxTouchPoints > 0
    }
}
const Ix = "carousel"
  , Mx = "bs.carousel"
  , Bn = `.${Mx}`
  , Q0 = ".data-api"
  , Rx = "ArrowLeft"
  , kx = "ArrowRight"
  , Px = 500
  , Xo = "next"
  , Nr = "prev"
  , Zr = "left"
  , Wl = "right"
  , Lx = `slide${Bn}`
  , kh = `slid${Bn}`
  , Ox = `keydown${Bn}`
  , Dx = `mouseenter${Bn}`
  , Nx = `mouseleave${Bn}`
  , Fx = `dragstart${Bn}`
  , Bx = `load${Bn}${Q0}`
  , Ux = `click${Bn}${Q0}`
  , tv = "carousel"
  , rl = "active"
  , Gx = "slide"
  , Hx = "carousel-item-end"
  , Vx = "carousel-item-start"
  , zx = "carousel-item-next"
  , $x = "carousel-item-prev"
  , ev = ".active"
  , iv = ".carousel-item"
  , jx = ev + iv
  , Wx = ".carousel-item img"
  , Xx = ".carousel-indicators"
  , Yx = "[data-bs-slide], [data-bs-slide-to]"
  , Kx = '[data-bs-ride="carousel"]'
  , Zx = {
    [Rx]: Wl,
    [kx]: Zr
}
  , qx = {
    interval: 5e3,
    keyboard: !0,
    pause: "hover",
    ride: !1,
    touch: !0,
    wrap: !0
}
  , Jx = {
    interval: "(number|boolean)",
    keyboard: "boolean",
    pause: "(string|boolean)",
    ride: "(boolean|string)",
    touch: "boolean",
    wrap: "boolean"
};
class Ka extends ms {
    constructor(t, i) {
        super(t, i),
        this._interval = null,
        this._activeElement = null,
        this._isSliding = !1,
        this.touchTimeout = null,
        this._swipeHelper = null,
        this._indicatorsElement = te.findOne(Xx, this._element),
        this._addEventListeners(),
        this._config.ride === tv && this.cycle()
    }
    static get Default() {
        return qx
    }
    static get DefaultType() {
        return Jx
    }
    static get NAME() {
        return Ix
    }
    next() {
        this._slide(Xo)
    }
    nextWhenVisible() {
        !document.hidden && Uo(this._element) && this.next()
    }
    prev() {
        this._slide(Nr)
    }
    pause() {
        this._isSliding && V0(this._element),
        this._clearInterval()
    }
    cycle() {
        this._clearInterval(),
        this._updateInterval(),
        this._interval = setInterval(()=>this.nextWhenVisible(), this._config.interval)
    }
    _maybeEnableCycle() {
        if (!!this._config.ride) {
            if (this._isSliding) {
                q.one(this._element, kh, ()=>this.cycle());
                return
            }
            this.cycle()
        }
    }
    to(t) {
        const i = this._getItems();
        if (t > i.length - 1 || t < 0)
            return;
        if (this._isSliding) {
            q.one(this._element, kh, ()=>this.to(t));
            return
        }
        const s = this._getItemIndex(this._getActive());
        if (s === t)
            return;
        const n = t > s ? Xo : Nr;
        this._slide(n, i[t])
    }
    dispose() {
        this._swipeHelper && this._swipeHelper.dispose(),
        super.dispose()
    }
    _configAfterMerge(t) {
        return t.defaultInterval = t.interval,
        t
    }
    _addEventListeners() {
        this._config.keyboard && q.on(this._element, Ox, t=>this._keydown(t)),
        this._config.pause === "hover" && (q.on(this._element, Dx, ()=>this.pause()),
        q.on(this._element, Nx, ()=>this._maybeEnableCycle())),
        this._config.touch && uc.isSupported() && this._addTouchEventListeners()
    }
    _addTouchEventListeners() {
        for (const s of te.find(Wx, this._element))
            q.on(s, Fx, n=>n.preventDefault());
        const i = {
            leftCallback: ()=>this._slide(this._directionToOrder(Zr)),
            rightCallback: ()=>this._slide(this._directionToOrder(Wl)),
            endCallback: ()=>{
                this._config.pause === "hover" && (this.pause(),
                this.touchTimeout && clearTimeout(this.touchTimeout),
                this.touchTimeout = setTimeout(()=>this._maybeEnableCycle(), Px + this._config.interval))
            }
        };
        this._swipeHelper = new uc(this._element,i)
    }
    _keydown(t) {
        if (/input|textarea/i.test(t.target.tagName))
            return;
        const i = Zx[t.key];
        i && (t.preventDefault(),
        this._slide(this._directionToOrder(i)))
    }
    _getItemIndex(t) {
        return this._getItems().indexOf(t)
    }
    _setActiveIndicatorElement(t) {
        if (!this._indicatorsElement)
            return;
        const i = te.findOne(ev, this._indicatorsElement);
        i.classList.remove(rl),
        i.removeAttribute("aria-current");
        const s = te.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
        s && (s.classList.add(rl),
        s.setAttribute("aria-current", "true"))
    }
    _updateInterval() {
        const t = this._activeElement || this._getActive();
        if (!t)
            return;
        const i = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
        this._config.interval = i || this._config.defaultInterval
    }
    _slide(t, i=null) {
        if (this._isSliding)
            return;
        const s = this._getActive()
          , n = t === Xo
          , r = i || lf(this._getItems(), s, n, this._config.wrap);
        if (r === s)
            return;
        const o = this._getItemIndex(r)
          , a = f=>q.trigger(this._element, f, {
            relatedTarget: r,
            direction: this._orderToDirection(t),
            from: this._getItemIndex(s),
            to: o
        });
        if (a(Lx).defaultPrevented || !s || !r)
            return;
        const c = Boolean(this._interval);
        this.pause(),
        this._isSliding = !0,
        this._setActiveIndicatorElement(o),
        this._activeElement = r;
        const h = n ? Vx : Hx
          , u = n ? zx : $x;
        r.classList.add(u),
        Xa(r),
        s.classList.add(h),
        r.classList.add(h);
        const d = ()=>{
            r.classList.remove(h, u),
            r.classList.add(rl),
            s.classList.remove(rl, u, h),
            this._isSliding = !1,
            a(kh)
        }
        ;
        this._queueCallback(d, s, this._isAnimated()),
        c && this.cycle()
    }
    _isAnimated() {
        return this._element.classList.contains(Gx)
    }
    _getActive() {
        return te.findOne(jx, this._element)
    }
    _getItems() {
        return te.find(iv, this._element)
    }
    _clearInterval() {
        this._interval && (clearInterval(this._interval),
        this._interval = null)
    }
    _directionToOrder(t) {
        return ji() ? t === Zr ? Nr : Xo : t === Zr ? Xo : Nr
    }
    _orderToDirection(t) {
        return ji() ? t === Nr ? Zr : Wl : t === Nr ? Wl : Zr
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = Ka.getOrCreateInstance(this, t);
            if (typeof t == "number") {
                i.to(t);
                return
            }
            if (typeof t == "string") {
                if (i[t] === void 0 || t.startsWith("_") || t === "constructor")
                    throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        })
    }
}
q.on(document, Ux, Yx, function(e) {
    const t = Xs(this);
    if (!t || !t.classList.contains(tv))
        return;
    e.preventDefault();
    const i = Ka.getOrCreateInstance(t)
      , s = this.getAttribute("data-bs-slide-to");
    if (s) {
        i.to(s),
        i._maybeEnableCycle();
        return
    }
    if (Ks.getDataAttribute(this, "slide") === "next") {
        i.next(),
        i._maybeEnableCycle();
        return
    }
    i.prev(),
    i._maybeEnableCycle()
});
q.on(window, Bx, ()=>{
    const e = te.find(Kx);
    for (const t of e)
        Ka.getOrCreateInstance(t)
}
);
Wi(Ka);
const Qx = "collapse"
  , t2 = "bs.collapse"
  , Za = `.${t2}`
  , e2 = ".data-api"
  , i2 = `show${Za}`
  , s2 = `shown${Za}`
  , n2 = `hide${Za}`
  , r2 = `hidden${Za}`
  , o2 = `click${Za}${e2}`
  , Ph = "show"
  , ro = "collapse"
  , ol = "collapsing"
  , a2 = "collapsed"
  , l2 = `:scope .${ro} .${ro}`
  , c2 = "collapse-horizontal"
  , h2 = "width"
  , u2 = "height"
  , d2 = ".collapse.show, .collapse.collapsing"
  , Mu = '[data-bs-toggle="collapse"]'
  , f2 = {
    parent: null,
    toggle: !0
}
  , p2 = {
    parent: "(null|element)",
    toggle: "boolean"
};
class Ra extends ms {
    constructor(t, i) {
        super(t, i),
        this._isTransitioning = !1,
        this._triggerArray = [];
        const s = te.find(Mu);
        for (const n of s) {
            const r = H0(n)
              , o = te.find(r).filter(a=>a === this._element);
            r !== null && o.length && this._triggerArray.push(n)
        }
        this._initializeChildren(),
        this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()),
        this._config.toggle && this.toggle()
    }
    static get Default() {
        return f2
    }
    static get DefaultType() {
        return p2
    }
    static get NAME() {
        return Qx
    }
    toggle() {
        this._isShown() ? this.hide() : this.show()
    }
    show() {
        if (this._isTransitioning || this._isShown())
            return;
        let t = [];
        if (this._config.parent && (t = this._getFirstLevelChildren(d2).filter(a=>a !== this._element).map(a=>Ra.getOrCreateInstance(a, {
            toggle: !1
        }))),
        t.length && t[0]._isTransitioning || q.trigger(this._element, i2).defaultPrevented)
            return;
        for (const a of t)
            a.hide();
        const s = this._getDimension();
        this._element.classList.remove(ro),
        this._element.classList.add(ol),
        this._element.style[s] = 0,
        this._addAriaAndCollapsedClass(this._triggerArray, !0),
        this._isTransitioning = !0;
        const n = ()=>{
            this._isTransitioning = !1,
            this._element.classList.remove(ol),
            this._element.classList.add(ro, Ph),
            this._element.style[s] = "",
            q.trigger(this._element, s2)
        }
          , o = `scroll${s[0].toUpperCase() + s.slice(1)}`;
        this._queueCallback(n, this._element, !0),
        this._element.style[s] = `${this._element[o]}px`
    }
    hide() {
        if (this._isTransitioning || !this._isShown() || q.trigger(this._element, n2).defaultPrevented)
            return;
        const i = this._getDimension();
        this._element.style[i] = `${this._element.getBoundingClientRect()[i]}px`,
        Xa(this._element),
        this._element.classList.add(ol),
        this._element.classList.remove(ro, Ph);
        for (const n of this._triggerArray) {
            const r = Xs(n);
            r && !this._isShown(r) && this._addAriaAndCollapsedClass([n], !1)
        }
        this._isTransitioning = !0;
        const s = ()=>{
            this._isTransitioning = !1,
            this._element.classList.remove(ol),
            this._element.classList.add(ro),
            q.trigger(this._element, r2)
        }
        ;
        this._element.style[i] = "",
        this._queueCallback(s, this._element, !0)
    }
    _isShown(t=this._element) {
        return t.classList.contains(Ph)
    }
    _configAfterMerge(t) {
        return t.toggle = Boolean(t.toggle),
        t.parent = Mn(t.parent),
        t
    }
    _getDimension() {
        return this._element.classList.contains(c2) ? h2 : u2
    }
    _initializeChildren() {
        if (!this._config.parent)
            return;
        const t = this._getFirstLevelChildren(Mu);
        for (const i of t) {
            const s = Xs(i);
            s && this._addAriaAndCollapsedClass([i], this._isShown(s))
        }
    }
    _getFirstLevelChildren(t) {
        const i = te.find(l2, this._config.parent);
        return te.find(t, this._config.parent).filter(s=>!i.includes(s))
    }
    _addAriaAndCollapsedClass(t, i) {
        if (!!t.length)
            for (const s of t)
                s.classList.toggle(a2, !i),
                s.setAttribute("aria-expanded", i)
    }
    static jQueryInterface(t) {
        const i = {};
        return typeof t == "string" && /show|hide/.test(t) && (i.toggle = !1),
        this.each(function() {
            const s = Ra.getOrCreateInstance(this, i);
            if (typeof t == "string") {
                if (typeof s[t] > "u")
                    throw new TypeError(`No method named "${t}"`);
                s[t]()
            }
        })
    }
}
q.on(document, o2, Mu, function(e) {
    (e.target.tagName === "A" || e.delegateTarget && e.delegateTarget.tagName === "A") && e.preventDefault();
    const t = H0(this)
      , i = te.find(t);
    for (const s of i)
        Ra.getOrCreateInstance(s, {
            toggle: !1
        }).toggle()
});
Wi(Ra);
const Vp = "dropdown"
  , m2 = "bs.dropdown"
  , Mr = `.${m2}`
  , hf = ".data-api"
  , g2 = "Escape"
  , zp = "Tab"
  , v2 = "ArrowUp"
  , $p = "ArrowDown"
  , _2 = 2
  , y2 = `hide${Mr}`
  , b2 = `hidden${Mr}`
  , x2 = `show${Mr}`
  , w2 = `shown${Mr}`
  , sv = `click${Mr}${hf}`
  , nv = `keydown${Mr}${hf}`
  , T2 = `keyup${Mr}${hf}`
  , qr = "show"
  , E2 = "dropup"
  , S2 = "dropend"
  , C2 = "dropstart"
  , A2 = "dropup-center"
  , I2 = "dropdown-center"
  , $c = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)'
  , M2 = `${$c}.${qr}`
  , rv = ".dropdown-menu"
  , R2 = ".navbar"
  , k2 = ".navbar-nav"
  , P2 = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)"
  , L2 = ji() ? "top-end" : "top-start"
  , O2 = ji() ? "top-start" : "top-end"
  , D2 = ji() ? "bottom-end" : "bottom-start"
  , N2 = ji() ? "bottom-start" : "bottom-end"
  , F2 = ji() ? "left-start" : "right-start"
  , B2 = ji() ? "right-start" : "left-start"
  , U2 = "top"
  , G2 = "bottom"
  , H2 = {
    autoClose: !0,
    boundary: "clippingParents",
    display: "dynamic",
    offset: [0, 2],
    popperConfig: null,
    reference: "toggle"
}
  , V2 = {
    autoClose: "(boolean|string)",
    boundary: "(string|element)",
    display: "string",
    offset: "(array|string|function)",
    popperConfig: "(null|object|function)",
    reference: "(string|element|object)"
};
class ks extends ms {
    constructor(t, i) {
        super(t, i),
        this._popper = null,
        this._parent = this._element.parentNode,
        this._menu = te.findOne(rv, this._parent),
        this._inNavbar = this._detectNavbar()
    }
    static get Default() {
        return H2
    }
    static get DefaultType() {
        return V2
    }
    static get NAME() {
        return Vp
    }
    toggle() {
        return this._isShown() ? this.hide() : this.show()
    }
    show() {
        if (Rn(this._element) || this._isShown())
            return;
        const t = {
            relatedTarget: this._element
        };
        if (!q.trigger(this._element, x2, t).defaultPrevented) {
            if (this._createPopper(),
            "ontouchstart"in document.documentElement && !this._parent.closest(k2))
                for (const s of [].concat(...document.body.children))
                    q.on(s, "mouseover", hc);
            this._element.focus(),
            this._element.setAttribute("aria-expanded", !0),
            this._menu.classList.add(qr),
            this._element.classList.add(qr),
            q.trigger(this._element, w2, t)
        }
    }
    hide() {
        if (Rn(this._element) || !this._isShown())
            return;
        const t = {
            relatedTarget: this._element
        };
        this._completeHide(t)
    }
    dispose() {
        this._popper && this._popper.destroy(),
        super.dispose()
    }
    update() {
        this._inNavbar = this._detectNavbar(),
        this._popper && this._popper.update()
    }
    _completeHide(t) {
        if (!q.trigger(this._element, y2, t).defaultPrevented) {
            if ("ontouchstart"in document.documentElement)
                for (const s of [].concat(...document.body.children))
                    q.off(s, "mouseover", hc);
            this._popper && this._popper.destroy(),
            this._menu.classList.remove(qr),
            this._element.classList.remove(qr),
            this._element.setAttribute("aria-expanded", "false"),
            Ks.removeDataAttribute(this._menu, "popper"),
            q.trigger(this._element, b2, t)
        }
    }
    _getConfig(t) {
        if (t = super._getConfig(t),
        typeof t.reference == "object" && !Ys(t.reference) && typeof t.reference.getBoundingClientRect != "function")
            throw new TypeError(`${Vp.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
        return t
    }
    _createPopper() {
        if (typeof U0 > "u")
            throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
        let t = this._element;
        this._config.reference === "parent" ? t = this._parent : Ys(this._config.reference) ? t = Mn(this._config.reference) : typeof this._config.reference == "object" && (t = this._config.reference);
        const i = this._getPopperConfig();
        this._popper = af(t, this._menu, i)
    }
    _isShown() {
        return this._menu.classList.contains(qr)
    }
    _getPlacement() {
        const t = this._parent;
        if (t.classList.contains(S2))
            return F2;
        if (t.classList.contains(C2))
            return B2;
        if (t.classList.contains(A2))
            return U2;
        if (t.classList.contains(I2))
            return G2;
        const i = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
        return t.classList.contains(E2) ? i ? O2 : L2 : i ? N2 : D2
    }
    _detectNavbar() {
        return this._element.closest(R2) !== null
    }
    _getOffset() {
        const {offset: t} = this._config;
        return typeof t == "string" ? t.split(",").map(i=>Number.parseInt(i, 10)) : typeof t == "function" ? i=>t(i, this._element) : t
    }
    _getPopperConfig() {
        const t = {
            placement: this._getPlacement(),
            modifiers: [{
                name: "preventOverflow",
                options: {
                    boundary: this._config.boundary
                }
            }, {
                name: "offset",
                options: {
                    offset: this._getOffset()
                }
            }]
        };
        return (this._inNavbar || this._config.display === "static") && (Ks.setDataAttribute(this._menu, "popper", "static"),
        t.modifiers = [{
            name: "applyStyles",
            enabled: !1
        }]),
        {
            ...t,
            ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig
        }
    }
    _selectMenuItem({key: t, target: i}) {
        const s = te.find(P2, this._menu).filter(n=>Uo(n));
        !s.length || lf(s, i, t === $p, !s.includes(i)).focus()
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = ks.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (typeof i[t] > "u")
                    throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        })
    }
    static clearMenus(t) {
        if (t.button === _2 || t.type === "keyup" && t.key !== zp)
            return;
        const i = te.find(M2);
        for (const s of i) {
            const n = ks.getInstance(s);
            if (!n || n._config.autoClose === !1)
                continue;
            const r = t.composedPath()
              , o = r.includes(n._menu);
            if (r.includes(n._element) || n._config.autoClose === "inside" && !o || n._config.autoClose === "outside" && o || n._menu.contains(t.target) && (t.type === "keyup" && t.key === zp || /input|select|option|textarea|form/i.test(t.target.tagName)))
                continue;
            const a = {
                relatedTarget: n._element
            };
            t.type === "click" && (a.clickEvent = t),
            n._completeHide(a)
        }
    }
    static dataApiKeydownHandler(t) {
        const i = /input|textarea/i.test(t.target.tagName)
          , s = t.key === g2
          , n = [v2, $p].includes(t.key);
        if (!n && !s || i && !s)
            return;
        t.preventDefault();
        const r = te.findOne($c, t.delegateTarget.parentNode)
          , o = ks.getOrCreateInstance(r);
        if (n) {
            t.stopPropagation(),
            o.show(),
            o._selectMenuItem(t);
            return
        }
        o._isShown() && (t.stopPropagation(),
        o.hide(),
        r.focus())
    }
}
q.on(document, nv, $c, ks.dataApiKeydownHandler);
q.on(document, nv, rv, ks.dataApiKeydownHandler);
q.on(document, sv, ks.clearMenus);
q.on(document, T2, ks.clearMenus);
q.on(document, sv, $c, function(e) {
    e.preventDefault(),
    ks.getOrCreateInstance(this).toggle()
});
Wi(ks);
const jp = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top"
  , Wp = ".sticky-top"
  , al = "padding-right"
  , Xp = "margin-right";
class Ru {
    constructor() {
        this._element = document.body
    }
    getWidth() {
        const t = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - t)
    }
    hide() {
        const t = this.getWidth();
        this._disableOverFlow(),
        this._setElementAttributes(this._element, al, i=>i + t),
        this._setElementAttributes(jp, al, i=>i + t),
        this._setElementAttributes(Wp, Xp, i=>i - t)
    }
    reset() {
        this._resetElementAttributes(this._element, "overflow"),
        this._resetElementAttributes(this._element, al),
        this._resetElementAttributes(jp, al),
        this._resetElementAttributes(Wp, Xp)
    }
    isOverflowing() {
        return this.getWidth() > 0
    }
    _disableOverFlow() {
        this._saveInitialAttribute(this._element, "overflow"),
        this._element.style.overflow = "hidden"
    }
    _setElementAttributes(t, i, s) {
        const n = this.getWidth()
          , r = o=>{
            if (o !== this._element && window.innerWidth > o.clientWidth + n)
                return;
            this._saveInitialAttribute(o, i);
            const a = window.getComputedStyle(o).getPropertyValue(i);
            o.style.setProperty(i, `${s(Number.parseFloat(a))}px`)
        }
        ;
        this._applyManipulationCallback(t, r)
    }
    _saveInitialAttribute(t, i) {
        const s = t.style.getPropertyValue(i);
        s && Ks.setDataAttribute(t, i, s)
    }
    _resetElementAttributes(t, i) {
        const s = n=>{
            const r = Ks.getDataAttribute(n, i);
            if (r === null) {
                n.style.removeProperty(i);
                return
            }
            Ks.removeDataAttribute(n, i),
            n.style.setProperty(i, r)
        }
        ;
        this._applyManipulationCallback(t, s)
    }
    _applyManipulationCallback(t, i) {
        if (Ys(t)) {
            i(t);
            return
        }
        for (const s of te.find(t, this._element))
            i(s)
    }
}
const ov = "backdrop"
  , z2 = "fade"
  , Yp = "show"
  , Kp = `mousedown.bs.${ov}`
  , $2 = {
    className: "modal-backdrop",
    clickCallback: null,
    isAnimated: !1,
    isVisible: !0,
    rootElement: "body"
}
  , j2 = {
    className: "string",
    clickCallback: "(function|null)",
    isAnimated: "boolean",
    isVisible: "boolean",
    rootElement: "(element|string)"
};
class av extends Ya {
    constructor(t) {
        super(),
        this._config = this._getConfig(t),
        this._isAppended = !1,
        this._element = null
    }
    static get Default() {
        return $2
    }
    static get DefaultType() {
        return j2
    }
    static get NAME() {
        return ov
    }
    show(t) {
        if (!this._config.isVisible) {
            $s(t);
            return
        }
        this._append();
        const i = this._getElement();
        this._config.isAnimated && Xa(i),
        i.classList.add(Yp),
        this._emulateAnimation(()=>{
            $s(t)
        }
        )
    }
    hide(t) {
        if (!this._config.isVisible) {
            $s(t);
            return
        }
        this._getElement().classList.remove(Yp),
        this._emulateAnimation(()=>{
            this.dispose(),
            $s(t)
        }
        )
    }
    dispose() {
        !this._isAppended || (q.off(this._element, Kp),
        this._element.remove(),
        this._isAppended = !1)
    }
    _getElement() {
        if (!this._element) {
            const t = document.createElement("div");
            t.className = this._config.className,
            this._config.isAnimated && t.classList.add(z2),
            this._element = t
        }
        return this._element
    }
    _configAfterMerge(t) {
        return t.rootElement = Mn(t.rootElement),
        t
    }
    _append() {
        if (this._isAppended)
            return;
        const t = this._getElement();
        this._config.rootElement.append(t),
        q.on(t, Kp, ()=>{
            $s(this._config.clickCallback)
        }
        ),
        this._isAppended = !0
    }
    _emulateAnimation(t) {
        j0(t, this._getElement(), this._config.isAnimated)
    }
}
const W2 = "focustrap"
  , X2 = "bs.focustrap"
  , dc = `.${X2}`
  , Y2 = `focusin${dc}`
  , K2 = `keydown.tab${dc}`
  , Z2 = "Tab"
  , q2 = "forward"
  , Zp = "backward"
  , J2 = {
    autofocus: !0,
    trapElement: null
}
  , Q2 = {
    autofocus: "boolean",
    trapElement: "element"
};
class lv extends Ya {
    constructor(t) {
        super(),
        this._config = this._getConfig(t),
        this._isActive = !1,
        this._lastTabNavDirection = null
    }
    static get Default() {
        return J2
    }
    static get DefaultType() {
        return Q2
    }
    static get NAME() {
        return W2
    }
    activate() {
        this._isActive || (this._config.autofocus && this._config.trapElement.focus(),
        q.off(document, dc),
        q.on(document, Y2, t=>this._handleFocusin(t)),
        q.on(document, K2, t=>this._handleKeydown(t)),
        this._isActive = !0)
    }
    deactivate() {
        !this._isActive || (this._isActive = !1,
        q.off(document, dc))
    }
    _handleFocusin(t) {
        const {trapElement: i} = this._config;
        if (t.target === document || t.target === i || i.contains(t.target))
            return;
        const s = te.focusableChildren(i);
        s.length === 0 ? i.focus() : this._lastTabNavDirection === Zp ? s[s.length - 1].focus() : s[0].focus()
    }
    _handleKeydown(t) {
        t.key === Z2 && (this._lastTabNavDirection = t.shiftKey ? Zp : q2)
    }
}
const tw = "modal"
  , ew = "bs.modal"
  , Bs = `.${ew}`
  , iw = ".data-api"
  , sw = "Escape"
  , nw = `hide${Bs}`
  , rw = `hidePrevented${Bs}`
  , cv = `hidden${Bs}`
  , hv = `show${Bs}`
  , ow = `shown${Bs}`
  , aw = `resize${Bs}`
  , lw = `mousedown.dismiss${Bs}`
  , cw = `keydown.dismiss${Bs}`
  , hw = `click${Bs}${iw}`
  , qp = "modal-open"
  , uw = "fade"
  , Jp = "show"
  , Lh = "modal-static"
  , dw = ".modal.show"
  , fw = ".modal-dialog"
  , pw = ".modal-body"
  , mw = '[data-bs-toggle="modal"]'
  , gw = {
    backdrop: !0,
    focus: !0,
    keyboard: !0
}
  , vw = {
    backdrop: "(boolean|string)",
    focus: "boolean",
    keyboard: "boolean"
};
class Ao extends ms {
    constructor(t, i) {
        super(t, i),
        this._dialog = te.findOne(fw, this._element),
        this._backdrop = this._initializeBackDrop(),
        this._focustrap = this._initializeFocusTrap(),
        this._isShown = !1,
        this._isTransitioning = !1,
        this._scrollBar = new Ru,
        this._addEventListeners()
    }
    static get Default() {
        return gw
    }
    static get DefaultType() {
        return vw
    }
    static get NAME() {
        return tw
    }
    toggle(t) {
        return this._isShown ? this.hide() : this.show(t)
    }
    show(t) {
        this._isShown || this._isTransitioning || q.trigger(this._element, hv, {
            relatedTarget: t
        }).defaultPrevented || (this._isShown = !0,
        this._isTransitioning = !0,
        this._scrollBar.hide(),
        document.body.classList.add(qp),
        this._adjustDialog(),
        this._backdrop.show(()=>this._showElement(t)))
    }
    hide() {
        !this._isShown || this._isTransitioning || q.trigger(this._element, nw).defaultPrevented || (this._isShown = !1,
        this._isTransitioning = !0,
        this._focustrap.deactivate(),
        this._element.classList.remove(Jp),
        this._queueCallback(()=>this._hideModal(), this._element, this._isAnimated()))
    }
    dispose() {
        for (const t of [window, this._dialog])
            q.off(t, Bs);
        this._backdrop.dispose(),
        this._focustrap.deactivate(),
        super.dispose()
    }
    handleUpdate() {
        this._adjustDialog()
    }
    _initializeBackDrop() {
        return new av({
            isVisible: Boolean(this._config.backdrop),
            isAnimated: this._isAnimated()
        })
    }
    _initializeFocusTrap() {
        return new lv({
            trapElement: this._element
        })
    }
    _showElement(t) {
        document.body.contains(this._element) || document.body.append(this._element),
        this._element.style.display = "block",
        this._element.removeAttribute("aria-hidden"),
        this._element.setAttribute("aria-modal", !0),
        this._element.setAttribute("role", "dialog"),
        this._element.scrollTop = 0;
        const i = te.findOne(pw, this._dialog);
        i && (i.scrollTop = 0),
        Xa(this._element),
        this._element.classList.add(Jp);
        const s = ()=>{
            this._config.focus && this._focustrap.activate(),
            this._isTransitioning = !1,
            q.trigger(this._element, ow, {
                relatedTarget: t
            })
        }
        ;
        this._queueCallback(s, this._dialog, this._isAnimated())
    }
    _addEventListeners() {
        q.on(this._element, cw, t=>{
            if (t.key === sw) {
                if (this._config.keyboard) {
                    t.preventDefault(),
                    this.hide();
                    return
                }
                this._triggerBackdropTransition()
            }
        }
        ),
        q.on(window, aw, ()=>{
            this._isShown && !this._isTransitioning && this._adjustDialog()
        }
        ),
        q.on(this._element, lw, t=>{
            if (t.target === t.currentTarget) {
                if (this._config.backdrop === "static") {
                    this._triggerBackdropTransition();
                    return
                }
                this._config.backdrop && this.hide()
            }
        }
        )
    }
    _hideModal() {
        this._element.style.display = "none",
        this._element.setAttribute("aria-hidden", !0),
        this._element.removeAttribute("aria-modal"),
        this._element.removeAttribute("role"),
        this._isTransitioning = !1,
        this._backdrop.hide(()=>{
            document.body.classList.remove(qp),
            this._resetAdjustments(),
            this._scrollBar.reset(),
            q.trigger(this._element, cv)
        }
        )
    }
    _isAnimated() {
        return this._element.classList.contains(uw)
    }
    _triggerBackdropTransition() {
        if (q.trigger(this._element, rw).defaultPrevented)
            return;
        const i = this._element.scrollHeight > document.documentElement.clientHeight
          , s = this._element.style.overflowY;
        s === "hidden" || this._element.classList.contains(Lh) || (i || (this._element.style.overflowY = "hidden"),
        this._element.classList.add(Lh),
        this._queueCallback(()=>{
            this._element.classList.remove(Lh),
            this._queueCallback(()=>{
                this._element.style.overflowY = s
            }
            , this._dialog)
        }
        , this._dialog),
        this._element.focus())
    }
    _adjustDialog() {
        const t = this._element.scrollHeight > document.documentElement.clientHeight
          , i = this._scrollBar.getWidth()
          , s = i > 0;
        if (s && !t) {
            const n = ji() ? "paddingLeft" : "paddingRight";
            this._element.style[n] = `${i}px`
        }
        if (!s && t) {
            const n = ji() ? "paddingRight" : "paddingLeft";
            this._element.style[n] = `${i}px`
        }
    }
    _resetAdjustments() {
        this._element.style.paddingLeft = "",
        this._element.style.paddingRight = ""
    }
    static jQueryInterface(t, i) {
        return this.each(function() {
            const s = Ao.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (typeof s[t] > "u")
                    throw new TypeError(`No method named "${t}"`);
                s[t](i)
            }
        })
    }
}
q.on(document, hw, mw, function(e) {
    const t = Xs(this);
    ["A", "AREA"].includes(this.tagName) && e.preventDefault(),
    q.one(t, hv, n=>{
        n.defaultPrevented || q.one(t, cv, ()=>{
            Uo(this) && this.focus()
        }
        )
    }
    );
    const i = te.findOne(dw);
    i && Ao.getInstance(i).hide(),
    Ao.getOrCreateInstance(t).toggle(this)
});
Hc(Ao);
Wi(Ao);
const _w = "offcanvas"
  , yw = "bs.offcanvas"
  , sn = `.${yw}`
  , uv = ".data-api"
  , bw = `load${sn}${uv}`
  , xw = "Escape"
  , Qp = "show"
  , tm = "showing"
  , em = "hiding"
  , ww = "offcanvas-backdrop"
  , dv = ".offcanvas.show"
  , Tw = `show${sn}`
  , Ew = `shown${sn}`
  , Sw = `hide${sn}`
  , im = `hidePrevented${sn}`
  , fv = `hidden${sn}`
  , Cw = `resize${sn}`
  , Aw = `click${sn}${uv}`
  , Iw = `keydown.dismiss${sn}`
  , Mw = '[data-bs-toggle="offcanvas"]'
  , Rw = {
    backdrop: !0,
    keyboard: !0,
    scroll: !1
}
  , kw = {
    backdrop: "(boolean|string)",
    keyboard: "boolean",
    scroll: "boolean"
};
class kn extends ms {
    constructor(t, i) {
        super(t, i),
        this._isShown = !1,
        this._backdrop = this._initializeBackDrop(),
        this._focustrap = this._initializeFocusTrap(),
        this._addEventListeners()
    }
    static get Default() {
        return Rw
    }
    static get DefaultType() {
        return kw
    }
    static get NAME() {
        return _w
    }
    toggle(t) {
        return this._isShown ? this.hide() : this.show(t)
    }
    show(t) {
        if (this._isShown || q.trigger(this._element, Tw, {
            relatedTarget: t
        }).defaultPrevented)
            return;
        this._isShown = !0,
        this._backdrop.show(),
        this._config.scroll || new Ru().hide(),
        this._element.setAttribute("aria-modal", !0),
        this._element.setAttribute("role", "dialog"),
        this._element.classList.add(tm);
        const s = ()=>{
            (!this._config.scroll || this._config.backdrop) && this._focustrap.activate(),
            this._element.classList.add(Qp),
            this._element.classList.remove(tm),
            q.trigger(this._element, Ew, {
                relatedTarget: t
            })
        }
        ;
        this._queueCallback(s, this._element, !0)
    }
    hide() {
        if (!this._isShown || q.trigger(this._element, Sw).defaultPrevented)
            return;
        this._focustrap.deactivate(),
        this._element.blur(),
        this._isShown = !1,
        this._element.classList.add(em),
        this._backdrop.hide();
        const i = ()=>{
            this._element.classList.remove(Qp, em),
            this._element.removeAttribute("aria-modal"),
            this._element.removeAttribute("role"),
            this._config.scroll || new Ru().reset(),
            q.trigger(this._element, fv)
        }
        ;
        this._queueCallback(i, this._element, !0)
    }
    dispose() {
        this._backdrop.dispose(),
        this._focustrap.deactivate(),
        super.dispose()
    }
    _initializeBackDrop() {
        const t = ()=>{
            if (this._config.backdrop === "static") {
                q.trigger(this._element, im);
                return
            }
            this.hide()
        }
          , i = Boolean(this._config.backdrop);
        return new av({
            className: ww,
            isVisible: i,
            isAnimated: !0,
            rootElement: this._element.parentNode,
            clickCallback: i ? t : null
        })
    }
    _initializeFocusTrap() {
        return new lv({
            trapElement: this._element
        })
    }
    _addEventListeners() {
        q.on(this._element, Iw, t=>{
            if (t.key === xw) {
                if (!this._config.keyboard) {
                    q.trigger(this._element, im);
                    return
                }
                this.hide()
            }
        }
        )
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = kn.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (i[t] === void 0 || t.startsWith("_") || t === "constructor")
                    throw new TypeError(`No method named "${t}"`);
                i[t](this)
            }
        })
    }
}
q.on(document, Aw, Mw, function(e) {
    const t = Xs(this);
    if (["A", "AREA"].includes(this.tagName) && e.preventDefault(),
    Rn(this))
        return;
    q.one(t, fv, ()=>{
        Uo(this) && this.focus()
    }
    );
    const i = te.findOne(dv);
    i && i !== t && kn.getInstance(i).hide(),
    kn.getOrCreateInstance(t).toggle(this)
});
q.on(window, bw, ()=>{
    for (const e of te.find(dv))
        kn.getOrCreateInstance(e).show()
}
);
q.on(window, Cw, ()=>{
    for (const e of te.find("[aria-modal][class*=show][class*=offcanvas-]"))
        getComputedStyle(e).position !== "fixed" && kn.getOrCreateInstance(e).hide()
}
);
Hc(kn);
Wi(kn);
const Pw = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"])
  , Lw = /^aria-[\w-]*$/i
  , Ow = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i
  , Dw = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i
  , Nw = (e,t)=>{
    const i = e.nodeName.toLowerCase();
    return t.includes(i) ? Pw.has(i) ? Boolean(Ow.test(e.nodeValue) || Dw.test(e.nodeValue)) : !0 : t.filter(s=>s instanceof RegExp).some(s=>s.test(i))
}
  , pv = {
    "*": ["class", "dir", "id", "lang", "role", Lw],
    a: ["target", "href", "title", "rel"],
    area: [],
    b: [],
    br: [],
    col: [],
    code: [],
    div: [],
    em: [],
    hr: [],
    h1: [],
    h2: [],
    h3: [],
    h4: [],
    h5: [],
    h6: [],
    i: [],
    img: ["src", "srcset", "alt", "title", "width", "height"],
    li: [],
    ol: [],
    p: [],
    pre: [],
    s: [],
    small: [],
    span: [],
    sub: [],
    sup: [],
    strong: [],
    u: [],
    ul: []
};
function Fw(e, t, i) {
    if (!e.length)
        return e;
    if (i && typeof i == "function")
        return i(e);
    const n = new window.DOMParser().parseFromString(e, "text/html")
      , r = [].concat(...n.body.querySelectorAll("*"));
    for (const o of r) {
        const a = o.nodeName.toLowerCase();
        if (!Object.keys(t).includes(a)) {
            o.remove();
            continue
        }
        const l = [].concat(...o.attributes)
          , c = [].concat(t["*"] || [], t[a] || []);
        for (const h of l)
            Nw(h, c) || o.removeAttribute(h.nodeName)
    }
    return n.body.innerHTML
}
const Bw = "TemplateFactory"
  , Uw = {
    allowList: pv,
    content: {},
    extraClass: "",
    html: !1,
    sanitize: !0,
    sanitizeFn: null,
    template: "<div></div>"
}
  , Gw = {
    allowList: "object",
    content: "object",
    extraClass: "(string|function)",
    html: "boolean",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    template: "string"
}
  , Hw = {
    entry: "(string|element|function|null)",
    selector: "(string|element)"
};
class Vw extends Ya {
    constructor(t) {
        super(),
        this._config = this._getConfig(t)
    }
    static get Default() {
        return Uw
    }
    static get DefaultType() {
        return Gw
    }
    static get NAME() {
        return Bw
    }
    getContent() {
        return Object.values(this._config.content).map(t=>this._resolvePossibleFunction(t)).filter(Boolean)
    }
    hasContent() {
        return this.getContent().length > 0
    }
    changeContent(t) {
        return this._checkContent(t),
        this._config.content = {
            ...this._config.content,
            ...t
        },
        this
    }
    toHtml() {
        const t = document.createElement("div");
        t.innerHTML = this._maybeSanitize(this._config.template);
        for (const [n,r] of Object.entries(this._config.content))
            this._setContent(t, r, n);
        const i = t.children[0]
          , s = this._resolvePossibleFunction(this._config.extraClass);
        return s && i.classList.add(...s.split(" ")),
        i
    }
    _typeCheckConfig(t) {
        super._typeCheckConfig(t),
        this._checkContent(t.content)
    }
    _checkContent(t) {
        for (const [i,s] of Object.entries(t))
            super._typeCheckConfig({
                selector: i,
                entry: s
            }, Hw)
    }
    _setContent(t, i, s) {
        const n = te.findOne(s, t);
        if (!!n) {
            if (i = this._resolvePossibleFunction(i),
            !i) {
                n.remove();
                return
            }
            if (Ys(i)) {
                this._putElementInTemplate(Mn(i), n);
                return
            }
            if (this._config.html) {
                n.innerHTML = this._maybeSanitize(i);
                return
            }
            n.textContent = i
        }
    }
    _maybeSanitize(t) {
        return this._config.sanitize ? Fw(t, this._config.allowList, this._config.sanitizeFn) : t
    }
    _resolvePossibleFunction(t) {
        return typeof t == "function" ? t(this) : t
    }
    _putElementInTemplate(t, i) {
        if (this._config.html) {
            i.innerHTML = "",
            i.append(t);
            return
        }
        i.textContent = t.textContent
    }
}
const zw = "tooltip"
  , $w = new Set(["sanitize", "allowList", "sanitizeFn"])
  , Oh = "fade"
  , jw = "modal"
  , ll = "show"
  , Ww = ".tooltip-inner"
  , sm = `.${jw}`
  , nm = "hide.bs.modal"
  , Yo = "hover"
  , Dh = "focus"
  , Xw = "click"
  , Yw = "manual"
  , Kw = "hide"
  , Zw = "hidden"
  , qw = "show"
  , Jw = "shown"
  , Qw = "inserted"
  , tT = "click"
  , eT = "focusin"
  , iT = "focusout"
  , sT = "mouseenter"
  , nT = "mouseleave"
  , rT = {
    AUTO: "auto",
    TOP: "top",
    RIGHT: ji() ? "left" : "right",
    BOTTOM: "bottom",
    LEFT: ji() ? "right" : "left"
}
  , oT = {
    allowList: pv,
    animation: !0,
    boundary: "clippingParents",
    container: !1,
    customClass: "",
    delay: 0,
    fallbackPlacements: ["top", "right", "bottom", "left"],
    html: !1,
    offset: [0, 0],
    placement: "top",
    popperConfig: null,
    sanitize: !0,
    sanitizeFn: null,
    selector: !1,
    template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
    title: "",
    trigger: "hover focus"
}
  , aT = {
    allowList: "object",
    animation: "boolean",
    boundary: "(string|element)",
    container: "(string|element|boolean)",
    customClass: "(string|function)",
    delay: "(number|object)",
    fallbackPlacements: "array",
    html: "boolean",
    offset: "(array|string|function)",
    placement: "(string|function)",
    popperConfig: "(null|object|function)",
    sanitize: "boolean",
    sanitizeFn: "(null|function)",
    selector: "(string|boolean)",
    template: "string",
    title: "(string|element|function)",
    trigger: "string"
};
class Ho extends ms {
    constructor(t, i) {
        if (typeof U0 > "u")
            throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
        super(t, i),
        this._isEnabled = !0,
        this._timeout = 0,
        this._isHovered = !1,
        this._activeTrigger = {},
        this._popper = null,
        this._templateFactory = null,
        this._newContent = null,
        this.tip = null,
        this._setListeners()
    }
    static get Default() {
        return oT
    }
    static get DefaultType() {
        return aT
    }
    static get NAME() {
        return zw
    }
    enable() {
        this._isEnabled = !0
    }
    disable() {
        this._isEnabled = !1
    }
    toggleEnabled() {
        this._isEnabled = !this._isEnabled
    }
    toggle(t) {
        if (!!this._isEnabled) {
            if (t) {
                const i = this._initializeOnDelegatedTarget(t);
                i._activeTrigger.click = !i._activeTrigger.click,
                i._isWithActiveTrigger() ? i._enter() : i._leave();
                return
            }
            if (this._isShown()) {
                this._leave();
                return
            }
            this._enter()
        }
    }
    dispose() {
        clearTimeout(this._timeout),
        q.off(this._element.closest(sm), nm, this._hideModalHandler),
        this.tip && this.tip.remove(),
        this._disposePopper(),
        super.dispose()
    }
    show() {
        if (this._element.style.display === "none")
            throw new Error("Please use show on visible elements");
        if (!(this._isWithContent() && this._isEnabled))
            return;
        const t = q.trigger(this._element, this.constructor.eventName(qw))
          , s = (z0(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
        if (t.defaultPrevented || !s)
            return;
        this.tip && (this.tip.remove(),
        this.tip = null);
        const n = this._getTipElement();
        this._element.setAttribute("aria-describedby", n.getAttribute("id"));
        const {container: r} = this._config;
        if (this._element.ownerDocument.documentElement.contains(this.tip) || (r.append(n),
        q.trigger(this._element, this.constructor.eventName(Qw))),
        this._popper ? this._popper.update() : this._popper = this._createPopper(n),
        n.classList.add(ll),
        "ontouchstart"in document.documentElement)
            for (const a of [].concat(...document.body.children))
                q.on(a, "mouseover", hc);
        const o = ()=>{
            const a = this._isHovered;
            this._isHovered = !1,
            q.trigger(this._element, this.constructor.eventName(Jw)),
            a && this._leave()
        }
        ;
        this._queueCallback(o, this.tip, this._isAnimated())
    }
    hide() {
        if (!this._isShown() || q.trigger(this._element, this.constructor.eventName(Kw)).defaultPrevented)
            return;
        const i = this._getTipElement();
        if (i.classList.remove(ll),
        "ontouchstart"in document.documentElement)
            for (const n of [].concat(...document.body.children))
                q.off(n, "mouseover", hc);
        this._activeTrigger[Xw] = !1,
        this._activeTrigger[Dh] = !1,
        this._activeTrigger[Yo] = !1,
        this._isHovered = !1;
        const s = ()=>{
            this._isWithActiveTrigger() || (this._isHovered || i.remove(),
            this._element.removeAttribute("aria-describedby"),
            q.trigger(this._element, this.constructor.eventName(Zw)),
            this._disposePopper())
        }
        ;
        this._queueCallback(s, this.tip, this._isAnimated())
    }
    update() {
        this._popper && this._popper.update()
    }
    _isWithContent() {
        return Boolean(this._getTitle())
    }
    _getTipElement() {
        return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())),
        this.tip
    }
    _createTipElement(t) {
        const i = this._getTemplateFactory(t).toHtml();
        if (!i)
            return null;
        i.classList.remove(Oh, ll),
        i.classList.add(`bs-${this.constructor.NAME}-auto`);
        const s = Xb(this.constructor.NAME).toString();
        return i.setAttribute("id", s),
        this._isAnimated() && i.classList.add(Oh),
        i
    }
    setContent(t) {
        this._newContent = t,
        this._isShown() && (this._disposePopper(),
        this.show())
    }
    _getTemplateFactory(t) {
        return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new Vw({
            ...this._config,
            content: t,
            extraClass: this._resolvePossibleFunction(this._config.customClass)
        }),
        this._templateFactory
    }
    _getContentForTemplate() {
        return {
            [Ww]: this._getTitle()
        }
    }
    _getTitle() {
        return this._resolvePossibleFunction(this._config.title) || this._config.originalTitle
    }
    _initializeOnDelegatedTarget(t) {
        return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig())
    }
    _isAnimated() {
        return this._config.animation || this.tip && this.tip.classList.contains(Oh)
    }
    _isShown() {
        return this.tip && this.tip.classList.contains(ll)
    }
    _createPopper(t) {
        const i = typeof this._config.placement == "function" ? this._config.placement.call(this, t, this._element) : this._config.placement
          , s = rT[i.toUpperCase()];
        return af(this._element, t, this._getPopperConfig(s))
    }
    _getOffset() {
        const {offset: t} = this._config;
        return typeof t == "string" ? t.split(",").map(i=>Number.parseInt(i, 10)) : typeof t == "function" ? i=>t(i, this._element) : t
    }
    _resolvePossibleFunction(t) {
        return typeof t == "function" ? t.call(this._element) : t
    }
    _getPopperConfig(t) {
        const i = {
            placement: t,
            modifiers: [{
                name: "flip",
                options: {
                    fallbackPlacements: this._config.fallbackPlacements
                }
            }, {
                name: "offset",
                options: {
                    offset: this._getOffset()
                }
            }, {
                name: "preventOverflow",
                options: {
                    boundary: this._config.boundary
                }
            }, {
                name: "arrow",
                options: {
                    element: `.${this.constructor.NAME}-arrow`
                }
            }, {
                name: "preSetPlacement",
                enabled: !0,
                phase: "beforeMain",
                fn: s=>{
                    this._getTipElement().setAttribute("data-popper-placement", s.state.placement)
                }
            }]
        };
        return {
            ...i,
            ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(i) : this._config.popperConfig
        }
    }
    _setListeners() {
        const t = this._config.trigger.split(" ");
        for (const i of t)
            if (i === "click")
                q.on(this._element, this.constructor.eventName(tT), this._config.selector, s=>this.toggle(s));
            else if (i !== Yw) {
                const s = i === Yo ? this.constructor.eventName(sT) : this.constructor.eventName(eT)
                  , n = i === Yo ? this.constructor.eventName(nT) : this.constructor.eventName(iT);
                q.on(this._element, s, this._config.selector, r=>{
                    const o = this._initializeOnDelegatedTarget(r);
                    o._activeTrigger[r.type === "focusin" ? Dh : Yo] = !0,
                    o._enter()
                }
                ),
                q.on(this._element, n, this._config.selector, r=>{
                    const o = this._initializeOnDelegatedTarget(r);
                    o._activeTrigger[r.type === "focusout" ? Dh : Yo] = o._element.contains(r.relatedTarget),
                    o._leave()
                }
                )
            }
        this._hideModalHandler = ()=>{
            this._element && this.hide()
        }
        ,
        q.on(this._element.closest(sm), nm, this._hideModalHandler),
        this._config.selector ? this._config = {
            ...this._config,
            trigger: "manual",
            selector: ""
        } : this._fixTitle()
    }
    _fixTitle() {
        const t = this._config.originalTitle;
        !t || (!this._element.getAttribute("aria-label") && !this._element.textContent.trim() && this._element.setAttribute("aria-label", t),
        this._element.removeAttribute("title"))
    }
    _enter() {
        if (this._isShown() || this._isHovered) {
            this._isHovered = !0;
            return
        }
        this._isHovered = !0,
        this._setTimeout(()=>{
            this._isHovered && this.show()
        }
        , this._config.delay.show)
    }
    _leave() {
        this._isWithActiveTrigger() || (this._isHovered = !1,
        this._setTimeout(()=>{
            this._isHovered || this.hide()
        }
        , this._config.delay.hide))
    }
    _setTimeout(t, i) {
        clearTimeout(this._timeout),
        this._timeout = setTimeout(t, i)
    }
    _isWithActiveTrigger() {
        return Object.values(this._activeTrigger).includes(!0)
    }
    _getConfig(t) {
        const i = Ks.getDataAttributes(this._element);
        for (const s of Object.keys(i))
            $w.has(s) && delete i[s];
        return t = {
            ...i,
            ...typeof t == "object" && t ? t : {}
        },
        t = this._mergeConfigObj(t),
        t = this._configAfterMerge(t),
        this._typeCheckConfig(t),
        t
    }
    _configAfterMerge(t) {
        return t.container = t.container === !1 ? document.body : Mn(t.container),
        typeof t.delay == "number" && (t.delay = {
            show: t.delay,
            hide: t.delay
        }),
        t.originalTitle = this._element.getAttribute("title") || "",
        typeof t.title == "number" && (t.title = t.title.toString()),
        typeof t.content == "number" && (t.content = t.content.toString()),
        t
    }
    _getDelegateConfig() {
        const t = {};
        for (const i in this._config)
            this.constructor.Default[i] !== this._config[i] && (t[i] = this._config[i]);
        return t
    }
    _disposePopper() {
        this._popper && (this._popper.destroy(),
        this._popper = null)
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = Ho.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (typeof i[t] > "u")
                    throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        })
    }
}
Wi(Ho);
const lT = "popover"
  , cT = ".popover-header"
  , hT = ".popover-body"
  , uT = {
    ...Ho.Default,
    content: "",
    offset: [0, 8],
    placement: "right",
    template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
    trigger: "click"
}
  , dT = {
    ...Ho.DefaultType,
    content: "(null|string|element|function)"
};
class uf extends Ho {
    static get Default() {
        return uT
    }
    static get DefaultType() {
        return dT
    }
    static get NAME() {
        return lT
    }
    _isWithContent() {
        return this._getTitle() || this._getContent()
    }
    _getContentForTemplate() {
        return {
            [cT]: this._getTitle(),
            [hT]: this._getContent()
        }
    }
    _getContent() {
        return this._resolvePossibleFunction(this._config.content)
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = uf.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (typeof i[t] > "u")
                    throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        })
    }
}
Wi(uf);
const fT = "scrollspy"
  , pT = "bs.scrollspy"
  , df = `.${pT}`
  , mT = ".data-api"
  , gT = `activate${df}`
  , rm = `click${df}`
  , vT = `load${df}${mT}`
  , _T = "dropdown-item"
  , Fr = "active"
  , yT = '[data-bs-spy="scroll"]'
  , Nh = "[href]"
  , bT = ".nav, .list-group"
  , om = ".nav-link"
  , xT = ".nav-item"
  , wT = ".list-group-item"
  , TT = `${om}, ${xT} > ${om}, ${wT}`
  , ET = ".dropdown"
  , ST = ".dropdown-toggle"
  , CT = {
    offset: null,
    rootMargin: "0px 0px -25%",
    smoothScroll: !1,
    target: null
}
  , AT = {
    offset: "(number|null)",
    rootMargin: "string",
    smoothScroll: "boolean",
    target: "element"
};
class jc extends ms {
    constructor(t, i) {
        super(t, i),
        this._targetLinks = new Map,
        this._observableSections = new Map,
        this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element,
        this._activeTarget = null,
        this._observer = null,
        this._previousScrollData = {
            visibleEntryTop: 0,
            parentScrollTop: 0
        },
        this.refresh()
    }
    static get Default() {
        return CT
    }
    static get DefaultType() {
        return AT
    }
    static get NAME() {
        return fT
    }
    refresh() {
        this._initializeTargetsAndObservables(),
        this._maybeEnableSmoothScroll(),
        this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
        for (const t of this._observableSections.values())
            this._observer.observe(t)
    }
    dispose() {
        this._observer.disconnect(),
        super.dispose()
    }
    _configAfterMerge(t) {
        return t.target = Mn(t.target) || document.body,
        t
    }
    _maybeEnableSmoothScroll() {
        !this._config.smoothScroll || (q.off(this._config.target, rm),
        q.on(this._config.target, rm, Nh, t=>{
            const i = this._observableSections.get(t.target.hash);
            if (i) {
                t.preventDefault();
                const s = this._rootElement || window
                  , n = i.offsetTop - this._element.offsetTop;
                if (s.scrollTo) {
                    s.scrollTo({
                        top: n,
                        behavior: "smooth"
                    });
                    return
                }
                s.scrollTop = n
            }
        }
        ))
    }
    _getNewObserver() {
        const t = {
            root: this._rootElement,
            threshold: [.1, .5, 1],
            rootMargin: this._getRootMargin()
        };
        return new IntersectionObserver(i=>this._observerCallback(i),t)
    }
    _observerCallback(t) {
        const i = o=>this._targetLinks.get(`#${o.target.id}`)
          , s = o=>{
            this._previousScrollData.visibleEntryTop = o.target.offsetTop,
            this._process(i(o))
        }
          , n = (this._rootElement || document.documentElement).scrollTop
          , r = n >= this._previousScrollData.parentScrollTop;
        this._previousScrollData.parentScrollTop = n;
        for (const o of t) {
            if (!o.isIntersecting) {
                this._activeTarget = null,
                this._clearActiveClass(i(o));
                continue
            }
            const a = o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
            if (r && a) {
                if (s(o),
                !n)
                    return;
                continue
            }
            !r && !a && s(o)
        }
    }
    _getRootMargin() {
        return this._config.offset ? `${this._config.offset}px 0px -30%` : this._config.rootMargin
    }
    _initializeTargetsAndObservables() {
        this._targetLinks = new Map,
        this._observableSections = new Map;
        const t = te.find(Nh, this._config.target);
        for (const i of t) {
            if (!i.hash || Rn(i))
                continue;
            const s = te.findOne(i.hash, this._element);
            Uo(s) && (this._targetLinks.set(i.hash, i),
            this._observableSections.set(i.hash, s))
        }
    }
    _process(t) {
        this._activeTarget !== t && (this._clearActiveClass(this._config.target),
        this._activeTarget = t,
        t.classList.add(Fr),
        this._activateParents(t),
        q.trigger(this._element, gT, {
            relatedTarget: t
        }))
    }
    _activateParents(t) {
        if (t.classList.contains(_T)) {
            te.findOne(ST, t.closest(ET)).classList.add(Fr);
            return
        }
        for (const i of te.parents(t, bT))
            for (const s of te.prev(i, TT))
                s.classList.add(Fr)
    }
    _clearActiveClass(t) {
        t.classList.remove(Fr);
        const i = te.find(`${Nh}.${Fr}`, t);
        for (const s of i)
            s.classList.remove(Fr)
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = jc.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (i[t] === void 0 || t.startsWith("_") || t === "constructor")
                    throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        })
    }
}
q.on(window, vT, ()=>{
    for (const e of te.find(yT))
        jc.getOrCreateInstance(e)
}
);
Wi(jc);
const IT = "tab"
  , MT = "bs.tab"
  , Rr = `.${MT}`
  , RT = `hide${Rr}`
  , kT = `hidden${Rr}`
  , PT = `show${Rr}`
  , LT = `shown${Rr}`
  , OT = `click${Rr}`
  , DT = `keydown${Rr}`
  , NT = `load${Rr}`
  , FT = "ArrowLeft"
  , am = "ArrowRight"
  , BT = "ArrowUp"
  , lm = "ArrowDown"
  , yn = "active"
  , cm = "fade"
  , Fh = "show"
  , UT = "dropdown"
  , GT = ".dropdown-toggle"
  , HT = ".dropdown-menu"
  , VT = ".dropdown-item"
  , Bh = ":not(.dropdown-toggle)"
  , zT = '.list-group, .nav, [role="tablist"]'
  , $T = ".nav-item, .list-group-item"
  , jT = `.nav-link${Bh}, .list-group-item${Bh}, [role="tab"]${Bh}`
  , mv = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]'
  , Uh = `${jT}, ${mv}`
  , WT = `.${yn}[data-bs-toggle="tab"], .${yn}[data-bs-toggle="pill"], .${yn}[data-bs-toggle="list"]`;
class Io extends ms {
    constructor(t) {
        super(t),
        this._parent = this._element.closest(zT),
        this._parent && (this._setInitialAttributes(this._parent, this._getChildren()),
        q.on(this._element, DT, i=>this._keydown(i)))
    }
    static get NAME() {
        return IT
    }
    show() {
        const t = this._element;
        if (this._elemIsActive(t))
            return;
        const i = this._getActiveElem()
          , s = i ? q.trigger(i, RT, {
            relatedTarget: t
        }) : null;
        q.trigger(t, PT, {
            relatedTarget: i
        }).defaultPrevented || s && s.defaultPrevented || (this._deactivate(i, t),
        this._activate(t, i))
    }
    _activate(t, i) {
        if (!t)
            return;
        t.classList.add(yn),
        this._activate(Xs(t));
        const s = ()=>{
            if (t.getAttribute("role") !== "tab") {
                t.classList.add(Fh);
                return
            }
            t.focus(),
            t.removeAttribute("tabindex"),
            t.setAttribute("aria-selected", !0),
            this._toggleDropDown(t, !0),
            q.trigger(t, LT, {
                relatedTarget: i
            })
        }
        ;
        this._queueCallback(s, t, t.classList.contains(cm))
    }
    _deactivate(t, i) {
        if (!t)
            return;
        t.classList.remove(yn),
        t.blur(),
        this._deactivate(Xs(t));
        const s = ()=>{
            if (t.getAttribute("role") !== "tab") {
                t.classList.remove(Fh);
                return
            }
            t.setAttribute("aria-selected", !1),
            t.setAttribute("tabindex", "-1"),
            this._toggleDropDown(t, !1),
            q.trigger(t, kT, {
                relatedTarget: i
            })
        }
        ;
        this._queueCallback(s, t, t.classList.contains(cm))
    }
    _keydown(t) {
        if (![FT, am, BT, lm].includes(t.key))
            return;
        t.stopPropagation(),
        t.preventDefault();
        const i = [am, lm].includes(t.key)
          , s = lf(this._getChildren().filter(n=>!Rn(n)), t.target, i, !0);
        s && Io.getOrCreateInstance(s).show()
    }
    _getChildren() {
        return te.find(Uh, this._parent)
    }
    _getActiveElem() {
        return this._getChildren().find(t=>this._elemIsActive(t)) || null
    }
    _setInitialAttributes(t, i) {
        this._setAttributeIfNotExists(t, "role", "tablist");
        for (const s of i)
            this._setInitialAttributesOnChild(s)
    }
    _setInitialAttributesOnChild(t) {
        t = this._getInnerElement(t);
        const i = this._elemIsActive(t)
          , s = this._getOuterElement(t);
        t.setAttribute("aria-selected", i),
        s !== t && this._setAttributeIfNotExists(s, "role", "presentation"),
        i || t.setAttribute("tabindex", "-1"),
        this._setAttributeIfNotExists(t, "role", "tab"),
        this._setInitialAttributesOnTargetPanel(t)
    }
    _setInitialAttributesOnTargetPanel(t) {
        const i = Xs(t);
        !i || (this._setAttributeIfNotExists(i, "role", "tabpanel"),
        t.id && this._setAttributeIfNotExists(i, "aria-labelledby", `#${t.id}`))
    }
    _toggleDropDown(t, i) {
        const s = this._getOuterElement(t);
        if (!s.classList.contains(UT))
            return;
        const n = (r,o)=>{
            const a = te.findOne(r, s);
            a && a.classList.toggle(o, i)
        }
        ;
        n(GT, yn),
        n(HT, Fh),
        n(VT, yn),
        s.setAttribute("aria-expanded", i)
    }
    _setAttributeIfNotExists(t, i, s) {
        t.hasAttribute(i) || t.setAttribute(i, s)
    }
    _elemIsActive(t) {
        return t.classList.contains(yn)
    }
    _getInnerElement(t) {
        return t.matches(Uh) ? t : te.findOne(Uh, t)
    }
    _getOuterElement(t) {
        return t.closest($T) || t
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = Io.getOrCreateInstance(this);
            if (typeof t == "string") {
                if (i[t] === void 0 || t.startsWith("_") || t === "constructor")
                    throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        })
    }
}
q.on(document, OT, mv, function(e) {
    ["A", "AREA"].includes(this.tagName) && e.preventDefault(),
    !Rn(this) && Io.getOrCreateInstance(this).show()
});
q.on(window, NT, ()=>{
    for (const e of te.find(WT))
        Io.getOrCreateInstance(e)
}
);
Wi(Io);
const XT = "toast"
  , YT = "bs.toast"
  , Un = `.${YT}`
  , KT = `mouseover${Un}`
  , ZT = `mouseout${Un}`
  , qT = `focusin${Un}`
  , JT = `focusout${Un}`
  , QT = `hide${Un}`
  , tE = `hidden${Un}`
  , eE = `show${Un}`
  , iE = `shown${Un}`
  , sE = "fade"
  , hm = "hide"
  , cl = "show"
  , hl = "showing"
  , nE = {
    animation: "boolean",
    autohide: "boolean",
    delay: "number"
}
  , rE = {
    animation: !0,
    autohide: !0,
    delay: 5e3
};
class Wc extends ms {
    constructor(t, i) {
        super(t, i),
        this._timeout = null,
        this._hasMouseInteraction = !1,
        this._hasKeyboardInteraction = !1,
        this._setListeners()
    }
    static get Default() {
        return rE
    }
    static get DefaultType() {
        return nE
    }
    static get NAME() {
        return XT
    }
    show() {
        if (q.trigger(this._element, eE).defaultPrevented)
            return;
        this._clearTimeout(),
        this._config.animation && this._element.classList.add(sE);
        const i = ()=>{
            this._element.classList.remove(hl),
            q.trigger(this._element, iE),
            this._maybeScheduleHide()
        }
        ;
        this._element.classList.remove(hm),
        Xa(this._element),
        this._element.classList.add(cl, hl),
        this._queueCallback(i, this._element, this._config.animation)
    }
    hide() {
        if (!this.isShown() || q.trigger(this._element, QT).defaultPrevented)
            return;
        const i = ()=>{
            this._element.classList.add(hm),
            this._element.classList.remove(hl, cl),
            q.trigger(this._element, tE)
        }
        ;
        this._element.classList.add(hl),
        this._queueCallback(i, this._element, this._config.animation)
    }
    dispose() {
        this._clearTimeout(),
        this.isShown() && this._element.classList.remove(cl),
        super.dispose()
    }
    isShown() {
        return this._element.classList.contains(cl)
    }
    _maybeScheduleHide() {
        !this._config.autohide || this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(()=>{
            this.hide()
        }
        , this._config.delay))
    }
    _onInteraction(t, i) {
        switch (t.type) {
        case "mouseover":
        case "mouseout":
            this._hasMouseInteraction = i;
            break;
        case "focusin":
        case "focusout":
            this._hasKeyboardInteraction = i;
            break
        }
        if (i) {
            this._clearTimeout();
            return
        }
        const s = t.relatedTarget;
        this._element === s || this._element.contains(s) || this._maybeScheduleHide()
    }
    _setListeners() {
        q.on(this._element, KT, t=>this._onInteraction(t, !0)),
        q.on(this._element, ZT, t=>this._onInteraction(t, !1)),
        q.on(this._element, qT, t=>this._onInteraction(t, !0)),
        q.on(this._element, JT, t=>this._onInteraction(t, !1))
    }
    _clearTimeout() {
        clearTimeout(this._timeout),
        this._timeout = null
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = Wc.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (typeof i[t] > "u")
                    throw new TypeError(`No method named "${t}"`);
                i[t](this)
            }
        })
    }
}
Hc(Wc);
Wi(Wc);
function ff(e, t) {
    const i = Object.create(null)
      , s = e.split(",");
    for (let n = 0; n < s.length; n++)
        i[s[n]] = !0;
    return t ? n=>!!i[n.toLowerCase()] : n=>!!i[n]
}
const oE = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly"
  , aE = ff(oE);
function gv(e) {
    return !!e || e === ""
}
function jt(e) {
    if (Wt(e)) {
        const t = {};
        for (let i = 0; i < e.length; i++) {
            const s = e[i]
              , n = Ye(s) ? hE(s) : jt(s);
            if (n)
                for (const r in n)
                    t[r] = n[r]
        }
        return t
    } else {
        if (Ye(e))
            return e;
        if (Ke(e))
            return e
    }
}
const lE = /;(?![^(]*\))/g
  , cE = /:(.+)/;
function hE(e) {
    const t = {};
    return e.split(lE).forEach(i=>{
        if (i) {
            const s = i.split(cE);
            s.length > 1 && (t[s[0].trim()] = s[1].trim())
        }
    }
    ),
    t
}
function Ai(e) {
    let t = "";
    if (Ye(e))
        t = e;
    else if (Wt(e))
        for (let i = 0; i < e.length; i++) {
            const s = Ai(e[i]);
            s && (t += s + " ")
        }
    else if (Ke(e))
        for (const i in e)
            e[i] && (t += i + " ");
    return t.trim()
}
const Dt = e=>e == null ? "" : Wt(e) || Ke(e) && (e.toString === xv || !Yt(e.toString)) ? JSON.stringify(e, vv, 2) : String(e)
  , vv = (e,t)=>t && t.__v_isRef ? vv(e, t.value) : uo(t) ? {
    [`Map(${t.size})`]: [...t.entries()].reduce((i,[s,n])=>(i[`${s} =>`] = n,
    i), {})
} : yv(t) ? {
    [`Set(${t.size})`]: [...t.values()]
} : Ke(t) && !Wt(t) && !wv(t) ? String(t) : t
  , xe = {}
  , ho = []
  , as = ()=>{}
  , uE = ()=>!1
  , dE = /^on[^a-z]/
  , Xc = e=>dE.test(e)
  , pf = e=>e.startsWith("onUpdate:")
  , ei = Object.assign
  , _v = (e,t)=>{
    const i = e.indexOf(t);
    i > -1 && e.splice(i, 1)
}
  , fE = Object.prototype.hasOwnProperty
  , he = (e,t)=>fE.call(e, t)
  , Wt = Array.isArray
  , uo = e=>Yc(e) === "[object Map]"
  , yv = e=>Yc(e) === "[object Set]"
  , Yt = e=>typeof e == "function"
  , Ye = e=>typeof e == "string"
  , mf = e=>typeof e == "symbol"
  , Ke = e=>e !== null && typeof e == "object"
  , bv = e=>Ke(e) && Yt(e.then) && Yt(e.catch)
  , xv = Object.prototype.toString
  , Yc = e=>xv.call(e)
  , pE = e=>Yc(e).slice(8, -1)
  , wv = e=>Yc(e) === "[object Object]"
  , gf = e=>Ye(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e
  , Xl = ff(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted")
  , Kc = e=>{
    const t = Object.create(null);
    return i=>t[i] || (t[i] = e(i))
}
  , mE = /-(\w)/g
  , Ds = Kc(e=>e.replace(mE, (t,i)=>i ? i.toUpperCase() : ""))
  , gE = /\B([A-Z])/g
  , Vo = Kc(e=>e.replace(gE, "-$1").toLowerCase())
  , Zc = Kc(e=>e.charAt(0).toUpperCase() + e.slice(1))
  , Gh = Kc(e=>e ? `on${Zc(e)}` : "")
  , ka = (e,t)=>!Object.is(e, t)
  , Yl = (e,t)=>{
    for (let i = 0; i < e.length; i++)
        e[i](t)
}
  , fc = (e,t,i)=>{
    Object.defineProperty(e, t, {
        configurable: !0,
        enumerable: !1,
        value: i
    })
}
  , ku = e=>{
    const t = parseFloat(e);
    return isNaN(t) ? e : t
}
;
let um;
const vE = ()=>um || (um = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
let jn;
const ul = [];
class _E {
    constructor(t=!1) {
        this.active = !0,
        this.effects = [],
        this.cleanups = [],
        !t && jn && (this.parent = jn,
        this.index = (jn.scopes || (jn.scopes = [])).push(this) - 1)
    }
    run(t) {
        if (this.active)
            try {
                return this.on(),
                t()
            } finally {
                this.off()
            }
    }
    on() {
        this.active && (ul.push(this),
        jn = this)
    }
    off() {
        this.active && (ul.pop(),
        jn = ul[ul.length - 1])
    }
    stop(t) {
        if (this.active) {
            if (this.effects.forEach(i=>i.stop()),
            this.cleanups.forEach(i=>i()),
            this.scopes && this.scopes.forEach(i=>i.stop(!0)),
            this.parent && !t) {
                const i = this.parent.scopes.pop();
                i && i !== this && (this.parent.scopes[this.index] = i,
                i.index = this.index)
            }
            this.active = !1
        }
    }
}
function yE(e, t) {
    t = t || jn,
    t && t.active && t.effects.push(e)
}
const vf = e=>{
    const t = new Set(e);
    return t.w = 0,
    t.n = 0,
    t
}
  , Tv = e=>(e.w & Pn) > 0
  , Ev = e=>(e.n & Pn) > 0
  , bE = ({deps: e})=>{
    if (e.length)
        for (let t = 0; t < e.length; t++)
            e[t].w |= Pn
}
  , xE = e=>{
    const {deps: t} = e;
    if (t.length) {
        let i = 0;
        for (let s = 0; s < t.length; s++) {
            const n = t[s];
            Tv(n) && !Ev(n) ? n.delete(e) : t[i++] = n,
            n.w &= ~Pn,
            n.n &= ~Pn
        }
        t.length = i
    }
}
  , Pu = new WeakMap;
let ua = 0
  , Pn = 1;
const Lu = 30
  , Ko = [];
let _r;
const yr = Symbol("")
  , Ou = Symbol("");
class _f {
    constructor(t, i=null, s) {
        this.fn = t,
        this.scheduler = i,
        this.active = !0,
        this.deps = [],
        yE(this, s)
    }
    run() {
        if (!this.active)
            return this.fn();
        if (!Ko.includes(this))
            try {
                return Ko.push(_r = this),
                wE(),
                Pn = 1 << ++ua,
                ua <= Lu ? bE(this) : dm(this),
                this.fn()
            } finally {
                ua <= Lu && xE(this),
                Pn = 1 << --ua,
                kr(),
                Ko.pop();
                const t = Ko.length;
                _r = t > 0 ? Ko[t - 1] : void 0
            }
    }
    stop() {
        this.active && (dm(this),
        this.onStop && this.onStop(),
        this.active = !1)
    }
}
function dm(e) {
    const {deps: t} = e;
    if (t.length) {
        for (let i = 0; i < t.length; i++)
            t[i].delete(e);
        t.length = 0
    }
}
let Mo = !0;
const yf = [];
function zo() {
    yf.push(Mo),
    Mo = !1
}
function wE() {
    yf.push(Mo),
    Mo = !0
}
function kr() {
    const e = yf.pop();
    Mo = e === void 0 ? !0 : e
}
function Ri(e, t, i) {
    if (!Sv())
        return;
    let s = Pu.get(e);
    s || Pu.set(e, s = new Map);
    let n = s.get(i);
    n || s.set(i, n = vf()),
    Cv(n)
}
function Sv() {
    return Mo && _r !== void 0
}
function Cv(e, t) {
    let i = !1;
    ua <= Lu ? Ev(e) || (e.n |= Pn,
    i = !Tv(e)) : i = !e.has(_r),
    i && (e.add(_r),
    _r.deps.push(e))
}
function Qs(e, t, i, s, n, r) {
    const o = Pu.get(e);
    if (!o)
        return;
    let a = [];
    if (t === "clear")
        a = [...o.values()];
    else if (i === "length" && Wt(e))
        o.forEach((l,c)=>{
            (c === "length" || c >= s) && a.push(l)
        }
        );
    else
        switch (i !== void 0 && a.push(o.get(i)),
        t) {
        case "add":
            Wt(e) ? gf(i) && a.push(o.get("length")) : (a.push(o.get(yr)),
            uo(e) && a.push(o.get(Ou)));
            break;
        case "delete":
            Wt(e) || (a.push(o.get(yr)),
            uo(e) && a.push(o.get(Ou)));
            break;
        case "set":
            uo(e) && a.push(o.get(yr));
            break
        }
    if (a.length === 1)
        a[0] && Du(a[0]);
    else {
        const l = [];
        for (const c of a)
            c && l.push(...c);
        Du(vf(l))
    }
}
function Du(e, t) {
    for (const i of Wt(e) ? e : [...e])
        (i !== _r || i.allowRecurse) && (i.scheduler ? i.scheduler() : i.run())
}
const TE = ff("__proto__,__v_isRef,__isVue")
  , Av = new Set(Object.getOwnPropertyNames(Symbol).map(e=>Symbol[e]).filter(mf))
  , EE = bf()
  , SE = bf(!1, !0)
  , CE = bf(!0)
  , fm = AE();
function AE() {
    const e = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(t=>{
        e[t] = function(...i) {
            const s = fe(this);
            for (let r = 0, o = this.length; r < o; r++)
                Ri(s, "get", r + "");
            const n = s[t](...i);
            return n === -1 || n === !1 ? s[t](...i.map(fe)) : n
        }
    }
    ),
    ["push", "pop", "shift", "unshift", "splice"].forEach(t=>{
        e[t] = function(...i) {
            zo();
            const s = fe(this)[t].apply(this, i);
            return kr(),
            s
        }
    }
    ),
    e
}
function bf(e=!1, t=!1) {
    return function(s, n, r) {
        if (n === "__v_isReactive")
            return !e;
        if (n === "__v_isReadonly")
            return e;
        if (n === "__v_raw" && r === (e ? t ? zE : Pv : t ? kv : Rv).get(s))
            return s;
        const o = Wt(s);
        if (!e && o && he(fm, n))
            return Reflect.get(fm, n, r);
        const a = Reflect.get(s, n, r);
        return (mf(n) ? Av.has(n) : TE(n)) || (e || Ri(s, "get", n),
        t) ? a : xi(a) ? !o || !gf(n) ? a.value : a : Ke(a) ? e ? Lv(a) : _i(a) : a
    }
}
const IE = Iv()
  , ME = Iv(!0);
function Iv(e=!1) {
    return function(i, s, n, r) {
        let o = i[s];
        if (!e && !Ef(n) && (n = fe(n),
        o = fe(o),
        !Wt(i) && xi(o) && !xi(n)))
            return o.value = n,
            !0;
        const a = Wt(i) && gf(s) ? Number(s) < i.length : he(i, s)
          , l = Reflect.set(i, s, n, r);
        return i === fe(r) && (a ? ka(n, o) && Qs(i, "set", s, n) : Qs(i, "add", s, n)),
        l
    }
}
function RE(e, t) {
    const i = he(e, t);
    e[t];
    const s = Reflect.deleteProperty(e, t);
    return s && i && Qs(e, "delete", t, void 0),
    s
}
function kE(e, t) {
    const i = Reflect.has(e, t);
    return (!mf(t) || !Av.has(t)) && Ri(e, "has", t),
    i
}
function PE(e) {
    return Ri(e, "iterate", Wt(e) ? "length" : yr),
    Reflect.ownKeys(e)
}
const Mv = {
    get: EE,
    set: IE,
    deleteProperty: RE,
    has: kE,
    ownKeys: PE
}
  , LE = {
    get: CE,
    set(e, t) {
        return !0
    },
    deleteProperty(e, t) {
        return !0
    }
}
  , OE = ei({}, Mv, {
    get: SE,
    set: ME
})
  , xf = e=>e
  , qc = e=>Reflect.getPrototypeOf(e);
function dl(e, t, i=!1, s=!1) {
    e = e.__v_raw;
    const n = fe(e)
      , r = fe(t);
    t !== r && !i && Ri(n, "get", t),
    !i && Ri(n, "get", r);
    const {has: o} = qc(n)
      , a = s ? xf : i ? Sf : Pa;
    if (o.call(n, t))
        return a(e.get(t));
    if (o.call(n, r))
        return a(e.get(r));
    e !== n && e.get(t)
}
function fl(e, t=!1) {
    const i = this.__v_raw
      , s = fe(i)
      , n = fe(e);
    return e !== n && !t && Ri(s, "has", e),
    !t && Ri(s, "has", n),
    e === n ? i.has(e) : i.has(e) || i.has(n)
}
function pl(e, t=!1) {
    return e = e.__v_raw,
    !t && Ri(fe(e), "iterate", yr),
    Reflect.get(e, "size", e)
}
function pm(e) {
    e = fe(e);
    const t = fe(this);
    return qc(t).has.call(t, e) || (t.add(e),
    Qs(t, "add", e, e)),
    this
}
function mm(e, t) {
    t = fe(t);
    const i = fe(this)
      , {has: s, get: n} = qc(i);
    let r = s.call(i, e);
    r || (e = fe(e),
    r = s.call(i, e));
    const o = n.call(i, e);
    return i.set(e, t),
    r ? ka(t, o) && Qs(i, "set", e, t) : Qs(i, "add", e, t),
    this
}
function gm(e) {
    const t = fe(this)
      , {has: i, get: s} = qc(t);
    let n = i.call(t, e);
    n || (e = fe(e),
    n = i.call(t, e)),
    s && s.call(t, e);
    const r = t.delete(e);
    return n && Qs(t, "delete", e, void 0),
    r
}
function vm() {
    const e = fe(this)
      , t = e.size !== 0
      , i = e.clear();
    return t && Qs(e, "clear", void 0, void 0),
    i
}
function ml(e, t) {
    return function(s, n) {
        const r = this
          , o = r.__v_raw
          , a = fe(o)
          , l = t ? xf : e ? Sf : Pa;
        return !e && Ri(a, "iterate", yr),
        o.forEach((c,h)=>s.call(n, l(c), l(h), r))
    }
}
function gl(e, t, i) {
    return function(...s) {
        const n = this.__v_raw
          , r = fe(n)
          , o = uo(r)
          , a = e === "entries" || e === Symbol.iterator && o
          , l = e === "keys" && o
          , c = n[e](...s)
          , h = i ? xf : t ? Sf : Pa;
        return !t && Ri(r, "iterate", l ? Ou : yr),
        {
            next() {
                const {value: u, done: d} = c.next();
                return d ? {
                    value: u,
                    done: d
                } : {
                    value: a ? [h(u[0]), h(u[1])] : h(u),
                    done: d
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}
function hn(e) {
    return function(...t) {
        return e === "delete" ? !1 : this
    }
}
function DE() {
    const e = {
        get(r) {
            return dl(this, r)
        },
        get size() {
            return pl(this)
        },
        has: fl,
        add: pm,
        set: mm,
        delete: gm,
        clear: vm,
        forEach: ml(!1, !1)
    }
      , t = {
        get(r) {
            return dl(this, r, !1, !0)
        },
        get size() {
            return pl(this)
        },
        has: fl,
        add: pm,
        set: mm,
        delete: gm,
        clear: vm,
        forEach: ml(!1, !0)
    }
      , i = {
        get(r) {
            return dl(this, r, !0)
        },
        get size() {
            return pl(this, !0)
        },
        has(r) {
            return fl.call(this, r, !0)
        },
        add: hn("add"),
        set: hn("set"),
        delete: hn("delete"),
        clear: hn("clear"),
        forEach: ml(!0, !1)
    }
      , s = {
        get(r) {
            return dl(this, r, !0, !0)
        },
        get size() {
            return pl(this, !0)
        },
        has(r) {
            return fl.call(this, r, !0)
        },
        add: hn("add"),
        set: hn("set"),
        delete: hn("delete"),
        clear: hn("clear"),
        forEach: ml(!0, !0)
    };
    return ["keys", "values", "entries", Symbol.iterator].forEach(r=>{
        e[r] = gl(r, !1, !1),
        i[r] = gl(r, !0, !1),
        t[r] = gl(r, !1, !0),
        s[r] = gl(r, !0, !0)
    }
    ),
    [e, i, t, s]
}
const [NE,FE,BE,UE] = DE();
function wf(e, t) {
    const i = t ? e ? UE : BE : e ? FE : NE;
    return (s,n,r)=>n === "__v_isReactive" ? !e : n === "__v_isReadonly" ? e : n === "__v_raw" ? s : Reflect.get(he(i, n) && n in s ? i : s, n, r)
}
const GE = {
    get: wf(!1, !1)
}
  , HE = {
    get: wf(!1, !0)
}
  , VE = {
    get: wf(!0, !1)
}
  , Rv = new WeakMap
  , kv = new WeakMap
  , Pv = new WeakMap
  , zE = new WeakMap;
function $E(e) {
    switch (e) {
    case "Object":
    case "Array":
        return 1;
    case "Map":
    case "Set":
    case "WeakMap":
    case "WeakSet":
        return 2;
    default:
        return 0
    }
}
function jE(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : $E(pE(e))
}
function _i(e) {
    return e && e.__v_isReadonly ? e : Tf(e, !1, Mv, GE, Rv)
}
function WE(e) {
    return Tf(e, !1, OE, HE, kv)
}
function Lv(e) {
    return Tf(e, !0, LE, VE, Pv)
}
function Tf(e, t, i, s, n) {
    if (!Ke(e) || e.__v_raw && !(t && e.__v_isReactive))
        return e;
    const r = n.get(e);
    if (r)
        return r;
    const o = jE(e);
    if (o === 0)
        return e;
    const a = new Proxy(e,o === 2 ? s : i);
    return n.set(e, a),
    a
}
function fo(e) {
    return Ef(e) ? fo(e.__v_raw) : !!(e && e.__v_isReactive)
}
function Ef(e) {
    return !!(e && e.__v_isReadonly)
}
function Ov(e) {
    return fo(e) || Ef(e)
}
function fe(e) {
    const t = e && e.__v_raw;
    return t ? fe(t) : e
}
function Ws(e) {
    return fc(e, "__v_skip", !0),
    e
}
const Pa = e=>Ke(e) ? _i(e) : e
  , Sf = e=>Ke(e) ? Lv(e) : e;
function Dv(e) {
    Sv() && (e = fe(e),
    e.dep || (e.dep = vf()),
    Cv(e.dep))
}
function Nv(e, t) {
    e = fe(e),
    e.dep && Du(e.dep)
}
function xi(e) {
    return Boolean(e && e.__v_isRef === !0)
}
function ut(e) {
    return XE(e, !1)
}
function XE(e, t) {
    return xi(e) ? e : new YE(e,t)
}
class YE {
    constructor(t, i) {
        this._shallow = i,
        this.dep = void 0,
        this.__v_isRef = !0,
        this._rawValue = i ? t : fe(t),
        this._value = i ? t : Pa(t)
    }
    get value() {
        return Dv(this),
        this._value
    }
    set value(t) {
        t = this._shallow ? t : fe(t),
        ka(t, this._rawValue) && (this._rawValue = t,
        this._value = this._shallow ? t : Pa(t),
        Nv(this))
    }
}
function KE(e) {
    return xi(e) ? e.value : e
}
const ZE = {
    get: (e,t,i)=>KE(Reflect.get(e, t, i)),
    set: (e,t,i,s)=>{
        const n = e[t];
        return xi(n) && !xi(i) ? (n.value = i,
        !0) : Reflect.set(e, t, i, s)
    }
};
function Fv(e) {
    return fo(e) ? e : new Proxy(e,ZE)
}
class qE {
    constructor(t, i, s) {
        this._setter = i,
        this.dep = void 0,
        this._dirty = !0,
        this.__v_isRef = !0,
        this.effect = new _f(t,()=>{
            this._dirty || (this._dirty = !0,
            Nv(this))
        }
        ),
        this.__v_isReadonly = s
    }
    get value() {
        const t = fe(this);
        return Dv(t),
        t._dirty && (t._dirty = !1,
        t._value = t.effect.run()),
        t._value
    }
    set value(t) {
        this._setter(t)
    }
}
function Ft(e, t) {
    let i, s;
    const n = Yt(e);
    return n ? (i = e,
    s = as) : (i = e.get,
    s = e.set),
    new qE(i,s,n || !s)
}
Promise.resolve();
function JE(e, t, ...i) {
    const s = e.vnode.props || xe;
    let n = i;
    const r = t.startsWith("update:")
      , o = r && t.slice(7);
    if (o && o in s) {
        const h = `${o === "modelValue" ? "model" : o}Modifiers`
          , {number: u, trim: d} = s[h] || xe;
        d ? n = i.map(f=>f.trim()) : u && (n = i.map(ku))
    }
    let a, l = s[a = Gh(t)] || s[a = Gh(Ds(t))];
    !l && r && (l = s[a = Gh(Vo(t))]),
    l && $i(l, e, 6, n);
    const c = s[a + "Once"];
    if (c) {
        if (!e.emitted)
            e.emitted = {};
        else if (e.emitted[a])
            return;
        e.emitted[a] = !0,
        $i(c, e, 6, n)
    }
}
function Bv(e, t, i=!1) {
    const s = t.emitsCache
      , n = s.get(e);
    if (n !== void 0)
        return n;
    const r = e.emits;
    let o = {}
      , a = !1;
    if (!Yt(e)) {
        const l = c=>{
            const h = Bv(c, t, !0);
            h && (a = !0,
            ei(o, h))
        }
        ;
        !i && t.mixins.length && t.mixins.forEach(l),
        e.extends && l(e.extends),
        e.mixins && e.mixins.forEach(l)
    }
    return !r && !a ? (s.set(e, null),
    null) : (Wt(r) ? r.forEach(l=>o[l] = null) : ei(o, r),
    s.set(e, o),
    o)
}
function Cf(e, t) {
    return !e || !Xc(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""),
    he(e, t[0].toLowerCase() + t.slice(1)) || he(e, Vo(t)) || he(e, t))
}
let Gi = null
  , Jc = null;
function pc(e) {
    const t = Gi;
    return Gi = e,
    Jc = e && e.type.__scopeId || null,
    t
}
function gs(e) {
    Jc = e
}
function vs() {
    Jc = null
}
function QE(e, t=Gi, i) {
    if (!t || e._n)
        return e;
    const s = (...n)=>{
        s._d && Am(-1);
        const r = pc(t)
          , o = e(...n);
        return pc(r),
        s._d && Am(1),
        o
    }
    ;
    return s._n = !0,
    s._c = !0,
    s._d = !0,
    s
}
function Hh(e) {
    const {type: t, vnode: i, proxy: s, withProxy: n, props: r, propsOptions: [o], slots: a, attrs: l, emit: c, render: h, renderCache: u, data: d, setupState: f, ctx: p, inheritAttrs: m} = e;
    let g, y;
    const x = pc(e);
    try {
        if (i.shapeFlag & 4) {
            const _ = n || s;
            g = Es(h.call(_, _, u, r, f, d, p)),
            y = l
        } else {
            const _ = t;
            g = Es(_.length > 1 ? _(r, {
                attrs: l,
                slots: a,
                emit: c
            }) : _(r, null)),
            y = t.props ? l : tS(l)
        }
    } catch (_) {
        Ea.length = 0,
        sh(_, e, 1),
        g = X(Ns)
    }
    let v = g;
    if (y && m !== !1) {
        const _ = Object.keys(y)
          , {shapeFlag: C} = v;
        _.length && C & 7 && (o && _.some(pf) && (y = eS(y, o)),
        v = Ro(v, y))
    }
    return i.dirs && (v.dirs = v.dirs ? v.dirs.concat(i.dirs) : i.dirs),
    i.transition && (v.transition = i.transition),
    g = v,
    pc(x),
    g
}
const tS = e=>{
    let t;
    for (const i in e)
        (i === "class" || i === "style" || Xc(i)) && ((t || (t = {}))[i] = e[i]);
    return t
}
  , eS = (e,t)=>{
    const i = {};
    for (const s in e)
        (!pf(s) || !(s.slice(9)in t)) && (i[s] = e[s]);
    return i
}
;
function iS(e, t, i) {
    const {props: s, children: n, component: r} = e
      , {props: o, children: a, patchFlag: l} = t
      , c = r.emitsOptions;
    if (t.dirs || t.transition)
        return !0;
    if (i && l >= 0) {
        if (l & 1024)
            return !0;
        if (l & 16)
            return s ? _m(s, o, c) : !!o;
        if (l & 8) {
            const h = t.dynamicProps;
            for (let u = 0; u < h.length; u++) {
                const d = h[u];
                if (o[d] !== s[d] && !Cf(c, d))
                    return !0
            }
        }
    } else
        return (n || a) && (!a || !a.$stable) ? !0 : s === o ? !1 : s ? o ? _m(s, o, c) : !0 : !!o;
    return !1
}
function _m(e, t, i) {
    const s = Object.keys(t);
    if (s.length !== Object.keys(e).length)
        return !0;
    for (let n = 0; n < s.length; n++) {
        const r = s[n];
        if (t[r] !== e[r] && !Cf(i, r))
            return !0
    }
    return !1
}
function sS({vnode: e, parent: t}, i) {
    for (; t && t.subTree === e; )
        (e = t.vnode).el = i,
        t = t.parent
}
const nS = e=>e.__isSuspense;
function rS(e, t) {
    t && t.pendingBranch ? Wt(e) ? t.effects.push(...e) : t.effects.push(e) : tC(e)
}
function Uv(e, t) {
    if (je) {
        let i = je.provides;
        const s = je.parent && je.parent.provides;
        s === i && (i = je.provides = Object.create(s)),
        i[e] = t
    }
}
function yi(e, t, i=!1) {
    const s = je || Gi;
    if (s) {
        const n = s.parent == null ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides;
        if (n && e in n)
            return n[e];
        if (arguments.length > 1)
            return i && Yt(t) ? t.call(s.proxy) : t
    }
}
function oS() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Ve(()=>{
        e.isMounted = !0
    }
    ),
    $v(()=>{
        e.isUnmounting = !0
    }
    ),
    e
}
const Li = [Function, Array]
  , aS = {
    name: "BaseTransition",
    props: {
        mode: String,
        appear: Boolean,
        persisted: Boolean,
        onBeforeEnter: Li,
        onEnter: Li,
        onAfterEnter: Li,
        onEnterCancelled: Li,
        onBeforeLeave: Li,
        onLeave: Li,
        onAfterLeave: Li,
        onLeaveCancelled: Li,
        onBeforeAppear: Li,
        onAppear: Li,
        onAfterAppear: Li,
        onAppearCancelled: Li
    },
    setup(e, {slots: t}) {
        const i = zS()
          , s = oS();
        let n;
        return ()=>{
            const r = t.default && Hv(t.default(), !0);
            if (!r || !r.length)
                return;
            const o = fe(e)
              , {mode: a} = o
              , l = r[0];
            if (s.isLeaving)
                return Vh(l);
            const c = ym(l);
            if (!c)
                return Vh(l);
            const h = Nu(c, o, s, i);
            Fu(c, h);
            const u = i.subTree
              , d = u && ym(u);
            let f = !1;
            const {getTransitionKey: p} = c.type;
            if (p) {
                const m = p();
                n === void 0 ? n = m : m !== n && (n = m,
                f = !0)
            }
            if (d && d.type !== Ns && (!er(c, d) || f)) {
                const m = Nu(d, o, s, i);
                if (Fu(d, m),
                a === "out-in")
                    return s.isLeaving = !0,
                    m.afterLeave = ()=>{
                        s.isLeaving = !1,
                        i.update()
                    }
                    ,
                    Vh(l);
                a === "in-out" && c.type !== Ns && (m.delayLeave = (g,y,x)=>{
                    const v = Gv(s, d);
                    v[String(d.key)] = d,
                    g._leaveCb = ()=>{
                        y(),
                        g._leaveCb = void 0,
                        delete h.delayedLeave
                    }
                    ,
                    h.delayedLeave = x
                }
                )
            }
            return l
        }
    }
}
  , lS = aS;
function Gv(e, t) {
    const {leavingVNodes: i} = e;
    let s = i.get(t.type);
    return s || (s = Object.create(null),
    i.set(t.type, s)),
    s
}
function Nu(e, t, i, s) {
    const {appear: n, mode: r, persisted: o=!1, onBeforeEnter: a, onEnter: l, onAfterEnter: c, onEnterCancelled: h, onBeforeLeave: u, onLeave: d, onAfterLeave: f, onLeaveCancelled: p, onBeforeAppear: m, onAppear: g, onAfterAppear: y, onAppearCancelled: x} = t
      , v = String(e.key)
      , _ = Gv(i, e)
      , C = (S,T)=>{
        S && $i(S, s, 9, T)
    }
      , k = {
        mode: r,
        persisted: o,
        beforeEnter(S) {
            let T = a;
            if (!i.isMounted)
                if (n)
                    T = m || a;
                else
                    return;
            S._leaveCb && S._leaveCb(!0);
            const L = _[v];
            L && er(e, L) && L.el._leaveCb && L.el._leaveCb(),
            C(T, [S])
        },
        enter(S) {
            let T = l
              , L = c
              , D = h;
            if (!i.isMounted)
                if (n)
                    T = g || l,
                    L = y || c,
                    D = x || h;
                else
                    return;
            let O = !1;
            const K = S._enterCb = P=>{
                O || (O = !0,
                P ? C(D, [S]) : C(L, [S]),
                k.delayedLeave && k.delayedLeave(),
                S._enterCb = void 0)
            }
            ;
            T ? (T(S, K),
            T.length <= 1 && K()) : K()
        },
        leave(S, T) {
            const L = String(e.key);
            if (S._enterCb && S._enterCb(!0),
            i.isUnmounting)
                return T();
            C(u, [S]);
            let D = !1;
            const O = S._leaveCb = K=>{
                D || (D = !0,
                T(),
                K ? C(p, [S]) : C(f, [S]),
                S._leaveCb = void 0,
                _[L] === e && delete _[L])
            }
            ;
            _[L] = e,
            d ? (d(S, O),
            d.length <= 1 && O()) : O()
        },
        clone(S) {
            return Nu(S, t, i, s)
        }
    };
    return k
}
function Vh(e) {
    if (Qc(e))
        return e = Ro(e),
        e.children = null,
        e
}
function ym(e) {
    return Qc(e) ? e.children ? e.children[0] : void 0 : e
}
function Fu(e, t) {
    e.shapeFlag & 6 && e.component ? Fu(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent),
    e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}
function Hv(e, t=!1) {
    let i = []
      , s = 0;
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        r.type === Nt ? (r.patchFlag & 128 && s++,
        i = i.concat(Hv(r.children, t))) : (t || r.type !== Ns) && i.push(r)
    }
    if (s > 1)
        for (let n = 0; n < i.length; n++)
            i[n].patchFlag = -2;
    return i
}
const Bu = e=>!!e.type.__asyncLoader
  , Qc = e=>e.type.__isKeepAlive;
function cS(e, t) {
    Vv(e, "a", t)
}
function hS(e, t) {
    Vv(e, "da", t)
}
function Vv(e, t, i=je) {
    const s = e.__wdc || (e.__wdc = ()=>{
        let n = i;
        for (; n; ) {
            if (n.isDeactivated)
                return;
            n = n.parent
        }
        return e()
    }
    );
    if (th(t, s, i),
    i) {
        let n = i.parent;
        for (; n && n.parent; )
            Qc(n.parent.vnode) && uS(s, t, i, n),
            n = n.parent
    }
}
function uS(e, t, i, s) {
    const n = th(t, e, s, !0);
    jv(()=>{
        _v(s[t], n)
    }
    , i)
}
function th(e, t, i=je, s=!1) {
    if (i) {
        const n = i[e] || (i[e] = [])
          , r = t.__weh || (t.__weh = (...o)=>{
            if (i.isUnmounted)
                return;
            zo(),
            ko(i);
            const a = $i(t, i, e, o);
            return xr(),
            kr(),
            a
        }
        );
        return s ? n.unshift(r) : n.push(r),
        r
    }
}
const nn = e=>(t,i=je)=>(!_c || e === "sp") && th(e, t, i)
  , zv = nn("bm")
  , Ve = nn("m")
  , dS = nn("bu")
  , Pr = nn("u")
  , $v = nn("bum")
  , jv = nn("um")
  , fS = nn("sp")
  , pS = nn("rtg")
  , mS = nn("rtc");
function gS(e, t=je) {
    th("ec", e, t)
}
let Uu = !0;
function vS(e) {
    const t = Xv(e)
      , i = e.proxy
      , s = e.ctx;
    Uu = !1,
    t.beforeCreate && bm(t.beforeCreate, e, "bc");
    const {data: n, computed: r, methods: o, watch: a, provide: l, inject: c, created: h, beforeMount: u, mounted: d, beforeUpdate: f, updated: p, activated: m, deactivated: g, beforeDestroy: y, beforeUnmount: x, destroyed: v, unmounted: _, render: C, renderTracked: k, renderTriggered: S, errorCaptured: T, serverPrefetch: L, expose: D, inheritAttrs: O, components: K, directives: P, filters: N} = t;
    if (c && _S(c, s, null, e.appContext.config.unwrapInjectedRef),
    o)
        for (const Q in o) {
            const pt = o[Q];
            Yt(pt) && (s[Q] = pt.bind(i))
        }
    if (n) {
        const Q = n.call(i, i);
        Ke(Q) && (e.data = _i(Q))
    }
    if (Uu = !0,
    r)
        for (const Q in r) {
            const pt = r[Q]
              , bt = Yt(pt) ? pt.bind(i, i) : Yt(pt.get) ? pt.get.bind(i, i) : as
              , ct = !Yt(pt) && Yt(pt.set) ? pt.set.bind(i) : as
              , gt = Ft({
                get: bt,
                set: ct
            });
            Object.defineProperty(s, Q, {
                enumerable: !0,
                configurable: !0,
                get: ()=>gt.value,
                set: xt=>gt.value = xt
            })
        }
    if (a)
        for (const Q in a)
            Wv(a[Q], s, i, Q);
    if (l) {
        const Q = Yt(l) ? l.call(i) : l;
        Reflect.ownKeys(Q).forEach(pt=>{
            Uv(pt, Q[pt])
        }
        )
    }
    h && bm(h, e, "c");
    function V(Q, pt) {
        Wt(pt) ? pt.forEach(bt=>Q(bt.bind(i))) : pt && Q(pt.bind(i))
    }
    if (V(zv, u),
    V(Ve, d),
    V(dS, f),
    V(Pr, p),
    V(cS, m),
    V(hS, g),
    V(gS, T),
    V(mS, k),
    V(pS, S),
    V($v, x),
    V(jv, _),
    V(fS, L),
    Wt(D))
        if (D.length) {
            const Q = e.exposed || (e.exposed = {});
            D.forEach(pt=>{
                Object.defineProperty(Q, pt, {
                    get: ()=>i[pt],
                    set: bt=>i[pt] = bt
                })
            }
            )
        } else
            e.exposed || (e.exposed = {});
    C && e.render === as && (e.render = C),
    O != null && (e.inheritAttrs = O),
    K && (e.components = K),
    P && (e.directives = P)
}
function _S(e, t, i=as, s=!1) {
    Wt(e) && (e = Gu(e));
    for (const n in e) {
        const r = e[n];
        let o;
        Ke(r) ? "default"in r ? o = yi(r.from || n, r.default, !0) : o = yi(r.from || n) : o = yi(r),
        xi(o) && s ? Object.defineProperty(t, n, {
            enumerable: !0,
            configurable: !0,
            get: ()=>o.value,
            set: a=>o.value = a
        }) : t[n] = o
    }
}
function bm(e, t, i) {
    $i(Wt(e) ? e.map(s=>s.bind(t.proxy)) : e.bind(t.proxy), t, i)
}
function Wv(e, t, i, s) {
    const n = s.includes(".") ? p_(i, s) : ()=>i[s];
    if (Ye(e)) {
        const r = t[e];
        Yt(r) && Aa(n, r)
    } else if (Yt(e))
        Aa(n, e.bind(i));
    else if (Ke(e))
        if (Wt(e))
            e.forEach(r=>Wv(r, t, i, s));
        else {
            const r = Yt(e.handler) ? e.handler.bind(i) : t[e.handler];
            Yt(r) && Aa(n, r, e)
        }
}
function Xv(e) {
    const t = e.type
      , {mixins: i, extends: s} = t
      , {mixins: n, optionsCache: r, config: {optionMergeStrategies: o}} = e.appContext
      , a = r.get(t);
    let l;
    return a ? l = a : !n.length && !i && !s ? l = t : (l = {},
    n.length && n.forEach(c=>mc(l, c, o, !0)),
    mc(l, t, o)),
    r.set(t, l),
    l
}
function mc(e, t, i, s=!1) {
    const {mixins: n, extends: r} = t;
    r && mc(e, r, i, !0),
    n && n.forEach(o=>mc(e, o, i, !0));
    for (const o in t)
        if (!(s && o === "expose")) {
            const a = yS[o] || i && i[o];
            e[o] = a ? a(e[o], t[o]) : t[o]
        }
    return e
}
const yS = {
    data: xm,
    props: Wn,
    emits: Wn,
    methods: Wn,
    computed: Wn,
    beforeCreate: ri,
    created: ri,
    beforeMount: ri,
    mounted: ri,
    beforeUpdate: ri,
    updated: ri,
    beforeDestroy: ri,
    beforeUnmount: ri,
    destroyed: ri,
    unmounted: ri,
    activated: ri,
    deactivated: ri,
    errorCaptured: ri,
    serverPrefetch: ri,
    components: Wn,
    directives: Wn,
    watch: xS,
    provide: xm,
    inject: bS
};
function xm(e, t) {
    return t ? e ? function() {
        return ei(Yt(e) ? e.call(this, this) : e, Yt(t) ? t.call(this, this) : t)
    }
    : t : e
}
function bS(e, t) {
    return Wn(Gu(e), Gu(t))
}
function Gu(e) {
    if (Wt(e)) {
        const t = {};
        for (let i = 0; i < e.length; i++)
            t[e[i]] = e[i];
        return t
    }
    return e
}
function ri(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}
function Wn(e, t) {
    return e ? ei(ei(Object.create(null), e), t) : t
}
function xS(e, t) {
    if (!e)
        return t;
    if (!t)
        return e;
    const i = ei(Object.create(null), e);
    for (const s in t)
        i[s] = ri(e[s], t[s]);
    return i
}
function wS(e, t, i, s=!1) {
    const n = {}
      , r = {};
    fc(r, eh, 1),
    e.propsDefaults = Object.create(null),
    Yv(e, t, n, r);
    for (const o in e.propsOptions[0])
        o in n || (n[o] = void 0);
    i ? e.props = s ? n : WE(n) : e.type.props ? e.props = n : e.props = r,
    e.attrs = r
}
function TS(e, t, i, s) {
    const {props: n, attrs: r, vnode: {patchFlag: o}} = e
      , a = fe(n)
      , [l] = e.propsOptions;
    let c = !1;
    if ((s || o > 0) && !(o & 16)) {
        if (o & 8) {
            const h = e.vnode.dynamicProps;
            for (let u = 0; u < h.length; u++) {
                let d = h[u];
                const f = t[d];
                if (l)
                    if (he(r, d))
                        f !== r[d] && (r[d] = f,
                        c = !0);
                    else {
                        const p = Ds(d);
                        n[p] = Hu(l, a, p, f, e, !1)
                    }
                else
                    f !== r[d] && (r[d] = f,
                    c = !0)
            }
        }
    } else {
        Yv(e, t, n, r) && (c = !0);
        let h;
        for (const u in a)
            (!t || !he(t, u) && ((h = Vo(u)) === u || !he(t, h))) && (l ? i && (i[u] !== void 0 || i[h] !== void 0) && (n[u] = Hu(l, a, u, void 0, e, !0)) : delete n[u]);
        if (r !== a)
            for (const u in r)
                (!t || !he(t, u)) && (delete r[u],
                c = !0)
    }
    c && Qs(e, "set", "$attrs")
}
function Yv(e, t, i, s) {
    const [n,r] = e.propsOptions;
    let o = !1, a;
    if (t)
        for (let l in t) {
            if (Xl(l))
                continue;
            const c = t[l];
            let h;
            n && he(n, h = Ds(l)) ? !r || !r.includes(h) ? i[h] = c : (a || (a = {}))[h] = c : Cf(e.emitsOptions, l) || (!(l in s) || c !== s[l]) && (s[l] = c,
            o = !0)
        }
    if (r) {
        const l = fe(i)
          , c = a || xe;
        for (let h = 0; h < r.length; h++) {
            const u = r[h];
            i[u] = Hu(n, l, u, c[u], e, !he(c, u))
        }
    }
    return o
}
function Hu(e, t, i, s, n, r) {
    const o = e[i];
    if (o != null) {
        const a = he(o, "default");
        if (a && s === void 0) {
            const l = o.default;
            if (o.type !== Function && Yt(l)) {
                const {propsDefaults: c} = n;
                i in c ? s = c[i] : (ko(n),
                s = c[i] = l.call(null, t),
                xr())
            } else
                s = l
        }
        o[0] && (r && !a ? s = !1 : o[1] && (s === "" || s === Vo(i)) && (s = !0))
    }
    return s
}
function Kv(e, t, i=!1) {
    const s = t.propsCache
      , n = s.get(e);
    if (n)
        return n;
    const r = e.props
      , o = {}
      , a = [];
    let l = !1;
    if (!Yt(e)) {
        const h = u=>{
            l = !0;
            const [d,f] = Kv(u, t, !0);
            ei(o, d),
            f && a.push(...f)
        }
        ;
        !i && t.mixins.length && t.mixins.forEach(h),
        e.extends && h(e.extends),
        e.mixins && e.mixins.forEach(h)
    }
    if (!r && !l)
        return s.set(e, ho),
        ho;
    if (Wt(r))
        for (let h = 0; h < r.length; h++) {
            const u = Ds(r[h]);
            wm(u) && (o[u] = xe)
        }
    else if (r)
        for (const h in r) {
            const u = Ds(h);
            if (wm(u)) {
                const d = r[h]
                  , f = o[u] = Wt(d) || Yt(d) ? {
                    type: d
                } : d;
                if (f) {
                    const p = Sm(Boolean, f.type)
                      , m = Sm(String, f.type);
                    f[0] = p > -1,
                    f[1] = m < 0 || p < m,
                    (p > -1 || he(f, "default")) && a.push(u)
                }
            }
        }
    const c = [o, a];
    return s.set(e, c),
    c
}
function wm(e) {
    return e[0] !== "$"
}
function Tm(e) {
    const t = e && e.toString().match(/^\s*function (\w+)/);
    return t ? t[1] : e === null ? "null" : ""
}
function Em(e, t) {
    return Tm(e) === Tm(t)
}
function Sm(e, t) {
    return Wt(t) ? t.findIndex(i=>Em(i, e)) : Yt(t) && Em(t, e) ? 0 : -1
}
const Zv = e=>e[0] === "_" || e === "$stable"
  , Af = e=>Wt(e) ? e.map(Es) : [Es(e)]
  , ES = (e,t,i)=>{
    const s = QE((...n)=>Af(t(...n)), i);
    return s._c = !1,
    s
}
  , qv = (e,t,i)=>{
    const s = e._ctx;
    for (const n in e) {
        if (Zv(n))
            continue;
        const r = e[n];
        if (Yt(r))
            t[n] = ES(n, r, s);
        else if (r != null) {
            const o = Af(r);
            t[n] = ()=>o
        }
    }
}
  , Jv = (e,t)=>{
    const i = Af(t);
    e.slots.default = ()=>i
}
  , SS = (e,t)=>{
    if (e.vnode.shapeFlag & 32) {
        const i = t._;
        i ? (e.slots = fe(t),
        fc(t, "_", i)) : qv(t, e.slots = {})
    } else
        e.slots = {},
        t && Jv(e, t);
    fc(e.slots, eh, 1)
}
  , CS = (e,t,i)=>{
    const {vnode: s, slots: n} = e;
    let r = !0
      , o = xe;
    if (s.shapeFlag & 32) {
        const a = t._;
        a ? i && a === 1 ? r = !1 : (ei(n, t),
        !i && a === 1 && delete n._) : (r = !t.$stable,
        qv(t, n)),
        o = t
    } else
        t && (Jv(e, t),
        o = {
            default: 1
        });
    if (r)
        for (const a in n)
            !Zv(a) && !(a in o) && delete n[a]
}
;
function ee(e, t) {
    const i = Gi;
    if (i === null)
        return e;
    const s = i.proxy
      , n = e.dirs || (e.dirs = []);
    for (let r = 0; r < t.length; r++) {
        let[o,a,l,c=xe] = t[r];
        Yt(o) && (o = {
            mounted: o,
            updated: o
        }),
        o.deep && sr(a),
        n.push({
            dir: o,
            instance: s,
            value: a,
            oldValue: void 0,
            arg: l,
            modifiers: c
        })
    }
    return e
}
function Gn(e, t, i, s) {
    const n = e.dirs
      , r = t && t.dirs;
    for (let o = 0; o < n.length; o++) {
        const a = n[o];
        r && (a.oldValue = r[o].value);
        let l = a.dir[s];
        l && (zo(),
        $i(l, i, 8, [e.el, a, e, t]),
        kr())
    }
}
function Qv() {
    return {
        app: null,
        config: {
            isNativeTag: uE,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let AS = 0;
function IS(e, t) {
    return function(s, n=null) {
        n != null && !Ke(n) && (n = null);
        const r = Qv()
          , o = new Set;
        let a = !1;
        const l = r.app = {
            _uid: AS++,
            _component: s,
            _props: n,
            _container: null,
            _context: r,
            _instance: null,
            version: iC,
            get config() {
                return r.config
            },
            set config(c) {},
            use(c, ...h) {
                return o.has(c) || (c && Yt(c.install) ? (o.add(c),
                c.install(l, ...h)) : Yt(c) && (o.add(c),
                c(l, ...h))),
                l
            },
            mixin(c) {
                return r.mixins.includes(c) || r.mixins.push(c),
                l
            },
            component(c, h) {
                return h ? (r.components[c] = h,
                l) : r.components[c]
            },
            directive(c, h) {
                return h ? (r.directives[c] = h,
                l) : r.directives[c]
            },
            mount(c, h, u) {
                if (!a) {
                    const d = X(s, n);
                    return d.appContext = r,
                    h && t ? t(d, c) : e(d, c, u),
                    a = !0,
                    l._container = c,
                    c.__vue_app__ = l,
                    Pf(d.component) || d.component.proxy
                }
            },
            unmount() {
                a && (e(null, l._container),
                delete l._container.__vue_app__)
            },
            provide(c, h) {
                return r.provides[c] = h,
                l
            }
        };
        return l
    }
}
const oi = rS;
function MS(e) {
    return RS(e)
}
function RS(e, t) {
    const i = vE();
    i.__VUE__ = !0;
    const {insert: s, remove: n, patchProp: r, createElement: o, createText: a, createComment: l, setText: c, setElementText: h, parentNode: u, nextSibling: d, setScopeId: f=as, cloneNode: p, insertStaticContent: m} = e
      , g = (E,M,F,$=null,Y=null,rt=null,dt=!1,tt=null,it=!!M.dynamicChildren)=>{
        if (E === M)
            return;
        E && !er(E, M) && ($ = Bt(E),
        It(E, Y, rt, !0),
        E = null),
        M.patchFlag === -2 && (it = !1,
        M.dynamicChildren = null);
        const {type: Z, ref: Ct, shapeFlag: yt} = M;
        switch (Z) {
        case Mf:
            y(E, M, F, $);
            break;
        case Ns:
            x(E, M, F, $);
            break;
        case Kl:
            E == null && v(M, F, $, dt);
            break;
        case Nt:
            P(E, M, F, $, Y, rt, dt, tt, it);
            break;
        default:
            yt & 1 ? k(E, M, F, $, Y, rt, dt, tt, it) : yt & 6 ? N(E, M, F, $, Y, rt, dt, tt, it) : (yt & 64 || yt & 128) && Z.process(E, M, F, $, Y, rt, dt, tt, it, re)
        }
        Ct != null && Y && Vu(Ct, E && E.ref, rt, M || E, !M)
    }
      , y = (E,M,F,$)=>{
        if (E == null)
            s(M.el = a(M.children), F, $);
        else {
            const Y = M.el = E.el;
            M.children !== E.children && c(Y, M.children)
        }
    }
      , x = (E,M,F,$)=>{
        E == null ? s(M.el = l(M.children || ""), F, $) : M.el = E.el
    }
      , v = (E,M,F,$)=>{
        [E.el,E.anchor] = m(E.children, M, F, $)
    }
      , _ = ({el: E, anchor: M},F,$)=>{
        let Y;
        for (; E && E !== M; )
            Y = d(E),
            s(E, F, $),
            E = Y;
        s(M, F, $)
    }
      , C = ({el: E, anchor: M})=>{
        let F;
        for (; E && E !== M; )
            F = d(E),
            n(E),
            E = F;
        n(M)
    }
      , k = (E,M,F,$,Y,rt,dt,tt,it)=>{
        dt = dt || M.type === "svg",
        E == null ? S(M, F, $, Y, rt, dt, tt, it) : D(E, M, Y, rt, dt, tt, it)
    }
      , S = (E,M,F,$,Y,rt,dt,tt)=>{
        let it, Z;
        const {type: Ct, props: yt, shapeFlag: At, transition: Pt, patchFlag: Kt, dirs: me} = E;
        if (E.el && p !== void 0 && Kt === -1)
            it = E.el = p(E.el);
        else {
            if (it = E.el = o(E.type, rt, yt && yt.is, yt),
            At & 8 ? h(it, E.children) : At & 16 && L(E.children, it, null, $, Y, rt && Ct !== "foreignObject", dt, tt),
            me && Gn(E, null, $, "created"),
            yt) {
                for (const oe in yt)
                    oe !== "value" && !Xl(oe) && r(it, oe, null, yt[oe], rt, E.children, $, Y, Tt);
                "value"in yt && r(it, "value", null, yt.value),
                (Z = yt.onVnodeBeforeMount) && xs(Z, $, E)
            }
            T(it, E, E.scopeId, dt, $)
        }
        me && Gn(E, null, $, "beforeMount");
        const ge = (!Y || Y && !Y.pendingBranch) && Pt && !Pt.persisted;
        ge && Pt.beforeEnter(it),
        s(it, M, F),
        ((Z = yt && yt.onVnodeMounted) || ge || me) && oi(()=>{
            Z && xs(Z, $, E),
            ge && Pt.enter(it),
            me && Gn(E, null, $, "mounted")
        }
        , Y)
    }
      , T = (E,M,F,$,Y)=>{
        if (F && f(E, F),
        $)
            for (let rt = 0; rt < $.length; rt++)
                f(E, $[rt]);
        if (Y) {
            let rt = Y.subTree;
            if (M === rt) {
                const dt = Y.vnode;
                T(E, dt, dt.scopeId, dt.slotScopeIds, Y.parent)
            }
        }
    }
      , L = (E,M,F,$,Y,rt,dt,tt,it=0)=>{
        for (let Z = it; Z < E.length; Z++) {
            const Ct = E[Z] = tt ? vn(E[Z]) : Es(E[Z]);
            g(null, Ct, M, F, $, Y, rt, dt, tt)
        }
    }
      , D = (E,M,F,$,Y,rt,dt)=>{
        const tt = M.el = E.el;
        let {patchFlag: it, dynamicChildren: Z, dirs: Ct} = M;
        it |= E.patchFlag & 16;
        const yt = E.props || xe
          , At = M.props || xe;
        let Pt;
        (Pt = At.onVnodeBeforeUpdate) && xs(Pt, F, M, E),
        Ct && Gn(M, E, F, "beforeUpdate");
        const Kt = Y && M.type !== "foreignObject";
        if (Z ? O(E.dynamicChildren, Z, tt, F, $, Kt, rt) : dt || bt(E, M, tt, null, F, $, Kt, rt, !1),
        it > 0) {
            if (it & 16)
                K(tt, M, yt, At, F, $, Y);
            else if (it & 2 && yt.class !== At.class && r(tt, "class", null, At.class, Y),
            it & 4 && r(tt, "style", yt.style, At.style, Y),
            it & 8) {
                const me = M.dynamicProps;
                for (let ge = 0; ge < me.length; ge++) {
                    const oe = me[ge]
                      , ui = yt[oe]
                      , w = At[oe];
                    (w !== ui || oe === "value") && r(tt, oe, ui, w, Y, E.children, F, $, Tt)
                }
            }
            it & 1 && E.children !== M.children && h(tt, M.children)
        } else
            !dt && Z == null && K(tt, M, yt, At, F, $, Y);
        ((Pt = At.onVnodeUpdated) || Ct) && oi(()=>{
            Pt && xs(Pt, F, M, E),
            Ct && Gn(M, E, F, "updated")
        }
        , $)
    }
      , O = (E,M,F,$,Y,rt,dt)=>{
        for (let tt = 0; tt < M.length; tt++) {
            const it = E[tt]
              , Z = M[tt]
              , Ct = it.el && (it.type === Nt || !er(it, Z) || it.shapeFlag & 70) ? u(it.el) : F;
            g(it, Z, Ct, null, $, Y, rt, dt, !0)
        }
    }
      , K = (E,M,F,$,Y,rt,dt)=>{
        if (F !== $) {
            for (const tt in $) {
                if (Xl(tt))
                    continue;
                const it = $[tt]
                  , Z = F[tt];
                it !== Z && tt !== "value" && r(E, tt, Z, it, dt, M.children, Y, rt, Tt)
            }
            if (F !== xe)
                for (const tt in F)
                    !Xl(tt) && !(tt in $) && r(E, tt, F[tt], null, dt, M.children, Y, rt, Tt);
            "value"in $ && r(E, "value", F.value, $.value)
        }
    }
      , P = (E,M,F,$,Y,rt,dt,tt,it)=>{
        const Z = M.el = E ? E.el : a("")
          , Ct = M.anchor = E ? E.anchor : a("");
        let {patchFlag: yt, dynamicChildren: At, slotScopeIds: Pt} = M;
        Pt && (tt = tt ? tt.concat(Pt) : Pt),
        E == null ? (s(Z, F, $),
        s(Ct, F, $),
        L(M.children, F, Ct, Y, rt, dt, tt, it)) : yt > 0 && yt & 64 && At && E.dynamicChildren ? (O(E.dynamicChildren, At, F, Y, rt, dt, tt),
        (M.key != null || Y && M === Y.subTree) && t_(E, M, !0)) : bt(E, M, F, Ct, Y, rt, dt, tt, it)
    }
      , N = (E,M,F,$,Y,rt,dt,tt,it)=>{
        M.slotScopeIds = tt,
        E == null ? M.shapeFlag & 512 ? Y.ctx.activate(M, F, $, dt, it) : W(M, F, $, Y, rt, dt, it) : V(E, M, it)
    }
      , W = (E,M,F,$,Y,rt,dt)=>{
        const tt = E.component = VS(E, $, Y);
        if (Qc(E) && (tt.ctx.renderer = re),
        $S(tt),
        tt.asyncDep) {
            if (Y && Y.registerDep(tt, Q),
            !E.el) {
                const it = tt.subTree = X(Ns);
                x(null, it, M, F)
            }
            return
        }
        Q(tt, E, M, F, Y, rt, dt)
    }
      , V = (E,M,F)=>{
        const $ = M.component = E.component;
        if (iS(E, M, F))
            if ($.asyncDep && !$.asyncResolved) {
                pt($, M, F);
                return
            } else
                $.next = M,
                JS($.update),
                $.update();
        else
            M.component = E.component,
            M.el = E.el,
            $.vnode = M
    }
      , Q = (E,M,F,$,Y,rt,dt)=>{
        const tt = ()=>{
            if (E.isMounted) {
                let {next: Ct, bu: yt, u: At, parent: Pt, vnode: Kt} = E, me = Ct, ge;
                it.allowRecurse = !1,
                Ct ? (Ct.el = Kt.el,
                pt(E, Ct, dt)) : Ct = Kt,
                yt && Yl(yt),
                (ge = Ct.props && Ct.props.onVnodeBeforeUpdate) && xs(ge, Pt, Ct, Kt),
                it.allowRecurse = !0;
                const oe = Hh(E)
                  , ui = E.subTree;
                E.subTree = oe,
                g(ui, oe, u(ui.el), Bt(ui), E, Y, rt),
                Ct.el = oe.el,
                me === null && sS(E, oe.el),
                At && oi(At, Y),
                (ge = Ct.props && Ct.props.onVnodeUpdated) && oi(()=>xs(ge, Pt, Ct, Kt), Y)
            } else {
                let Ct;
                const {el: yt, props: At} = M
                  , {bm: Pt, m: Kt, parent: me} = E
                  , ge = Bu(M);
                if (it.allowRecurse = !1,
                Pt && Yl(Pt),
                !ge && (Ct = At && At.onVnodeBeforeMount) && xs(Ct, me, M),
                it.allowRecurse = !0,
                yt && ce) {
                    const oe = ()=>{
                        E.subTree = Hh(E),
                        ce(yt, E.subTree, E, Y, null)
                    }
                    ;
                    ge ? M.type.__asyncLoader().then(()=>!E.isUnmounted && oe()) : oe()
                } else {
                    const oe = E.subTree = Hh(E);
                    g(null, oe, F, $, E, Y, rt),
                    M.el = oe.el
                }
                if (Kt && oi(Kt, Y),
                !ge && (Ct = At && At.onVnodeMounted)) {
                    const oe = M;
                    oi(()=>xs(Ct, me, oe), Y)
                }
                M.shapeFlag & 256 && E.a && oi(E.a, Y),
                E.isMounted = !0,
                M = F = $ = null
            }
        }
          , it = new _f(tt,()=>l_(E.update),E.scope)
          , Z = E.update = it.run.bind(it);
        Z.id = E.uid,
        it.allowRecurse = Z.allowRecurse = !0,
        Z()
    }
      , pt = (E,M,F)=>{
        M.component = E;
        const $ = E.vnode.props;
        E.vnode = M,
        E.next = null,
        TS(E, M.props, $, F),
        CS(E, M.children, F),
        zo(),
        Of(void 0, E.update),
        kr()
    }
      , bt = (E,M,F,$,Y,rt,dt,tt,it=!1)=>{
        const Z = E && E.children
          , Ct = E ? E.shapeFlag : 0
          , yt = M.children
          , {patchFlag: At, shapeFlag: Pt} = M;
        if (At > 0) {
            if (At & 128) {
                gt(Z, yt, F, $, Y, rt, dt, tt, it);
                return
            } else if (At & 256) {
                ct(Z, yt, F, $, Y, rt, dt, tt, it);
                return
            }
        }
        Pt & 8 ? (Ct & 16 && Tt(Z, Y, rt),
        yt !== Z && h(F, yt)) : Ct & 16 ? Pt & 16 ? gt(Z, yt, F, $, Y, rt, dt, tt, it) : Tt(Z, Y, rt, !0) : (Ct & 8 && h(F, ""),
        Pt & 16 && L(yt, F, $, Y, rt, dt, tt, it))
    }
      , ct = (E,M,F,$,Y,rt,dt,tt,it)=>{
        E = E || ho,
        M = M || ho;
        const Z = E.length
          , Ct = M.length
          , yt = Math.min(Z, Ct);
        let At;
        for (At = 0; At < yt; At++) {
            const Pt = M[At] = it ? vn(M[At]) : Es(M[At]);
            g(E[At], Pt, F, null, Y, rt, dt, tt, it)
        }
        Z > Ct ? Tt(E, Y, rt, !0, !1, yt) : L(M, F, $, Y, rt, dt, tt, it, yt)
    }
      , gt = (E,M,F,$,Y,rt,dt,tt,it)=>{
        let Z = 0;
        const Ct = M.length;
        let yt = E.length - 1
          , At = Ct - 1;
        for (; Z <= yt && Z <= At; ) {
            const Pt = E[Z]
              , Kt = M[Z] = it ? vn(M[Z]) : Es(M[Z]);
            if (er(Pt, Kt))
                g(Pt, Kt, F, null, Y, rt, dt, tt, it);
            else
                break;
            Z++
        }
        for (; Z <= yt && Z <= At; ) {
            const Pt = E[yt]
              , Kt = M[At] = it ? vn(M[At]) : Es(M[At]);
            if (er(Pt, Kt))
                g(Pt, Kt, F, null, Y, rt, dt, tt, it);
            else
                break;
            yt--,
            At--
        }
        if (Z > yt) {
            if (Z <= At) {
                const Pt = At + 1
                  , Kt = Pt < Ct ? M[Pt].el : $;
                for (; Z <= At; )
                    g(null, M[Z] = it ? vn(M[Z]) : Es(M[Z]), F, Kt, Y, rt, dt, tt, it),
                    Z++
            }
        } else if (Z > At)
            for (; Z <= yt; )
                It(E[Z], Y, rt, !0),
                Z++;
        else {
            const Pt = Z
              , Kt = Z
              , me = new Map;
            for (Z = Kt; Z <= At; Z++) {
                const et = M[Z] = it ? vn(M[Z]) : Es(M[Z]);
                et.key != null && me.set(et.key, Z)
            }
            let ge, oe = 0;
            const ui = At - Kt + 1;
            let w = !1
              , R = 0;
            const z = new Array(ui);
            for (Z = 0; Z < ui; Z++)
                z[Z] = 0;
            for (Z = Pt; Z <= yt; Z++) {
                const et = E[Z];
                if (oe >= ui) {
                    It(et, Y, rt, !0);
                    continue
                }
                let _t;
                if (et.key != null)
                    _t = me.get(et.key);
                else
                    for (ge = Kt; ge <= At; ge++)
                        if (z[ge - Kt] === 0 && er(et, M[ge])) {
                            _t = ge;
                            break
                        }
                _t === void 0 ? It(et, Y, rt, !0) : (z[_t - Kt] = Z + 1,
                _t >= R ? R = _t : w = !0,
                g(et, M[_t], F, null, Y, rt, dt, tt, it),
                oe++)
            }
            const G = w ? kS(z) : ho;
            for (ge = G.length - 1,
            Z = ui - 1; Z >= 0; Z--) {
                const et = Kt + Z
                  , _t = M[et]
                  , Mt = et + 1 < Ct ? M[et + 1].el : $;
                z[Z] === 0 ? g(null, _t, F, Mt, Y, rt, dt, tt, it) : w && (ge < 0 || Z !== G[ge] ? xt(_t, F, Mt, 2) : ge--)
            }
        }
    }
      , xt = (E,M,F,$,Y=null)=>{
        const {el: rt, type: dt, transition: tt, children: it, shapeFlag: Z} = E;
        if (Z & 6) {
            xt(E.component.subTree, M, F, $);
            return
        }
        if (Z & 128) {
            E.suspense.move(M, F, $);
            return
        }
        if (Z & 64) {
            dt.move(E, M, F, re);
            return
        }
        if (dt === Nt) {
            s(rt, M, F);
            for (let yt = 0; yt < it.length; yt++)
                xt(it[yt], M, F, $);
            s(E.anchor, M, F);
            return
        }
        if (dt === Kl) {
            _(E, M, F);
            return
        }
        if ($ !== 2 && Z & 1 && tt)
            if ($ === 0)
                tt.beforeEnter(rt),
                s(rt, M, F),
                oi(()=>tt.enter(rt), Y);
            else {
                const {leave: yt, delayLeave: At, afterLeave: Pt} = tt
                  , Kt = ()=>s(rt, M, F)
                  , me = ()=>{
                    yt(rt, ()=>{
                        Kt(),
                        Pt && Pt()
                    }
                    )
                }
                ;
                At ? At(rt, Kt, me) : me()
            }
        else
            s(rt, M, F)
    }
      , It = (E,M,F,$=!1,Y=!1)=>{
        const {type: rt, props: dt, ref: tt, children: it, dynamicChildren: Z, shapeFlag: Ct, patchFlag: yt, dirs: At} = E;
        if (tt != null && Vu(tt, null, F, E, !0),
        Ct & 256) {
            M.ctx.deactivate(E);
            return
        }
        const Pt = Ct & 1 && At
          , Kt = !Bu(E);
        let me;
        if (Kt && (me = dt && dt.onVnodeBeforeUnmount) && xs(me, M, E),
        Ct & 6)
            wt(E.component, F, $);
        else {
            if (Ct & 128) {
                E.suspense.unmount(F, $);
                return
            }
            Pt && Gn(E, null, M, "beforeUnmount"),
            Ct & 64 ? E.type.remove(E, M, F, Y, re, $) : Z && (rt !== Nt || yt > 0 && yt & 64) ? Tt(Z, M, F, !1, !0) : (rt === Nt && yt & 384 || !Y && Ct & 16) && Tt(it, M, F),
            $ && St(E)
        }
        (Kt && (me = dt && dt.onVnodeUnmounted) || Pt) && oi(()=>{
            me && xs(me, M, E),
            Pt && Gn(E, null, M, "unmounted")
        }
        , F)
    }
      , St = E=>{
        const {type: M, el: F, anchor: $, transition: Y} = E;
        if (M === Nt) {
            J(F, $);
            return
        }
        if (M === Kl) {
            C(E);
            return
        }
        const rt = ()=>{
            n(F),
            Y && !Y.persisted && Y.afterLeave && Y.afterLeave()
        }
        ;
        if (E.shapeFlag & 1 && Y && !Y.persisted) {
            const {leave: dt, delayLeave: tt} = Y
              , it = ()=>dt(F, rt);
            tt ? tt(E.el, rt, it) : it()
        } else
            rt()
    }
      , J = (E,M)=>{
        let F;
        for (; E !== M; )
            F = d(E),
            n(E),
            E = F;
        n(M)
    }
      , wt = (E,M,F)=>{
        const {bum: $, scope: Y, update: rt, subTree: dt, um: tt} = E;
        $ && Yl($),
        Y.stop(),
        rt && (rt.active = !1,
        It(dt, E, M, F)),
        tt && oi(tt, M),
        oi(()=>{
            E.isUnmounted = !0
        }
        , M),
        M && M.pendingBranch && !M.isUnmounted && E.asyncDep && !E.asyncResolved && E.suspenseId === M.pendingId && (M.deps--,
        M.deps === 0 && M.resolve())
    }
      , Tt = (E,M,F,$=!1,Y=!1,rt=0)=>{
        for (let dt = rt; dt < E.length; dt++)
            It(E[dt], M, F, $, Y)
    }
      , Bt = E=>E.shapeFlag & 6 ? Bt(E.component.subTree) : E.shapeFlag & 128 ? E.suspense.next() : d(E.anchor || E.el)
      , kt = (E,M,F)=>{
        E == null ? M._vnode && It(M._vnode, null, null, !0) : g(M._vnode || null, E, M, null, null, null, F),
        u_(),
        M._vnode = E
    }
      , re = {
        p: g,
        um: It,
        m: xt,
        r: St,
        mt: W,
        mc: L,
        pc: bt,
        pbc: O,
        n: Bt,
        o: e
    };
    let Xt, ce;
    return t && ([Xt,ce] = t(re)),
    {
        render: kt,
        hydrate: Xt,
        createApp: IS(kt, Xt)
    }
}
function Vu(e, t, i, s, n=!1) {
    if (Wt(e)) {
        e.forEach((d,f)=>Vu(d, t && (Wt(t) ? t[f] : t), i, s, n));
        return
    }
    if (Bu(s) && !n)
        return;
    const r = s.shapeFlag & 4 ? Pf(s.component) || s.component.proxy : s.el
      , o = n ? null : r
      , {i: a, r: l} = e
      , c = t && t.r
      , h = a.refs === xe ? a.refs = {} : a.refs
      , u = a.setupState;
    if (c != null && c !== l && (Ye(c) ? (h[c] = null,
    he(u, c) && (u[c] = null)) : xi(c) && (c.value = null)),
    Ye(l)) {
        const d = ()=>{
            h[l] = o,
            he(u, l) && (u[l] = o)
        }
        ;
        o ? (d.id = -1,
        oi(d, i)) : d()
    } else if (xi(l)) {
        const d = ()=>{
            l.value = o
        }
        ;
        o ? (d.id = -1,
        oi(d, i)) : d()
    } else
        Yt(l) && Sn(l, a, 12, [o, h])
}
function xs(e, t, i, s=null) {
    $i(e, t, 7, [i, s])
}
function t_(e, t, i=!1) {
    const s = e.children
      , n = t.children;
    if (Wt(s) && Wt(n))
        for (let r = 0; r < s.length; r++) {
            const o = s[r];
            let a = n[r];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = n[r] = vn(n[r]),
            a.el = o.el),
            i || t_(o, a))
        }
}
function kS(e) {
    const t = e.slice()
      , i = [0];
    let s, n, r, o, a;
    const l = e.length;
    for (s = 0; s < l; s++) {
        const c = e[s];
        if (c !== 0) {
            if (n = i[i.length - 1],
            e[n] < c) {
                t[s] = n,
                i.push(s);
                continue
            }
            for (r = 0,
            o = i.length - 1; r < o; )
                a = r + o >> 1,
                e[i[a]] < c ? r = a + 1 : o = a;
            c < e[i[r]] && (r > 0 && (t[s] = i[r - 1]),
            i[r] = s)
        }
    }
    for (r = i.length,
    o = i[r - 1]; r-- > 0; )
        i[r] = o,
        o = t[o];
    return i
}
const PS = e=>e.__isTeleport
  , If = "components";
function se(e, t) {
    return i_(If, e, !0, t) || e
}
const e_ = Symbol();
function Ne(e) {
    return Ye(e) ? i_(If, e, !1) || e : e || e_
}
function i_(e, t, i=!0, s=!1) {
    const n = Gi || je;
    if (n) {
        const r = n.type;
        if (e === If) {
            const a = YS(r);
            if (a && (a === t || a === Ds(t) || a === Zc(Ds(t))))
                return r
        }
        const o = Cm(n[e] || r[e], t) || Cm(n.appContext[e], t);
        return !o && s ? r : o
    }
}
function Cm(e, t) {
    return e && (e[t] || e[Ds(t)] || e[Zc(Ds(t))])
}
const Nt = Symbol(void 0)
  , Mf = Symbol(void 0)
  , Ns = Symbol(void 0)
  , Kl = Symbol(void 0)
  , Ea = [];
let br = null;
function st(e=!1) {
    Ea.push(br = e ? null : [])
}
function LS() {
    Ea.pop(),
    br = Ea[Ea.length - 1] || null
}
let gc = 1;
function Am(e) {
    gc += e
}
function s_(e) {
    return e.dynamicChildren = gc > 0 ? br || ho : null,
    LS(),
    gc > 0 && br && br.push(e),
    e
}
function nt(e, t, i, s, n, r) {
    return s_(b(e, t, i, s, n, r, !0))
}
function Rf(e, t, i, s, n) {
    return s_(X(e, t, i, s, n, !0))
}
function OS(e) {
    return e ? e.__v_isVNode === !0 : !1
}
function er(e, t) {
    return e.type === t.type && e.key === t.key
}
const eh = "__vInternal"
  , n_ = ({key: e})=>e ?? null
  , Zl = ({ref: e})=>e != null ? Ye(e) || xi(e) || Yt(e) ? {
    i: Gi,
    r: e
} : e : null;
function b(e, t=null, i=null, s=0, n=null, r=e === Nt ? 0 : 1, o=!1, a=!1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && n_(t),
        ref: t && Zl(t),
        scopeId: Jc,
        slotScopeIds: null,
        children: i,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: r,
        patchFlag: s,
        dynamicProps: n,
        dynamicChildren: null,
        appContext: null
    };
    return a ? (kf(l, i),
    r & 128 && e.normalize(l)) : i && (l.shapeFlag |= Ye(i) ? 8 : 16),
    gc > 0 && !o && br && (l.patchFlag > 0 || r & 6) && l.patchFlag !== 32 && br.push(l),
    l
}
const X = DS;
function DS(e, t=null, i=null, s=0, n=null, r=!1) {
    if ((!e || e === e_) && (e = Ns),
    OS(e)) {
        const a = Ro(e, t, !0);
        return i && kf(a, i),
        a
    }
    if (KS(e) && (e = e.__vccOpts),
    t) {
        t = NS(t);
        let {class: a, style: l} = t;
        a && !Ye(a) && (t.class = Ai(a)),
        Ke(l) && (Ov(l) && !Wt(l) && (l = ei({}, l)),
        t.style = jt(l))
    }
    const o = Ye(e) ? 1 : nS(e) ? 128 : PS(e) ? 64 : Ke(e) ? 4 : Yt(e) ? 2 : 0;
    return b(e, t, i, s, n, o, r, !0)
}
function NS(e) {
    return e ? Ov(e) || eh in e ? ei({}, e) : e : null
}
function Ro(e, t, i=!1) {
    const {props: s, ref: n, patchFlag: r, children: o} = e
      , a = t ? BS(s || {}, t) : s;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: a,
        key: a && n_(a),
        ref: t && t.ref ? i && n ? Wt(n) ? n.concat(Zl(t)) : [n, Zl(t)] : Zl(t) : n,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: o,
        target: e.target,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== Nt ? r === -1 ? 16 : r | 16 : r,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: e.transition,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && Ro(e.ssContent),
        ssFallback: e.ssFallback && Ro(e.ssFallback),
        el: e.el,
        anchor: e.anchor
    }
}
function po(e=" ", t=0) {
    return X(Mf, null, e, t)
}
function ih(e, t) {
    const i = X(Kl, null, e);
    return i.staticCount = t,
    i
}
function FS(e="", t=!1) {
    return t ? (st(),
    Rf(Ns, null, e)) : X(Ns, null, e)
}
function Es(e) {
    return e == null || typeof e == "boolean" ? X(Ns) : Wt(e) ? X(Nt, null, e.slice()) : typeof e == "object" ? vn(e) : X(Mf, null, String(e))
}
function vn(e) {
    return e.el === null || e.memo ? e : Ro(e)
}
function kf(e, t) {
    let i = 0;
    const {shapeFlag: s} = e;
    if (t == null)
        t = null;
    else if (Wt(t))
        i = 16;
    else if (typeof t == "object")
        if (s & 65) {
            const n = t.default;
            n && (n._c && (n._d = !1),
            kf(e, n()),
            n._c && (n._d = !0));
            return
        } else {
            i = 32;
            const n = t._;
            !n && !(eh in t) ? t._ctx = Gi : n === 3 && Gi && (Gi.slots._ === 1 ? t._ = 1 : (t._ = 2,
            e.patchFlag |= 1024))
        }
    else
        Yt(t) ? (t = {
            default: t,
            _ctx: Gi
        },
        i = 32) : (t = String(t),
        s & 64 ? (i = 16,
        t = [po(t)]) : i = 8);
    e.children = t,
    e.shapeFlag |= i
}
function BS(...e) {
    const t = {};
    for (let i = 0; i < e.length; i++) {
        const s = e[i];
        for (const n in s)
            if (n === "class")
                t.class !== s.class && (t.class = Ai([t.class, s.class]));
            else if (n === "style")
                t.style = jt([t.style, s.style]);
            else if (Xc(n)) {
                const r = t[n]
                  , o = s[n];
                r !== o && !(Wt(r) && r.includes(o)) && (t[n] = r ? [].concat(r, o) : o)
            } else
                n !== "" && (t[n] = s[n])
    }
    return t
}
function Jt(e, t, i, s) {
    let n;
    const r = i && i[s];
    if (Wt(e) || Ye(e)) {
        n = new Array(e.length);
        for (let o = 0, a = e.length; o < a; o++)
            n[o] = t(e[o], o, void 0, r && r[o])
    } else if (typeof e == "number") {
        n = new Array(e);
        for (let o = 0; o < e; o++)
            n[o] = t(o + 1, o, void 0, r && r[o])
    } else if (Ke(e))
        if (e[Symbol.iterator])
            n = Array.from(e, (o,a)=>t(o, a, void 0, r && r[a]));
        else {
            const o = Object.keys(e);
            n = new Array(o.length);
            for (let a = 0, l = o.length; a < l; a++) {
                const c = o[a];
                n[a] = t(e[c], c, a, r && r[a])
            }
        }
    else
        n = [];
    return i && (i[s] = n),
    n
}
const zu = e=>e ? r_(e) ? Pf(e) || e.proxy : zu(e.parent) : null
  , vc = ei(Object.create(null), {
    $: e=>e,
    $el: e=>e.vnode.el,
    $data: e=>e.data,
    $props: e=>e.props,
    $attrs: e=>e.attrs,
    $slots: e=>e.slots,
    $refs: e=>e.refs,
    $parent: e=>zu(e.parent),
    $root: e=>zu(e.root),
    $emit: e=>e.emit,
    $options: e=>Xv(e),
    $forceUpdate: e=>()=>l_(e.update),
    $nextTick: e=>fa.bind(e.proxy),
    $watch: e=>eC.bind(e)
})
  , US = {
    get({_: e}, t) {
        const {ctx: i, setupState: s, data: n, props: r, accessCache: o, type: a, appContext: l} = e;
        let c;
        if (t[0] !== "$") {
            const f = o[t];
            if (f !== void 0)
                switch (f) {
                case 1:
                    return s[t];
                case 2:
                    return n[t];
                case 4:
                    return i[t];
                case 3:
                    return r[t]
                }
            else {
                if (s !== xe && he(s, t))
                    return o[t] = 1,
                    s[t];
                if (n !== xe && he(n, t))
                    return o[t] = 2,
                    n[t];
                if ((c = e.propsOptions[0]) && he(c, t))
                    return o[t] = 3,
                    r[t];
                if (i !== xe && he(i, t))
                    return o[t] = 4,
                    i[t];
                Uu && (o[t] = 0)
            }
        }
        const h = vc[t];
        let u, d;
        if (h)
            return t === "$attrs" && Ri(e, "get", t),
            h(e);
        if ((u = a.__cssModules) && (u = u[t]))
            return u;
        if (i !== xe && he(i, t))
            return o[t] = 4,
            i[t];
        if (d = l.config.globalProperties,
        he(d, t))
            return d[t]
    },
    set({_: e}, t, i) {
        const {data: s, setupState: n, ctx: r} = e;
        if (n !== xe && he(n, t))
            n[t] = i;
        else if (s !== xe && he(s, t))
            s[t] = i;
        else if (he(e.props, t))
            return !1;
        return t[0] === "$" && t.slice(1)in e ? !1 : (r[t] = i,
        !0)
    },
    has({_: {data: e, setupState: t, accessCache: i, ctx: s, appContext: n, propsOptions: r}}, o) {
        let a;
        return !!i[o] || e !== xe && he(e, o) || t !== xe && he(t, o) || (a = r[0]) && he(a, o) || he(s, o) || he(vc, o) || he(n.config.globalProperties, o)
    }
}
  , GS = Qv();
let HS = 0;
function VS(e, t, i) {
    const s = e.type
      , n = (t ? t.appContext : e.appContext) || GS
      , r = {
        uid: HS++,
        vnode: e,
        type: s,
        parent: t,
        appContext: n,
        root: null,
        next: null,
        subTree: null,
        update: null,
        scope: new _E(!0),
        render: null,
        proxy: null,
        exposed: null,
        exposeProxy: null,
        withProxy: null,
        provides: t ? t.provides : Object.create(n.provides),
        accessCache: null,
        renderCache: [],
        components: null,
        directives: null,
        propsOptions: Kv(s, n),
        emitsOptions: Bv(s, n),
        emit: null,
        emitted: null,
        propsDefaults: xe,
        inheritAttrs: s.inheritAttrs,
        ctx: xe,
        data: xe,
        props: xe,
        attrs: xe,
        slots: xe,
        refs: xe,
        setupState: xe,
        setupContext: null,
        suspense: i,
        suspenseId: i ? i.pendingId : 0,
        asyncDep: null,
        asyncResolved: !1,
        isMounted: !1,
        isUnmounted: !1,
        isDeactivated: !1,
        bc: null,
        c: null,
        bm: null,
        m: null,
        bu: null,
        u: null,
        um: null,
        bum: null,
        da: null,
        a: null,
        rtg: null,
        rtc: null,
        ec: null,
        sp: null
    };
    return r.ctx = {
        _: r
    },
    r.root = t ? t.root : r,
    r.emit = JE.bind(null, r),
    e.ce && e.ce(r),
    r
}
let je = null;
const zS = ()=>je || Gi
  , ko = e=>{
    je = e,
    e.scope.on()
}
  , xr = ()=>{
    je && je.scope.off(),
    je = null
}
;
function r_(e) {
    return e.vnode.shapeFlag & 4
}
let _c = !1;
function $S(e, t=!1) {
    _c = t;
    const {props: i, children: s} = e.vnode
      , n = r_(e);
    wS(e, i, n, t),
    SS(e, s);
    const r = n ? jS(e, t) : void 0;
    return _c = !1,
    r
}
function jS(e, t) {
    const i = e.type;
    e.accessCache = Object.create(null),
    e.proxy = Ws(new Proxy(e.ctx,US));
    const {setup: s} = i;
    if (s) {
        const n = e.setupContext = s.length > 1 ? XS(e) : null;
        ko(e),
        zo();
        const r = Sn(s, e, 0, [e.props, n]);
        if (kr(),
        xr(),
        bv(r)) {
            if (r.then(xr, xr),
            t)
                return r.then(o=>{
                    Im(e, o, t)
                }
                ).catch(o=>{
                    sh(o, e, 0)
                }
                );
            e.asyncDep = r
        } else
            Im(e, r, t)
    } else
        o_(e, t)
}
function Im(e, t, i) {
    Yt(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : Ke(t) && (e.setupState = Fv(t)),
    o_(e, i)
}
let Mm;
function o_(e, t, i) {
    const s = e.type;
    if (!e.render) {
        if (!t && Mm && !s.render) {
            const n = s.template;
            if (n) {
                const {isCustomElement: r, compilerOptions: o} = e.appContext.config
                  , {delimiters: a, compilerOptions: l} = s
                  , c = ei(ei({
                    isCustomElement: r,
                    delimiters: a
                }, o), l);
                s.render = Mm(n, c)
            }
        }
        e.render = s.render || as
    }
    ko(e),
    zo(),
    vS(e),
    kr(),
    xr()
}
function WS(e) {
    return new Proxy(e.attrs,{
        get(t, i) {
            return Ri(e, "get", "$attrs"),
            t[i]
        }
    })
}
function XS(e) {
    const t = s=>{
        e.exposed = s || {}
    }
    ;
    let i;
    return {
        get attrs() {
            return i || (i = WS(e))
        },
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}
function Pf(e) {
    if (e.exposed)
        return e.exposeProxy || (e.exposeProxy = new Proxy(Fv(Ws(e.exposed)),{
            get(t, i) {
                if (i in t)
                    return t[i];
                if (i in vc)
                    return vc[i](e)
            }
        }))
}
function YS(e) {
    return Yt(e) && e.displayName || e.name
}
function KS(e) {
    return Yt(e) && "__vccOpts"in e
}
function Sn(e, t, i, s) {
    let n;
    try {
        n = s ? e(...s) : e()
    } catch (r) {
        sh(r, t, i)
    }
    return n
}
function $i(e, t, i, s) {
    if (Yt(e)) {
        const r = Sn(e, t, i, s);
        return r && bv(r) && r.catch(o=>{
            sh(o, t, i)
        }
        ),
        r
    }
    const n = [];
    for (let r = 0; r < e.length; r++)
        n.push($i(e[r], t, i, s));
    return n
}
function sh(e, t, i, s=!0) {
    const n = t ? t.vnode : null;
    if (t) {
        let r = t.parent;
        const o = t.proxy
          , a = i;
        for (; r; ) {
            const c = r.ec;
            if (c) {
                for (let h = 0; h < c.length; h++)
                    if (c[h](e, o, a) === !1)
                        return
            }
            r = r.parent
        }
        const l = t.appContext.config.errorHandler;
        if (l) {
            Sn(l, null, 10, [e, o, a]);
            return
        }
    }
    ZS(e, i, n, s)
}
function ZS(e, t, i, s=!0) {
    console.error(e)
}
let yc = !1
  , $u = !1;
const Ci = [];
let js = 0;
const Sa = [];
let da = null
  , Jr = 0;
const Ca = [];
let pn = null
  , Qr = 0;
const a_ = Promise.resolve();
let Lf = null
  , ju = null;
function fa(e) {
    const t = Lf || a_;
    return e ? t.then(this ? e.bind(this) : e) : t
}
function qS(e) {
    let t = js + 1
      , i = Ci.length;
    for (; t < i; ) {
        const s = t + i >>> 1;
        La(Ci[s]) < e ? t = s + 1 : i = s
    }
    return t
}
function l_(e) {
    (!Ci.length || !Ci.includes(e, yc && e.allowRecurse ? js + 1 : js)) && e !== ju && (e.id == null ? Ci.push(e) : Ci.splice(qS(e.id), 0, e),
    c_())
}
function c_() {
    !yc && !$u && ($u = !0,
    Lf = a_.then(d_))
}
function JS(e) {
    const t = Ci.indexOf(e);
    t > js && Ci.splice(t, 1)
}
function h_(e, t, i, s) {
    Wt(e) ? i.push(...e) : (!t || !t.includes(e, e.allowRecurse ? s + 1 : s)) && i.push(e),
    c_()
}
function QS(e) {
    h_(e, da, Sa, Jr)
}
function tC(e) {
    h_(e, pn, Ca, Qr)
}
function Of(e, t=null) {
    if (Sa.length) {
        for (ju = t,
        da = [...new Set(Sa)],
        Sa.length = 0,
        Jr = 0; Jr < da.length; Jr++)
            da[Jr]();
        da = null,
        Jr = 0,
        ju = null,
        Of(e, t)
    }
}
function u_(e) {
    if (Ca.length) {
        const t = [...new Set(Ca)];
        if (Ca.length = 0,
        pn) {
            pn.push(...t);
            return
        }
        for (pn = t,
        pn.sort((i,s)=>La(i) - La(s)),
        Qr = 0; Qr < pn.length; Qr++)
            pn[Qr]();
        pn = null,
        Qr = 0
    }
}
const La = e=>e.id == null ? 1 / 0 : e.id;
function d_(e) {
    $u = !1,
    yc = !0,
    Of(e),
    Ci.sort((i,s)=>La(i) - La(s));
    const t = as;
    try {
        for (js = 0; js < Ci.length; js++) {
            const i = Ci[js];
            i && i.active !== !1 && Sn(i, null, 14)
        }
    } finally {
        js = 0,
        Ci.length = 0,
        u_(),
        yc = !1,
        Lf = null,
        (Ci.length || Sa.length || Ca.length) && d_(e)
    }
}
const Rm = {};
function Aa(e, t, i) {
    return f_(e, t, i)
}
function f_(e, t, {immediate: i, deep: s, flush: n, onTrack: r, onTrigger: o}=xe) {
    const a = je;
    let l, c = !1, h = !1;
    if (xi(e) ? (l = ()=>e.value,
    c = !!e._shallow) : fo(e) ? (l = ()=>e,
    s = !0) : Wt(e) ? (h = !0,
    c = e.some(fo),
    l = ()=>e.map(y=>{
        if (xi(y))
            return y.value;
        if (fo(y))
            return sr(y);
        if (Yt(y))
            return Sn(y, a, 2)
    }
    )) : Yt(e) ? t ? l = ()=>Sn(e, a, 2) : l = ()=>{
        if (!(a && a.isUnmounted))
            return u && u(),
            $i(e, a, 3, [d])
    }
    : l = as,
    t && s) {
        const y = l;
        l = ()=>sr(y())
    }
    let u, d = y=>{
        u = g.onStop = ()=>{
            Sn(y, a, 4)
        }
    }
    ;
    if (_c)
        return d = as,
        t ? i && $i(t, a, 3, [l(), h ? [] : void 0, d]) : l(),
        as;
    let f = h ? [] : Rm;
    const p = ()=>{
        if (!!g.active)
            if (t) {
                const y = g.run();
                (s || c || (h ? y.some((x,v)=>ka(x, f[v])) : ka(y, f))) && (u && u(),
                $i(t, a, 3, [y, f === Rm ? void 0 : f, d]),
                f = y)
            } else
                g.run()
    }
    ;
    p.allowRecurse = !!t;
    let m;
    n === "sync" ? m = p : n === "post" ? m = ()=>oi(p, a && a.suspense) : m = ()=>{
        !a || a.isMounted ? QS(p) : p()
    }
    ;
    const g = new _f(l,m);
    return t ? i ? p() : f = g.run() : n === "post" ? oi(g.run.bind(g), a && a.suspense) : g.run(),
    ()=>{
        g.stop(),
        a && a.scope && _v(a.scope.effects, g)
    }
}
function eC(e, t, i) {
    const s = this.proxy
      , n = Ye(e) ? e.includes(".") ? p_(s, e) : ()=>s[e] : e.bind(s, s);
    let r;
    Yt(t) ? r = t : (r = t.handler,
    i = t);
    const o = je;
    ko(this);
    const a = f_(n, r.bind(s), i);
    return o ? ko(o) : xr(),
    a
}
function p_(e, t) {
    const i = t.split(".");
    return ()=>{
        let s = e;
        for (let n = 0; n < i.length && s; n++)
            s = s[i[n]];
        return s
    }
}
function sr(e, t) {
    if (!Ke(e) || e.__v_skip || (t = t || new Set,
    t.has(e)))
        return e;
    if (t.add(e),
    xi(e))
        sr(e.value, t);
    else if (Wt(e))
        for (let i = 0; i < e.length; i++)
            sr(e[i], t);
    else if (yv(e) || uo(e))
        e.forEach(i=>{
            sr(i, t)
        }
        );
    else if (wv(e))
        for (const i in e)
            sr(e[i], t);
    return e
}
const iC = "3.2.24"
  , sC = "http://www.w3.org/2000/svg"
  , Br = typeof document < "u" ? document : null
  , km = new Map
  , nC = {
    insert: (e,t,i)=>{
        t.insertBefore(e, i || null)
    }
    ,
    remove: e=>{
        const t = e.parentNode;
        t && t.removeChild(e)
    }
    ,
    createElement: (e,t,i,s)=>{
        const n = t ? Br.createElementNS(sC, e) : Br.createElement(e, i ? {
            is: i
        } : void 0);
        return e === "select" && s && s.multiple != null && n.setAttribute("multiple", s.multiple),
        n
    }
    ,
    createText: e=>Br.createTextNode(e),
    createComment: e=>Br.createComment(e),
    setText: (e,t)=>{
        e.nodeValue = t
    }
    ,
    setElementText: (e,t)=>{
        e.textContent = t
    }
    ,
    parentNode: e=>e.parentNode,
    nextSibling: e=>e.nextSibling,
    querySelector: e=>Br.querySelector(e),
    setScopeId(e, t) {
        e.setAttribute(t, "")
    },
    cloneNode(e) {
        const t = e.cloneNode(!0);
        return "_value"in e && (t._value = e._value),
        t
    },
    insertStaticContent(e, t, i, s) {
        const n = i ? i.previousSibling : t.lastChild;
        let r = km.get(e);
        if (!r) {
            const o = Br.createElement("template");
            if (o.innerHTML = s ? `<svg>${e}</svg>` : e,
            r = o.content,
            s) {
                const a = r.firstChild;
                for (; a.firstChild; )
                    r.appendChild(a.firstChild);
                r.removeChild(a)
            }
            km.set(e, r)
        }
        return t.insertBefore(r.cloneNode(!0), i),
        [n ? n.nextSibling : t.firstChild, i ? i.previousSibling : t.lastChild]
    }
};
function rC(e, t, i) {
    const s = e._vtc;
    s && (t = (t ? [t, ...s] : [...s]).join(" ")),
    t == null ? e.removeAttribute("class") : i ? e.setAttribute("class", t) : e.className = t
}
function oC(e, t, i) {
    const s = e.style
      , n = Ye(i);
    if (i && !n) {
        for (const r in i)
            Wu(s, r, i[r]);
        if (t && !Ye(t))
            for (const r in t)
                i[r] == null && Wu(s, r, "")
    } else {
        const r = s.display;
        n ? t !== i && (s.cssText = i) : t && e.removeAttribute("style"),
        "_vod"in e && (s.display = r)
    }
}
const Pm = /\s*!important$/;
function Wu(e, t, i) {
    if (Wt(i))
        i.forEach(s=>Wu(e, t, s));
    else if (t.startsWith("--"))
        e.setProperty(t, i);
    else {
        const s = aC(e, t);
        Pm.test(i) ? e.setProperty(Vo(s), i.replace(Pm, ""), "important") : e[s] = i
    }
}
const Lm = ["Webkit", "Moz", "ms"]
  , zh = {};
function aC(e, t) {
    const i = zh[t];
    if (i)
        return i;
    let s = Ds(t);
    if (s !== "filter" && s in e)
        return zh[t] = s;
    s = Zc(s);
    for (let n = 0; n < Lm.length; n++) {
        const r = Lm[n] + s;
        if (r in e)
            return zh[t] = r
    }
    return t
}
const Om = "http://www.w3.org/1999/xlink";
function lC(e, t, i, s, n) {
    if (s && t.startsWith("xlink:"))
        i == null ? e.removeAttributeNS(Om, t.slice(6, t.length)) : e.setAttributeNS(Om, t, i);
    else {
        const r = aE(t);
        i == null || r && !gv(i) ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : i)
    }
}
function cC(e, t, i, s, n, r, o) {
    if (t === "innerHTML" || t === "textContent") {
        s && o(s, n, r),
        e[t] = i ?? "";
        return
    }
    if (t === "value" && e.tagName !== "PROGRESS" && !e.tagName.includes("-")) {
        e._value = i;
        const a = i ?? "";
        (e.value !== a || e.tagName === "OPTION") && (e.value = a),
        i == null && e.removeAttribute(t);
        return
    }
    if (i === "" || i == null) {
        const a = typeof e[t];
        if (a === "boolean") {
            e[t] = gv(i);
            return
        } else if (i == null && a === "string") {
            e[t] = "",
            e.removeAttribute(t);
            return
        } else if (a === "number") {
            try {
                e[t] = 0
            } catch {}
            e.removeAttribute(t);
            return
        }
    }
    try {
        e[t] = i
    } catch {}
}
let bc = Date.now
  , m_ = !1;
if (typeof window < "u") {
    bc() > document.createEvent("Event").timeStamp && (bc = ()=>performance.now());
    const e = navigator.userAgent.match(/firefox\/(\d+)/i);
    m_ = !!(e && Number(e[1]) <= 53)
}
let Xu = 0;
const hC = Promise.resolve()
  , uC = ()=>{
    Xu = 0
}
  , dC = ()=>Xu || (hC.then(uC),
Xu = bc());
function to(e, t, i, s) {
    e.addEventListener(t, i, s)
}
function fC(e, t, i, s) {
    e.removeEventListener(t, i, s)
}
function pC(e, t, i, s, n=null) {
    const r = e._vei || (e._vei = {})
      , o = r[t];
    if (s && o)
        o.value = s;
    else {
        const [a,l] = mC(t);
        if (s) {
            const c = r[t] = gC(s, n);
            to(e, a, c, l)
        } else
            o && (fC(e, a, o, l),
            r[t] = void 0)
    }
}
const Dm = /(?:Once|Passive|Capture)$/;
function mC(e) {
    let t;
    if (Dm.test(e)) {
        t = {};
        let i;
        for (; i = e.match(Dm); )
            e = e.slice(0, e.length - i[0].length),
            t[i[0].toLowerCase()] = !0
    }
    return [Vo(e.slice(2)), t]
}
function gC(e, t) {
    const i = s=>{
        const n = s.timeStamp || bc();
        (m_ || n >= i.attached - 1) && $i(vC(s, i.value), t, 5, [s])
    }
    ;
    return i.value = e,
    i.attached = dC(),
    i
}
function vC(e, t) {
    if (Wt(t)) {
        const i = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = ()=>{
            i.call(e),
            e._stopped = !0
        }
        ,
        t.map(s=>n=>!n._stopped && s(n))
    } else
        return t
}
const Nm = /^on[a-z]/
  , _C = (e,t,i,s,n=!1,r,o,a,l)=>{
    t === "class" ? rC(e, s, n) : t === "style" ? oC(e, i, s) : Xc(t) ? pf(t) || pC(e, t, i, s, o) : (t[0] === "." ? (t = t.slice(1),
    !0) : t[0] === "^" ? (t = t.slice(1),
    !1) : yC(e, t, s, n)) ? cC(e, t, s, r, o, a, l) : (t === "true-value" ? e._trueValue = s : t === "false-value" && (e._falseValue = s),
    lC(e, t, s, n))
}
;
function yC(e, t, i, s) {
    return s ? !!(t === "innerHTML" || t === "textContent" || t in e && Nm.test(t) && Yt(i)) : t === "spellcheck" || t === "draggable" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || Nm.test(t) && Ye(i) ? !1 : t in e
}
const bC = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
lS.props;
const Fm = e=>{
    const t = e.props["onUpdate:modelValue"];
    return Wt(t) ? i=>Yl(t, i) : t
}
;
function xC(e) {
    e.target.composing = !0
}
function Bm(e) {
    const t = e.target;
    t.composing && (t.composing = !1,
    wC(t, "input"))
}
function wC(e, t) {
    const i = document.createEvent("HTMLEvents");
    i.initEvent(t, !0, !0),
    e.dispatchEvent(i)
}
const nr = {
    created(e, {modifiers: {lazy: t, trim: i, number: s}}, n) {
        e._assign = Fm(n);
        const r = s || n.props && n.props.type === "number";
        to(e, t ? "change" : "input", o=>{
            if (o.target.composing)
                return;
            let a = e.value;
            i ? a = a.trim() : r && (a = ku(a)),
            e._assign(a)
        }
        ),
        i && to(e, "change", ()=>{
            e.value = e.value.trim()
        }
        ),
        t || (to(e, "compositionstart", xC),
        to(e, "compositionend", Bm),
        to(e, "change", Bm))
    },
    mounted(e, {value: t}) {
        e.value = t ?? ""
    },
    beforeUpdate(e, {value: t, modifiers: {lazy: i, trim: s, number: n}}, r) {
        if (e._assign = Fm(r),
        e.composing || document.activeElement === e && (i || s && e.value.trim() === t || (n || e.type === "number") && ku(e.value) === t))
            return;
        const o = t ?? "";
        e.value !== o && (e.value = o)
    }
}
  , ye = {
    beforeMount(e, {value: t}, {transition: i}) {
        e._vod = e.style.display === "none" ? "" : e.style.display,
        i && t ? i.beforeEnter(e) : Zo(e, t)
    },
    mounted(e, {value: t}, {transition: i}) {
        i && t && i.enter(e)
    },
    updated(e, {value: t, oldValue: i}, {transition: s}) {
        !t != !i && (s ? t ? (s.beforeEnter(e),
        Zo(e, !0),
        s.enter(e)) : s.leave(e, ()=>{
            Zo(e, !1)
        }
        ) : Zo(e, t))
    },
    beforeUnmount(e, {value: t}) {
        Zo(e, t)
    }
};
function Zo(e, t) {
    e.style.display = t ? e._vod : "none"
}
const TC = ei({
    patchProp: _C
}, nC);
let Um;
function EC() {
    return Um || (Um = MS(TC))
}
const SC = (...e)=>{
    const t = EC().createApp(...e)
      , {mount: i} = t;
    return t.mount = s=>{
        const n = CC(s);
        if (!n)
            return;
        const r = t._component;
        !Yt(r) && !r.render && !r.template && (r.template = n.innerHTML),
        n.innerHTML = "";
        const o = i(n, !1, n instanceof SVGElement);
        return n instanceof Element && (n.removeAttribute("v-cloak"),
        n.setAttribute("data-v-app", "")),
        o
    }
    ,
    t
}
;
function CC(e) {
    return Ye(e) ? document.querySelector(e) : e
}
var Lr = (e=>(e[e.WEBGL_LEGACY = 0] = "WEBGL_LEGACY",
e[e.WEBGL = 1] = "WEBGL",
e[e.WEBGL2 = 2] = "WEBGL2",
e))(Lr || {})
  , Yu = (e=>(e[e.COLOR = 16384] = "COLOR",
e[e.DEPTH = 256] = "DEPTH",
e[e.STENCIL = 1024] = "STENCIL",
e))(Yu || {})
  , j = (e=>(e[e.NORMAL = 0] = "NORMAL",
e[e.ADD = 1] = "ADD",
e[e.MULTIPLY = 2] = "MULTIPLY",
e[e.SCREEN = 3] = "SCREEN",
e[e.OVERLAY = 4] = "OVERLAY",
e[e.DARKEN = 5] = "DARKEN",
e[e.LIGHTEN = 6] = "LIGHTEN",
e[e.COLOR_DODGE = 7] = "COLOR_DODGE",
e[e.COLOR_BURN = 8] = "COLOR_BURN",
e[e.HARD_LIGHT = 9] = "HARD_LIGHT",
e[e.SOFT_LIGHT = 10] = "SOFT_LIGHT",
e[e.DIFFERENCE = 11] = "DIFFERENCE",
e[e.EXCLUSION = 12] = "EXCLUSION",
e[e.HUE = 13] = "HUE",
e[e.SATURATION = 14] = "SATURATION",
e[e.COLOR = 15] = "COLOR",
e[e.LUMINOSITY = 16] = "LUMINOSITY",
e[e.NORMAL_NPM = 17] = "NORMAL_NPM",
e[e.ADD_NPM = 18] = "ADD_NPM",
e[e.SCREEN_NPM = 19] = "SCREEN_NPM",
e[e.NONE = 20] = "NONE",
e[e.SRC_OVER = 0] = "SRC_OVER",
e[e.SRC_IN = 21] = "SRC_IN",
e[e.SRC_OUT = 22] = "SRC_OUT",
e[e.SRC_ATOP = 23] = "SRC_ATOP",
e[e.DST_OVER = 24] = "DST_OVER",
e[e.DST_IN = 25] = "DST_IN",
e[e.DST_OUT = 26] = "DST_OUT",
e[e.DST_ATOP = 27] = "DST_ATOP",
e[e.ERASE = 26] = "ERASE",
e[e.SUBTRACT = 28] = "SUBTRACT",
e[e.XOR = 29] = "XOR",
e))(j || {})
  , rs = (e=>(e[e.POINTS = 0] = "POINTS",
e[e.LINES = 1] = "LINES",
e[e.LINE_LOOP = 2] = "LINE_LOOP",
e[e.LINE_STRIP = 3] = "LINE_STRIP",
e[e.TRIANGLES = 4] = "TRIANGLES",
e[e.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP",
e[e.TRIANGLE_FAN = 6] = "TRIANGLE_FAN",
e))(rs || {})
  , ot = (e=>(e[e.RGBA = 6408] = "RGBA",
e[e.RGB = 6407] = "RGB",
e[e.RG = 33319] = "RG",
e[e.RED = 6403] = "RED",
e[e.RGBA_INTEGER = 36249] = "RGBA_INTEGER",
e[e.RGB_INTEGER = 36248] = "RGB_INTEGER",
e[e.RG_INTEGER = 33320] = "RG_INTEGER",
e[e.RED_INTEGER = 36244] = "RED_INTEGER",
e[e.ALPHA = 6406] = "ALPHA",
e[e.LUMINANCE = 6409] = "LUMINANCE",
e[e.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA",
e[e.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT",
e[e.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL",
e))(ot || {})
  , mo = (e=>(e[e.TEXTURE_2D = 3553] = "TEXTURE_2D",
e[e.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP",
e[e.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY",
e[e.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X",
e[e.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X",
e[e.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y",
e[e.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y",
e[e.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z",
e[e.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z",
e))(mo || {})
  , Rt = (e=>(e[e.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE",
e[e.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT",
e[e.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5",
e[e.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4",
e[e.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1",
e[e.UNSIGNED_INT = 5125] = "UNSIGNED_INT",
e[e.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV",
e[e.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV",
e[e.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8",
e[e.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV",
e[e.BYTE = 5120] = "BYTE",
e[e.SHORT = 5122] = "SHORT",
e[e.INT = 5124] = "INT",
e[e.FLOAT = 5126] = "FLOAT",
e[e.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV",
e[e.HALF_FLOAT = 36193] = "HALF_FLOAT",
e))(Rt || {})
  , Ku = (e=>(e[e.FLOAT = 0] = "FLOAT",
e[e.INT = 1] = "INT",
e[e.UINT = 2] = "UINT",
e))(Ku || {})
  , Hi = (e=>(e[e.NEAREST = 0] = "NEAREST",
e[e.LINEAR = 1] = "LINEAR",
e))(Hi || {})
  , Zs = (e=>(e[e.CLAMP = 33071] = "CLAMP",
e[e.REPEAT = 10497] = "REPEAT",
e[e.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT",
e))(Zs || {})
  , ds = (e=>(e[e.OFF = 0] = "OFF",
e[e.POW2 = 1] = "POW2",
e[e.ON = 2] = "ON",
e[e.ON_MANUAL = 3] = "ON_MANUAL",
e))(ds || {})
  , _s = (e=>(e[e.NPM = 0] = "NPM",
e[e.UNPACK = 1] = "UNPACK",
e[e.PMA = 2] = "PMA",
e[e.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA",
e[e.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD",
e[e.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA",
e))(_s || {})
  , Ss = (e=>(e[e.NO = 0] = "NO",
e[e.YES = 1] = "YES",
e[e.AUTO = 2] = "AUTO",
e[e.BLEND = 0] = "BLEND",
e[e.CLEAR = 1] = "CLEAR",
e[e.BLIT = 2] = "BLIT",
e))(Ss || {})
  , Df = (e=>(e[e.AUTO = 0] = "AUTO",
e[e.MANUAL = 1] = "MANUAL",
e))(Df || {})
  , Vi = (e=>(e.LOW = "lowp",
e.MEDIUM = "mediump",
e.HIGH = "highp",
e))(Vi || {})
  , Ue = (e=>(e[e.NONE = 0] = "NONE",
e[e.SCISSOR = 1] = "SCISSOR",
e[e.STENCIL = 2] = "STENCIL",
e[e.SPRITE = 3] = "SPRITE",
e[e.COLOR = 4] = "COLOR",
e))(Ue || {})
  , De = (e=>(e[e.NONE = 0] = "NONE",
e[e.LOW = 2] = "LOW",
e[e.MEDIUM = 4] = "MEDIUM",
e[e.HIGH = 8] = "HIGH",
e))(De || {})
  , Ps = (e=>(e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER",
e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER",
e[e.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER",
e))(Ps || {});
const AC = {
    createCanvas: (e,t)=>{
        const i = document.createElement("canvas");
        return i.width = e,
        i.height = t,
        i
    }
    ,
    getCanvasRenderingContext2D: ()=>CanvasRenderingContext2D,
    getWebGLRenderingContext: ()=>WebGLRenderingContext,
    getNavigator: ()=>navigator,
    getBaseUrl: ()=>document.baseURI ?? window.location.href,
    getFontFaceSet: ()=>document.fonts,
    fetch: (e,t)=>fetch(e, t),
    parseXML: e=>new DOMParser().parseFromString(e, "text/xml")
}
  , ft = {
    ADAPTER: AC,
    RESOLUTION: 1,
    RENDER_OPTIONS: {
        view: null,
        width: 800,
        height: 600,
        autoDensity: !1,
        backgroundColor: 0,
        backgroundAlpha: 1,
        clearBeforeRender: !0,
        antialias: !1,
        premultipliedAlpha: !0,
        preserveDrawingBuffer: !1,
        hello: !1
    },
    CREATE_IMAGE_BITMAP: !1,
    ROUND_PIXELS: !1
};
var $h = /iPhone/i
  , Gm = /iPod/i
  , Hm = /iPad/i
  , Vm = /\biOS-universal(?:.+)Mac\b/i
  , jh = /\bAndroid(?:.+)Mobile\b/i
  , zm = /Android/i
  , Ur = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i
  , vl = /Silk/i
  , Gs = /Windows Phone/i
  , $m = /\bWindows(?:.+)ARM\b/i
  , jm = /BlackBerry/i
  , Wm = /BB10/i
  , Xm = /Opera Mini/i
  , Ym = /\b(CriOS|Chrome)(?:.+)Mobile/i
  , Km = /Mobile(?:.+)Firefox\b/i
  , Zm = function(e) {
    return typeof e < "u" && e.platform === "MacIntel" && typeof e.maxTouchPoints == "number" && e.maxTouchPoints > 1 && typeof MSStream > "u"
};
function IC(e) {
    return function(t) {
        return t.test(e)
    }
}
function MC(e) {
    var t = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
    };
    !e && typeof navigator < "u" ? t = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
    } : typeof e == "string" ? t.userAgent = e : e && e.userAgent && (t = {
        userAgent: e.userAgent,
        platform: e.platform,
        maxTouchPoints: e.maxTouchPoints || 0
    });
    var i = t.userAgent
      , s = i.split("[FBAN");
    typeof s[1] < "u" && (i = s[0]),
    s = i.split("Twitter"),
    typeof s[1] < "u" && (i = s[0]);
    var n = IC(i)
      , r = {
        apple: {
            phone: n($h) && !n(Gs),
            ipod: n(Gm),
            tablet: !n($h) && (n(Hm) || Zm(t)) && !n(Gs),
            universal: n(Vm),
            device: (n($h) || n(Gm) || n(Hm) || n(Vm) || Zm(t)) && !n(Gs)
        },
        amazon: {
            phone: n(Ur),
            tablet: !n(Ur) && n(vl),
            device: n(Ur) || n(vl)
        },
        android: {
            phone: !n(Gs) && n(Ur) || !n(Gs) && n(jh),
            tablet: !n(Gs) && !n(Ur) && !n(jh) && (n(vl) || n(zm)),
            device: !n(Gs) && (n(Ur) || n(vl) || n(jh) || n(zm)) || n(/\bokhttp\b/i)
        },
        windows: {
            phone: n(Gs),
            tablet: n($m),
            device: n(Gs) || n($m)
        },
        other: {
            blackberry: n(jm),
            blackberry10: n(Wm),
            opera: n(Xm),
            firefox: n(Km),
            chrome: n(Ym),
            device: n(jm) || n(Wm) || n(Xm) || n(Km) || n(Ym)
        },
        any: !1,
        phone: !1,
        tablet: !1
    };
    return r.any = r.apple.device || r.android.device || r.windows.device || r.other.device,
    r.phone = r.apple.phone || r.android.phone || r.windows.phone,
    r.tablet = r.apple.tablet || r.android.tablet || r.windows.tablet,
    r
}
const Is = MC(globalThis.navigator);
ft.RETINA_PREFIX = /@([0-9\.]+)x/;
ft.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var Wh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}
  , g_ = {
    exports: {}
};
(function(e) {
    var t = Object.prototype.hasOwnProperty
      , i = "~";
    function s() {}
    Object.create && (s.prototype = Object.create(null),
    new s().__proto__ || (i = !1));
    function n(l, c, h) {
        this.fn = l,
        this.context = c,
        this.once = h || !1
    }
    function r(l, c, h, u, d) {
        if (typeof h != "function")
            throw new TypeError("The listener must be a function");
        var f = new n(h,u || l,d)
          , p = i ? i + c : c;
        return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], f] : l._events[p].push(f) : (l._events[p] = f,
        l._eventsCount++),
        l
    }
    function o(l, c) {
        --l._eventsCount === 0 ? l._events = new s : delete l._events[c]
    }
    function a() {
        this._events = new s,
        this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var c = [], h, u;
        if (this._eventsCount === 0)
            return c;
        for (u in h = this._events)
            t.call(h, u) && c.push(i ? u.slice(1) : u);
        return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(h)) : c
    }
    ,
    a.prototype.listeners = function(c) {
        var h = i ? i + c : c
          , u = this._events[h];
        if (!u)
            return [];
        if (u.fn)
            return [u.fn];
        for (var d = 0, f = u.length, p = new Array(f); d < f; d++)
            p[d] = u[d].fn;
        return p
    }
    ,
    a.prototype.listenerCount = function(c) {
        var h = i ? i + c : c
          , u = this._events[h];
        return u ? u.fn ? 1 : u.length : 0
    }
    ,
    a.prototype.emit = function(c, h, u, d, f, p) {
        var m = i ? i + c : c;
        if (!this._events[m])
            return !1;
        var g = this._events[m], y = arguments.length, x, v;
        if (g.fn) {
            switch (g.once && this.removeListener(c, g.fn, void 0, !0),
            y) {
            case 1:
                return g.fn.call(g.context),
                !0;
            case 2:
                return g.fn.call(g.context, h),
                !0;
            case 3:
                return g.fn.call(g.context, h, u),
                !0;
            case 4:
                return g.fn.call(g.context, h, u, d),
                !0;
            case 5:
                return g.fn.call(g.context, h, u, d, f),
                !0;
            case 6:
                return g.fn.call(g.context, h, u, d, f, p),
                !0
            }
            for (v = 1,
            x = new Array(y - 1); v < y; v++)
                x[v - 1] = arguments[v];
            g.fn.apply(g.context, x)
        } else {
            var _ = g.length, C;
            for (v = 0; v < _; v++)
                switch (g[v].once && this.removeListener(c, g[v].fn, void 0, !0),
                y) {
                case 1:
                    g[v].fn.call(g[v].context);
                    break;
                case 2:
                    g[v].fn.call(g[v].context, h);
                    break;
                case 3:
                    g[v].fn.call(g[v].context, h, u);
                    break;
                case 4:
                    g[v].fn.call(g[v].context, h, u, d);
                    break;
                default:
                    if (!x)
                        for (C = 1,
                        x = new Array(y - 1); C < y; C++)
                            x[C - 1] = arguments[C];
                    g[v].fn.apply(g[v].context, x)
                }
        }
        return !0
    }
    ,
    a.prototype.on = function(c, h, u) {
        return r(this, c, h, u, !1)
    }
    ,
    a.prototype.once = function(c, h, u) {
        return r(this, c, h, u, !0)
    }
    ,
    a.prototype.removeListener = function(c, h, u, d) {
        var f = i ? i + c : c;
        if (!this._events[f])
            return this;
        if (!h)
            return o(this, f),
            this;
        var p = this._events[f];
        if (p.fn)
            p.fn === h && (!d || p.once) && (!u || p.context === u) && o(this, f);
        else {
            for (var m = 0, g = [], y = p.length; m < y; m++)
                (p[m].fn !== h || d && !p[m].once || u && p[m].context !== u) && g.push(p[m]);
            g.length ? this._events[f] = g.length === 1 ? g[0] : g : o(this, f)
        }
        return this
    }
    ,
    a.prototype.removeAllListeners = function(c) {
        var h;
        return c ? (h = i ? i + c : c,
        this._events[h] && o(this, h)) : (this._events = new s,
        this._eventsCount = 0),
        this
    }
    ,
    a.prototype.off = a.prototype.removeListener,
    a.prototype.addListener = a.prototype.on,
    a.prefixed = i,
    a.EventEmitter = a,
    e.exports = a
}
)(g_);
var $o = g_.exports
  , Nf = {
    exports: {}
};
Nf.exports = nh;
Nf.exports.default = nh;
function nh(e, t, i) {
    i = i || 2;
    var s = t && t.length
      , n = s ? t[0] * i : e.length
      , r = v_(e, 0, n, i, !0)
      , o = [];
    if (!r || r.next === r.prev)
        return o;
    var a, l, c, h, u, d, f;
    if (s && (r = OC(e, t, r, i)),
    e.length > 80 * i) {
        a = c = e[0],
        l = h = e[1];
        for (var p = i; p < n; p += i)
            u = e[p],
            d = e[p + 1],
            u < a && (a = u),
            d < l && (l = d),
            u > c && (c = u),
            d > h && (h = d);
        f = Math.max(c - a, h - l),
        f = f !== 0 ? 32767 / f : 0
    }
    return Oa(r, o, i, a, l, f, 0),
    o
}
function v_(e, t, i, s, n) {
    var r, o;
    if (n === Ju(e, t, i, s) > 0)
        for (r = t; r < i; r += s)
            o = qm(r, e[r], e[r + 1], o);
    else
        for (r = i - s; r >= t; r -= s)
            o = qm(r, e[r], e[r + 1], o);
    return o && rh(o, o.next) && (Na(o),
    o = o.next),
    o
}
function Cr(e, t) {
    if (!e)
        return e;
    t || (t = e);
    var i = e, s;
    do
        if (s = !1,
        !i.steiner && (rh(i, i.next) || Re(i.prev, i, i.next) === 0)) {
            if (Na(i),
            i = t = i.prev,
            i === i.next)
                break;
            s = !0
        } else
            i = i.next;
    while (s || i !== t);
    return t
}
function Oa(e, t, i, s, n, r, o) {
    if (!!e) {
        !o && r && UC(e, s, n, r);
        for (var a = e, l, c; e.prev !== e.next; ) {
            if (l = e.prev,
            c = e.next,
            r ? kC(e, s, n, r) : RC(e)) {
                t.push(l.i / i | 0),
                t.push(e.i / i | 0),
                t.push(c.i / i | 0),
                Na(e),
                e = c.next,
                a = c.next;
                continue
            }
            if (e = c,
            e === a) {
                o ? o === 1 ? (e = PC(Cr(e), t, i),
                Oa(e, t, i, s, n, r, 2)) : o === 2 && LC(e, t, i, s, n, r) : Oa(Cr(e), t, i, s, n, r, 1);
                break
            }
        }
    }
}
function RC(e) {
    var t = e.prev
      , i = e
      , s = e.next;
    if (Re(t, i, s) >= 0)
        return !1;
    for (var n = t.x, r = i.x, o = s.x, a = t.y, l = i.y, c = s.y, h = n < r ? n < o ? n : o : r < o ? r : o, u = a < l ? a < c ? a : c : l < c ? l : c, d = n > r ? n > o ? n : o : r > o ? r : o, f = a > l ? a > c ? a : c : l > c ? l : c, p = s.next; p !== t; ) {
        if (p.x >= h && p.x <= d && p.y >= u && p.y <= f && oo(n, a, r, l, o, c, p.x, p.y) && Re(p.prev, p, p.next) >= 0)
            return !1;
        p = p.next
    }
    return !0
}
function kC(e, t, i, s) {
    var n = e.prev
      , r = e
      , o = e.next;
    if (Re(n, r, o) >= 0)
        return !1;
    for (var a = n.x, l = r.x, c = o.x, h = n.y, u = r.y, d = o.y, f = a < l ? a < c ? a : c : l < c ? l : c, p = h < u ? h < d ? h : d : u < d ? u : d, m = a > l ? a > c ? a : c : l > c ? l : c, g = h > u ? h > d ? h : d : u > d ? u : d, y = Zu(f, p, t, i, s), x = Zu(m, g, t, i, s), v = e.prevZ, _ = e.nextZ; v && v.z >= y && _ && _.z <= x; ) {
        if (v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== n && v !== o && oo(a, h, l, u, c, d, v.x, v.y) && Re(v.prev, v, v.next) >= 0 || (v = v.prevZ,
        _.x >= f && _.x <= m && _.y >= p && _.y <= g && _ !== n && _ !== o && oo(a, h, l, u, c, d, _.x, _.y) && Re(_.prev, _, _.next) >= 0))
            return !1;
        _ = _.nextZ
    }
    for (; v && v.z >= y; ) {
        if (v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== n && v !== o && oo(a, h, l, u, c, d, v.x, v.y) && Re(v.prev, v, v.next) >= 0)
            return !1;
        v = v.prevZ
    }
    for (; _ && _.z <= x; ) {
        if (_.x >= f && _.x <= m && _.y >= p && _.y <= g && _ !== n && _ !== o && oo(a, h, l, u, c, d, _.x, _.y) && Re(_.prev, _, _.next) >= 0)
            return !1;
        _ = _.nextZ
    }
    return !0
}
function PC(e, t, i) {
    var s = e;
    do {
        var n = s.prev
          , r = s.next.next;
        !rh(n, r) && __(n, s, s.next, r) && Da(n, r) && Da(r, n) && (t.push(n.i / i | 0),
        t.push(s.i / i | 0),
        t.push(r.i / i | 0),
        Na(s),
        Na(s.next),
        s = e = r),
        s = s.next
    } while (s !== e);
    return Cr(s)
}
function LC(e, t, i, s, n, r) {
    var o = e;
    do {
        for (var a = o.next.next; a !== o.prev; ) {
            if (o.i !== a.i && VC(o, a)) {
                var l = y_(o, a);
                o = Cr(o, o.next),
                l = Cr(l, l.next),
                Oa(o, t, i, s, n, r, 0),
                Oa(l, t, i, s, n, r, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== e)
}
function OC(e, t, i, s) {
    var n = [], r, o, a, l, c;
    for (r = 0,
    o = t.length; r < o; r++)
        a = t[r] * s,
        l = r < o - 1 ? t[r + 1] * s : e.length,
        c = v_(e, a, l, s, !1),
        c === c.next && (c.steiner = !0),
        n.push(HC(c));
    for (n.sort(DC),
    r = 0; r < n.length; r++)
        i = NC(n[r], i);
    return i
}
function DC(e, t) {
    return e.x - t.x
}
function NC(e, t) {
    var i = FC(e, t);
    if (!i)
        return t;
    var s = y_(i, e);
    return Cr(s, s.next),
    Cr(i, i.next)
}
function FC(e, t) {
    var i = t, s = e.x, n = e.y, r = -1 / 0, o;
    do {
        if (n <= i.y && n >= i.next.y && i.next.y !== i.y) {
            var a = i.x + (n - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
            if (a <= s && a > r && (r = a,
            o = i.x < i.next.x ? i : i.next,
            a === s))
                return o
        }
        i = i.next
    } while (i !== t);
    if (!o)
        return null;
    var l = o, c = o.x, h = o.y, u = 1 / 0, d;
    i = o;
    do
        s >= i.x && i.x >= c && s !== i.x && oo(n < h ? s : r, n, c, h, n < h ? r : s, n, i.x, i.y) && (d = Math.abs(n - i.y) / (s - i.x),
        Da(i, e) && (d < u || d === u && (i.x > o.x || i.x === o.x && BC(o, i))) && (o = i,
        u = d)),
        i = i.next;
    while (i !== l);
    return o
}
function BC(e, t) {
    return Re(e.prev, e, t.prev) < 0 && Re(t.next, e, e.next) < 0
}
function UC(e, t, i, s) {
    var n = e;
    do
        n.z === 0 && (n.z = Zu(n.x, n.y, t, i, s)),
        n.prevZ = n.prev,
        n.nextZ = n.next,
        n = n.next;
    while (n !== e);
    n.prevZ.nextZ = null,
    n.prevZ = null,
    GC(n)
}
function GC(e) {
    var t, i, s, n, r, o, a, l, c = 1;
    do {
        for (i = e,
        e = null,
        r = null,
        o = 0; i; ) {
            for (o++,
            s = i,
            a = 0,
            t = 0; t < c && (a++,
            s = s.nextZ,
            !!s); t++)
                ;
            for (l = c; a > 0 || l > 0 && s; )
                a !== 0 && (l === 0 || !s || i.z <= s.z) ? (n = i,
                i = i.nextZ,
                a--) : (n = s,
                s = s.nextZ,
                l--),
                r ? r.nextZ = n : e = n,
                n.prevZ = r,
                r = n;
            i = s
        }
        r.nextZ = null,
        c *= 2
    } while (o > 1);
    return e
}
function Zu(e, t, i, s, n) {
    return e = (e - i) * n | 0,
    t = (t - s) * n | 0,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    t = (t | t << 8) & 16711935,
    t = (t | t << 4) & 252645135,
    t = (t | t << 2) & 858993459,
    t = (t | t << 1) & 1431655765,
    e | t << 1
}
function HC(e) {
    var t = e
      , i = e;
    do
        (t.x < i.x || t.x === i.x && t.y < i.y) && (i = t),
        t = t.next;
    while (t !== e);
    return i
}
function oo(e, t, i, s, n, r, o, a) {
    return (n - o) * (t - a) >= (e - o) * (r - a) && (e - o) * (s - a) >= (i - o) * (t - a) && (i - o) * (r - a) >= (n - o) * (s - a)
}
function VC(e, t) {
    return e.next.i !== t.i && e.prev.i !== t.i && !zC(e, t) && (Da(e, t) && Da(t, e) && $C(e, t) && (Re(e.prev, e, t.prev) || Re(e, t.prev, t)) || rh(e, t) && Re(e.prev, e, e.next) > 0 && Re(t.prev, t, t.next) > 0)
}
function Re(e, t, i) {
    return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
}
function rh(e, t) {
    return e.x === t.x && e.y === t.y
}
function __(e, t, i, s) {
    var n = yl(Re(e, t, i))
      , r = yl(Re(e, t, s))
      , o = yl(Re(i, s, e))
      , a = yl(Re(i, s, t));
    return !!(n !== r && o !== a || n === 0 && _l(e, i, t) || r === 0 && _l(e, s, t) || o === 0 && _l(i, e, s) || a === 0 && _l(i, t, s))
}
function _l(e, t, i) {
    return t.x <= Math.max(e.x, i.x) && t.x >= Math.min(e.x, i.x) && t.y <= Math.max(e.y, i.y) && t.y >= Math.min(e.y, i.y)
}
function yl(e) {
    return e > 0 ? 1 : e < 0 ? -1 : 0
}
function zC(e, t) {
    var i = e;
    do {
        if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && __(i, i.next, e, t))
            return !0;
        i = i.next
    } while (i !== e);
    return !1
}
function Da(e, t) {
    return Re(e.prev, e, e.next) < 0 ? Re(e, t, e.next) >= 0 && Re(e, e.prev, t) >= 0 : Re(e, t, e.prev) < 0 || Re(e, e.next, t) < 0
}
function $C(e, t) {
    var i = e
      , s = !1
      , n = (e.x + t.x) / 2
      , r = (e.y + t.y) / 2;
    do
        i.y > r != i.next.y > r && i.next.y !== i.y && n < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (s = !s),
        i = i.next;
    while (i !== e);
    return s
}
function y_(e, t) {
    var i = new qu(e.i,e.x,e.y)
      , s = new qu(t.i,t.x,t.y)
      , n = e.next
      , r = t.prev;
    return e.next = t,
    t.prev = e,
    i.next = n,
    n.prev = i,
    s.next = i,
    i.prev = s,
    r.next = s,
    s.prev = r,
    s
}
function qm(e, t, i, s) {
    var n = new qu(e,t,i);
    return s ? (n.next = s.next,
    n.prev = s,
    s.next.prev = n,
    s.next = n) : (n.prev = n,
    n.next = n),
    n
}
function Na(e) {
    e.next.prev = e.prev,
    e.prev.next = e.next,
    e.prevZ && (e.prevZ.nextZ = e.nextZ),
    e.nextZ && (e.nextZ.prevZ = e.prevZ)
}
function qu(e, t, i) {
    this.i = e,
    this.x = t,
    this.y = i,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
nh.deviation = function(e, t, i, s) {
    var n = t && t.length
      , r = n ? t[0] * i : e.length
      , o = Math.abs(Ju(e, 0, r, i));
    if (n)
        for (var a = 0, l = t.length; a < l; a++) {
            var c = t[a] * i
              , h = a < l - 1 ? t[a + 1] * i : e.length;
            o -= Math.abs(Ju(e, c, h, i))
        }
    var u = 0;
    for (a = 0; a < s.length; a += 3) {
        var d = s[a] * i
          , f = s[a + 1] * i
          , p = s[a + 2] * i;
        u += Math.abs((e[d] - e[p]) * (e[f + 1] - e[d + 1]) - (e[d] - e[f]) * (e[p + 1] - e[d + 1]))
    }
    return o === 0 && u === 0 ? 0 : Math.abs((u - o) / o)
}
;
function Ju(e, t, i, s) {
    for (var n = 0, r = t, o = i - s; r < i; r += s)
        n += (e[o] - e[r]) * (e[r + 1] + e[o + 1]),
        o = r;
    return n
}
nh.flatten = function(e) {
    for (var t = e[0][0].length, i = {
        vertices: [],
        holes: [],
        dimensions: t
    }, s = 0, n = 0; n < e.length; n++) {
        for (var r = 0; r < e[n].length; r++)
            for (var o = 0; o < t; o++)
                i.vertices.push(e[n][r][o]);
        n > 0 && (s += e[n - 1].length,
        i.holes.push(s))
    }
    return i
}
;
var b_ = Nf.exports
  , Qu = {
    exports: {}
};
/*! https://mths.be/punycode v1.3.2 by @mathias */
(function(e, t) {
    (function(i) {
        var s = t && !t.nodeType && t
          , n = e && !e.nodeType && e
          , r = typeof Wh == "object" && Wh;
        (r.global === r || r.window === r || r.self === r) && (i = r);
        var o, a = 2147483647, l = 36, c = 1, h = 26, u = 38, d = 700, f = 72, p = 128, m = "-", g = /^xn--/, y = /[^\x20-\x7E]/, x = /[\x2E\u3002\uFF0E\uFF61]/g, v = {
            overflow: "Overflow: input needs wider integers to process",
            "not-basic": "Illegal input >= 0x80 (not a basic code point)",
            "invalid-input": "Invalid input"
        }, _ = l - c, C = Math.floor, k = String.fromCharCode, S;
        function T(ct) {
            throw RangeError(v[ct])
        }
        function L(ct, gt) {
            for (var xt = ct.length, It = []; xt--; )
                It[xt] = gt(ct[xt]);
            return It
        }
        function D(ct, gt) {
            var xt = ct.split("@")
              , It = "";
            xt.length > 1 && (It = xt[0] + "@",
            ct = xt[1]),
            ct = ct.replace(x, ".");
            var St = ct.split(".")
              , J = L(St, gt).join(".");
            return It + J
        }
        function O(ct) {
            for (var gt = [], xt = 0, It = ct.length, St, J; xt < It; )
                St = ct.charCodeAt(xt++),
                St >= 55296 && St <= 56319 && xt < It ? (J = ct.charCodeAt(xt++),
                (J & 64512) == 56320 ? gt.push(((St & 1023) << 10) + (J & 1023) + 65536) : (gt.push(St),
                xt--)) : gt.push(St);
            return gt
        }
        function K(ct) {
            return L(ct, function(gt) {
                var xt = "";
                return gt > 65535 && (gt -= 65536,
                xt += k(gt >>> 10 & 1023 | 55296),
                gt = 56320 | gt & 1023),
                xt += k(gt),
                xt
            }).join("")
        }
        function P(ct) {
            return ct - 48 < 10 ? ct - 22 : ct - 65 < 26 ? ct - 65 : ct - 97 < 26 ? ct - 97 : l
        }
        function N(ct, gt) {
            return ct + 22 + 75 * (ct < 26) - ((gt != 0) << 5)
        }
        function W(ct, gt, xt) {
            var It = 0;
            for (ct = xt ? C(ct / d) : ct >> 1,
            ct += C(ct / gt); ct > _ * h >> 1; It += l)
                ct = C(ct / _);
            return C(It + (_ + 1) * ct / (ct + u))
        }
        function V(ct) {
            var gt = [], xt = ct.length, It, St = 0, J = p, wt = f, Tt, Bt, kt, re, Xt, ce, E, M, F;
            for (Tt = ct.lastIndexOf(m),
            Tt < 0 && (Tt = 0),
            Bt = 0; Bt < Tt; ++Bt)
                ct.charCodeAt(Bt) >= 128 && T("not-basic"),
                gt.push(ct.charCodeAt(Bt));
            for (kt = Tt > 0 ? Tt + 1 : 0; kt < xt; ) {
                for (re = St,
                Xt = 1,
                ce = l; kt >= xt && T("invalid-input"),
                E = P(ct.charCodeAt(kt++)),
                (E >= l || E > C((a - St) / Xt)) && T("overflow"),
                St += E * Xt,
                M = ce <= wt ? c : ce >= wt + h ? h : ce - wt,
                !(E < M); ce += l)
                    F = l - M,
                    Xt > C(a / F) && T("overflow"),
                    Xt *= F;
                It = gt.length + 1,
                wt = W(St - re, It, re == 0),
                C(St / It) > a - J && T("overflow"),
                J += C(St / It),
                St %= It,
                gt.splice(St++, 0, J)
            }
            return K(gt)
        }
        function Q(ct) {
            var gt, xt, It, St, J, wt, Tt, Bt, kt, re, Xt, ce = [], E, M, F, $;
            for (ct = O(ct),
            E = ct.length,
            gt = p,
            xt = 0,
            J = f,
            wt = 0; wt < E; ++wt)
                Xt = ct[wt],
                Xt < 128 && ce.push(k(Xt));
            for (It = St = ce.length,
            St && ce.push(m); It < E; ) {
                for (Tt = a,
                wt = 0; wt < E; ++wt)
                    Xt = ct[wt],
                    Xt >= gt && Xt < Tt && (Tt = Xt);
                for (M = It + 1,
                Tt - gt > C((a - xt) / M) && T("overflow"),
                xt += (Tt - gt) * M,
                gt = Tt,
                wt = 0; wt < E; ++wt)
                    if (Xt = ct[wt],
                    Xt < gt && ++xt > a && T("overflow"),
                    Xt == gt) {
                        for (Bt = xt,
                        kt = l; re = kt <= J ? c : kt >= J + h ? h : kt - J,
                        !(Bt < re); kt += l)
                            $ = Bt - re,
                            F = l - re,
                            ce.push(k(N(re + $ % F, 0))),
                            Bt = C($ / F);
                        ce.push(k(N(Bt, 0))),
                        J = W(xt, M, It == St),
                        xt = 0,
                        ++It
                    }
                ++xt,
                ++gt
            }
            return ce.join("")
        }
        function pt(ct) {
            return D(ct, function(gt) {
                return g.test(gt) ? V(gt.slice(4).toLowerCase()) : gt
            })
        }
        function bt(ct) {
            return D(ct, function(gt) {
                return y.test(gt) ? "xn--" + Q(gt) : gt
            })
        }
        if (o = {
            version: "1.3.2",
            ucs2: {
                decode: O,
                encode: K
            },
            decode: V,
            encode: Q,
            toASCII: bt,
            toUnicode: pt
        },
        s && n)
            if (e.exports == s)
                n.exports = o;
            else
                for (S in o)
                    o.hasOwnProperty(S) && (s[S] = o[S]);
        else
            i.punycode = o
    }
    )(Wh)
}
)(Qu, Qu.exports);
var jC = {
    isString: function(e) {
        return typeof e == "string"
    },
    isObject: function(e) {
        return typeof e == "object" && e !== null
    },
    isNull: function(e) {
        return e === null
    },
    isNullOrUndefined: function(e) {
        return e == null
    }
}
  , Fa = {};
function WC(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
}
var XC = function(e, t, i, s) {
    t = t || "&",
    i = i || "=";
    var n = {};
    if (typeof e != "string" || e.length === 0)
        return n;
    var r = /\+/g;
    e = e.split(t);
    var o = 1e3;
    s && typeof s.maxKeys == "number" && (o = s.maxKeys);
    var a = e.length;
    o > 0 && a > o && (a = o);
    for (var l = 0; l < a; ++l) {
        var c = e[l].replace(r, "%20"), h = c.indexOf(i), u, d, f, p;
        h >= 0 ? (u = c.substr(0, h),
        d = c.substr(h + 1)) : (u = c,
        d = ""),
        f = decodeURIComponent(u),
        p = decodeURIComponent(d),
        WC(n, f) ? Array.isArray(n[f]) ? n[f].push(p) : n[f] = [n[f], p] : n[f] = p
    }
    return n
}
  , qo = function(e) {
    switch (typeof e) {
    case "string":
        return e;
    case "boolean":
        return e ? "true" : "false";
    case "number":
        return isFinite(e) ? e : "";
    default:
        return ""
    }
}
  , YC = function(e, t, i, s) {
    return t = t || "&",
    i = i || "=",
    e === null && (e = void 0),
    typeof e == "object" ? Object.keys(e).map(function(n) {
        var r = encodeURIComponent(qo(n)) + i;
        return Array.isArray(e[n]) ? e[n].map(function(o) {
            return r + encodeURIComponent(qo(o))
        }).join(t) : r + encodeURIComponent(qo(e[n]))
    }).join(t) : s ? encodeURIComponent(qo(s)) + i + encodeURIComponent(qo(e)) : ""
};
Fa.decode = Fa.parse = XC;
Fa.encode = Fa.stringify = YC;
var KC = Qu.exports
  , Cs = jC
  , ZC = oh
  , qC = l3
  , JC = a3;
function ls() {
    this.protocol = null,
    this.slashes = null,
    this.auth = null,
    this.host = null,
    this.port = null,
    this.hostname = null,
    this.hash = null,
    this.search = null,
    this.query = null,
    this.pathname = null,
    this.path = null,
    this.href = null
}
var QC = /^([a-z0-9.+-]+:)/i
  , t3 = /:[0-9]*$/
  , e3 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/
  , i3 = ["<", ">", '"', "`", " ", "\r", `
`, "	"]
  , s3 = ["{", "}", "|", "\\", "^", "`"].concat(i3)
  , td = ["'"].concat(s3)
  , Jm = ["%", "/", "?", ";", "#"].concat(td)
  , Qm = ["/", "?", "#"]
  , n3 = 255
  , tg = /^[+a-z0-9A-Z_-]{0,63}$/
  , r3 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/
  , o3 = {
    javascript: !0,
    "javascript:": !0
}
  , ed = {
    javascript: !0,
    "javascript:": !0
}
  , go = {
    http: !0,
    https: !0,
    ftp: !0,
    gopher: !0,
    file: !0,
    "http:": !0,
    "https:": !0,
    "ftp:": !0,
    "gopher:": !0,
    "file:": !0
}
  , id = Fa;
function oh(e, t, i) {
    if (e && Cs.isObject(e) && e instanceof ls)
        return e;
    var s = new ls;
    return s.parse(e, t, i),
    s
}
ls.prototype.parse = function(e, t, i) {
    if (!Cs.isString(e))
        throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
    var s = e.indexOf("?")
      , n = s !== -1 && s < e.indexOf("#") ? "?" : "#"
      , r = e.split(n)
      , o = /\\/g;
    r[0] = r[0].replace(o, "/"),
    e = r.join(n);
    var a = e;
    if (a = a.trim(),
    !i && e.split("#").length === 1) {
        var l = e3.exec(a);
        if (l)
            return this.path = a,
            this.href = a,
            this.pathname = l[1],
            l[2] ? (this.search = l[2],
            t ? this.query = id.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "",
            this.query = {}),
            this
    }
    var c = QC.exec(a);
    if (c) {
        c = c[0];
        var h = c.toLowerCase();
        this.protocol = h,
        a = a.substr(c.length)
    }
    if (i || c || a.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var u = a.substr(0, 2) === "//";
        u && !(c && ed[c]) && (a = a.substr(2),
        this.slashes = !0)
    }
    if (!ed[c] && (u || c && !go[c])) {
        for (var d = -1, f = 0; f < Qm.length; f++) {
            var p = a.indexOf(Qm[f]);
            p !== -1 && (d === -1 || p < d) && (d = p)
        }
        var m, g;
        d === -1 ? g = a.lastIndexOf("@") : g = a.lastIndexOf("@", d),
        g !== -1 && (m = a.slice(0, g),
        a = a.slice(g + 1),
        this.auth = decodeURIComponent(m)),
        d = -1;
        for (var f = 0; f < Jm.length; f++) {
            var p = a.indexOf(Jm[f]);
            p !== -1 && (d === -1 || p < d) && (d = p)
        }
        d === -1 && (d = a.length),
        this.host = a.slice(0, d),
        a = a.slice(d),
        this.parseHost(),
        this.hostname = this.hostname || "";
        var y = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!y)
            for (var x = this.hostname.split(/\./), f = 0, v = x.length; f < v; f++) {
                var _ = x[f];
                if (!!_ && !_.match(tg)) {
                    for (var C = "", k = 0, S = _.length; k < S; k++)
                        _.charCodeAt(k) > 127 ? C += "x" : C += _[k];
                    if (!C.match(tg)) {
                        var T = x.slice(0, f)
                          , L = x.slice(f + 1)
                          , D = _.match(r3);
                        D && (T.push(D[1]),
                        L.unshift(D[2])),
                        L.length && (a = "/" + L.join(".") + a),
                        this.hostname = T.join(".");
                        break
                    }
                }
            }
        this.hostname.length > n3 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(),
        y || (this.hostname = KC.toASCII(this.hostname));
        var O = this.port ? ":" + this.port : ""
          , K = this.hostname || "";
        this.host = K + O,
        this.href += this.host,
        y && (this.hostname = this.hostname.substr(1, this.hostname.length - 2),
        a[0] !== "/" && (a = "/" + a))
    }
    if (!o3[h])
        for (var f = 0, v = td.length; f < v; f++) {
            var P = td[f];
            if (a.indexOf(P) !== -1) {
                var N = encodeURIComponent(P);
                N === P && (N = escape(P)),
                a = a.split(P).join(N)
            }
        }
    var W = a.indexOf("#");
    W !== -1 && (this.hash = a.substr(W),
    a = a.slice(0, W));
    var V = a.indexOf("?");
    if (V !== -1 ? (this.search = a.substr(V),
    this.query = a.substr(V + 1),
    t && (this.query = id.parse(this.query)),
    a = a.slice(0, V)) : t && (this.search = "",
    this.query = {}),
    a && (this.pathname = a),
    go[h] && this.hostname && !this.pathname && (this.pathname = "/"),
    this.pathname || this.search) {
        var O = this.pathname || ""
          , Q = this.search || "";
        this.path = O + Q
    }
    return this.href = this.format(),
    this
}
;
function a3(e) {
    return Cs.isString(e) && (e = oh(e)),
    e instanceof ls ? e.format() : ls.prototype.format.call(e)
}
ls.prototype.format = function() {
    var e = this.auth || "";
    e && (e = encodeURIComponent(e),
    e = e.replace(/%3A/i, ":"),
    e += "@");
    var t = this.protocol || ""
      , i = this.pathname || ""
      , s = this.hash || ""
      , n = !1
      , r = "";
    this.host ? n = e + this.host : this.hostname && (n = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"),
    this.port && (n += ":" + this.port)),
    this.query && Cs.isObject(this.query) && Object.keys(this.query).length && (r = id.stringify(this.query));
    var o = this.search || r && "?" + r || "";
    return t && t.substr(-1) !== ":" && (t += ":"),
    this.slashes || (!t || go[t]) && n !== !1 ? (n = "//" + (n || ""),
    i && i.charAt(0) !== "/" && (i = "/" + i)) : n || (n = ""),
    s && s.charAt(0) !== "#" && (s = "#" + s),
    o && o.charAt(0) !== "?" && (o = "?" + o),
    i = i.replace(/[?#]/g, function(a) {
        return encodeURIComponent(a)
    }),
    o = o.replace("#", "%23"),
    t + n + i + o + s
}
;
function l3(e, t) {
    return oh(e, !1, !0).resolve(t)
}
ls.prototype.resolve = function(e) {
    return this.resolveObject(oh(e, !1, !0)).format()
}
;
ls.prototype.resolveObject = function(e) {
    if (Cs.isString(e)) {
        var t = new ls;
        t.parse(e, !1, !0),
        e = t
    }
    for (var i = new ls, s = Object.keys(this), n = 0; n < s.length; n++) {
        var r = s[n];
        i[r] = this[r]
    }
    if (i.hash = e.hash,
    e.href === "")
        return i.href = i.format(),
        i;
    if (e.slashes && !e.protocol) {
        for (var o = Object.keys(e), a = 0; a < o.length; a++) {
            var l = o[a];
            l !== "protocol" && (i[l] = e[l])
        }
        return go[i.protocol] && i.hostname && !i.pathname && (i.path = i.pathname = "/"),
        i.href = i.format(),
        i
    }
    if (e.protocol && e.protocol !== i.protocol) {
        if (!go[e.protocol]) {
            for (var c = Object.keys(e), h = 0; h < c.length; h++) {
                var u = c[h];
                i[u] = e[u]
            }
            return i.href = i.format(),
            i
        }
        if (i.protocol = e.protocol,
        !e.host && !ed[e.protocol]) {
            for (var v = (e.pathname || "").split("/"); v.length && !(e.host = v.shift()); )
                ;
            e.host || (e.host = ""),
            e.hostname || (e.hostname = ""),
            v[0] !== "" && v.unshift(""),
            v.length < 2 && v.unshift(""),
            i.pathname = v.join("/")
        } else
            i.pathname = e.pathname;
        if (i.search = e.search,
        i.query = e.query,
        i.host = e.host || "",
        i.auth = e.auth,
        i.hostname = e.hostname || e.host,
        i.port = e.port,
        i.pathname || i.search) {
            var d = i.pathname || ""
              , f = i.search || "";
            i.path = d + f
        }
        return i.slashes = i.slashes || e.slashes,
        i.href = i.format(),
        i
    }
    var p = i.pathname && i.pathname.charAt(0) === "/"
      , m = e.host || e.pathname && e.pathname.charAt(0) === "/"
      , g = m || p || i.host && e.pathname
      , y = g
      , x = i.pathname && i.pathname.split("/") || []
      , v = e.pathname && e.pathname.split("/") || []
      , _ = i.protocol && !go[i.protocol];
    if (_ && (i.hostname = "",
    i.port = null,
    i.host && (x[0] === "" ? x[0] = i.host : x.unshift(i.host)),
    i.host = "",
    e.protocol && (e.hostname = null,
    e.port = null,
    e.host && (v[0] === "" ? v[0] = e.host : v.unshift(e.host)),
    e.host = null),
    g = g && (v[0] === "" || x[0] === "")),
    m)
        i.host = e.host || e.host === "" ? e.host : i.host,
        i.hostname = e.hostname || e.hostname === "" ? e.hostname : i.hostname,
        i.search = e.search,
        i.query = e.query,
        x = v;
    else if (v.length)
        x || (x = []),
        x.pop(),
        x = x.concat(v),
        i.search = e.search,
        i.query = e.query;
    else if (!Cs.isNullOrUndefined(e.search)) {
        if (_) {
            i.hostname = i.host = x.shift();
            var C = i.host && i.host.indexOf("@") > 0 ? i.host.split("@") : !1;
            C && (i.auth = C.shift(),
            i.host = i.hostname = C.shift())
        }
        return i.search = e.search,
        i.query = e.query,
        (!Cs.isNull(i.pathname) || !Cs.isNull(i.search)) && (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")),
        i.href = i.format(),
        i
    }
    if (!x.length)
        return i.pathname = null,
        i.search ? i.path = "/" + i.search : i.path = null,
        i.href = i.format(),
        i;
    for (var k = x.slice(-1)[0], S = (i.host || e.host || x.length > 1) && (k === "." || k === "..") || k === "", T = 0, L = x.length; L >= 0; L--)
        k = x[L],
        k === "." ? x.splice(L, 1) : k === ".." ? (x.splice(L, 1),
        T++) : T && (x.splice(L, 1),
        T--);
    if (!g && !y)
        for (; T--; T)
            x.unshift("..");
    g && x[0] !== "" && (!x[0] || x[0].charAt(0) !== "/") && x.unshift(""),
    S && x.join("/").substr(-1) !== "/" && x.push("");
    var D = x[0] === "" || x[0] && x[0].charAt(0) === "/";
    if (_) {
        i.hostname = i.host = D ? "" : x.length ? x.shift() : "";
        var C = i.host && i.host.indexOf("@") > 0 ? i.host.split("@") : !1;
        C && (i.auth = C.shift(),
        i.host = i.hostname = C.shift())
    }
    return g = g || i.host && x.length,
    g && !D && x.unshift(""),
    x.length ? i.pathname = x.join("/") : (i.pathname = null,
    i.path = null),
    (!Cs.isNull(i.pathname) || !Cs.isNull(i.search)) && (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")),
    i.auth = e.auth || i.auth,
    i.slashes = i.slashes || e.slashes,
    i.href = i.format(),
    i
}
;
ls.prototype.parseHost = function() {
    var e = this.host
      , t = t3.exec(e);
    t && (t = t[0],
    t !== ":" && (this.port = t.substr(1)),
    e = e.substr(0, e.length - t.length)),
    e && (this.hostname = e)
}
;
const x_ = {
    parse: ZC,
    format: JC,
    resolve: qC
};
function Ki(e) {
    if (typeof e != "string")
        throw new TypeError(`Path must be a string. Received ${JSON.stringify(e)}`)
}
function Jo(e) {
    return e.split("?")[0].split("#")[0]
}
function c3(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}
function h3(e, t, i) {
    return e.replace(new RegExp(c3(t),"g"), i)
}
function u3(e, t) {
    let i = ""
      , s = 0
      , n = -1
      , r = 0
      , o = -1;
    for (let a = 0; a <= e.length; ++a) {
        if (a < e.length)
            o = e.charCodeAt(a);
        else {
            if (o === 47)
                break;
            o = 47
        }
        if (o === 47) {
            if (!(n === a - 1 || r === 1))
                if (n !== a - 1 && r === 2) {
                    if (i.length < 2 || s !== 2 || i.charCodeAt(i.length - 1) !== 46 || i.charCodeAt(i.length - 2) !== 46) {
                        if (i.length > 2) {
                            const l = i.lastIndexOf("/");
                            if (l !== i.length - 1) {
                                l === -1 ? (i = "",
                                s = 0) : (i = i.slice(0, l),
                                s = i.length - 1 - i.lastIndexOf("/")),
                                n = a,
                                r = 0;
                                continue
                            }
                        } else if (i.length === 2 || i.length === 1) {
                            i = "",
                            s = 0,
                            n = a,
                            r = 0;
                            continue
                        }
                    }
                    t && (i.length > 0 ? i += "/.." : i = "..",
                    s = 2)
                } else
                    i.length > 0 ? i += `/${e.slice(n + 1, a)}` : i = e.slice(n + 1, a),
                    s = a - n - 1;
            n = a,
            r = 0
        } else
            o === 46 && r !== -1 ? ++r : r = -1
    }
    return i
}
const Xe = {
    toPosix(e) {
        return h3(e, "\\", "/")
    },
    isUrl(e) {
        return /^https?:/.test(this.toPosix(e))
    },
    isDataUrl(e) {
        return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(e)
    },
    hasProtocol(e) {
        return /^[^/:]+:\//.test(this.toPosix(e))
    },
    getProtocol(e) {
        Ki(e),
        e = this.toPosix(e);
        let t = "";
        const i = /^file:\/\/\//.exec(e)
          , s = /^[^/:]+:\/\//.exec(e)
          , n = /^[^/:]+:\//.exec(e);
        if (i || s || n) {
            const r = i?.[0] || s?.[0] || n?.[0];
            t = r,
            e = e.slice(r.length)
        }
        return t
    },
    toAbsolute(e, t, i) {
        if (this.isDataUrl(e))
            return e;
        const s = Jo(this.toPosix(t ?? ft.ADAPTER.getBaseUrl()))
          , n = Jo(this.toPosix(i ?? this.rootname(s)));
        return Ki(e),
        e = this.toPosix(e),
        e.startsWith("/") ? Xe.join(n, e.slice(1)) : this.isAbsolute(e) ? e : this.join(s, e)
    },
    normalize(e) {
        if (e = this.toPosix(e),
        Ki(e),
        e.length === 0)
            return ".";
        let t = "";
        const i = e.startsWith("/");
        this.hasProtocol(e) && (t = this.rootname(e),
        e = e.slice(t.length));
        const s = e.endsWith("/");
        return e = u3(e, !1),
        e.length > 0 && s && (e += "/"),
        i ? `/${e}` : t + e
    },
    isAbsolute(e) {
        return Ki(e),
        e = this.toPosix(e),
        this.hasProtocol(e) ? !0 : e.startsWith("/")
    },
    join(...e) {
        if (e.length === 0)
            return ".";
        let t;
        for (let i = 0; i < e.length; ++i) {
            const s = e[i];
            if (Ki(s),
            s.length > 0)
                if (t === void 0)
                    t = s;
                else {
                    const n = e[i - 1] ?? "";
                    this.extname(n) ? t += `/../${s}` : t += `/${s}`
                }
        }
        return t === void 0 ? "." : this.normalize(t)
    },
    dirname(e) {
        if (Ki(e),
        e.length === 0)
            return ".";
        e = this.toPosix(e);
        let t = e.charCodeAt(0);
        const i = t === 47;
        let s = -1
          , n = !0;
        const r = this.getProtocol(e)
          , o = e;
        e = e.slice(r.length);
        for (let a = e.length - 1; a >= 1; --a)
            if (t = e.charCodeAt(a),
            t === 47) {
                if (!n) {
                    s = a;
                    break
                }
            } else
                n = !1;
        return s === -1 ? i ? "/" : this.isUrl(o) ? r + e : r : i && s === 1 ? "//" : r + e.slice(0, s)
    },
    rootname(e) {
        Ki(e),
        e = this.toPosix(e);
        let t = "";
        if (e.startsWith("/") ? t = "/" : t = this.getProtocol(e),
        this.isUrl(e)) {
            const i = e.indexOf("/", t.length);
            i !== -1 ? t = e.slice(0, i) : t = e,
            t.endsWith("/") || (t += "/")
        }
        return t
    },
    basename(e, t) {
        Ki(e),
        t && Ki(t),
        e = Jo(this.toPosix(e));
        let i = 0, s = -1, n = !0, r;
        if (t !== void 0 && t.length > 0 && t.length <= e.length) {
            if (t.length === e.length && t === e)
                return "";
            let o = t.length - 1
              , a = -1;
            for (r = e.length - 1; r >= 0; --r) {
                const l = e.charCodeAt(r);
                if (l === 47) {
                    if (!n) {
                        i = r + 1;
                        break
                    }
                } else
                    a === -1 && (n = !1,
                    a = r + 1),
                    o >= 0 && (l === t.charCodeAt(o) ? --o === -1 && (s = r) : (o = -1,
                    s = a))
            }
            return i === s ? s = a : s === -1 && (s = e.length),
            e.slice(i, s)
        }
        for (r = e.length - 1; r >= 0; --r)
            if (e.charCodeAt(r) === 47) {
                if (!n) {
                    i = r + 1;
                    break
                }
            } else
                s === -1 && (n = !1,
                s = r + 1);
        return s === -1 ? "" : e.slice(i, s)
    },
    extname(e) {
        Ki(e),
        e = Jo(this.toPosix(e));
        let t = -1
          , i = 0
          , s = -1
          , n = !0
          , r = 0;
        for (let o = e.length - 1; o >= 0; --o) {
            const a = e.charCodeAt(o);
            if (a === 47) {
                if (!n) {
                    i = o + 1;
                    break
                }
                continue
            }
            s === -1 && (n = !1,
            s = o + 1),
            a === 46 ? t === -1 ? t = o : r !== 1 && (r = 1) : t !== -1 && (r = -1)
        }
        return t === -1 || s === -1 || r === 0 || r === 1 && t === s - 1 && t === i + 1 ? "" : e.slice(t, s)
    },
    parse(e) {
        Ki(e);
        const t = {
            root: "",
            dir: "",
            base: "",
            ext: "",
            name: ""
        };
        if (e.length === 0)
            return t;
        e = Jo(this.toPosix(e));
        let i = e.charCodeAt(0);
        const s = this.isAbsolute(e);
        let n;
        t.root = this.rootname(e),
        s || this.hasProtocol(e) ? n = 1 : n = 0;
        let r = -1
          , o = 0
          , a = -1
          , l = !0
          , c = e.length - 1
          , h = 0;
        for (; c >= n; --c) {
            if (i = e.charCodeAt(c),
            i === 47) {
                if (!l) {
                    o = c + 1;
                    break
                }
                continue
            }
            a === -1 && (l = !1,
            a = c + 1),
            i === 46 ? r === -1 ? r = c : h !== 1 && (h = 1) : r !== -1 && (h = -1)
        }
        return r === -1 || a === -1 || h === 0 || h === 1 && r === a - 1 && r === o + 1 ? a !== -1 && (o === 0 && s ? t.base = t.name = e.slice(1, a) : t.base = t.name = e.slice(o, a)) : (o === 0 && s ? (t.name = e.slice(1, r),
        t.base = e.slice(1, a)) : (t.name = e.slice(o, r),
        t.base = e.slice(o, a)),
        t.ext = e.slice(r, a)),
        t.dir = this.dirname(e),
        t
    },
    sep: "/",
    delimiter: ":"
}
  , eg = {};
function Qt(e, t, i=3) {
    if (eg[t])
        return;
    let s = new Error().stack;
    typeof s > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${e}`) : (s = s.split(`
`).splice(i).join(`
`),
    console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}
Deprecated since v${e}`),
    console.warn(s),
    console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${e}`),
    console.warn(s))),
    eg[t] = !0
}
function d3() {
    Qt("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello")
}
function f3() {
    Qt("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`)
}
let Xh;
function w_() {
    return typeof Xh > "u" && (Xh = function() {
        const t = {
            stencil: !0,
            failIfMajorPerformanceCaveat: ft.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
        };
        try {
            if (!ft.ADAPTER.getWebGLRenderingContext())
                return !1;
            const i = ft.ADAPTER.createCanvas();
            let s = i.getContext("webgl", t) || i.getContext("experimental-webgl", t);
            const n = !!s?.getContextAttributes()?.stencil;
            if (s) {
                const r = s.getExtension("WEBGL_lose_context");
                r && r.loseContext()
            }
            return s = null,
            n
        } catch {
            return !1
        }
    }()),
    Xh
}
var p3 = "#f0f8ff"
  , m3 = "#faebd7"
  , g3 = "#00ffff"
  , v3 = "#7fffd4"
  , _3 = "#f0ffff"
  , y3 = "#f5f5dc"
  , b3 = "#ffe4c4"
  , x3 = "#000000"
  , w3 = "#ffebcd"
  , T3 = "#0000ff"
  , E3 = "#8a2be2"
  , S3 = "#a52a2a"
  , C3 = "#deb887"
  , A3 = "#5f9ea0"
  , I3 = "#7fff00"
  , M3 = "#d2691e"
  , R3 = "#ff7f50"
  , k3 = "#6495ed"
  , P3 = "#fff8dc"
  , L3 = "#dc143c"
  , O3 = "#00ffff"
  , D3 = "#00008b"
  , N3 = "#008b8b"
  , F3 = "#b8860b"
  , B3 = "#a9a9a9"
  , U3 = "#006400"
  , G3 = "#a9a9a9"
  , H3 = "#bdb76b"
  , V3 = "#8b008b"
  , z3 = "#556b2f"
  , $3 = "#ff8c00"
  , j3 = "#9932cc"
  , W3 = "#8b0000"
  , X3 = "#e9967a"
  , Y3 = "#8fbc8f"
  , K3 = "#483d8b"
  , Z3 = "#2f4f4f"
  , q3 = "#2f4f4f"
  , J3 = "#00ced1"
  , Q3 = "#9400d3"
  , tA = "#ff1493"
  , eA = "#00bfff"
  , iA = "#696969"
  , sA = "#696969"
  , nA = "#1e90ff"
  , rA = "#b22222"
  , oA = "#fffaf0"
  , aA = "#228b22"
  , lA = "#ff00ff"
  , cA = "#dcdcdc"
  , hA = "#f8f8ff"
  , uA = "#daa520"
  , dA = "#ffd700"
  , fA = "#808080"
  , pA = "#008000"
  , mA = "#adff2f"
  , gA = "#808080"
  , vA = "#f0fff0"
  , _A = "#ff69b4"
  , yA = "#cd5c5c"
  , bA = "#4b0082"
  , xA = "#fffff0"
  , wA = "#f0e68c"
  , TA = "#fff0f5"
  , EA = "#e6e6fa"
  , SA = "#7cfc00"
  , CA = "#fffacd"
  , AA = "#add8e6"
  , IA = "#f08080"
  , MA = "#e0ffff"
  , RA = "#fafad2"
  , kA = "#d3d3d3"
  , PA = "#90ee90"
  , LA = "#d3d3d3"
  , OA = "#ffb6c1"
  , DA = "#ffa07a"
  , NA = "#20b2aa"
  , FA = "#87cefa"
  , BA = "#778899"
  , UA = "#778899"
  , GA = "#b0c4de"
  , HA = "#ffffe0"
  , VA = "#00ff00"
  , zA = "#32cd32"
  , $A = "#faf0e6"
  , jA = "#ff00ff"
  , WA = "#800000"
  , XA = "#66cdaa"
  , YA = "#0000cd"
  , KA = "#ba55d3"
  , ZA = "#9370db"
  , qA = "#3cb371"
  , JA = "#7b68ee"
  , QA = "#00fa9a"
  , t5 = "#48d1cc"
  , e5 = "#c71585"
  , i5 = "#191970"
  , s5 = "#f5fffa"
  , n5 = "#ffe4e1"
  , r5 = "#ffe4b5"
  , o5 = "#ffdead"
  , a5 = "#000080"
  , l5 = "#fdf5e6"
  , c5 = "#808000"
  , h5 = "#6b8e23"
  , u5 = "#ffa500"
  , d5 = "#ff4500"
  , f5 = "#da70d6"
  , p5 = "#eee8aa"
  , m5 = "#98fb98"
  , g5 = "#afeeee"
  , v5 = "#db7093"
  , _5 = "#ffefd5"
  , y5 = "#ffdab9"
  , b5 = "#cd853f"
  , x5 = "#ffc0cb"
  , w5 = "#dda0dd"
  , T5 = "#b0e0e6"
  , E5 = "#800080"
  , S5 = "#663399"
  , C5 = "#ff0000"
  , A5 = "#bc8f8f"
  , I5 = "#4169e1"
  , M5 = "#8b4513"
  , R5 = "#fa8072"
  , k5 = "#f4a460"
  , P5 = "#2e8b57"
  , L5 = "#fff5ee"
  , O5 = "#a0522d"
  , D5 = "#c0c0c0"
  , N5 = "#87ceeb"
  , F5 = "#6a5acd"
  , B5 = "#708090"
  , U5 = "#708090"
  , G5 = "#fffafa"
  , H5 = "#00ff7f"
  , V5 = "#4682b4"
  , z5 = "#d2b48c"
  , $5 = "#008080"
  , j5 = "#d8bfd8"
  , W5 = "#ff6347"
  , X5 = "#40e0d0"
  , Y5 = "#ee82ee"
  , K5 = "#f5deb3"
  , Z5 = "#ffffff"
  , q5 = "#f5f5f5"
  , J5 = "#ffff00"
  , Q5 = "#9acd32"
  , t4 = {
    aliceblue: p3,
    antiquewhite: m3,
    aqua: g3,
    aquamarine: v3,
    azure: _3,
    beige: y3,
    bisque: b3,
    black: x3,
    blanchedalmond: w3,
    blue: T3,
    blueviolet: E3,
    brown: S3,
    burlywood: C3,
    cadetblue: A3,
    chartreuse: I3,
    chocolate: M3,
    coral: R3,
    cornflowerblue: k3,
    cornsilk: P3,
    crimson: L3,
    cyan: O3,
    darkblue: D3,
    darkcyan: N3,
    darkgoldenrod: F3,
    darkgray: B3,
    darkgreen: U3,
    darkgrey: G3,
    darkkhaki: H3,
    darkmagenta: V3,
    darkolivegreen: z3,
    darkorange: $3,
    darkorchid: j3,
    darkred: W3,
    darksalmon: X3,
    darkseagreen: Y3,
    darkslateblue: K3,
    darkslategray: Z3,
    darkslategrey: q3,
    darkturquoise: J3,
    darkviolet: Q3,
    deeppink: tA,
    deepskyblue: eA,
    dimgray: iA,
    dimgrey: sA,
    dodgerblue: nA,
    firebrick: rA,
    floralwhite: oA,
    forestgreen: aA,
    fuchsia: lA,
    gainsboro: cA,
    ghostwhite: hA,
    goldenrod: uA,
    gold: dA,
    gray: fA,
    green: pA,
    greenyellow: mA,
    grey: gA,
    honeydew: vA,
    hotpink: _A,
    indianred: yA,
    indigo: bA,
    ivory: xA,
    khaki: wA,
    lavenderblush: TA,
    lavender: EA,
    lawngreen: SA,
    lemonchiffon: CA,
    lightblue: AA,
    lightcoral: IA,
    lightcyan: MA,
    lightgoldenrodyellow: RA,
    lightgray: kA,
    lightgreen: PA,
    lightgrey: LA,
    lightpink: OA,
    lightsalmon: DA,
    lightseagreen: NA,
    lightskyblue: FA,
    lightslategray: BA,
    lightslategrey: UA,
    lightsteelblue: GA,
    lightyellow: HA,
    lime: VA,
    limegreen: zA,
    linen: $A,
    magenta: jA,
    maroon: WA,
    mediumaquamarine: XA,
    mediumblue: YA,
    mediumorchid: KA,
    mediumpurple: ZA,
    mediumseagreen: qA,
    mediumslateblue: JA,
    mediumspringgreen: QA,
    mediumturquoise: t5,
    mediumvioletred: e5,
    midnightblue: i5,
    mintcream: s5,
    mistyrose: n5,
    moccasin: r5,
    navajowhite: o5,
    navy: a5,
    oldlace: l5,
    olive: c5,
    olivedrab: h5,
    orange: u5,
    orangered: d5,
    orchid: f5,
    palegoldenrod: p5,
    palegreen: m5,
    paleturquoise: g5,
    palevioletred: v5,
    papayawhip: _5,
    peachpuff: y5,
    peru: b5,
    pink: x5,
    plum: w5,
    powderblue: T5,
    purple: E5,
    rebeccapurple: S5,
    red: C5,
    rosybrown: A5,
    royalblue: I5,
    saddlebrown: M5,
    salmon: R5,
    sandybrown: k5,
    seagreen: P5,
    seashell: L5,
    sienna: O5,
    silver: D5,
    skyblue: N5,
    slateblue: F5,
    slategray: B5,
    slategrey: U5,
    snow: G5,
    springgreen: H5,
    steelblue: V5,
    tan: z5,
    teal: $5,
    thistle: j5,
    tomato: W5,
    turquoise: X5,
    violet: Y5,
    wheat: K5,
    white: Z5,
    whitesmoke: q5,
    yellow: J5,
    yellowgreen: Q5
};
function tn(e, t=[]) {
    return t[0] = (e >> 16 & 255) / 255,
    t[1] = (e >> 8 & 255) / 255,
    t[2] = (e & 255) / 255,
    t
}
function ah(e) {
    let t = e.toString(16);
    return t = "000000".substring(0, 6 - t.length) + t,
    `#${t}`
}
function lh(e) {
    if (typeof e == "string" && (e = t4[e.toLowerCase()] || e,
    e[0] === "#" && (e = e.slice(1)),
    e.length === 3)) {
        const [t,i,s] = e;
        e = t + t + i + i + s + s
    }
    return parseInt(e, 16)
}
function Ff(e) {
    return (e[0] * 255 << 16) + (e[1] * 255 << 8) + (e[2] * 255 | 0)
}
function e4() {
    const e = []
      , t = [];
    for (let s = 0; s < 32; s++)
        e[s] = s,
        t[s] = s;
    e[j.NORMAL_NPM] = j.NORMAL,
    e[j.ADD_NPM] = j.ADD,
    e[j.SCREEN_NPM] = j.SCREEN,
    t[j.NORMAL] = j.NORMAL_NPM,
    t[j.ADD] = j.ADD_NPM,
    t[j.SCREEN] = j.SCREEN_NPM;
    const i = [];
    return i.push(t),
    i.push(e),
    i
}
const Bf = e4();
function Uf(e, t) {
    return Bf[t ? 1 : 0][e]
}
function T_(e, t, i, s) {
    return i = i || new Float32Array(4),
    s || s === void 0 ? (i[0] = e[0] * t,
    i[1] = e[1] * t,
    i[2] = e[2] * t) : (i[0] = e[0],
    i[1] = e[1],
    i[2] = e[2]),
    i[3] = t,
    i
}
function ch(e, t) {
    if (t === 1)
        return (t * 255 << 24) + e;
    if (t === 0)
        return 0;
    let i = e >> 16 & 255
      , s = e >> 8 & 255
      , n = e & 255;
    return i = i * t + .5 | 0,
    s = s * t + .5 | 0,
    n = n * t + .5 | 0,
    (t * 255 << 24) + (i << 16) + (s << 8) + n
}
function Gf(e, t, i, s) {
    return i = i || new Float32Array(4),
    i[0] = (e >> 16 & 255) / 255,
    i[1] = (e >> 8 & 255) / 255,
    i[2] = (e & 255) / 255,
    (s || s === void 0) && (i[0] *= t,
    i[1] *= t,
    i[2] *= t),
    i[3] = t,
    i
}
const E_ = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;
function S_(e, t=null) {
    const i = e * 6;
    if (t = t || new Uint16Array(i),
    t.length !== i)
        throw new Error(`Out buffer length is incorrect, got ${t.length} and expected ${i}`);
    for (let s = 0, n = 0; s < i; s += 6,
    n += 4)
        t[s + 0] = n + 0,
        t[s + 1] = n + 1,
        t[s + 2] = n + 2,
        t[s + 3] = n + 0,
        t[s + 4] = n + 2,
        t[s + 5] = n + 3;
    return t
}
function hh(e) {
    if (e.BYTES_PER_ELEMENT === 4)
        return e instanceof Float32Array ? "Float32Array" : e instanceof Uint32Array ? "Uint32Array" : "Int32Array";
    if (e.BYTES_PER_ELEMENT === 2) {
        if (e instanceof Uint16Array)
            return "Uint16Array"
    } else if (e.BYTES_PER_ELEMENT === 1 && e instanceof Uint8Array)
        return "Uint8Array";
    return null
}
const i4 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
};
function s4(e, t) {
    let i = 0
      , s = 0;
    const n = {};
    for (let l = 0; l < e.length; l++)
        s += t[l],
        i += e[l].length;
    const r = new ArrayBuffer(i * 4);
    let o = null
      , a = 0;
    for (let l = 0; l < e.length; l++) {
        const c = t[l]
          , h = e[l]
          , u = hh(h);
        n[u] || (n[u] = new i4[u](r)),
        o = n[u];
        for (let d = 0; d < h.length; d++) {
            const f = (d / c | 0) * s + a
              , p = d % c;
            o[f + p] = h[d]
        }
        a += c
    }
    return new Float32Array(r)
}
function Ba(e) {
    return e += e === 0 ? 1 : 0,
    --e,
    e |= e >>> 1,
    e |= e >>> 2,
    e |= e >>> 4,
    e |= e >>> 8,
    e |= e >>> 16,
    e + 1
}
function sd(e) {
    return !(e & e - 1) && !!e
}
function nd(e) {
    let t = (e > 65535 ? 1 : 0) << 4;
    e >>>= t;
    let i = (e > 255 ? 1 : 0) << 3;
    return e >>>= i,
    t |= i,
    i = (e > 15 ? 1 : 0) << 2,
    e >>>= i,
    t |= i,
    i = (e > 3 ? 1 : 0) << 1,
    e >>>= i,
    t |= i,
    t | e >> 1
}
function wr(e, t, i) {
    const s = e.length;
    let n;
    if (t >= s || i === 0)
        return;
    i = t + i > s ? s - t : i;
    const r = s - i;
    for (n = t; n < r; ++n)
        e[n] = e[n + i];
    e.length = r
}
function rr(e) {
    return e === 0 ? 0 : e < 0 ? -1 : 1
}
let n4 = 0;
function Ln() {
    return ++n4
}
const C_ = class {
    constructor(e, t, i, s) {
        this.left = e,
        this.top = t,
        this.right = i,
        this.bottom = s
    }
    get width() {
        return this.right - this.left
    }
    get height() {
        return this.bottom - this.top
    }
    isEmpty() {
        return this.left === this.right || this.top === this.bottom
    }
}
;
let xc = C_;
xc.EMPTY = new C_(0,0,0,0);
const rd = {}
  , ai = Object.create(null)
  , mi = Object.create(null);
function r4() {
    let e;
    for (e in ai)
        ai[e].destroy();
    for (e in mi)
        mi[e].destroy()
}
function o4() {
    let e;
    for (e in ai)
        delete ai[e];
    for (e in mi)
        delete mi[e]
}
class Po {
    constructor(t, i, s) {
        this._canvas = ft.ADAPTER.createCanvas(),
        this._context = this._canvas.getContext("2d"),
        this.resolution = s || ft.RESOLUTION,
        this.resize(t, i)
    }
    clear() {
        this._checkDestroyed(),
        this._context.setTransform(1, 0, 0, 1, 0, 0),
        this._context.clearRect(0, 0, this._canvas.width, this._canvas.height)
    }
    resize(t, i) {
        this._checkDestroyed(),
        this._canvas.width = Math.round(t * this.resolution),
        this._canvas.height = Math.round(i * this.resolution)
    }
    destroy() {
        this._context = null,
        this._canvas = null
    }
    get width() {
        return this._checkDestroyed(),
        this._canvas.width
    }
    set width(t) {
        this._checkDestroyed(),
        this._canvas.width = Math.round(t)
    }
    get height() {
        return this._checkDestroyed(),
        this._canvas.height
    }
    set height(t) {
        this._checkDestroyed(),
        this._canvas.height = Math.round(t)
    }
    get canvas() {
        return this._checkDestroyed(),
        this._canvas
    }
    get context() {
        return this._checkDestroyed(),
        this._context
    }
    _checkDestroyed() {
        if (this._canvas === null)
            throw new TypeError("The CanvasRenderTarget has already been destroyed")
    }
}
function ig(e, t, i) {
    for (let s = 0, n = 4 * i * t; s < t; ++s,
    n += 4)
        if (e[n + 3] !== 0)
            return !1;
    return !0
}
function sg(e, t, i, s, n) {
    const r = 4 * t;
    for (let o = s, a = s * r + 4 * i; o <= n; ++o,
    a += r)
        if (e[a + 3] !== 0)
            return !1;
    return !0
}
function A_(e) {
    const {width: t, height: i} = e
      , s = e.getContext("2d", {
        willReadFrequently: !0
    });
    if (s === null)
        throw new TypeError("Failed to get canvas 2D context");
    const r = s.getImageData(0, 0, t, i).data;
    let o = 0
      , a = 0
      , l = t - 1
      , c = i - 1;
    for (; a < i && ig(r, t, a); )
        ++a;
    if (a === i)
        return xc.EMPTY;
    for (; ig(r, t, c); )
        --c;
    for (; sg(r, t, o, a, c); )
        ++o;
    for (; sg(r, t, l, a, c); )
        --l;
    return ++l,
    ++c,
    new xc(o,a,l,c)
}
function I_(e) {
    const t = A_(e)
      , {width: i, height: s} = t;
    let n = null;
    if (!t.isEmpty()) {
        const r = e.getContext("2d");
        if (r === null)
            throw new TypeError("Failed to get canvas 2D context");
        n = r.getImageData(t.left, t.top, i, s)
    }
    return {
        width: i,
        height: s,
        data: n
    }
}
function a4(e) {
    const t = E_.exec(e);
    if (t)
        return {
            mediaType: t[1] ? t[1].toLowerCase() : void 0,
            subType: t[2] ? t[2].toLowerCase() : void 0,
            charset: t[3] ? t[3].toLowerCase() : void 0,
            encoding: t[4] ? t[4].toLowerCase() : void 0,
            data: t[5]
        }
}
let bl;
function M_(e, t=globalThis.location) {
    if (e.startsWith("data:"))
        return "";
    t = t || globalThis.location,
    bl || (bl = document.createElement("a")),
    bl.href = e;
    const i = x_.parse(bl.href)
      , s = !i.port && t.port === "" || i.port === t.port;
    return i.hostname !== t.hostname || !s || i.protocol !== t.protocol ? "anonymous" : ""
}
function en(e, t=1) {
    const i = ft.RETINA_PREFIX?.exec(e);
    return i ? parseFloat(i[1]) : t
}
var l4 = Object.freeze(Object.defineProperty({
    __proto__: null,
    isMobile: Is,
    EventEmitter: $o,
    earcut: b_,
    url: x_,
    path: Xe,
    sayHello: f3,
    skipHello: d3,
    isWebGLSupported: w_,
    hex2rgb: tn,
    hex2string: ah,
    rgb2hex: Ff,
    string2hex: lh,
    correctBlendMode: Uf,
    premultiplyBlendMode: Bf,
    premultiplyRgba: T_,
    premultiplyTint: ch,
    premultiplyTintToRgba: Gf,
    DATA_URI: E_,
    createIndicesForQuads: S_,
    getBufferType: hh,
    interleaveTypedArrays: s4,
    isPow2: sd,
    log2: nd,
    nextPow2: Ba,
    removeItems: wr,
    sign: rr,
    uid: Ln,
    deprecation: Qt,
    BoundingBox: xc,
    BaseTextureCache: mi,
    ProgramCache: rd,
    TextureCache: ai,
    clearTextureCache: o4,
    destroyTextureCache: r4,
    CanvasRenderTarget: Po,
    getCanvasBoundingBox: A_,
    trimCanvas: I_,
    decomposeDataUri: a4,
    determineCrossOrigin: M_,
    getResolutionOfUrl: en
}, Symbol.toStringTag, {
    value: "Module"
}))
  , lt = (e=>(e.Renderer = "renderer",
e.Application = "application",
e.RendererSystem = "renderer-webgl-system",
e.RendererPlugin = "renderer-webgl-plugin",
e.CanvasRendererSystem = "renderer-canvas-system",
e.CanvasRendererPlugin = "renderer-canvas-plugin",
e.Asset = "asset",
e.LoadParser = "load-parser",
e.ResolveParser = "resolve-parser",
e.CacheParser = "cache-parser",
e.DetectionParser = "detection-parser",
e))(lt || {});
const od = e=>{
    if (typeof e == "function" || typeof e == "object" && e.extension) {
        if (!e.extension)
            throw new Error("Extension class must have an extension object");
        e = {
            ...typeof e.extension != "object" ? {
                type: e.extension
            } : e.extension,
            ref: e
        }
    }
    if (typeof e == "object")
        e = {
            ...e
        };
    else
        throw new Error("Invalid extension type");
    return typeof e.type == "string" && (e.type = [e.type]),
    e
}
  , ng = (e,t)=>od(e).priority ?? t
  , vt = {
    _addHandlers: {},
    _removeHandlers: {},
    _queue: {},
    remove(...e) {
        return e.map(od).forEach(t=>{
            t.type.forEach(i=>this._removeHandlers[i]?.(t))
        }
        ),
        this
    },
    add(...e) {
        return e.map(od).forEach(t=>{
            t.type.forEach(i=>{
                const s = this._addHandlers
                  , n = this._queue;
                s[i] ? s[i](t) : (n[i] = n[i] || [],
                n[i].push(t))
            }
            )
        }
        ),
        this
    },
    handle(e, t, i) {
        const s = this._addHandlers
          , n = this._removeHandlers;
        if (s[e] || n[e])
            throw new Error(`Extension type ${e} already has a handler`);
        s[e] = t,
        n[e] = i;
        const r = this._queue;
        return r[e] && (r[e].forEach(o=>t(o)),
        delete r[e]),
        this
    },
    handleByMap(e, t) {
        return this.handle(e, i=>{
            t[i.name] = i.ref
        }
        , i=>{
            delete t[i.name]
        }
        )
    },
    handleByList(e, t, i=-1) {
        return this.handle(e, s=>{
            t.includes(s.ref) || (t.push(s.ref),
            t.sort((n,r)=>ng(r, i) - ng(n, i)))
        }
        , s=>{
            const n = t.indexOf(s.ref);
            n !== -1 && t.splice(n, 1)
        }
        )
    }
};
class ad {
    constructor(t) {
        typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t,
        this.uint32View = new Uint32Array(this.rawBinaryData),
        this.float32View = new Float32Array(this.rawBinaryData)
    }
    get int8View() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)),
        this._int8View
    }
    get uint8View() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)),
        this._uint8View
    }
    get int16View() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)),
        this._int16View
    }
    get uint16View() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)),
        this._uint16View
    }
    get int32View() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)),
        this._int32View
    }
    view(t) {
        return this[`${t}View`]
    }
    destroy() {
        this.rawBinaryData = null,
        this._int8View = null,
        this._uint8View = null,
        this._int16View = null,
        this._uint16View = null,
        this._int32View = null,
        this.uint32View = null,
        this.float32View = null
    }
    static sizeOf(t) {
        switch (t) {
        case "int8":
        case "uint8":
            return 1;
        case "int16":
        case "uint16":
            return 2;
        case "int32":
        case "uint32":
        case "float32":
            return 4;
        default:
            throw new Error(`${t} isn't a valid view type`)
        }
    }
}
const c4 = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);
function h4(e) {
    let t = "";
    for (let i = 0; i < e; ++i)
        i > 0 && (t += `
else `),
        i < e - 1 && (t += `if(test == ${i}.0){}`);
    return t
}
function u4(e, t) {
    if (e === 0)
        throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const i = t.createShader(t.FRAGMENT_SHADER);
    for (; ; ) {
        const s = c4.replace(/%forloop%/gi, h4(e));
        if (t.shaderSource(i, s),
        t.compileShader(i),
        !t.getShaderParameter(i, t.COMPILE_STATUS))
            e = e / 2 | 0;
        else
            break
    }
    return e
}
const Yh = 0
  , Kh = 1
  , Zh = 2
  , qh = 3
  , Jh = 4
  , Qh = 5;
class rn {
    constructor() {
        this.data = 0,
        this.blendMode = j.NORMAL,
        this.polygonOffset = 0,
        this.blend = !0,
        this.depthMask = !0
    }
    get blend() {
        return !!(this.data & 1 << Yh)
    }
    set blend(t) {
        !!(this.data & 1 << Yh) !== t && (this.data ^= 1 << Yh)
    }
    get offsets() {
        return !!(this.data & 1 << Kh)
    }
    set offsets(t) {
        !!(this.data & 1 << Kh) !== t && (this.data ^= 1 << Kh)
    }
    get culling() {
        return !!(this.data & 1 << Zh)
    }
    set culling(t) {
        !!(this.data & 1 << Zh) !== t && (this.data ^= 1 << Zh)
    }
    get depthTest() {
        return !!(this.data & 1 << qh)
    }
    set depthTest(t) {
        !!(this.data & 1 << qh) !== t && (this.data ^= 1 << qh)
    }
    get depthMask() {
        return !!(this.data & 1 << Qh)
    }
    set depthMask(t) {
        !!(this.data & 1 << Qh) !== t && (this.data ^= 1 << Qh)
    }
    get clockwiseFrontFace() {
        return !!(this.data & 1 << Jh)
    }
    set clockwiseFrontFace(t) {
        !!(this.data & 1 << Jh) !== t && (this.data ^= 1 << Jh)
    }
    get blendMode() {
        return this._blendMode
    }
    set blendMode(t) {
        this.blend = t !== j.NONE,
        this._blendMode = t
    }
    get polygonOffset() {
        return this._polygonOffset
    }
    set polygonOffset(t) {
        this.offsets = !!t,
        this._polygonOffset = t
    }
    toString() {
        return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
    }
    static for2d() {
        const t = new rn;
        return t.depthTest = !1,
        t.blend = !0,
        t
    }
}
const ld = [];
function R_(e, t) {
    if (!e)
        return null;
    let i = "";
    if (typeof e == "string") {
        const s = /\.(\w{3,4})(?:$|\?|#)/i.exec(e);
        s && (i = s[1].toLowerCase())
    }
    for (let s = ld.length - 1; s >= 0; --s) {
        const n = ld[s];
        if (n.test && n.test(e, i))
            return new n(e,t)
    }
    throw new Error("Unrecognized source type to auto-detect Resource")
}
class cs {
    constructor(t) {
        this.items = [],
        this._name = t,
        this._aliasCount = 0
    }
    emit(t, i, s, n, r, o, a, l) {
        if (arguments.length > 8)
            throw new Error("max arguments reached");
        const {name: c, items: h} = this;
        this._aliasCount++;
        for (let u = 0, d = h.length; u < d; u++)
            h[u][c](t, i, s, n, r, o, a, l);
        return h === this.items && this._aliasCount--,
        this
    }
    ensureNonAliasedItems() {
        this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0,
        this.items = this.items.slice(0))
    }
    add(t) {
        return t[this._name] && (this.ensureNonAliasedItems(),
        this.remove(t),
        this.items.push(t)),
        this
    }
    remove(t) {
        const i = this.items.indexOf(t);
        return i !== -1 && (this.ensureNonAliasedItems(),
        this.items.splice(i, 1)),
        this
    }
    contains(t) {
        return this.items.includes(t)
    }
    removeAll() {
        return this.ensureNonAliasedItems(),
        this.items.length = 0,
        this
    }
    destroy() {
        this.removeAll(),
        this.items = null,
        this._name = null
    }
    get empty() {
        return this.items.length === 0
    }
    get name() {
        return this._name
    }
}
Object.defineProperties(cs.prototype, {
    dispatch: {
        value: cs.prototype.emit
    },
    run: {
        value: cs.prototype.emit
    }
});
class Ua {
    constructor(t=0, i=0) {
        this._width = t,
        this._height = i,
        this.destroyed = !1,
        this.internal = !1,
        this.onResize = new cs("setRealSize"),
        this.onUpdate = new cs("update"),
        this.onError = new cs("onError")
    }
    bind(t) {
        this.onResize.add(t),
        this.onUpdate.add(t),
        this.onError.add(t),
        (this._width || this._height) && this.onResize.emit(this._width, this._height)
    }
    unbind(t) {
        this.onResize.remove(t),
        this.onUpdate.remove(t),
        this.onError.remove(t)
    }
    resize(t, i) {
        (t !== this._width || i !== this._height) && (this._width = t,
        this._height = i,
        this.onResize.emit(t, i))
    }
    get valid() {
        return !!this._width && !!this._height
    }
    update() {
        this.destroyed || this.onUpdate.emit()
    }
    load() {
        return Promise.resolve(this)
    }
    get width() {
        return this._width
    }
    get height() {
        return this._height
    }
    style(t, i, s) {
        return !1
    }
    dispose() {}
    destroy() {
        this.destroyed || (this.destroyed = !0,
        this.dispose(),
        this.onError.removeAll(),
        this.onError = null,
        this.onResize.removeAll(),
        this.onResize = null,
        this.onUpdate.removeAll(),
        this.onUpdate = null)
    }
    static test(t, i) {
        return !1
    }
}
class qa extends Ua {
    constructor(t, i) {
        const {width: s, height: n} = i || {};
        if (!s || !n)
            throw new Error("BufferResource width or height invalid");
        super(s, n),
        this.data = t
    }
    upload(t, i, s) {
        const n = t.gl;
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === _s.UNPACK);
        const r = i.realWidth
          , o = i.realHeight;
        return s.width === r && s.height === o ? n.texSubImage2D(i.target, 0, 0, 0, r, o, i.format, s.type, this.data) : (s.width = r,
        s.height = o,
        n.texImage2D(i.target, 0, s.internalFormat, r, o, 0, i.format, s.type, this.data)),
        !0
    }
    dispose() {
        this.data = null
    }
    static test(t) {
        return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
    }
}
const d4 = {
    scaleMode: Hi.NEAREST,
    format: ot.RGBA,
    alphaMode: _s.NPM
}
  , eo = class extends $o {
    constructor(e=null, t=null) {
        super(),
        t = Object.assign({}, eo.defaultOptions, t);
        const {alphaMode: i, mipmap: s, anisotropicLevel: n, scaleMode: r, width: o, height: a, wrapMode: l, format: c, type: h, target: u, resolution: d, resourceOptions: f} = t;
        e && !(e instanceof Ua) && (e = R_(e, f),
        e.internal = !0),
        this.resolution = d || ft.RESOLUTION,
        this.width = Math.round((o || 0) * this.resolution) / this.resolution,
        this.height = Math.round((a || 0) * this.resolution) / this.resolution,
        this._mipmap = s,
        this.anisotropicLevel = n,
        this._wrapMode = l,
        this._scaleMode = r,
        this.format = c,
        this.type = h,
        this.target = u,
        this.alphaMode = i,
        this.uid = Ln(),
        this.touched = 0,
        this.isPowerOfTwo = !1,
        this._refreshPOT(),
        this._glTextures = {},
        this.dirtyId = 0,
        this.dirtyStyleId = 0,
        this.cacheId = null,
        this.valid = o > 0 && a > 0,
        this.textureCacheIds = [],
        this.destroyed = !1,
        this.resource = null,
        this._batchEnabled = 0,
        this._batchLocation = 0,
        this.parentTextureArray = null,
        this.setResource(e)
    }
    get realWidth() {
        return Math.round(this.width * this.resolution)
    }
    get realHeight() {
        return Math.round(this.height * this.resolution)
    }
    get mipmap() {
        return this._mipmap
    }
    set mipmap(e) {
        this._mipmap !== e && (this._mipmap = e,
        this.dirtyStyleId++)
    }
    get scaleMode() {
        return this._scaleMode
    }
    set scaleMode(e) {
        this._scaleMode !== e && (this._scaleMode = e,
        this.dirtyStyleId++)
    }
    get wrapMode() {
        return this._wrapMode
    }
    set wrapMode(e) {
        this._wrapMode !== e && (this._wrapMode = e,
        this.dirtyStyleId++)
    }
    setStyle(e, t) {
        let i;
        return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e,
        i = !0),
        t !== void 0 && t !== this.mipmap && (this.mipmap = t,
        i = !0),
        i && this.dirtyStyleId++,
        this
    }
    setSize(e, t, i) {
        return i = i || this.resolution,
        this.setRealSize(e * i, t * i, i)
    }
    setRealSize(e, t, i) {
        return this.resolution = i || this.resolution,
        this.width = Math.round(e) / this.resolution,
        this.height = Math.round(t) / this.resolution,
        this._refreshPOT(),
        this.update(),
        this
    }
    _refreshPOT() {
        this.isPowerOfTwo = sd(this.realWidth) && sd(this.realHeight)
    }
    setResolution(e) {
        const t = this.resolution;
        return t === e ? this : (this.resolution = e,
        this.valid && (this.width = Math.round(this.width * t) / e,
        this.height = Math.round(this.height * t) / e,
        this.emit("update", this)),
        this._refreshPOT(),
        this)
    }
    setResource(e) {
        if (this.resource === e)
            return this;
        if (this.resource)
            throw new Error("Resource can be set only once");
        return e.bind(this),
        this.resource = e,
        this
    }
    update() {
        this.valid ? (this.dirtyId++,
        this.dirtyStyleId++,
        this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0,
        this.emit("loaded", this),
        this.emit("update", this))
    }
    onError(e) {
        this.emit("error", this, e)
    }
    destroy() {
        this.resource && (this.resource.unbind(this),
        this.resource.internal && this.resource.destroy(),
        this.resource = null),
        this.cacheId && (delete mi[this.cacheId],
        delete ai[this.cacheId],
        this.cacheId = null),
        this.dispose(),
        eo.removeFromCache(this),
        this.textureCacheIds = null,
        this.destroyed = !0
    }
    dispose() {
        this.emit("dispose", this)
    }
    castToBaseTexture() {
        return this
    }
    static from(e, t, i=ft.STRICT_TEXTURE_CACHE) {
        const s = typeof e == "string";
        let n = null;
        if (s)
            n = e;
        else {
            if (!e._pixiId) {
                const o = t?.pixiIdPrefix || "pixiid";
                e._pixiId = `${o}_${Ln()}`
            }
            n = e._pixiId
        }
        let r = mi[n];
        if (s && i && !r)
            throw new Error(`The cacheId "${n}" does not exist in BaseTextureCache.`);
        return r || (r = new eo(e,t),
        r.cacheId = n,
        eo.addToCache(r, n)),
        r
    }
    static fromBuffer(e, t, i, s) {
        e = e || new Float32Array(t * i * 4);
        const n = new qa(e,{
            width: t,
            height: i
        })
          , r = e instanceof Float32Array ? Rt.FLOAT : Rt.UNSIGNED_BYTE;
        return new eo(n,Object.assign({}, d4, s || {
            width: t,
            height: i,
            type: r
        }))
    }
    static addToCache(e, t) {
        t && (e.textureCacheIds.includes(t) || e.textureCacheIds.push(t),
        mi[t] && mi[t] !== e && console.warn(`BaseTexture added to the cache with an id [${t}] that already had an entry`),
        mi[t] = e)
    }
    static removeFromCache(e) {
        if (typeof e == "string") {
            const t = mi[e];
            if (t) {
                const i = t.textureCacheIds.indexOf(e);
                return i > -1 && t.textureCacheIds.splice(i, 1),
                delete mi[e],
                t
            }
        } else if (e?.textureCacheIds) {
            for (let t = 0; t < e.textureCacheIds.length; ++t)
                delete mi[e.textureCacheIds[t]];
            return e.textureCacheIds.length = 0,
            e
        }
        return null
    }
}
;
let Ot = eo;
Ot.defaultOptions = {
    mipmap: ds.POW2,
    anisotropicLevel: 0,
    scaleMode: Hi.LINEAR,
    wrapMode: Zs.CLAMP,
    alphaMode: _s.UNPACK,
    target: mo.TEXTURE_2D,
    format: ot.RGBA,
    type: Rt.UNSIGNED_BYTE
};
Ot._globalBatch = 0;
class cd {
    constructor() {
        this.texArray = null,
        this.blend = 0,
        this.type = rs.TRIANGLES,
        this.start = 0,
        this.size = 0,
        this.data = null
    }
}
let f4 = 0;
class Fe {
    constructor(t, i=!0, s=!1) {
        this.data = t || new Float32Array(1),
        this._glBuffers = {},
        this._updateID = 0,
        this.index = s,
        this.static = i,
        this.id = f4++,
        this.disposeRunner = new cs("disposeBuffer")
    }
    update(t) {
        t instanceof Array && (t = new Float32Array(t)),
        this.data = t || this.data,
        this._updateID++
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(),
        this.data = null
    }
    set index(t) {
        this.type = t ? Ps.ELEMENT_ARRAY_BUFFER : Ps.ARRAY_BUFFER
    }
    get index() {
        return this.type === Ps.ELEMENT_ARRAY_BUFFER
    }
    static from(t) {
        return t instanceof Array && (t = new Float32Array(t)),
        new Fe(t)
    }
}
class wc {
    constructor(t, i=0, s=!1, n=Rt.FLOAT, r, o, a, l=1) {
        this.buffer = t,
        this.size = i,
        this.normalized = s,
        this.type = n,
        this.stride = r,
        this.start = o,
        this.instance = a,
        this.divisor = l
    }
    destroy() {
        this.buffer = null
    }
    static from(t, i, s, n, r) {
        return new wc(t,i,s,n,r)
    }
}
const p4 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
};
function m4(e, t) {
    let i = 0
      , s = 0;
    const n = {};
    for (let l = 0; l < e.length; l++)
        s += t[l],
        i += e[l].length;
    const r = new ArrayBuffer(i * 4);
    let o = null
      , a = 0;
    for (let l = 0; l < e.length; l++) {
        const c = t[l]
          , h = e[l]
          , u = hh(h);
        n[u] || (n[u] = new p4[u](r)),
        o = n[u];
        for (let d = 0; d < h.length; d++) {
            const f = (d / c | 0) * s + a
              , p = d % c;
            o[f + p] = h[d]
        }
        a += c
    }
    return new Float32Array(r)
}
const rg = {
    5126: 4,
    5123: 2,
    5121: 1
};
let g4 = 0;
const v4 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array,
    Uint16Array
};
class On {
    constructor(t=[], i={}) {
        this.buffers = t,
        this.indexBuffer = null,
        this.attributes = i,
        this.glVertexArrayObjects = {},
        this.id = g4++,
        this.instanced = !1,
        this.instanceCount = 1,
        this.disposeRunner = new cs("disposeGeometry"),
        this.refCount = 0
    }
    addAttribute(t, i, s=0, n=!1, r, o, a, l=!1) {
        if (!i)
            throw new Error("You must pass a buffer when creating an attribute");
        i instanceof Fe || (i instanceof Array && (i = new Float32Array(i)),
        i = new Fe(i));
        const c = t.split("|");
        if (c.length > 1) {
            for (let u = 0; u < c.length; u++)
                this.addAttribute(c[u], i, s, n, r);
            return this
        }
        let h = this.buffers.indexOf(i);
        return h === -1 && (this.buffers.push(i),
        h = this.buffers.length - 1),
        this.attributes[t] = new wc(h,s,n,r,o,a,l),
        this.instanced = this.instanced || l,
        this
    }
    getAttribute(t) {
        return this.attributes[t]
    }
    getBuffer(t) {
        return this.buffers[this.getAttribute(t).buffer]
    }
    addIndex(t) {
        return t instanceof Fe || (t instanceof Array && (t = new Uint16Array(t)),
        t = new Fe(t)),
        t.type = Ps.ELEMENT_ARRAY_BUFFER,
        this.indexBuffer = t,
        this.buffers.includes(t) || this.buffers.push(t),
        this
    }
    getIndex() {
        return this.indexBuffer
    }
    interleave() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer)
            return this;
        const t = []
          , i = []
          , s = new Fe;
        let n;
        for (n in this.attributes) {
            const r = this.attributes[n]
              , o = this.buffers[r.buffer];
            t.push(o.data),
            i.push(r.size * rg[r.type] / 4),
            r.buffer = 0
        }
        for (s.data = m4(t, i),
        n = 0; n < this.buffers.length; n++)
            this.buffers[n] !== this.indexBuffer && this.buffers[n].destroy();
        return this.buffers = [s],
        this.indexBuffer && this.buffers.push(this.indexBuffer),
        this
    }
    getSize() {
        for (const t in this.attributes) {
            const i = this.attributes[t];
            return this.buffers[i.buffer].data.length / (i.stride / 4 || i.size)
        }
        return 0
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(),
        this.buffers = null,
        this.indexBuffer = null,
        this.attributes = null
    }
    clone() {
        const t = new On;
        for (let i = 0; i < this.buffers.length; i++)
            t.buffers[i] = new Fe(this.buffers[i].data.slice(0));
        for (const i in this.attributes) {
            const s = this.attributes[i];
            t.attributes[i] = new wc(s.buffer,s.size,s.normalized,s.type,s.stride,s.start,s.instance)
        }
        return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)],
        t.indexBuffer.type = Ps.ELEMENT_ARRAY_BUFFER),
        t
    }
    static merge(t) {
        const i = new On
          , s = []
          , n = []
          , r = [];
        let o;
        for (let a = 0; a < t.length; a++) {
            o = t[a];
            for (let l = 0; l < o.buffers.length; l++)
                n[l] = n[l] || 0,
                n[l] += o.buffers[l].data.length,
                r[l] = 0
        }
        for (let a = 0; a < o.buffers.length; a++)
            s[a] = new v4[hh(o.buffers[a].data)](n[a]),
            i.buffers[a] = new Fe(s[a]);
        for (let a = 0; a < t.length; a++) {
            o = t[a];
            for (let l = 0; l < o.buffers.length; l++)
                s[l].set(o.buffers[l].data, r[l]),
                r[l] += o.buffers[l].data.length
        }
        if (i.attributes = o.attributes,
        o.indexBuffer) {
            i.indexBuffer = i.buffers[o.buffers.indexOf(o.indexBuffer)],
            i.indexBuffer.type = Ps.ELEMENT_ARRAY_BUFFER;
            let a = 0
              , l = 0
              , c = 0
              , h = 0;
            for (let u = 0; u < o.buffers.length; u++)
                if (o.buffers[u] !== o.indexBuffer) {
                    h = u;
                    break
                }
            for (const u in o.attributes) {
                const d = o.attributes[u];
                (d.buffer | 0) === h && (l += d.size * rg[d.type] / 4)
            }
            for (let u = 0; u < t.length; u++) {
                const d = t[u].indexBuffer.data;
                for (let f = 0; f < d.length; f++)
                    i.indexBuffer.data[f + c] += a;
                a += t[u].buffers[h].data.length / l,
                c += d.length
            }
        }
        return i
    }
}
class k_ extends On {
    constructor(t=!1) {
        super(),
        this._buffer = new Fe(null,t,!1),
        this._indexBuffer = new Fe(null,t,!0),
        this.addAttribute("aVertexPosition", this._buffer, 2, !1, Rt.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, Rt.FLOAT).addAttribute("aColor", this._buffer, 4, !0, Rt.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, Rt.FLOAT).addIndex(this._indexBuffer)
    }
}
const Tc = Math.PI * 2
  , _4 = 180 / Math.PI
  , y4 = Math.PI / 180;
var we = (e=>(e[e.POLY = 0] = "POLY",
e[e.RECT = 1] = "RECT",
e[e.CIRC = 2] = "CIRC",
e[e.ELIP = 3] = "ELIP",
e[e.RREC = 4] = "RREC",
e))(we || {});
class Zt {
    constructor(t=0, i=0) {
        this.x = 0,
        this.y = 0,
        this.x = t,
        this.y = i
    }
    clone() {
        return new Zt(this.x,this.y)
    }
    copyFrom(t) {
        return this.set(t.x, t.y),
        this
    }
    copyTo(t) {
        return t.set(this.x, this.y),
        t
    }
    equals(t) {
        return t.x === this.x && t.y === this.y
    }
    set(t=0, i=t) {
        return this.x = t,
        this.y = i,
        this
    }
    toString() {
        return `[@pixi/math:Point x=${this.x} y=${this.y}]`
    }
}
const xl = [new Zt, new Zt, new Zt, new Zt];
class qt {
    constructor(t=0, i=0, s=0, n=0) {
        this.x = Number(t),
        this.y = Number(i),
        this.width = Number(s),
        this.height = Number(n),
        this.type = we.RECT
    }
    get left() {
        return this.x
    }
    get right() {
        return this.x + this.width
    }
    get top() {
        return this.y
    }
    get bottom() {
        return this.y + this.height
    }
    static get EMPTY() {
        return new qt(0,0,0,0)
    }
    clone() {
        return new qt(this.x,this.y,this.width,this.height)
    }
    copyFrom(t) {
        return this.x = t.x,
        this.y = t.y,
        this.width = t.width,
        this.height = t.height,
        this
    }
    copyTo(t) {
        return t.x = this.x,
        t.y = this.y,
        t.width = this.width,
        t.height = this.height,
        t
    }
    contains(t, i) {
        return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && i >= this.y && i < this.y + this.height
    }
    intersects(t, i) {
        if (!i) {
            const T = this.x < t.x ? t.x : this.x;
            if ((this.right > t.right ? t.right : this.right) <= T)
                return !1;
            const D = this.y < t.y ? t.y : this.y;
            return (this.bottom > t.bottom ? t.bottom : this.bottom) > D
        }
        const s = this.left
          , n = this.right
          , r = this.top
          , o = this.bottom;
        if (n <= s || o <= r)
            return !1;
        const a = xl[0].set(t.left, t.top)
          , l = xl[1].set(t.left, t.bottom)
          , c = xl[2].set(t.right, t.top)
          , h = xl[3].set(t.right, t.bottom);
        if (c.x <= a.x || l.y <= a.y)
            return !1;
        const u = Math.sign(i.a * i.d - i.b * i.c);
        if (u === 0 || (i.apply(a, a),
        i.apply(l, l),
        i.apply(c, c),
        i.apply(h, h),
        Math.max(a.x, l.x, c.x, h.x) <= s || Math.min(a.x, l.x, c.x, h.x) >= n || Math.max(a.y, l.y, c.y, h.y) <= r || Math.min(a.y, l.y, c.y, h.y) >= o))
            return !1;
        const d = u * (l.y - a.y)
          , f = u * (a.x - l.x)
          , p = d * s + f * r
          , m = d * n + f * r
          , g = d * s + f * o
          , y = d * n + f * o;
        if (Math.max(p, m, g, y) <= d * a.x + f * a.y || Math.min(p, m, g, y) >= d * h.x + f * h.y)
            return !1;
        const x = u * (a.y - c.y)
          , v = u * (c.x - a.x)
          , _ = x * s + v * r
          , C = x * n + v * r
          , k = x * s + v * o
          , S = x * n + v * o;
        return !(Math.max(_, C, k, S) <= x * a.x + v * a.y || Math.min(_, C, k, S) >= x * h.x + v * h.y)
    }
    pad(t=0, i=t) {
        return this.x -= t,
        this.y -= i,
        this.width += t * 2,
        this.height += i * 2,
        this
    }
    fit(t) {
        const i = Math.max(this.x, t.x)
          , s = Math.min(this.x + this.width, t.x + t.width)
          , n = Math.max(this.y, t.y)
          , r = Math.min(this.y + this.height, t.y + t.height);
        return this.x = i,
        this.width = Math.max(s - i, 0),
        this.y = n,
        this.height = Math.max(r - n, 0),
        this
    }
    ceil(t=1, i=.001) {
        const s = Math.ceil((this.x + this.width - i) * t) / t
          , n = Math.ceil((this.y + this.height - i) * t) / t;
        return this.x = Math.floor((this.x + i) * t) / t,
        this.y = Math.floor((this.y + i) * t) / t,
        this.width = s - this.x,
        this.height = n - this.y,
        this
    }
    enlarge(t) {
        const i = Math.min(this.x, t.x)
          , s = Math.max(this.x + this.width, t.x + t.width)
          , n = Math.min(this.y, t.y)
          , r = Math.max(this.y + this.height, t.y + t.height);
        return this.x = i,
        this.width = s - i,
        this.y = n,
        this.height = r - n,
        this
    }
    toString() {
        return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
    }
}
class Hf {
    constructor(t=0, i=0, s=0) {
        this.x = t,
        this.y = i,
        this.radius = s,
        this.type = we.CIRC
    }
    clone() {
        return new Hf(this.x,this.y,this.radius)
    }
    contains(t, i) {
        if (this.radius <= 0)
            return !1;
        const s = this.radius * this.radius;
        let n = this.x - t
          , r = this.y - i;
        return n *= n,
        r *= r,
        n + r <= s
    }
    getBounds() {
        return new qt(this.x - this.radius,this.y - this.radius,this.radius * 2,this.radius * 2)
    }
    toString() {
        return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
    }
}
class Vf {
    constructor(t=0, i=0, s=0, n=0) {
        this.x = t,
        this.y = i,
        this.width = s,
        this.height = n,
        this.type = we.ELIP
    }
    clone() {
        return new Vf(this.x,this.y,this.width,this.height)
    }
    contains(t, i) {
        if (this.width <= 0 || this.height <= 0)
            return !1;
        let s = (t - this.x) / this.width
          , n = (i - this.y) / this.height;
        return s *= s,
        n *= n,
        s + n <= 1
    }
    getBounds() {
        return new qt(this.x - this.width,this.y - this.height,this.width,this.height)
    }
    toString() {
        return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
    }
}
class vo {
    constructor(...t) {
        let i = Array.isArray(t[0]) ? t[0] : t;
        if (typeof i[0] != "number") {
            const s = [];
            for (let n = 0, r = i.length; n < r; n++)
                s.push(i[n].x, i[n].y);
            i = s
        }
        this.points = i,
        this.type = we.POLY,
        this.closeStroke = !0
    }
    clone() {
        const t = this.points.slice()
          , i = new vo(t);
        return i.closeStroke = this.closeStroke,
        i
    }
    contains(t, i) {
        let s = !1;
        const n = this.points.length / 2;
        for (let r = 0, o = n - 1; r < n; o = r++) {
            const a = this.points[r * 2]
              , l = this.points[r * 2 + 1]
              , c = this.points[o * 2]
              , h = this.points[o * 2 + 1];
            l > i != h > i && t < (c - a) * ((i - l) / (h - l)) + a && (s = !s)
        }
        return s
    }
    toString() {
        return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((t,i)=>`${t}, ${i}`, "")}]`
    }
}
class zf {
    constructor(t=0, i=0, s=0, n=0, r=20) {
        this.x = t,
        this.y = i,
        this.width = s,
        this.height = n,
        this.radius = r,
        this.type = we.RREC
    }
    clone() {
        return new zf(this.x,this.y,this.width,this.height,this.radius)
    }
    contains(t, i) {
        if (this.width <= 0 || this.height <= 0)
            return !1;
        if (t >= this.x && t <= this.x + this.width && i >= this.y && i <= this.y + this.height) {
            const s = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (i >= this.y + s && i <= this.y + this.height - s || t >= this.x + s && t <= this.x + this.width - s)
                return !0;
            let n = t - (this.x + s)
              , r = i - (this.y + s);
            const o = s * s;
            if (n * n + r * r <= o || (n = t - (this.x + this.width - s),
            n * n + r * r <= o) || (r = i - (this.y + this.height - s),
            n * n + r * r <= o) || (n = t - (this.x + s),
            n * n + r * r <= o))
                return !0
        }
        return !1
    }
    toString() {
        return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
    }
}
class pe {
    constructor(t=1, i=0, s=0, n=1, r=0, o=0) {
        this.array = null,
        this.a = t,
        this.b = i,
        this.c = s,
        this.d = n,
        this.tx = r,
        this.ty = o
    }
    fromArray(t) {
        this.a = t[0],
        this.b = t[1],
        this.c = t[3],
        this.d = t[4],
        this.tx = t[2],
        this.ty = t[5]
    }
    set(t, i, s, n, r, o) {
        return this.a = t,
        this.b = i,
        this.c = s,
        this.d = n,
        this.tx = r,
        this.ty = o,
        this
    }
    toArray(t, i) {
        this.array || (this.array = new Float32Array(9));
        const s = i || this.array;
        return t ? (s[0] = this.a,
        s[1] = this.b,
        s[2] = 0,
        s[3] = this.c,
        s[4] = this.d,
        s[5] = 0,
        s[6] = this.tx,
        s[7] = this.ty,
        s[8] = 1) : (s[0] = this.a,
        s[1] = this.c,
        s[2] = this.tx,
        s[3] = this.b,
        s[4] = this.d,
        s[5] = this.ty,
        s[6] = 0,
        s[7] = 0,
        s[8] = 1),
        s
    }
    apply(t, i) {
        i = i || new Zt;
        const s = t.x
          , n = t.y;
        return i.x = this.a * s + this.c * n + this.tx,
        i.y = this.b * s + this.d * n + this.ty,
        i
    }
    applyInverse(t, i) {
        i = i || new Zt;
        const s = 1 / (this.a * this.d + this.c * -this.b)
          , n = t.x
          , r = t.y;
        return i.x = this.d * s * n + -this.c * s * r + (this.ty * this.c - this.tx * this.d) * s,
        i.y = this.a * s * r + -this.b * s * n + (-this.ty * this.a + this.tx * this.b) * s,
        i
    }
    translate(t, i) {
        return this.tx += t,
        this.ty += i,
        this
    }
    scale(t, i) {
        return this.a *= t,
        this.d *= i,
        this.c *= t,
        this.b *= i,
        this.tx *= t,
        this.ty *= i,
        this
    }
    rotate(t) {
        const i = Math.cos(t)
          , s = Math.sin(t)
          , n = this.a
          , r = this.c
          , o = this.tx;
        return this.a = n * i - this.b * s,
        this.b = n * s + this.b * i,
        this.c = r * i - this.d * s,
        this.d = r * s + this.d * i,
        this.tx = o * i - this.ty * s,
        this.ty = o * s + this.ty * i,
        this
    }
    append(t) {
        const i = this.a
          , s = this.b
          , n = this.c
          , r = this.d;
        return this.a = t.a * i + t.b * n,
        this.b = t.a * s + t.b * r,
        this.c = t.c * i + t.d * n,
        this.d = t.c * s + t.d * r,
        this.tx = t.tx * i + t.ty * n + this.tx,
        this.ty = t.tx * s + t.ty * r + this.ty,
        this
    }
    setTransform(t, i, s, n, r, o, a, l, c) {
        return this.a = Math.cos(a + c) * r,
        this.b = Math.sin(a + c) * r,
        this.c = -Math.sin(a - l) * o,
        this.d = Math.cos(a - l) * o,
        this.tx = t - (s * this.a + n * this.c),
        this.ty = i - (s * this.b + n * this.d),
        this
    }
    prepend(t) {
        const i = this.tx;
        if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
            const s = this.a
              , n = this.c;
            this.a = s * t.a + this.b * t.c,
            this.b = s * t.b + this.b * t.d,
            this.c = n * t.a + this.d * t.c,
            this.d = n * t.b + this.d * t.d
        }
        return this.tx = i * t.a + this.ty * t.c + t.tx,
        this.ty = i * t.b + this.ty * t.d + t.ty,
        this
    }
    decompose(t) {
        const i = this.a
          , s = this.b
          , n = this.c
          , r = this.d
          , o = t.pivot
          , a = -Math.atan2(-n, r)
          , l = Math.atan2(s, i)
          , c = Math.abs(a + l);
        return c < 1e-5 || Math.abs(Tc - c) < 1e-5 ? (t.rotation = l,
        t.skew.x = t.skew.y = 0) : (t.rotation = 0,
        t.skew.x = a,
        t.skew.y = l),
        t.scale.x = Math.sqrt(i * i + s * s),
        t.scale.y = Math.sqrt(n * n + r * r),
        t.position.x = this.tx + (o.x * i + o.y * n),
        t.position.y = this.ty + (o.x * s + o.y * r),
        t
    }
    invert() {
        const t = this.a
          , i = this.b
          , s = this.c
          , n = this.d
          , r = this.tx
          , o = t * n - i * s;
        return this.a = n / o,
        this.b = -i / o,
        this.c = -s / o,
        this.d = t / o,
        this.tx = (s * this.ty - n * r) / o,
        this.ty = -(t * this.ty - i * r) / o,
        this
    }
    identity() {
        return this.a = 1,
        this.b = 0,
        this.c = 0,
        this.d = 1,
        this.tx = 0,
        this.ty = 0,
        this
    }
    clone() {
        const t = new pe;
        return t.a = this.a,
        t.b = this.b,
        t.c = this.c,
        t.d = this.d,
        t.tx = this.tx,
        t.ty = this.ty,
        t
    }
    copyTo(t) {
        return t.a = this.a,
        t.b = this.b,
        t.c = this.c,
        t.d = this.d,
        t.tx = this.tx,
        t.ty = this.ty,
        t
    }
    copyFrom(t) {
        return this.a = t.a,
        this.b = t.b,
        this.c = t.c,
        this.d = t.d,
        this.tx = t.tx,
        this.ty = t.ty,
        this
    }
    toString() {
        return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
    }
    static get IDENTITY() {
        return new pe
    }
    static get TEMP_MATRIX() {
        return new pe
    }
}
const Xn = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1]
  , Yn = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1]
  , Kn = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1]
  , Zn = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1]
  , hd = []
  , P_ = []
  , wl = Math.sign;
function b4() {
    for (let e = 0; e < 16; e++) {
        const t = [];
        hd.push(t);
        for (let i = 0; i < 16; i++) {
            const s = wl(Xn[e] * Xn[i] + Kn[e] * Yn[i])
              , n = wl(Yn[e] * Xn[i] + Zn[e] * Yn[i])
              , r = wl(Xn[e] * Kn[i] + Kn[e] * Zn[i])
              , o = wl(Yn[e] * Kn[i] + Zn[e] * Zn[i]);
            for (let a = 0; a < 16; a++)
                if (Xn[a] === s && Yn[a] === n && Kn[a] === r && Zn[a] === o) {
                    t.push(a);
                    break
                }
        }
    }
    for (let e = 0; e < 16; e++) {
        const t = new pe;
        t.set(Xn[e], Yn[e], Kn[e], Zn[e], 0, 0),
        P_.push(t)
    }
}
b4();
const Se = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: e=>Xn[e],
    uY: e=>Yn[e],
    vX: e=>Kn[e],
    vY: e=>Zn[e],
    inv: e=>e & 8 ? e & 15 : -e & 7,
    add: (e,t)=>hd[e][t],
    sub: (e,t)=>hd[e][Se.inv(t)],
    rotate180: e=>e ^ 4,
    isVertical: e=>(e & 3) === 2,
    byDirection: (e,t)=>Math.abs(e) * 2 <= Math.abs(t) ? t >= 0 ? Se.S : Se.N : Math.abs(t) * 2 <= Math.abs(e) ? e > 0 ? Se.E : Se.W : t > 0 ? e > 0 ? Se.SE : Se.SW : e > 0 ? Se.NE : Se.NW,
    matrixAppendRotationInv: (e,t,i=0,s=0)=>{
        const n = P_[Se.inv(t)];
        n.tx = i,
        n.ty = s,
        e.append(n)
    }
};
class wn {
    constructor(t, i, s=0, n=0) {
        this._x = s,
        this._y = n,
        this.cb = t,
        this.scope = i
    }
    clone(t=this.cb, i=this.scope) {
        return new wn(t,i,this._x,this._y)
    }
    set(t=0, i=t) {
        return (this._x !== t || this._y !== i) && (this._x = t,
        this._y = i,
        this.cb.call(this.scope)),
        this
    }
    copyFrom(t) {
        return (this._x !== t.x || this._y !== t.y) && (this._x = t.x,
        this._y = t.y,
        this.cb.call(this.scope)),
        this
    }
    copyTo(t) {
        return t.set(this._x, this._y),
        t
    }
    equals(t) {
        return t.x === this._x && t.y === this._y
    }
    toString() {
        return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`
    }
    get x() {
        return this._x
    }
    set x(t) {
        this._x !== t && (this._x = t,
        this.cb.call(this.scope))
    }
    get y() {
        return this._y
    }
    set y(t) {
        this._y !== t && (this._y = t,
        this.cb.call(this.scope))
    }
}
const L_ = class {
    constructor() {
        this.worldTransform = new pe,
        this.localTransform = new pe,
        this.position = new wn(this.onChange,this,0,0),
        this.scale = new wn(this.onChange,this,1,1),
        this.pivot = new wn(this.onChange,this,0,0),
        this.skew = new wn(this.updateSkew,this,0,0),
        this._rotation = 0,
        this._cx = 1,
        this._sx = 0,
        this._cy = 0,
        this._sy = 1,
        this._localID = 0,
        this._currentLocalID = 0,
        this._worldID = 0,
        this._parentID = 0
    }
    onChange() {
        this._localID++
    }
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y),
        this._sx = Math.sin(this._rotation + this.skew.y),
        this._cy = -Math.sin(this._rotation - this.skew.x),
        this._sy = Math.cos(this._rotation - this.skew.x),
        this._localID++
    }
    toString() {
        return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
    }
    updateLocalTransform() {
        const e = this.localTransform;
        this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x,
        e.b = this._sx * this.scale.x,
        e.c = this._cy * this.scale.y,
        e.d = this._sy * this.scale.y,
        e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c),
        e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d),
        this._currentLocalID = this._localID,
        this._parentID = -1)
    }
    updateTransform(e) {
        const t = this.localTransform;
        if (this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x,
        t.b = this._sx * this.scale.x,
        t.c = this._cy * this.scale.y,
        t.d = this._sy * this.scale.y,
        t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c),
        t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d),
        this._currentLocalID = this._localID,
        this._parentID = -1),
        this._parentID !== e._worldID) {
            const i = e.worldTransform
              , s = this.worldTransform;
            s.a = t.a * i.a + t.b * i.c,
            s.b = t.a * i.b + t.b * i.d,
            s.c = t.c * i.a + t.d * i.c,
            s.d = t.c * i.b + t.d * i.d,
            s.tx = t.tx * i.a + t.ty * i.c + i.tx,
            s.ty = t.tx * i.b + t.ty * i.d + i.ty,
            this._parentID = e._worldID,
            this._worldID++
        }
    }
    setFromMatrix(e) {
        e.decompose(this),
        this._localID++
    }
    get rotation() {
        return this._rotation
    }
    set rotation(e) {
        this._rotation !== e && (this._rotation = e,
        this.updateSkew())
    }
}
;
let uh = L_;
uh.IDENTITY = new L_;
var x4 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`
  , w4 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;
function og(e, t, i) {
    const s = e.createShader(t);
    return e.shaderSource(s, i),
    e.compileShader(s),
    s
}
function tu(e) {
    const t = new Array(e);
    for (let i = 0; i < t.length; i++)
        t[i] = !1;
    return t
}
function O_(e, t) {
    switch (e) {
    case "float":
        return 0;
    case "vec2":
        return new Float32Array(2 * t);
    case "vec3":
        return new Float32Array(3 * t);
    case "vec4":
        return new Float32Array(4 * t);
    case "int":
    case "uint":
    case "sampler2D":
    case "sampler2DArray":
        return 0;
    case "ivec2":
        return new Int32Array(2 * t);
    case "ivec3":
        return new Int32Array(3 * t);
    case "ivec4":
        return new Int32Array(4 * t);
    case "uvec2":
        return new Uint32Array(2 * t);
    case "uvec3":
        return new Uint32Array(3 * t);
    case "uvec4":
        return new Uint32Array(4 * t);
    case "bool":
        return !1;
    case "bvec2":
        return tu(2 * t);
    case "bvec3":
        return tu(3 * t);
    case "bvec4":
        return tu(4 * t);
    case "mat2":
        return new Float32Array([1, 0, 0, 1]);
    case "mat3":
        return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    case "mat4":
        return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
}
const _o = [{
    test: e=>e.type === "float" && e.size === 1 && !e.isArray,
    code: e=>`
            if(uv["${e}"] !== ud["${e}"].value)
            {
                ud["${e}"].value = uv["${e}"]
                gl.uniform1f(ud["${e}"].location, uv["${e}"])
            }
            `
}, {
    test: (e,t)=>(e.type === "sampler2D" || e.type === "samplerCube" || e.type === "sampler2DArray") && e.size === 1 && !e.isArray && (t == null || t.castToBaseTexture !== void 0),
    code: e=>`t = syncData.textureCount++;

            renderer.texture.bind(uv["${e}"], t);

            if(ud["${e}"].value !== t)
            {
                ud["${e}"].value = t;
                gl.uniform1i(ud["${e}"].location, t);
; // eslint-disable-line max-len
            }`
}, {
    test: (e,t)=>e.type === "mat3" && e.size === 1 && !e.isArray && t.a !== void 0,
    code: e=>`
            gl.uniformMatrix3fv(ud["${e}"].location, false, uv["${e}"].toArray(true));
            `,
    codeUbo: e=>`
                var ${e}_matrix = uv.${e}.toArray(true);

                data[offset] = ${e}_matrix[0];
                data[offset+1] = ${e}_matrix[1];
                data[offset+2] = ${e}_matrix[2];
        
                data[offset + 4] = ${e}_matrix[3];
                data[offset + 5] = ${e}_matrix[4];
                data[offset + 6] = ${e}_matrix[5];
        
                data[offset + 8] = ${e}_matrix[6];
                data[offset + 9] = ${e}_matrix[7];
                data[offset + 10] = ${e}_matrix[8];
            `
}, {
    test: (e,t)=>e.type === "vec2" && e.size === 1 && !e.isArray && t.x !== void 0,
    code: e=>`
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${e}"].location, v.x, v.y);
                }`,
    codeUbo: e=>`
                v = uv.${e};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
}, {
    test: e=>e.type === "vec2" && e.size === 1 && !e.isArray,
    code: e=>`
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${e}"].location, v[0], v[1]);
                }
            `
}, {
    test: (e,t)=>e.type === "vec4" && e.size === 1 && !e.isArray && t.width !== void 0,
    code: e=>`
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${e}"].location, v.x, v.y, v.width, v.height)
                }`,
    codeUbo: e=>`
                    v = uv.${e};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
}, {
    test: e=>e.type === "vec4" && e.size === 1 && !e.isArray,
    code: e=>`
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${e}"].location, v[0], v[1], v[2], v[3])
                }`
}]
  , T4 = {
    float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
    vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
    vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
    vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
    int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
    uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
    uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
    uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
    bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
    bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
    bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
    bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
    sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
}
  , E4 = {
    float: "gl.uniform1fv(location, v)",
    vec2: "gl.uniform2fv(location, v)",
    vec3: "gl.uniform3fv(location, v)",
    vec4: "gl.uniform4fv(location, v)",
    mat4: "gl.uniformMatrix4fv(location, false, v)",
    mat3: "gl.uniformMatrix3fv(location, false, v)",
    mat2: "gl.uniformMatrix2fv(location, false, v)",
    int: "gl.uniform1iv(location, v)",
    ivec2: "gl.uniform2iv(location, v)",
    ivec3: "gl.uniform3iv(location, v)",
    ivec4: "gl.uniform4iv(location, v)",
    uint: "gl.uniform1uiv(location, v)",
    uvec2: "gl.uniform2uiv(location, v)",
    uvec3: "gl.uniform3uiv(location, v)",
    uvec4: "gl.uniform4uiv(location, v)",
    bool: "gl.uniform1iv(location, v)",
    bvec2: "gl.uniform2iv(location, v)",
    bvec3: "gl.uniform3iv(location, v)",
    bvec4: "gl.uniform4iv(location, v)",
    sampler2D: "gl.uniform1iv(location, v)",
    samplerCube: "gl.uniform1iv(location, v)",
    sampler2DArray: "gl.uniform1iv(location, v)"
};
function S4(e, t) {
    const i = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
    for (const s in e.uniforms) {
        const n = t[s];
        if (!n) {
            e.uniforms[s]?.group && (e.uniforms[s].ubo ? i.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${s}, '${s}');
                    `) : i.push(`
                        renderer.shader.syncUniformGroup(uv.${s}, syncData);
                    `));
            continue
        }
        const r = e.uniforms[s];
        let o = !1;
        for (let a = 0; a < _o.length; a++)
            if (_o[a].test(n, r)) {
                i.push(_o[a].code(s, r)),
                o = !0;
                break
            }
        if (!o) {
            const l = (n.size === 1 && !n.isArray ? T4 : E4)[n.type].replace("location", `ud["${s}"].location`);
            i.push(`
            cu = ud["${s}"];
            cv = cu.value;
            v = uv["${s}"];
            ${l};`)
        }
    }
    return new Function("ud","uv","renderer","syncData",i.join(`
`))
}
const D_ = {};
let Tl = D_;
function C4() {
    if (Tl === D_ || Tl?.isContextLost()) {
        const e = ft.ADAPTER.createCanvas();
        let t;
        ft.PREFER_ENV >= Lr.WEBGL2 && (t = e.getContext("webgl2", {})),
        t || (t = e.getContext("webgl", {}) || e.getContext("experimental-webgl", {}),
        t ? t.getExtension("WEBGL_draw_buffers") : t = null),
        Tl = t
    }
    return Tl
}
let El;
function A4() {
    if (!El) {
        El = Vi.MEDIUM;
        const e = C4();
        e && e.getShaderPrecisionFormat && (El = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision ? Vi.HIGH : Vi.MEDIUM)
    }
    return El
}
function ag(e, t) {
    const i = e.getShaderSource(t).split(`
`).map((c,h)=>`${h}: ${c}`)
      , s = e.getShaderInfoLog(t)
      , n = s.split(`
`)
      , r = {}
      , o = n.map(c=>parseFloat(c.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(c=>c && !r[c] ? (r[c] = !0,
    !0) : !1)
      , a = [""];
    o.forEach(c=>{
        i[c - 1] = `%c${i[c - 1]}%c`,
        a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
    }
    );
    const l = i.join(`
`);
    a[0] = l,
    console.error(s),
    console.groupCollapsed("click to view full shader code"),
    console.warn(...a),
    console.groupEnd()
}
function I4(e, t, i, s) {
    e.getProgramParameter(t, e.LINK_STATUS) || (e.getShaderParameter(i, e.COMPILE_STATUS) || ag(e, i),
    e.getShaderParameter(s, e.COMPILE_STATUS) || ag(e, s),
    console.error("PixiJS Error: Could not initialize shader."),
    e.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", e.getProgramInfoLog(t)))
}
const M4 = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
};
function N_(e) {
    return M4[e]
}
let Sl = null;
const lg = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};
function F_(e, t) {
    if (!Sl) {
        const i = Object.keys(lg);
        Sl = {};
        for (let s = 0; s < i.length; ++s) {
            const n = i[s];
            Sl[e[n]] = lg[n]
        }
    }
    return Sl[t]
}
function cg(e, t, i) {
    if (e.substring(0, 9) !== "precision") {
        let s = t;
        return t === Vi.HIGH && i !== Vi.HIGH && (s = Vi.MEDIUM),
        `precision ${s} float;
${e}`
    } else if (i !== Vi.HIGH && e.substring(0, 15) === "precision highp")
        return e.replace("precision highp", "precision mediump");
    return e
}
let Qo;
function R4() {
    if (typeof Qo == "boolean")
        return Qo;
    try {
        Qo = new Function("param1","param2","param3","return param1[param2] === param3;")({
            a: "b"
        }, "a", "b") === !0
    } catch {
        Qo = !1
    }
    return Qo
}
let k4 = 0;
const Cl = {}
  , io = class {
    constructor(e, t, i="pixi-shader", s={}) {
        this.extra = {},
        this.id = k4++,
        this.vertexSrc = e || io.defaultVertexSrc,
        this.fragmentSrc = t || io.defaultFragmentSrc,
        this.vertexSrc = this.vertexSrc.trim(),
        this.fragmentSrc = this.fragmentSrc.trim(),
        this.extra = s,
        this.vertexSrc.substring(0, 8) !== "#version" && (i = i.replace(/\s+/g, "-"),
        Cl[i] ? (Cl[i]++,
        i += `-${Cl[i]}`) : Cl[i] = 1,
        this.vertexSrc = `#define SHADER_NAME ${i}
${this.vertexSrc}`,
        this.fragmentSrc = `#define SHADER_NAME ${i}
${this.fragmentSrc}`,
        this.vertexSrc = cg(this.vertexSrc, io.defaultVertexPrecision, Vi.HIGH),
        this.fragmentSrc = cg(this.fragmentSrc, io.defaultFragmentPrecision, A4())),
        this.glPrograms = {},
        this.syncUniforms = null
    }
    static get defaultVertexSrc() {
        return w4
    }
    static get defaultFragmentSrc() {
        return x4
    }
    static from(e, t, i) {
        const s = e + t;
        let n = rd[s];
        return n || (rd[s] = n = new io(e,t,i)),
        n
    }
}
;
let os = io;
os.defaultVertexPrecision = Vi.HIGH;
os.defaultFragmentPrecision = Is.apple.device ? Vi.HIGH : Vi.MEDIUM;
let P4 = 0;
class hs {
    constructor(t, i, s) {
        this.group = !0,
        this.syncUniforms = {},
        this.dirtyId = 0,
        this.id = P4++,
        this.static = !!i,
        this.ubo = !!s,
        t instanceof Fe ? (this.buffer = t,
        this.buffer.type = Ps.UNIFORM_BUFFER,
        this.autoManage = !1,
        this.ubo = !0) : (this.uniforms = t,
        this.ubo && (this.buffer = new Fe(new Float32Array(1)),
        this.buffer.type = Ps.UNIFORM_BUFFER,
        this.autoManage = !0))
    }
    update() {
        this.dirtyId++,
        !this.autoManage && this.buffer && this.buffer.update()
    }
    add(t, i, s) {
        if (!this.ubo)
            this.uniforms[t] = new hs(i,s);
        else
            throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them")
    }
    static from(t, i, s) {
        return new hs(t,i,s)
    }
    static uboFrom(t, i) {
        return new hs(t,i ?? !0,!0)
    }
}
class Ls {
    constructor(t, i) {
        this.uniformBindCount = 0,
        this.program = t,
        i ? i instanceof hs ? this.uniformGroup = i : this.uniformGroup = new hs(i) : this.uniformGroup = new hs({}),
        this.disposeRunner = new cs("disposeShader")
    }
    checkUniformExists(t, i) {
        if (i.uniforms[t])
            return !0;
        for (const s in i.uniforms) {
            const n = i.uniforms[s];
            if (n.group && this.checkUniformExists(t, n))
                return !0
        }
        return !1
    }
    destroy() {
        this.uniformGroup = null,
        this.disposeRunner.emit(this),
        this.disposeRunner.destroy()
    }
    get uniforms() {
        return this.uniformGroup.uniforms
    }
    static from(t, i, s) {
        const n = os.from(t, i);
        return new Ls(n,s)
    }
}
class L4 {
    constructor(t, i) {
        if (this.vertexSrc = t,
        this.fragTemplate = i,
        this.programCache = {},
        this.defaultGroupCache = {},
        !i.includes("%count%"))
            throw new Error('Fragment template must contain "%count%".');
        if (!i.includes("%forloop%"))
            throw new Error('Fragment template must contain "%forloop%".')
    }
    generateShader(t) {
        if (!this.programCache[t]) {
            const s = new Int32Array(t);
            for (let r = 0; r < t; r++)
                s[r] = r;
            this.defaultGroupCache[t] = hs.from({
                uSamplers: s
            }, !0);
            let n = this.fragTemplate;
            n = n.replace(/%count%/gi, `${t}`),
            n = n.replace(/%forloop%/gi, this.generateSampleSrc(t)),
            this.programCache[t] = new os(this.vertexSrc,n)
        }
        const i = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new pe,
            default: this.defaultGroupCache[t]
        };
        return new Ls(this.programCache[t],i)
    }
    generateSampleSrc(t) {
        let i = "";
        i += `
`,
        i += `
`;
        for (let s = 0; s < t; s++)
            s > 0 && (i += `
else `),
            s < t - 1 && (i += `if(vTextureId < ${s}.5)`),
            i += `
{`,
            i += `
	color = texture2D(uSamplers[${s}], vTextureCoord);`,
            i += `
}`;
        return i += `
`,
        i += `
`,
        i
    }
}
class ud {
    constructor() {
        this.elements = [],
        this.ids = [],
        this.count = 0
    }
    clear() {
        for (let t = 0; t < this.count; t++)
            this.elements[t] = null;
        this.count = 0
    }
}
function O4() {
    return !Is.apple.device
}
function D4(e) {
    let t = !0;
    const i = ft.ADAPTER.getNavigator();
    if (Is.tablet || Is.phone) {
        if (Is.apple.device) {
            const s = i.userAgent.match(/OS (\d+)_(\d+)?/);
            s && parseInt(s[1], 10) < 11 && (t = !1)
        }
        if (Is.android.device) {
            const s = i.userAgent.match(/Android\s([0-9.]*)/);
            s && parseInt(s[1], 10) < 7 && (t = !1)
        }
    }
    return t ? e : 4
}
class dh {
    constructor(t) {
        this.renderer = t
    }
    flush() {}
    destroy() {
        this.renderer = null
    }
    start() {}
    stop() {
        this.flush()
    }
    render(t) {}
}
var N4 = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`
  , F4 = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
const qi = class extends dh {
    constructor(e) {
        super(e),
        this.setShaderGenerator(),
        this.geometryClass = k_,
        this.vertexSize = 6,
        this.state = rn.for2d(),
        this.size = qi.defaultBatchSize * 4,
        this._vertexCount = 0,
        this._indexCount = 0,
        this._bufferedElements = [],
        this._bufferedTextures = [],
        this._bufferSize = 0,
        this._shader = null,
        this._packedGeometries = [],
        this._packedGeometryPoolSize = 2,
        this._flushId = 0,
        this._aBuffers = {},
        this._iBuffers = {},
        this.maxTextures = 1,
        this.renderer.on("prerender", this.onPrerender, this),
        e.runners.contextChange.add(this),
        this._dcIndex = 0,
        this._aIndex = 0,
        this._iIndex = 0,
        this._attributeBuffer = null,
        this._indexBuffer = null,
        this._tempBoundTextures = []
    }
    static get defaultMaxTextures() {
        return this._defaultMaxTextures = this._defaultMaxTextures ?? D4(32),
        this._defaultMaxTextures
    }
    static set defaultMaxTextures(e) {
        this._defaultMaxTextures = e
    }
    static get canUploadSameBuffer() {
        return this._canUploadSameBuffer = this._canUploadSameBuffer ?? O4(),
        this._canUploadSameBuffer
    }
    static set canUploadSameBuffer(e) {
        this._canUploadSameBuffer = e
    }
    get MAX_TEXTURES() {
        return Qt("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"),
        this.maxTextures
    }
    static get defaultVertexSrc() {
        return F4
    }
    static get defaultFragmentTemplate() {
        return N4
    }
    setShaderGenerator({vertex: e=qi.defaultVertexSrc, fragment: t=qi.defaultFragmentTemplate}={}) {
        this.shaderGenerator = new L4(e,t)
    }
    contextChange() {
        const e = this.renderer.gl;
        ft.PREFER_ENV === Lr.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), qi.defaultMaxTextures),
        this.maxTextures = u4(this.maxTextures, e)),
        this._shader = this.shaderGenerator.generateShader(this.maxTextures);
        for (let t = 0; t < this._packedGeometryPoolSize; t++)
            this._packedGeometries[t] = new this.geometryClass;
        this.initFlushBuffers()
    }
    initFlushBuffers() {
        const {_drawCallPool: e, _textureArrayPool: t} = qi
          , i = this.size / 4
          , s = Math.floor(i / this.maxTextures) + 1;
        for (; e.length < i; )
            e.push(new cd);
        for (; t.length < s; )
            t.push(new ud);
        for (let n = 0; n < this.maxTextures; n++)
            this._tempBoundTextures[n] = null
    }
    onPrerender() {
        this._flushId = 0
    }
    render(e) {
        !e._texture.valid || (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(),
        this._vertexCount += e.vertexData.length / 2,
        this._indexCount += e.indices.length,
        this._bufferedTextures[this._bufferSize] = e._texture.baseTexture,
        this._bufferedElements[this._bufferSize++] = e)
    }
    buildTexturesAndDrawCalls() {
        const {_bufferedTextures: e, maxTextures: t} = this
          , i = qi._textureArrayPool
          , s = this.renderer.batch
          , n = this._tempBoundTextures
          , r = this.renderer.textureGC.count;
        let o = ++Ot._globalBatch
          , a = 0
          , l = i[0]
          , c = 0;
        s.copyBoundTextures(n, t);
        for (let h = 0; h < this._bufferSize; ++h) {
            const u = e[h];
            e[h] = null,
            u._batchEnabled !== o && (l.count >= t && (s.boundArray(l, n, o, t),
            this.buildDrawCalls(l, c, h),
            c = h,
            l = i[++a],
            ++o),
            u._batchEnabled = o,
            u.touched = r,
            l.elements[l.count++] = u)
        }
        l.count > 0 && (s.boundArray(l, n, o, t),
        this.buildDrawCalls(l, c, this._bufferSize),
        ++a,
        ++o);
        for (let h = 0; h < n.length; h++)
            n[h] = null;
        Ot._globalBatch = o
    }
    buildDrawCalls(e, t, i) {
        const {_bufferedElements: s, _attributeBuffer: n, _indexBuffer: r, vertexSize: o} = this
          , a = qi._drawCallPool;
        let l = this._dcIndex
          , c = this._aIndex
          , h = this._iIndex
          , u = a[l];
        u.start = this._iIndex,
        u.texArray = e;
        for (let d = t; d < i; ++d) {
            const f = s[d]
              , p = f._texture.baseTexture
              , m = Bf[p.alphaMode ? 1 : 0][f.blendMode];
            s[d] = null,
            t < d && u.blend !== m && (u.size = h - u.start,
            t = d,
            u = a[++l],
            u.texArray = e,
            u.start = h),
            this.packInterleavedGeometry(f, n, r, c, h),
            c += f.vertexData.length / 2 * o,
            h += f.indices.length,
            u.blend = m
        }
        t < i && (u.size = h - u.start,
        ++l),
        this._dcIndex = l,
        this._aIndex = c,
        this._iIndex = h
    }
    bindAndClearTexArray(e) {
        const t = this.renderer.texture;
        for (let i = 0; i < e.count; i++)
            t.bind(e.elements[i], e.ids[i]),
            e.elements[i] = null;
        e.count = 0
    }
    updateGeometry() {
        const {_packedGeometries: e, _attributeBuffer: t, _indexBuffer: i} = this;
        qi.canUploadSameBuffer ? (e[this._flushId]._buffer.update(t.rawBinaryData),
        e[this._flushId]._indexBuffer.update(i),
        this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++,
        e[this._flushId] = new this.geometryClass),
        e[this._flushId]._buffer.update(t.rawBinaryData),
        e[this._flushId]._indexBuffer.update(i),
        this.renderer.geometry.bind(e[this._flushId]),
        this.renderer.geometry.updateBuffers(),
        this._flushId++)
    }
    drawBatches() {
        const e = this._dcIndex
          , {gl: t, state: i} = this.renderer
          , s = qi._drawCallPool;
        let n = null;
        for (let r = 0; r < e; r++) {
            const {texArray: o, type: a, size: l, start: c, blend: h} = s[r];
            n !== o && (n = o,
            this.bindAndClearTexArray(o)),
            this.state.blendMode = h,
            i.set(this.state),
            t.drawElements(a, l, t.UNSIGNED_SHORT, c * 2)
        }
    }
    flush() {
        this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount),
        this._indexBuffer = this.getIndexBuffer(this._indexCount),
        this._aIndex = 0,
        this._iIndex = 0,
        this._dcIndex = 0,
        this.buildTexturesAndDrawCalls(),
        this.updateGeometry(),
        this.drawBatches(),
        this._bufferSize = 0,
        this._vertexCount = 0,
        this._indexCount = 0)
    }
    start() {
        this.renderer.state.set(this.state),
        this.renderer.texture.ensureSamplerType(this.maxTextures),
        this.renderer.shader.bind(this._shader),
        qi.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
    }
    stop() {
        this.flush()
    }
    destroy() {
        for (let e = 0; e < this._packedGeometryPoolSize; e++)
            this._packedGeometries[e] && this._packedGeometries[e].destroy();
        this.renderer.off("prerender", this.onPrerender, this),
        this._aBuffers = null,
        this._iBuffers = null,
        this._packedGeometries = null,
        this._attributeBuffer = null,
        this._indexBuffer = null,
        this._shader && (this._shader.destroy(),
        this._shader = null),
        super.destroy()
    }
    getAttributeBuffer(e) {
        const t = Ba(Math.ceil(e / 8))
          , i = nd(t)
          , s = t * 8;
        this._aBuffers.length <= i && (this._iBuffers.length = i + 1);
        let n = this._aBuffers[s];
        return n || (this._aBuffers[s] = n = new ad(s * this.vertexSize * 4)),
        n
    }
    getIndexBuffer(e) {
        const t = Ba(Math.ceil(e / 12))
          , i = nd(t)
          , s = t * 12;
        this._iBuffers.length <= i && (this._iBuffers.length = i + 1);
        let n = this._iBuffers[i];
        return n || (this._iBuffers[i] = n = new Uint16Array(s)),
        n
    }
    packInterleavedGeometry(e, t, i, s, n) {
        const {uint32View: r, float32View: o} = t
          , a = s / this.vertexSize
          , l = e.uvs
          , c = e.indices
          , h = e.vertexData
          , u = e._texture.baseTexture._batchLocation
          , d = Math.min(e.worldAlpha, 1)
          , f = d < 1 && e._texture.baseTexture.alphaMode ? ch(e._tintRGB, d) : e._tintRGB + (d * 255 << 24);
        for (let p = 0; p < h.length; p += 2)
            o[s++] = h[p],
            o[s++] = h[p + 1],
            o[s++] = l[p],
            o[s++] = l[p + 1],
            r[s++] = f,
            o[s++] = u;
        for (let p = 0; p < c.length; p++)
            i[n++] = a + c[p]
    }
}
;
let ss = qi;
ss.defaultBatchSize = 4096;
ss.extension = {
    name: "batch",
    type: lt.RendererPlugin
};
ss._drawCallPool = [];
ss._textureArrayPool = [];
vt.add(ss);
var B4 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`
  , U4 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const pa = class extends Ls {
    constructor(e, t, i) {
        const s = os.from(e || pa.defaultVertexSrc, t || pa.defaultFragmentSrc);
        super(s, i),
        this.padding = 0,
        this.resolution = pa.defaultResolution,
        this.multisample = pa.defaultMultisample,
        this.enabled = !0,
        this.autoFit = !0,
        this.state = new rn
    }
    apply(e, t, i, s, n) {
        e.applyFilter(this, t, i, s)
    }
    get blendMode() {
        return this.state.blendMode
    }
    set blendMode(e) {
        this.state.blendMode = e
    }
    get resolution() {
        return this._resolution
    }
    set resolution(e) {
        this._resolution = e
    }
    static get defaultVertexSrc() {
        return U4
    }
    static get defaultFragmentSrc() {
        return B4
    }
}
;
let qe = pa;
qe.defaultResolution = 1;
qe.defaultMultisample = De.NONE;
class B_ {
    constructor() {
        this.clearBeforeRender = !0,
        this._backgroundColor = 0,
        this._backgroundColorRgba = [0, 0, 0, 1],
        this._backgroundColorString = "#000000",
        this.color = this._backgroundColor,
        this.alpha = 1
    }
    init(t) {
        this.clearBeforeRender = t.clearBeforeRender,
        t.color && (this.color = typeof t.color == "string" ? lh(t.color) : t.color),
        this.alpha = t.alpha
    }
    get color() {
        return this._backgroundColor
    }
    set color(t) {
        this._backgroundColor = t,
        this._backgroundColorString = ah(t),
        tn(t, this._backgroundColorRgba)
    }
    get alpha() {
        return this._backgroundColorRgba[3]
    }
    set alpha(t) {
        this._backgroundColorRgba[3] = t
    }
    get colorRgba() {
        return this._backgroundColorRgba
    }
    get colorString() {
        return this._backgroundColorString
    }
    destroy() {}
}
B_.extension = {
    type: [lt.RendererSystem, lt.CanvasRendererSystem],
    name: "background"
};
vt.add(B_);
class U_ {
    constructor(t) {
        this.renderer = t,
        this.emptyRenderer = new dh(t),
        this.currentRenderer = this.emptyRenderer
    }
    setObjectRenderer(t) {
        this.currentRenderer !== t && (this.currentRenderer.stop(),
        this.currentRenderer = t,
        this.currentRenderer.start())
    }
    flush() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    reset() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    copyBoundTextures(t, i) {
        const {boundTextures: s} = this.renderer.texture;
        for (let n = i - 1; n >= 0; --n)
            t[n] = s[n] || null,
            t[n] && (t[n]._batchLocation = n)
    }
    boundArray(t, i, s, n) {
        const {elements: r, ids: o, count: a} = t;
        let l = 0;
        for (let c = 0; c < a; c++) {
            const h = r[c]
              , u = h._batchLocation;
            if (u >= 0 && u < n && i[u] === h) {
                o[c] = u;
                continue
            }
            for (; l < n; ) {
                const d = i[l];
                if (d && d._batchEnabled === s && d._batchLocation === l) {
                    l++;
                    continue
                }
                o[c] = l,
                h._batchLocation = l,
                i[l] = h;
                break
            }
        }
    }
    destroy() {
        this.renderer = null
    }
}
U_.extension = {
    type: lt.RendererSystem,
    name: "batch"
};
vt.add(U_);
let hg = 0;
class G_ {
    constructor(t) {
        this.renderer = t,
        this.webGLVersion = 1,
        this.extensions = {},
        this.supports = {
            uint32Indices: !1
        },
        this.handleContextLost = this.handleContextLost.bind(this),
        this.handleContextRestored = this.handleContextRestored.bind(this)
    }
    get isLost() {
        return !this.gl || this.gl.isContextLost()
    }
    contextChange(t) {
        this.gl = t,
        this.renderer.gl = t,
        this.renderer.CONTEXT_UID = hg++
    }
    init(t) {
        if (t.context)
            this.initFromContext(t.context);
        else {
            const i = this.renderer.background.alpha < 1
              , s = t.premultipliedAlpha;
            this.preserveDrawingBuffer = t.preserveDrawingBuffer,
            this.useContextAlpha = t.useContextAlpha,
            this.powerPreference = t.powerPreference,
            this.initFromOptions({
                alpha: i,
                premultipliedAlpha: s,
                antialias: t.antialias,
                stencil: !0,
                preserveDrawingBuffer: t.preserveDrawingBuffer,
                powerPreference: t.powerPreference
            })
        }
    }
    initFromContext(t) {
        this.gl = t,
        this.validateContext(t),
        this.renderer.gl = t,
        this.renderer.CONTEXT_UID = hg++,
        this.renderer.runners.contextChange.emit(t);
        const i = this.renderer.view;
        i.addEventListener !== void 0 && (i.addEventListener("webglcontextlost", this.handleContextLost, !1),
        i.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
    }
    initFromOptions(t) {
        const i = this.createContext(this.renderer.view, t);
        this.initFromContext(i)
    }
    createContext(t, i) {
        let s;
        if (ft.PREFER_ENV >= Lr.WEBGL2 && (s = t.getContext("webgl2", i)),
        s)
            this.webGLVersion = 2;
        else if (this.webGLVersion = 1,
        s = t.getContext("webgl", i) || t.getContext("experimental-webgl", i),
        !s)
            throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        return this.gl = s,
        this.getExtensions(),
        this.gl
    }
    getExtensions() {
        const {gl: t} = this
          , i = {
            loseContext: t.getExtension("WEBGL_lose_context"),
            anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: t.getExtension("WEBGL_compressed_texture_etc"),
            etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: t.getExtension("WEBGL_compressed_texture_atc"),
            astc: t.getExtension("WEBGL_compressed_texture_astc")
        };
        this.webGLVersion === 1 ? Object.assign(this.extensions, i, {
            drawBuffers: t.getExtension("WEBGL_draw_buffers"),
            depthTexture: t.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: t.getExtension("OES_element_index_uint"),
            floatTexture: t.getExtension("OES_texture_float"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            textureHalfFloat: t.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
        }) : this.webGLVersion === 2 && Object.assign(this.extensions, i, {
            colorBufferFloat: t.getExtension("EXT_color_buffer_float")
        })
    }
    handleContextLost(t) {
        t.preventDefault(),
        setTimeout(()=>{
            this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext()
        }
        , 0)
    }
    handleContextRestored() {
        this.renderer.runners.contextChange.emit(this.gl)
    }
    destroy() {
        const t = this.renderer.view;
        this.renderer = null,
        t.removeEventListener !== void 0 && (t.removeEventListener("webglcontextlost", this.handleContextLost),
        t.removeEventListener("webglcontextrestored", this.handleContextRestored)),
        this.gl.useProgram(null),
        this.extensions.loseContext && this.extensions.loseContext.loseContext()
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && this.gl.flush()
    }
    validateContext(t) {
        const i = t.getContextAttributes()
          , s = "WebGL2RenderingContext"in globalThis && t instanceof globalThis.WebGL2RenderingContext;
        s && (this.webGLVersion = 2),
        i && !i.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        const n = s || !!t.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = n,
        n || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
    }
}
G_.extension = {
    type: lt.RendererSystem,
    name: "context"
};
vt.add(G_);
class G4 extends qa {
    upload(t, i, s) {
        const n = t.gl;
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === _s.UNPACK);
        const r = i.realWidth
          , o = i.realHeight;
        return s.width === r && s.height === o ? n.texSubImage2D(i.target, 0, 0, 0, r, o, i.format, s.type, this.data) : (s.width = r,
        s.height = o,
        n.texImage2D(i.target, 0, s.internalFormat, r, o, 0, i.format, s.type, this.data)),
        !0
    }
}
class dd {
    constructor(t, i) {
        this.width = Math.round(t || 100),
        this.height = Math.round(i || 100),
        this.stencil = !1,
        this.depth = !1,
        this.dirtyId = 0,
        this.dirtyFormat = 0,
        this.dirtySize = 0,
        this.depthTexture = null,
        this.colorTextures = [],
        this.glFramebuffers = {},
        this.disposeRunner = new cs("disposeFramebuffer"),
        this.multisample = De.NONE
    }
    get colorTexture() {
        return this.colorTextures[0]
    }
    addColorTexture(t=0, i) {
        return this.colorTextures[t] = i || new Ot(null,{
            scaleMode: Hi.NEAREST,
            resolution: 1,
            mipmap: ds.OFF,
            width: this.width,
            height: this.height
        }),
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    addDepthTexture(t) {
        return this.depthTexture = t || new Ot(new G4(null,{
            width: this.width,
            height: this.height
        }),{
            scaleMode: Hi.NEAREST,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: ds.OFF,
            format: ot.DEPTH_COMPONENT,
            type: Rt.UNSIGNED_SHORT
        }),
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    enableDepth() {
        return this.depth = !0,
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    enableStencil() {
        return this.stencil = !0,
        this.dirtyId++,
        this.dirtyFormat++,
        this
    }
    resize(t, i) {
        if (t = Math.round(t),
        i = Math.round(i),
        !(t === this.width && i === this.height)) {
            this.width = t,
            this.height = i,
            this.dirtyId++,
            this.dirtySize++;
            for (let s = 0; s < this.colorTextures.length; s++) {
                const n = this.colorTextures[s]
                  , r = n.resolution;
                n.setSize(t / r, i / r)
            }
            if (this.depthTexture) {
                const s = this.depthTexture.resolution;
                this.depthTexture.setSize(t / s, i / s)
            }
        }
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroyDepthTexture() {
        this.depthTexture && (this.depthTexture.destroy(),
        this.depthTexture = null,
        ++this.dirtyId,
        ++this.dirtyFormat)
    }
}
class $f extends Ot {
    constructor(t={}) {
        if (typeof t == "number") {
            const i = arguments[0]
              , s = arguments[1]
              , n = arguments[2]
              , r = arguments[3];
            t = {
                width: i,
                height: s,
                scaleMode: n,
                resolution: r
            }
        }
        t.width = t.width || 100,
        t.height = t.height || 100,
        t.multisample ?? (t.multisample = De.NONE),
        super(null, t),
        this.mipmap = ds.OFF,
        this.valid = !0,
        this.clearColor = [0, 0, 0, 0],
        this.framebuffer = new dd(this.realWidth,this.realHeight).addColorTexture(0, this),
        this.framebuffer.multisample = t.multisample,
        this.maskStack = [],
        this.filterStack = [{}]
    }
    resize(t, i) {
        this.framebuffer.resize(t * this.resolution, i * this.resolution),
        this.setRealSize(this.framebuffer.width, this.framebuffer.height)
    }
    dispose() {
        this.framebuffer.dispose(),
        super.dispose()
    }
    destroy() {
        super.destroy(),
        this.framebuffer.destroyDepthTexture(),
        this.framebuffer = null
    }
}
class Dn extends Ua {
    constructor(t) {
        const i = t
          , s = i.naturalWidth || i.videoWidth || i.width
          , n = i.naturalHeight || i.videoHeight || i.height;
        super(s, n),
        this.source = t,
        this.noSubImage = !1
    }
    static crossOrigin(t, i, s) {
        s === void 0 && !i.startsWith("data:") ? t.crossOrigin = M_(i) : s !== !1 && (t.crossOrigin = typeof s == "string" ? s : "anonymous")
    }
    upload(t, i, s, n) {
        const r = t.gl
          , o = i.realWidth
          , a = i.realHeight;
        if (n = n || this.source,
        typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) {
            if (!n.complete || n.naturalWidth === 0)
                return !1
        } else if (typeof HTMLVideoElement < "u" && n instanceof HTMLVideoElement && n.readyState <= 1 && n.buffered.length === 0)
            return !1;
        return r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === _s.UNPACK),
        !this.noSubImage && i.target === r.TEXTURE_2D && s.width === o && s.height === a ? r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, i.format, s.type, n) : (s.width = o,
        s.height = a,
        r.texImage2D(i.target, 0, s.internalFormat, i.format, s.type, n)),
        !0
    }
    update() {
        if (this.destroyed)
            return;
        const t = this.source
          , i = t.naturalWidth || t.videoWidth || t.width
          , s = t.naturalHeight || t.videoHeight || t.height;
        this.resize(i, s),
        super.update()
    }
    dispose() {
        this.source = null
    }
}
class H_ extends Dn {
    constructor(t, i) {
        if (i = i || {},
        typeof t == "string") {
            const s = new Image;
            Dn.crossOrigin(s, t, i.crossorigin),
            s.src = t,
            t = s
        }
        super(t),
        !t.complete && !!this._width && !!this._height && (this._width = 0,
        this._height = 0),
        this.url = t.src,
        this._process = null,
        this.preserveBitmap = !1,
        this.createBitmap = (i.createBitmap ?? ft.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap,
        this.alphaMode = typeof i.alphaMode == "number" ? i.alphaMode : null,
        this.bitmap = null,
        this._load = null,
        i.autoLoad !== !1 && this.load()
    }
    load(t) {
        return this._load ? this._load : (t !== void 0 && (this.createBitmap = t),
        this._load = new Promise((i,s)=>{
            const n = this.source;
            this.url = n.src;
            const r = ()=>{
                this.destroyed || (n.onload = null,
                n.onerror = null,
                this.resize(n.width, n.height),
                this._load = null,
                this.createBitmap ? i(this.process()) : i(this))
            }
            ;
            n.complete && n.src ? r() : (n.onload = r,
            n.onerror = o=>{
                s(o),
                this.onError.emit(o)
            }
            )
        }
        ),
        this._load)
    }
    process() {
        const t = this.source;
        if (this._process !== null)
            return this._process;
        if (this.bitmap !== null || !globalThis.createImageBitmap)
            return Promise.resolve(this);
        const i = globalThis.createImageBitmap
          , s = !t.crossOrigin || t.crossOrigin === "anonymous";
        return this._process = fetch(t.src, {
            mode: s ? "cors" : "no-cors"
        }).then(n=>n.blob()).then(n=>i(n, 0, 0, t.width, t.height, {
            premultiplyAlpha: this.alphaMode === null || this.alphaMode === _s.UNPACK ? "premultiply" : "none"
        })).then(n=>this.destroyed ? Promise.reject() : (this.bitmap = n,
        this.update(),
        this._process = null,
        Promise.resolve(this))),
        this._process
    }
    upload(t, i, s) {
        if (typeof this.alphaMode == "number" && (i.alphaMode = this.alphaMode),
        !this.createBitmap)
            return super.upload(t, i, s);
        if (!this.bitmap && (this.process(),
        !this.bitmap))
            return !1;
        if (super.upload(t, i, s, this.bitmap),
        !this.preserveBitmap) {
            let n = !0;
            const r = i._glTextures;
            for (const o in r) {
                const a = r[o];
                if (a !== s && a.dirtyId !== i.dirtyId) {
                    n = !1;
                    break
                }
            }
            n && (this.bitmap.close && this.bitmap.close(),
            this.bitmap = null)
        }
        return !0
    }
    dispose() {
        this.source.onload = null,
        this.source.onerror = null,
        super.dispose(),
        this.bitmap && (this.bitmap.close(),
        this.bitmap = null),
        this._process = null,
        this._load = null
    }
    static test(t) {
        return typeof HTMLImageElement < "u" && (typeof t == "string" || t instanceof HTMLImageElement)
    }
}
class V_ {
    constructor() {
        this.x0 = 0,
        this.y0 = 0,
        this.x1 = 1,
        this.y1 = 0,
        this.x2 = 1,
        this.y2 = 1,
        this.x3 = 0,
        this.y3 = 1,
        this.uvsFloat32 = new Float32Array(8)
    }
    set(t, i, s) {
        const n = i.width
          , r = i.height;
        if (s) {
            const o = t.width / 2 / n
              , a = t.height / 2 / r
              , l = t.x / n + o
              , c = t.y / r + a;
            s = Se.add(s, Se.NW),
            this.x0 = l + o * Se.uX(s),
            this.y0 = c + a * Se.uY(s),
            s = Se.add(s, 2),
            this.x1 = l + o * Se.uX(s),
            this.y1 = c + a * Se.uY(s),
            s = Se.add(s, 2),
            this.x2 = l + o * Se.uX(s),
            this.y2 = c + a * Se.uY(s),
            s = Se.add(s, 2),
            this.x3 = l + o * Se.uX(s),
            this.y3 = c + a * Se.uY(s)
        } else
            this.x0 = t.x / n,
            this.y0 = t.y / r,
            this.x1 = (t.x + t.width) / n,
            this.y1 = t.y / r,
            this.x2 = (t.x + t.width) / n,
            this.y2 = (t.y + t.height) / r,
            this.x3 = t.x / n,
            this.y3 = (t.y + t.height) / r;
        this.uvsFloat32[0] = this.x0,
        this.uvsFloat32[1] = this.y0,
        this.uvsFloat32[2] = this.x1,
        this.uvsFloat32[3] = this.y1,
        this.uvsFloat32[4] = this.x2,
        this.uvsFloat32[5] = this.y2,
        this.uvsFloat32[6] = this.x3,
        this.uvsFloat32[7] = this.y3
    }
    toString() {
        return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`
    }
}
const ug = new V_;
function Al(e) {
    e.destroy = function() {}
    ,
    e.on = function() {}
    ,
    e.once = function() {}
    ,
    e.emit = function() {}
}
class ht extends $o {
    constructor(t, i, s, n, r, o) {
        if (super(),
        this.noFrame = !1,
        i || (this.noFrame = !0,
        i = new qt(0,0,1,1)),
        t instanceof ht && (t = t.baseTexture),
        this.baseTexture = t,
        this._frame = i,
        this.trim = n,
        this.valid = !1,
        this._uvs = ug,
        this.uvMatrix = null,
        this.orig = s || i,
        this._rotate = Number(r || 0),
        r === !0)
            this._rotate = 2;
        else if (this._rotate % 2 !== 0)
            throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        this.defaultAnchor = o ? new Zt(o.x,o.y) : new Zt(0,0),
        this._updateID = 0,
        this.textureCacheIds = [],
        t.valid ? this.noFrame ? t.valid && this.onBaseTextureUpdated(t) : this.frame = i : t.once("loaded", this.onBaseTextureUpdated, this),
        this.noFrame && t.on("update", this.onBaseTextureUpdated, this)
    }
    update() {
        this.baseTexture.resource && this.baseTexture.resource.update()
    }
    onBaseTextureUpdated(t) {
        if (this.noFrame) {
            if (!this.baseTexture.valid)
                return;
            this._frame.width = t.width,
            this._frame.height = t.height,
            this.valid = !0,
            this.updateUvs()
        } else
            this.frame = this._frame;
        this.emit("update", this)
    }
    destroy(t) {
        if (this.baseTexture) {
            if (t) {
                const {resource: i} = this.baseTexture;
                i?.url && ai[i.url] && ht.removeFromCache(i.url),
                this.baseTexture.destroy()
            }
            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this),
            this.baseTexture.off("update", this.onBaseTextureUpdated, this),
            this.baseTexture = null
        }
        this._frame = null,
        this._uvs = null,
        this.trim = null,
        this.orig = null,
        this.valid = !1,
        ht.removeFromCache(this),
        this.textureCacheIds = null
    }
    clone() {
        const t = this._frame.clone()
          , i = this._frame === this.orig ? t : this.orig.clone()
          , s = new ht(this.baseTexture,!this.noFrame && t,i,this.trim?.clone(),this.rotate,this.defaultAnchor);
        return this.noFrame && (s._frame = t),
        s
    }
    updateUvs() {
        this._uvs === ug && (this._uvs = new V_),
        this._uvs.set(this._frame, this.baseTexture, this.rotate),
        this._updateID++
    }
    static from(t, i={}, s=ft.STRICT_TEXTURE_CACHE) {
        const n = typeof t == "string";
        let r = null;
        if (n)
            r = t;
        else if (t instanceof Ot) {
            if (!t.cacheId) {
                const a = i?.pixiIdPrefix || "pixiid";
                t.cacheId = `${a}-${Ln()}`,
                Ot.addToCache(t, t.cacheId)
            }
            r = t.cacheId
        } else {
            if (!t._pixiId) {
                const a = i?.pixiIdPrefix || "pixiid";
                t._pixiId = `${a}_${Ln()}`
            }
            r = t._pixiId
        }
        let o = ai[r];
        if (n && s && !o)
            throw new Error(`The cacheId "${r}" does not exist in TextureCache.`);
        return !o && !(t instanceof Ot) ? (i.resolution || (i.resolution = en(t)),
        o = new ht(new Ot(t,i)),
        o.baseTexture.cacheId = r,
        Ot.addToCache(o.baseTexture, r),
        ht.addToCache(o, r)) : !o && t instanceof Ot && (o = new ht(t),
        ht.addToCache(o, r)),
        o
    }
    static fromURL(t, i) {
        const s = Object.assign({
            autoLoad: !1
        }, i?.resourceOptions)
          , n = ht.from(t, Object.assign({
            resourceOptions: s
        }, i), !1)
          , r = n.baseTexture.resource;
        return n.baseTexture.valid ? Promise.resolve(n) : r.load().then(()=>Promise.resolve(n))
    }
    static fromBuffer(t, i, s, n) {
        return new ht(Ot.fromBuffer(t, i, s, n))
    }
    static fromLoader(t, i, s, n) {
        const r = new Ot(t,Object.assign({
            scaleMode: Ot.defaultOptions.scaleMode,
            resolution: en(i)
        }, n))
          , {resource: o} = r;
        o instanceof H_ && (o.url = i);
        const a = new ht(r);
        return s || (s = i),
        Ot.addToCache(a.baseTexture, s),
        ht.addToCache(a, s),
        s !== i && (Ot.addToCache(a.baseTexture, i),
        ht.addToCache(a, i)),
        a.baseTexture.valid ? Promise.resolve(a) : new Promise(l=>{
            a.baseTexture.once("loaded", ()=>l(a))
        }
        )
    }
    static addToCache(t, i) {
        i && (t.textureCacheIds.includes(i) || t.textureCacheIds.push(i),
        ai[i] && ai[i] !== t && console.warn(`Texture added to the cache with an id [${i}] that already had an entry`),
        ai[i] = t)
    }
    static removeFromCache(t) {
        if (typeof t == "string") {
            const i = ai[t];
            if (i) {
                const s = i.textureCacheIds.indexOf(t);
                return s > -1 && i.textureCacheIds.splice(s, 1),
                delete ai[t],
                i
            }
        } else if (t?.textureCacheIds) {
            for (let i = 0; i < t.textureCacheIds.length; ++i)
                ai[t.textureCacheIds[i]] === t && delete ai[t.textureCacheIds[i]];
            return t.textureCacheIds.length = 0,
            t
        }
        return null
    }
    get resolution() {
        return this.baseTexture.resolution
    }
    get frame() {
        return this._frame
    }
    set frame(t) {
        this._frame = t,
        this.noFrame = !1;
        const {x: i, y: s, width: n, height: r} = t
          , o = i + n > this.baseTexture.width
          , a = s + r > this.baseTexture.height;
        if (o || a) {
            const l = o && a ? "and" : "or"
              , c = `X: ${i} + ${n} = ${i + n} > ${this.baseTexture.width}`
              , h = `Y: ${s} + ${r} = ${s + r} > ${this.baseTexture.height}`;
            throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${c} ${l} ${h}`)
        }
        this.valid = n && r && this.baseTexture.valid,
        !this.trim && !this.rotate && (this.orig = t),
        this.valid && this.updateUvs()
    }
    get rotate() {
        return this._rotate
    }
    set rotate(t) {
        this._rotate = t,
        this.valid && this.updateUvs()
    }
    get width() {
        return this.orig.width
    }
    get height() {
        return this.orig.height
    }
    castToBaseTexture() {
        return this.baseTexture
    }
    static get EMPTY() {
        return ht._EMPTY || (ht._EMPTY = new ht(new Ot),
        Al(ht._EMPTY),
        Al(ht._EMPTY.baseTexture)),
        ht._EMPTY
    }
    static get WHITE() {
        if (!ht._WHITE) {
            const t = ft.ADAPTER.createCanvas(16, 16)
              , i = t.getContext("2d");
            t.width = 16,
            t.height = 16,
            i.fillStyle = "white",
            i.fillRect(0, 0, 16, 16),
            ht._WHITE = new ht(Ot.from(t)),
            Al(ht._WHITE),
            Al(ht._WHITE.baseTexture)
        }
        return ht._WHITE
    }
}
class fs extends ht {
    constructor(t, i) {
        super(t, i),
        this.valid = !0,
        this.filterFrame = null,
        this.filterPoolKey = null,
        this.updateUvs()
    }
    get framebuffer() {
        return this.baseTexture.framebuffer
    }
    get multisample() {
        return this.framebuffer.multisample
    }
    set multisample(t) {
        this.framebuffer.multisample = t
    }
    resize(t, i, s=!0) {
        const n = this.baseTexture.resolution
          , r = Math.round(t * n) / n
          , o = Math.round(i * n) / n;
        this.valid = r > 0 && o > 0,
        this._frame.width = this.orig.width = r,
        this._frame.height = this.orig.height = o,
        s && this.baseTexture.resize(r, o),
        this.updateUvs()
    }
    setResolution(t) {
        const {baseTexture: i} = this;
        i.resolution !== t && (i.setResolution(t),
        this.resize(i.width, i.height, !1))
    }
    static create(t) {
        return new fs(new $f(t))
    }
}
class z_ {
    constructor(t) {
        this.texturePool = {},
        this.textureOptions = t || {},
        this.enableFullScreen = !1,
        this._pixelsWidth = 0,
        this._pixelsHeight = 0
    }
    createTexture(t, i, s=De.NONE) {
        const n = new $f(Object.assign({
            width: t,
            height: i,
            resolution: 1,
            multisample: s
        }, this.textureOptions));
        return new fs(n)
    }
    getOptimalTexture(t, i, s=1, n=De.NONE) {
        let r;
        t = Math.ceil(t * s - 1e-6),
        i = Math.ceil(i * s - 1e-6),
        !this.enableFullScreen || t !== this._pixelsWidth || i !== this._pixelsHeight ? (t = Ba(t),
        i = Ba(i),
        r = ((t & 65535) << 16 | i & 65535) >>> 0,
        n > 1 && (r += n * 4294967296)) : r = n > 1 ? -n : -1,
        this.texturePool[r] || (this.texturePool[r] = []);
        let o = this.texturePool[r].pop();
        return o || (o = this.createTexture(t, i, n)),
        o.filterPoolKey = r,
        o.setResolution(s),
        o
    }
    getFilterTexture(t, i, s) {
        const n = this.getOptimalTexture(t.width, t.height, i || t.resolution, s || De.NONE);
        return n.filterFrame = t.filterFrame,
        n
    }
    returnTexture(t) {
        const i = t.filterPoolKey;
        t.filterFrame = null,
        this.texturePool[i].push(t)
    }
    returnFilterTexture(t) {
        this.returnTexture(t)
    }
    clear(t) {
        if (t = t !== !1,
        t)
            for (const i in this.texturePool) {
                const s = this.texturePool[i];
                if (s)
                    for (let n = 0; n < s.length; n++)
                        s[n].destroy(!0)
            }
        this.texturePool = {}
    }
    setScreenSize(t) {
        if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
            this.enableFullScreen = t.width > 0 && t.height > 0;
            for (const i in this.texturePool) {
                if (!(Number(i) < 0))
                    continue;
                const s = this.texturePool[i];
                if (s)
                    for (let n = 0; n < s.length; n++)
                        s[n].destroy(!0);
                this.texturePool[i] = []
            }
            this._pixelsWidth = t.width,
            this._pixelsHeight = t.height
        }
    }
}
z_.SCREEN_KEY = -1;
class H4 extends On {
    constructor() {
        super(),
        this.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2])
    }
}
class $_ extends On {
    constructor() {
        super(),
        this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]),
        this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]),
        this.vertexBuffer = new Fe(this.vertices),
        this.uvBuffer = new Fe(this.uvs),
        this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3])
    }
    map(t, i) {
        let s = 0
          , n = 0;
        return this.uvs[0] = s,
        this.uvs[1] = n,
        this.uvs[2] = s + i.width / t.width,
        this.uvs[3] = n,
        this.uvs[4] = s + i.width / t.width,
        this.uvs[5] = n + i.height / t.height,
        this.uvs[6] = s,
        this.uvs[7] = n + i.height / t.height,
        s = i.x,
        n = i.y,
        this.vertices[0] = s,
        this.vertices[1] = n,
        this.vertices[2] = s + i.width,
        this.vertices[3] = n,
        this.vertices[4] = s + i.width,
        this.vertices[5] = n + i.height,
        this.vertices[6] = s,
        this.vertices[7] = n + i.height,
        this.invalidate(),
        this
    }
    invalidate() {
        return this.vertexBuffer._updateID++,
        this.uvBuffer._updateID++,
        this
    }
}
class V4 {
    constructor() {
        this.renderTexture = null,
        this.target = null,
        this.legacy = !1,
        this.resolution = 1,
        this.multisample = De.NONE,
        this.sourceFrame = new qt,
        this.destinationFrame = new qt,
        this.bindingSourceFrame = new qt,
        this.bindingDestinationFrame = new qt,
        this.filters = [],
        this.transform = null
    }
    clear() {
        this.target = null,
        this.filters = null,
        this.renderTexture = null
    }
}
const Il = [new Zt, new Zt, new Zt, new Zt]
  , eu = new pe;
class j_ {
    constructor(t) {
        this.renderer = t,
        this.defaultFilterStack = [{}],
        this.texturePool = new z_,
        this.statePool = [],
        this.quad = new H4,
        this.quadUv = new $_,
        this.tempRect = new qt,
        this.activeState = {},
        this.globalUniforms = new hs({
            outputFrame: new qt,
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4)
        },!0),
        this.forceClear = !1,
        this.useMaxPadding = !1
    }
    init() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    push(t, i) {
        const s = this.renderer
          , n = this.defaultFilterStack
          , r = this.statePool.pop() || new V4
          , o = this.renderer.renderTexture;
        let a = i[0].resolution
          , l = i[0].multisample
          , c = i[0].padding
          , h = i[0].autoFit
          , u = i[0].legacy ?? !0;
        for (let p = 1; p < i.length; p++) {
            const m = i[p];
            a = Math.min(a, m.resolution),
            l = Math.min(l, m.multisample),
            c = this.useMaxPadding ? Math.max(c, m.padding) : c + m.padding,
            h = h && m.autoFit,
            u = u || (m.legacy ?? !0)
        }
        n.length === 1 && (this.defaultFilterStack[0].renderTexture = o.current),
        n.push(r),
        r.resolution = a,
        r.multisample = l,
        r.legacy = u,
        r.target = t,
        r.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)),
        r.sourceFrame.pad(c);
        const d = this.tempRect.copyFrom(o.sourceFrame);
        s.projection.transform && this.transformAABB(eu.copyFrom(s.projection.transform).invert(), d),
        h ? (r.sourceFrame.fit(d),
        (r.sourceFrame.width <= 0 || r.sourceFrame.height <= 0) && (r.sourceFrame.width = 0,
        r.sourceFrame.height = 0)) : r.sourceFrame.intersects(d) || (r.sourceFrame.width = 0,
        r.sourceFrame.height = 0),
        this.roundFrame(r.sourceFrame, o.current ? o.current.resolution : s.resolution, o.sourceFrame, o.destinationFrame, s.projection.transform),
        r.renderTexture = this.getOptimalFilterTexture(r.sourceFrame.width, r.sourceFrame.height, a, l),
        r.filters = i,
        r.destinationFrame.width = r.renderTexture.width,
        r.destinationFrame.height = r.renderTexture.height;
        const f = this.tempRect;
        f.x = 0,
        f.y = 0,
        f.width = r.sourceFrame.width,
        f.height = r.sourceFrame.height,
        r.renderTexture.filterFrame = r.sourceFrame,
        r.bindingSourceFrame.copyFrom(o.sourceFrame),
        r.bindingDestinationFrame.copyFrom(o.destinationFrame),
        r.transform = s.projection.transform,
        s.projection.transform = null,
        o.bind(r.renderTexture, r.sourceFrame, f),
        s.framebuffer.clear(0, 0, 0, 0)
    }
    pop() {
        const t = this.defaultFilterStack
          , i = t.pop()
          , s = i.filters;
        this.activeState = i;
        const n = this.globalUniforms.uniforms;
        n.outputFrame = i.sourceFrame,
        n.resolution = i.resolution;
        const r = n.inputSize
          , o = n.inputPixel
          , a = n.inputClamp;
        if (r[0] = i.destinationFrame.width,
        r[1] = i.destinationFrame.height,
        r[2] = 1 / r[0],
        r[3] = 1 / r[1],
        o[0] = Math.round(r[0] * i.resolution),
        o[1] = Math.round(r[1] * i.resolution),
        o[2] = 1 / o[0],
        o[3] = 1 / o[1],
        a[0] = .5 * o[2],
        a[1] = .5 * o[3],
        a[2] = i.sourceFrame.width * r[2] - .5 * o[2],
        a[3] = i.sourceFrame.height * r[3] - .5 * o[3],
        i.legacy) {
            const c = n.filterArea;
            c[0] = i.destinationFrame.width,
            c[1] = i.destinationFrame.height,
            c[2] = i.sourceFrame.x,
            c[3] = i.sourceFrame.y,
            n.filterClamp = n.inputClamp
        }
        this.globalUniforms.update();
        const l = t[t.length - 1];
        if (this.renderer.framebuffer.blit(),
        s.length === 1)
            s[0].apply(this, i.renderTexture, l.renderTexture, Ss.BLEND, i),
            this.returnFilterTexture(i.renderTexture);
        else {
            let c = i.renderTexture
              , h = this.getOptimalFilterTexture(c.width, c.height, i.resolution);
            h.filterFrame = c.filterFrame;
            let u = 0;
            for (u = 0; u < s.length - 1; ++u) {
                u === 1 && i.multisample > 1 && (h = this.getOptimalFilterTexture(c.width, c.height, i.resolution),
                h.filterFrame = c.filterFrame),
                s[u].apply(this, c, h, Ss.CLEAR, i);
                const d = c;
                c = h,
                h = d
            }
            s[u].apply(this, c, l.renderTexture, Ss.BLEND, i),
            u > 1 && i.multisample > 1 && this.returnFilterTexture(i.renderTexture),
            this.returnFilterTexture(c),
            this.returnFilterTexture(h)
        }
        i.clear(),
        this.statePool.push(i)
    }
    bindAndClear(t, i=Ss.CLEAR) {
        const {renderTexture: s, state: n} = this.renderer;
        if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null,
        t?.filterFrame) {
            const o = this.tempRect;
            o.x = 0,
            o.y = 0,
            o.width = t.filterFrame.width,
            o.height = t.filterFrame.height,
            s.bind(t, t.filterFrame, o)
        } else
            t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? s.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
        const r = n.stateId & 1 || this.forceClear;
        (i === Ss.CLEAR || i === Ss.BLIT && r) && this.renderer.framebuffer.clear(0, 0, 0, 0)
    }
    applyFilter(t, i, s, n) {
        const r = this.renderer;
        r.state.set(t.state),
        this.bindAndClear(s, n),
        t.uniforms.uSampler = i,
        t.uniforms.filterGlobals = this.globalUniforms,
        r.shader.bind(t),
        t.legacy = !!t.program.attributeData.aTextureCoord,
        t.legacy ? (this.quadUv.map(i._frame, i.filterFrame),
        r.geometry.bind(this.quadUv),
        r.geometry.draw(rs.TRIANGLES)) : (r.geometry.bind(this.quad),
        r.geometry.draw(rs.TRIANGLE_STRIP))
    }
    calculateSpriteMatrix(t, i) {
        const {sourceFrame: s, destinationFrame: n} = this.activeState
          , {orig: r} = i._texture
          , o = t.set(n.width, 0, 0, n.height, s.x, s.y)
          , a = i.worldTransform.copyTo(pe.TEMP_MATRIX);
        return a.invert(),
        o.prepend(a),
        o.scale(1 / r.width, 1 / r.height),
        o.translate(i.anchor.x, i.anchor.y),
        o
    }
    destroy() {
        this.renderer = null,
        this.texturePool.clear(!1)
    }
    getOptimalFilterTexture(t, i, s=1, n=De.NONE) {
        return this.texturePool.getOptimalTexture(t, i, s, n)
    }
    getFilterTexture(t, i, s) {
        if (typeof t == "number") {
            const r = t;
            t = i,
            i = r
        }
        t = t || this.activeState.renderTexture;
        const n = this.texturePool.getOptimalTexture(t.width, t.height, i || t.resolution, s || De.NONE);
        return n.filterFrame = t.filterFrame,
        n
    }
    returnFilterTexture(t) {
        this.texturePool.returnTexture(t)
    }
    emptyPool() {
        this.texturePool.clear(!0)
    }
    resize() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    transformAABB(t, i) {
        const s = Il[0]
          , n = Il[1]
          , r = Il[2]
          , o = Il[3];
        s.set(i.left, i.top),
        n.set(i.left, i.bottom),
        r.set(i.right, i.top),
        o.set(i.right, i.bottom),
        t.apply(s, s),
        t.apply(n, n),
        t.apply(r, r),
        t.apply(o, o);
        const a = Math.min(s.x, n.x, r.x, o.x)
          , l = Math.min(s.y, n.y, r.y, o.y)
          , c = Math.max(s.x, n.x, r.x, o.x)
          , h = Math.max(s.y, n.y, r.y, o.y);
        i.x = a,
        i.y = l,
        i.width = c - a,
        i.height = h - l
    }
    roundFrame(t, i, s, n, r) {
        if (!(t.width <= 0 || t.height <= 0 || s.width <= 0 || s.height <= 0)) {
            if (r) {
                const {a: o, b: a, c: l, d: c} = r;
                if ((Math.abs(a) > 1e-4 || Math.abs(l) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(c) > 1e-4))
                    return
            }
            r = r ? eu.copyFrom(r) : eu.identity(),
            r.translate(-s.x, -s.y).scale(n.width / s.width, n.height / s.height).translate(n.x, n.y),
            this.transformAABB(r, t),
            t.ceil(i),
            this.transformAABB(r.invert(), t)
        }
    }
}
j_.extension = {
    type: lt.RendererSystem,
    name: "filter"
};
vt.add(j_);
class z4 {
    constructor(t) {
        this.framebuffer = t,
        this.stencil = null,
        this.dirtyId = -1,
        this.dirtyFormat = -1,
        this.dirtySize = -1,
        this.multisample = De.NONE,
        this.msaaBuffer = null,
        this.blitFramebuffer = null,
        this.mipLevel = 0
    }
}
const $4 = new qt;
class W_ {
    constructor(t) {
        this.renderer = t,
        this.managedFramebuffers = [],
        this.unknownFramebuffer = new dd(10,10),
        this.msaaSamples = null
    }
    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID,
        this.current = this.unknownFramebuffer,
        this.viewport = new qt,
        this.hasMRT = !0,
        this.writeDepthTexture = !0,
        this.renderer.context.webGLVersion === 1) {
            let i = this.renderer.context.extensions.drawBuffers
              , s = this.renderer.context.extensions.depthTexture;
            ft.PREFER_ENV === Lr.WEBGL_LEGACY && (i = null,
            s = null),
            i ? t.drawBuffers = n=>i.drawBuffersWEBGL(n) : (this.hasMRT = !1,
            t.drawBuffers = ()=>{}
            ),
            s || (this.writeDepthTexture = !1)
        } else
            this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
    }
    bind(t, i, s=0) {
        const {gl: n} = this;
        if (t) {
            const r = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
            this.current !== t && (this.current = t,
            n.bindFramebuffer(n.FRAMEBUFFER, r.framebuffer)),
            r.mipLevel !== s && (t.dirtyId++,
            t.dirtyFormat++,
            r.mipLevel = s),
            r.dirtyId !== t.dirtyId && (r.dirtyId = t.dirtyId,
            r.dirtyFormat !== t.dirtyFormat ? (r.dirtyFormat = t.dirtyFormat,
            r.dirtySize = t.dirtySize,
            this.updateFramebuffer(t, s)) : r.dirtySize !== t.dirtySize && (r.dirtySize = t.dirtySize,
            this.resizeFramebuffer(t)));
            for (let o = 0; o < t.colorTextures.length; o++) {
                const a = t.colorTextures[o];
                this.renderer.texture.unbind(a.parentTextureArray || a)
            }
            if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture),
            i) {
                const o = i.width >> s
                  , a = i.height >> s
                  , l = o / i.width;
                this.setViewport(i.x * l, i.y * l, o, a)
            } else {
                const o = t.width >> s
                  , a = t.height >> s;
                this.setViewport(0, 0, o, a)
            }
        } else
            this.current && (this.current = null,
            n.bindFramebuffer(n.FRAMEBUFFER, null)),
            i ? this.setViewport(i.x, i.y, i.width, i.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
    }
    setViewport(t, i, s, n) {
        const r = this.viewport;
        t = Math.round(t),
        i = Math.round(i),
        s = Math.round(s),
        n = Math.round(n),
        (r.width !== s || r.height !== n || r.x !== t || r.y !== i) && (r.x = t,
        r.y = i,
        r.width = s,
        r.height = n,
        this.gl.viewport(t, i, s, n))
    }
    get size() {
        return this.current ? {
            x: 0,
            y: 0,
            width: this.current.width,
            height: this.current.height
        } : {
            x: 0,
            y: 0,
            width: this.renderer.width,
            height: this.renderer.height
        }
    }
    clear(t, i, s, n, r=Yu.COLOR | Yu.DEPTH) {
        const {gl: o} = this;
        o.clearColor(t, i, s, n),
        o.clear(r)
    }
    initFramebuffer(t) {
        const {gl: i} = this
          , s = new z4(i.createFramebuffer());
        return s.multisample = this.detectSamples(t.multisample),
        t.glFramebuffers[this.CONTEXT_UID] = s,
        this.managedFramebuffers.push(t),
        t.disposeRunner.add(this),
        s
    }
    resizeFramebuffer(t) {
        const {gl: i} = this
          , s = t.glFramebuffers[this.CONTEXT_UID];
        s.stencil && (i.bindRenderbuffer(i.RENDERBUFFER, s.stencil),
        s.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, s.multisample, i.DEPTH24_STENCIL8, t.width, t.height) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t.width, t.height));
        const n = t.colorTextures;
        let r = n.length;
        i.drawBuffers || (r = Math.min(r, 1));
        for (let o = 0; o < r; o++) {
            const a = n[o]
              , l = a.parentTextureArray || a;
            this.renderer.texture.bind(l, 0),
            o === 0 && s.msaaBuffer && (i.bindRenderbuffer(i.RENDERBUFFER, s.msaaBuffer),
            i.renderbufferStorageMultisample(i.RENDERBUFFER, s.multisample, l._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height))
        }
        t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0)
    }
    updateFramebuffer(t, i) {
        const {gl: s} = this
          , n = t.glFramebuffers[this.CONTEXT_UID]
          , r = t.colorTextures;
        let o = r.length;
        s.drawBuffers || (o = Math.min(o, 1)),
        n.multisample > 1 && this.canMultisampleFramebuffer(t) ? n.msaaBuffer = n.msaaBuffer || s.createRenderbuffer() : n.msaaBuffer && (s.deleteRenderbuffer(n.msaaBuffer),
        n.msaaBuffer = null,
        n.blitFramebuffer && (n.blitFramebuffer.dispose(),
        n.blitFramebuffer = null));
        const a = [];
        for (let l = 0; l < o; l++) {
            const c = r[l]
              , h = c.parentTextureArray || c;
            this.renderer.texture.bind(h, 0),
            l === 0 && n.msaaBuffer ? (s.bindRenderbuffer(s.RENDERBUFFER, n.msaaBuffer),
            s.renderbufferStorageMultisample(s.RENDERBUFFER, n.multisample, h._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height),
            s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, n.msaaBuffer)) : (s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + l, c.target, h._glTextures[this.CONTEXT_UID].texture, i),
            a.push(s.COLOR_ATTACHMENT0 + l))
        }
        if (a.length > 1 && s.drawBuffers(a),
        t.depthTexture && this.writeDepthTexture) {
            const c = t.depthTexture;
            this.renderer.texture.bind(c, 0),
            s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, c._glTextures[this.CONTEXT_UID].texture, i)
        }
        (t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (n.stencil = n.stencil || s.createRenderbuffer(),
        s.bindRenderbuffer(s.RENDERBUFFER, n.stencil),
        n.msaaBuffer ? s.renderbufferStorageMultisample(s.RENDERBUFFER, n.multisample, s.DEPTH24_STENCIL8, t.width, t.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, t.width, t.height),
        s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, n.stencil)) : n.stencil && (s.deleteRenderbuffer(n.stencil),
        n.stencil = null)
    }
    canMultisampleFramebuffer(t) {
        return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture
    }
    detectSamples(t) {
        const {msaaSamples: i} = this;
        let s = De.NONE;
        if (t <= 1 || i === null)
            return s;
        for (let n = 0; n < i.length; n++)
            if (i[n] <= t) {
                s = i[n];
                break
            }
        return s === 1 && (s = De.NONE),
        s
    }
    blit(t, i, s) {
        const {current: n, renderer: r, gl: o, CONTEXT_UID: a} = this;
        if (r.context.webGLVersion !== 2 || !n)
            return;
        const l = n.glFramebuffers[a];
        if (!l)
            return;
        if (!t) {
            if (!l.msaaBuffer)
                return;
            const h = n.colorTextures[0];
            if (!h)
                return;
            l.blitFramebuffer || (l.blitFramebuffer = new dd(n.width,n.height),
            l.blitFramebuffer.addColorTexture(0, h)),
            t = l.blitFramebuffer,
            t.colorTextures[0] !== h && (t.colorTextures[0] = h,
            t.dirtyId++,
            t.dirtyFormat++),
            (t.width !== n.width || t.height !== n.height) && (t.width = n.width,
            t.height = n.height,
            t.dirtyId++,
            t.dirtySize++)
        }
        i || (i = $4,
        i.width = n.width,
        i.height = n.height),
        s || (s = i);
        const c = i.width === s.width && i.height === s.height;
        this.bind(t),
        o.bindFramebuffer(o.READ_FRAMEBUFFER, l.framebuffer),
        o.blitFramebuffer(i.left, i.top, i.right, i.bottom, s.left, s.top, s.right, s.bottom, o.COLOR_BUFFER_BIT, c ? o.NEAREST : o.LINEAR)
    }
    disposeFramebuffer(t, i) {
        const s = t.glFramebuffers[this.CONTEXT_UID]
          , n = this.gl;
        if (!s)
            return;
        delete t.glFramebuffers[this.CONTEXT_UID];
        const r = this.managedFramebuffers.indexOf(t);
        r >= 0 && this.managedFramebuffers.splice(r, 1),
        t.disposeRunner.remove(this),
        i || (n.deleteFramebuffer(s.framebuffer),
        s.msaaBuffer && n.deleteRenderbuffer(s.msaaBuffer),
        s.stencil && n.deleteRenderbuffer(s.stencil)),
        s.blitFramebuffer && s.blitFramebuffer.dispose()
    }
    disposeAll(t) {
        const i = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (let s = 0; s < i.length; s++)
            this.disposeFramebuffer(i[s], t)
    }
    forceStencil() {
        const t = this.current;
        if (!t)
            return;
        const i = t.glFramebuffers[this.CONTEXT_UID];
        if (!i || i.stencil)
            return;
        t.stencil = !0;
        const s = t.width
          , n = t.height
          , r = this.gl
          , o = r.createRenderbuffer();
        r.bindRenderbuffer(r.RENDERBUFFER, o),
        i.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, i.multisample, r.DEPTH24_STENCIL8, s, n) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, s, n),
        i.stencil = o,
        r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, o)
    }
    reset() {
        this.current = this.unknownFramebuffer,
        this.viewport = new qt
    }
    destroy() {
        this.renderer = null
    }
}
W_.extension = {
    type: lt.RendererSystem,
    name: "framebuffer"
};
vt.add(W_);
const iu = {
    5126: 4,
    5123: 2,
    5121: 1
};
class X_ {
    constructor(t) {
        this.renderer = t,
        this._activeGeometry = null,
        this._activeVao = null,
        this.hasVao = !0,
        this.hasInstance = !0,
        this.canUseUInt32ElementIndex = !1,
        this.managedGeometries = {}
    }
    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl
          , i = this.renderer.context;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID,
        i.webGLVersion !== 2) {
            let s = this.renderer.context.extensions.vertexArrayObject;
            ft.PREFER_ENV === Lr.WEBGL_LEGACY && (s = null),
            s ? (t.createVertexArray = ()=>s.createVertexArrayOES(),
            t.bindVertexArray = n=>s.bindVertexArrayOES(n),
            t.deleteVertexArray = n=>s.deleteVertexArrayOES(n)) : (this.hasVao = !1,
            t.createVertexArray = ()=>null,
            t.bindVertexArray = ()=>null,
            t.deleteVertexArray = ()=>null)
        }
        if (i.webGLVersion !== 2) {
            const s = t.getExtension("ANGLE_instanced_arrays");
            s ? (t.vertexAttribDivisor = (n,r)=>s.vertexAttribDivisorANGLE(n, r),
            t.drawElementsInstanced = (n,r,o,a,l)=>s.drawElementsInstancedANGLE(n, r, o, a, l),
            t.drawArraysInstanced = (n,r,o,a)=>s.drawArraysInstancedANGLE(n, r, o, a)) : this.hasInstance = !1
        }
        this.canUseUInt32ElementIndex = i.webGLVersion === 2 || !!i.extensions.uint32ElementIndex
    }
    bind(t, i) {
        i = i || this.renderer.shader.shader;
        const {gl: s} = this;
        let n = t.glVertexArrayObjects[this.CONTEXT_UID]
          , r = !1;
        n || (this.managedGeometries[t.id] = t,
        t.disposeRunner.add(this),
        t.glVertexArrayObjects[this.CONTEXT_UID] = n = {},
        r = !0);
        const o = n[i.program.id] || this.initGeometryVao(t, i, r);
        this._activeGeometry = t,
        this._activeVao !== o && (this._activeVao = o,
        this.hasVao ? s.bindVertexArray(o) : this.activateVao(t, i.program)),
        this.updateBuffers()
    }
    reset() {
        this.unbind()
    }
    updateBuffers() {
        const t = this._activeGeometry
          , i = this.renderer.buffer;
        for (let s = 0; s < t.buffers.length; s++) {
            const n = t.buffers[s];
            i.update(n)
        }
    }
    checkCompatibility(t, i) {
        const s = t.attributes
          , n = i.attributeData;
        for (const r in n)
            if (!s[r])
                throw new Error(`shader and geometry incompatible, geometry missing the "${r}" attribute`)
    }
    getSignature(t, i) {
        const s = t.attributes
          , n = i.attributeData
          , r = ["g", t.id];
        for (const o in s)
            n[o] && r.push(o, n[o].location);
        return r.join("-")
    }
    initGeometryVao(t, i, s=!0) {
        const n = this.gl
          , r = this.CONTEXT_UID
          , o = this.renderer.buffer
          , a = i.program;
        a.glPrograms[r] || this.renderer.shader.generateProgram(i),
        this.checkCompatibility(t, a);
        const l = this.getSignature(t, a)
          , c = t.glVertexArrayObjects[this.CONTEXT_UID];
        let h = c[l];
        if (h)
            return c[a.id] = h,
            h;
        const u = t.buffers
          , d = t.attributes
          , f = {}
          , p = {};
        for (const m in u)
            f[m] = 0,
            p[m] = 0;
        for (const m in d)
            !d[m].size && a.attributeData[m] ? d[m].size = a.attributeData[m].size : d[m].size || console.warn(`PIXI Geometry attribute '${m}' size cannot be determined (likely the bound shader does not have the attribute)`),
            f[d[m].buffer] += d[m].size * iu[d[m].type];
        for (const m in d) {
            const g = d[m]
              , y = g.size;
            g.stride === void 0 && (f[g.buffer] === y * iu[g.type] ? g.stride = 0 : g.stride = f[g.buffer]),
            g.start === void 0 && (g.start = p[g.buffer],
            p[g.buffer] += y * iu[g.type])
        }
        h = n.createVertexArray(),
        n.bindVertexArray(h);
        for (let m = 0; m < u.length; m++) {
            const g = u[m];
            o.bind(g),
            s && g._glBuffers[r].refCount++
        }
        return this.activateVao(t, a),
        c[a.id] = h,
        c[l] = h,
        n.bindVertexArray(null),
        o.unbind(Ps.ARRAY_BUFFER),
        h
    }
    disposeGeometry(t, i) {
        if (!this.managedGeometries[t.id])
            return;
        delete this.managedGeometries[t.id];
        const s = t.glVertexArrayObjects[this.CONTEXT_UID]
          , n = this.gl
          , r = t.buffers
          , o = this.renderer?.buffer;
        if (t.disposeRunner.remove(this),
        !!s) {
            if (o)
                for (let a = 0; a < r.length; a++) {
                    const l = r[a]._glBuffers[this.CONTEXT_UID];
                    l && (l.refCount--,
                    l.refCount === 0 && !i && o.dispose(r[a], i))
                }
            if (!i) {
                for (const a in s)
                    if (a[0] === "g") {
                        const l = s[a];
                        this._activeVao === l && this.unbind(),
                        n.deleteVertexArray(l)
                    }
            }
            delete t.glVertexArrayObjects[this.CONTEXT_UID]
        }
    }
    disposeAll(t) {
        const i = Object.keys(this.managedGeometries);
        for (let s = 0; s < i.length; s++)
            this.disposeGeometry(this.managedGeometries[i[s]], t)
    }
    activateVao(t, i) {
        const s = this.gl
          , n = this.CONTEXT_UID
          , r = this.renderer.buffer
          , o = t.buffers
          , a = t.attributes;
        t.indexBuffer && r.bind(t.indexBuffer);
        let l = null;
        for (const c in a) {
            const h = a[c]
              , u = o[h.buffer]
              , d = u._glBuffers[n];
            if (i.attributeData[c]) {
                l !== d && (r.bind(u),
                l = d);
                const f = i.attributeData[c].location;
                if (s.enableVertexAttribArray(f),
                s.vertexAttribPointer(f, h.size, h.type || s.FLOAT, h.normalized, h.stride, h.start),
                h.instance)
                    if (this.hasInstance)
                        s.vertexAttribDivisor(f, h.divisor);
                    else
                        throw new Error("geometry error, GPU Instancing is not supported on this device")
            }
        }
    }
    draw(t, i, s, n) {
        const {gl: r} = this
          , o = this._activeGeometry;
        if (o.indexBuffer) {
            const a = o.indexBuffer.data.BYTES_PER_ELEMENT
              , l = a === 2 ? r.UNSIGNED_SHORT : r.UNSIGNED_INT;
            a === 2 || a === 4 && this.canUseUInt32ElementIndex ? o.instanced ? r.drawElementsInstanced(t, i || o.indexBuffer.data.length, l, (s || 0) * a, n || 1) : r.drawElements(t, i || o.indexBuffer.data.length, l, (s || 0) * a) : console.warn("unsupported index buffer type: uint32")
        } else
            o.instanced ? r.drawArraysInstanced(t, s, i || o.getSize(), n || 1) : r.drawArrays(t, s, i || o.getSize());
        return this
    }
    unbind() {
        this.gl.bindVertexArray(null),
        this._activeVao = null,
        this._activeGeometry = null
    }
    destroy() {
        this.renderer = null
    }
}
X_.extension = {
    type: lt.RendererSystem,
    name: "geometry"
};
vt.add(X_);
const dg = new pe;
class jf {
    constructor(t, i) {
        this._texture = t,
        this.mapCoord = new pe,
        this.uClampFrame = new Float32Array(4),
        this.uClampOffset = new Float32Array(2),
        this._textureID = -1,
        this._updateID = 0,
        this.clampOffset = 0,
        this.clampMargin = typeof i > "u" ? .5 : i,
        this.isSimple = !1
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture = t,
        this._textureID = -1
    }
    multiplyUvs(t, i) {
        i === void 0 && (i = t);
        const s = this.mapCoord;
        for (let n = 0; n < t.length; n += 2) {
            const r = t[n]
              , o = t[n + 1];
            i[n] = r * s.a + o * s.c + s.tx,
            i[n + 1] = r * s.b + o * s.d + s.ty
        }
        return i
    }
    update(t) {
        const i = this._texture;
        if (!i || !i.valid || !t && this._textureID === i._updateID)
            return !1;
        this._textureID = i._updateID,
        this._updateID++;
        const s = i._uvs;
        this.mapCoord.set(s.x1 - s.x0, s.y1 - s.y0, s.x3 - s.x0, s.y3 - s.y0, s.x0, s.y0);
        const n = i.orig
          , r = i.trim;
        r && (dg.set(n.width / r.width, 0, 0, n.height / r.height, -r.x / r.width, -r.y / r.height),
        this.mapCoord.append(dg));
        const o = i.baseTexture
          , a = this.uClampFrame
          , l = this.clampMargin / o.resolution
          , c = this.clampOffset;
        return a[0] = (i._frame.x + l + c) / o.width,
        a[1] = (i._frame.y + l + c) / o.height,
        a[2] = (i._frame.x + i._frame.width - l + c) / o.width,
        a[3] = (i._frame.y + i._frame.height - l + c) / o.height,
        this.uClampOffset[0] = c / o.realWidth,
        this.uClampOffset[1] = c / o.realHeight,
        this.isSimple = i._frame.width === o.width && i._frame.height === o.height && i.rotate === 0,
        !0
    }
}
var j4 = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`
  , W4 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;
class X4 extends qe {
    constructor(t, i, s) {
        let n = null;
        typeof t != "string" && i === void 0 && s === void 0 && (n = t,
        t = void 0,
        i = void 0,
        s = void 0),
        super(t || W4, i || j4, s),
        this.maskSprite = n,
        this.maskMatrix = new pe
    }
    get maskSprite() {
        return this._maskSprite
    }
    set maskSprite(t) {
        this._maskSprite = t,
        this._maskSprite && (this._maskSprite.renderable = !1)
    }
    apply(t, i, s, n) {
        const r = this._maskSprite
          , o = r._texture;
        !o.valid || (o.uvMatrix || (o.uvMatrix = new jf(o,0)),
        o.uvMatrix.update(),
        this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1,
        this.uniforms.mask = o,
        this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, r).prepend(o.uvMatrix.mapCoord),
        this.uniforms.alpha = r.worldAlpha,
        this.uniforms.maskClamp = o.uvMatrix.uClampFrame,
        t.applyFilter(this, i, s, n))
    }
}
class Y4 {
    constructor(t=null) {
        this.type = Ue.NONE,
        this.autoDetect = !0,
        this.maskObject = t || null,
        this.pooled = !1,
        this.isMaskData = !0,
        this.resolution = null,
        this.multisample = qe.defaultMultisample,
        this.enabled = !0,
        this.colorMask = 15,
        this._filters = null,
        this._stencilCounter = 0,
        this._scissorCounter = 0,
        this._scissorRect = null,
        this._scissorRectLocal = null,
        this._colorMask = 15,
        this._target = null
    }
    get filter() {
        return this._filters ? this._filters[0] : null
    }
    set filter(t) {
        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null
    }
    reset() {
        this.pooled && (this.maskObject = null,
        this.type = Ue.NONE,
        this.autoDetect = !0),
        this._target = null,
        this._scissorRectLocal = null
    }
    copyCountersOrReset(t) {
        t ? (this._stencilCounter = t._stencilCounter,
        this._scissorCounter = t._scissorCounter,
        this._scissorRect = t._scissorRect) : (this._stencilCounter = 0,
        this._scissorCounter = 0,
        this._scissorRect = null)
    }
}
class Y_ {
    constructor(t) {
        this.renderer = t,
        this.enableScissor = !0,
        this.alphaMaskPool = [],
        this.maskDataPool = [],
        this.maskStack = [],
        this.alphaMaskIndex = 0
    }
    setMaskStack(t) {
        this.maskStack = t,
        this.renderer.scissor.setMaskStack(t),
        this.renderer.stencil.setMaskStack(t)
    }
    push(t, i) {
        let s = i;
        if (!s.isMaskData) {
            const r = this.maskDataPool.pop() || new Y4;
            r.pooled = !0,
            r.maskObject = i,
            s = r
        }
        const n = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        if (s.copyCountersOrReset(n),
        s._colorMask = n ? n._colorMask : 15,
        s.autoDetect && this.detect(s),
        s._target = t,
        s.type !== Ue.SPRITE && this.maskStack.push(s),
        s.enabled)
            switch (s.type) {
            case Ue.SCISSOR:
                this.renderer.scissor.push(s);
                break;
            case Ue.STENCIL:
                this.renderer.stencil.push(s);
                break;
            case Ue.SPRITE:
                s.copyCountersOrReset(null),
                this.pushSpriteMask(s);
                break;
            case Ue.COLOR:
                this.pushColorMask(s);
                break
            }
        s.type === Ue.SPRITE && this.maskStack.push(s)
    }
    pop(t) {
        const i = this.maskStack.pop();
        if (!(!i || i._target !== t)) {
            if (i.enabled)
                switch (i.type) {
                case Ue.SCISSOR:
                    this.renderer.scissor.pop(i);
                    break;
                case Ue.STENCIL:
                    this.renderer.stencil.pop(i.maskObject);
                    break;
                case Ue.SPRITE:
                    this.popSpriteMask(i);
                    break;
                case Ue.COLOR:
                    this.popColorMask(i);
                    break
                }
            if (i.reset(),
            i.pooled && this.maskDataPool.push(i),
            this.maskStack.length !== 0) {
                const s = this.maskStack[this.maskStack.length - 1];
                s.type === Ue.SPRITE && s._filters && (s._filters[0].maskSprite = s.maskObject)
            }
        }
    }
    detect(t) {
        const i = t.maskObject;
        i ? i.isSprite ? t.type = Ue.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = Ue.SCISSOR : t.type = Ue.STENCIL : t.type = Ue.COLOR
    }
    pushSpriteMask(t) {
        const {maskObject: i} = t
          , s = t._target;
        let n = t._filters;
        n || (n = this.alphaMaskPool[this.alphaMaskIndex],
        n || (n = this.alphaMaskPool[this.alphaMaskIndex] = [new X4]));
        const r = this.renderer
          , o = r.renderTexture;
        let a, l;
        if (o.current) {
            const h = o.current;
            a = t.resolution || h.resolution,
            l = t.multisample ?? h.multisample
        } else
            a = t.resolution || r.resolution,
            l = t.multisample ?? r.multisample;
        n[0].resolution = a,
        n[0].multisample = l,
        n[0].maskSprite = i;
        const c = s.filterArea;
        s.filterArea = i.getBounds(!0),
        r.filter.push(s, n),
        s.filterArea = c,
        t._filters || this.alphaMaskIndex++
    }
    popSpriteMask(t) {
        this.renderer.filter.pop(),
        t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--,
        this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
    }
    pushColorMask(t) {
        const i = t._colorMask
          , s = t._colorMask = i & t.colorMask;
        s !== i && this.renderer.gl.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)
    }
    popColorMask(t) {
        const i = t._colorMask
          , s = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
        s !== i && this.renderer.gl.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)
    }
    destroy() {
        this.renderer = null
    }
}
Y_.extension = {
    type: lt.RendererSystem,
    name: "mask"
};
vt.add(Y_);
class K_ {
    constructor(t) {
        this.renderer = t,
        this.maskStack = [],
        this.glConst = 0
    }
    getStackLength() {
        return this.maskStack.length
    }
    setMaskStack(t) {
        const {gl: i} = this.renderer
          , s = this.getStackLength();
        this.maskStack = t;
        const n = this.getStackLength();
        n !== s && (n === 0 ? i.disable(this.glConst) : (i.enable(this.glConst),
        this._useCurrent()))
    }
    _useCurrent() {}
    destroy() {
        this.renderer = null,
        this.maskStack = null
    }
}
const fg = new pe
  , pg = []
  , ql = class extends K_ {
    constructor(e) {
        super(e),
        this.glConst = ft.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST
    }
    getStackLength() {
        const e = this.maskStack[this.maskStack.length - 1];
        return e ? e._scissorCounter : 0
    }
    calcScissorRect(e) {
        if (e._scissorRectLocal)
            return;
        const t = e._scissorRect
          , {maskObject: i} = e
          , {renderer: s} = this
          , n = s.renderTexture
          , r = i.getBounds(!0, pg.pop() ?? new qt);
        this.roundFrameToPixels(r, n.current ? n.current.resolution : s.resolution, n.sourceFrame, n.destinationFrame, s.projection.transform),
        t && r.fit(t),
        e._scissorRectLocal = r
    }
    static isMatrixRotated(e) {
        if (!e)
            return !1;
        const {a: t, b: i, c: s, d: n} = e;
        return (Math.abs(i) > 1e-4 || Math.abs(s) > 1e-4) && (Math.abs(t) > 1e-4 || Math.abs(n) > 1e-4)
    }
    testScissor(e) {
        const {maskObject: t} = e;
        if (!t.isFastRect || !t.isFastRect() || ql.isMatrixRotated(t.worldTransform) || ql.isMatrixRotated(this.renderer.projection.transform))
            return !1;
        this.calcScissorRect(e);
        const i = e._scissorRectLocal;
        return i.width > 0 && i.height > 0
    }
    roundFrameToPixels(e, t, i, s, n) {
        ql.isMatrixRotated(n) || (n = n ? fg.copyFrom(n) : fg.identity(),
        n.translate(-i.x, -i.y).scale(s.width / i.width, s.height / i.height).translate(s.x, s.y),
        this.renderer.filter.transformAABB(n, e),
        e.fit(s),
        e.x = Math.round(e.x * t),
        e.y = Math.round(e.y * t),
        e.width = Math.round(e.width * t),
        e.height = Math.round(e.height * t))
    }
    push(e) {
        e._scissorRectLocal || this.calcScissorRect(e);
        const {gl: t} = this.renderer;
        e._scissorRect || t.enable(t.SCISSOR_TEST),
        e._scissorCounter++,
        e._scissorRect = e._scissorRectLocal,
        this._useCurrent()
    }
    pop(e) {
        const {gl: t} = this.renderer;
        e && pg.push(e._scissorRectLocal),
        this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST)
    }
    _useCurrent() {
        const e = this.maskStack[this.maskStack.length - 1]._scissorRect;
        let t;
        this.renderer.renderTexture.current ? t = e.y : t = this.renderer.height - e.height - e.y,
        this.renderer.gl.scissor(e.x, t, e.width, e.height)
    }
}
;
let Z_ = ql;
Z_.extension = {
    type: lt.RendererSystem,
    name: "scissor"
};
vt.add(Z_);
class q_ extends K_ {
    constructor(t) {
        super(t),
        this.glConst = ft.ADAPTER.getWebGLRenderingContext().STENCIL_TEST
    }
    getStackLength() {
        const t = this.maskStack[this.maskStack.length - 1];
        return t ? t._stencilCounter : 0
    }
    push(t) {
        const i = t.maskObject
          , {gl: s} = this.renderer
          , n = t._stencilCounter;
        n === 0 && (this.renderer.framebuffer.forceStencil(),
        s.clearStencil(0),
        s.clear(s.STENCIL_BUFFER_BIT),
        s.enable(s.STENCIL_TEST)),
        t._stencilCounter++;
        const r = t._colorMask;
        r !== 0 && (t._colorMask = 0,
        s.colorMask(!1, !1, !1, !1)),
        s.stencilFunc(s.EQUAL, n, 4294967295),
        s.stencilOp(s.KEEP, s.KEEP, s.INCR),
        i.renderable = !0,
        i.render(this.renderer),
        this.renderer.batch.flush(),
        i.renderable = !1,
        r !== 0 && (t._colorMask = r,
        s.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0)),
        this._useCurrent()
    }
    pop(t) {
        const i = this.renderer.gl;
        if (this.getStackLength() === 0)
            i.disable(i.STENCIL_TEST);
        else {
            const s = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null
              , n = s ? s._colorMask : 15;
            n !== 0 && (s._colorMask = 0,
            i.colorMask(!1, !1, !1, !1)),
            i.stencilOp(i.KEEP, i.KEEP, i.DECR),
            t.renderable = !0,
            t.render(this.renderer),
            this.renderer.batch.flush(),
            t.renderable = !1,
            n !== 0 && (s._colorMask = n,
            i.colorMask((n & 1) !== 0, (n & 2) !== 0, (n & 4) !== 0, (n & 8) !== 0)),
            this._useCurrent()
        }
    }
    _useCurrent() {
        const t = this.renderer.gl;
        t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295),
        t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
    }
}
q_.extension = {
    type: lt.RendererSystem,
    name: "stencil"
};
vt.add(q_);
class J_ {
    constructor(t) {
        this.renderer = t,
        this.plugins = {},
        Object.defineProperties(this.plugins, {
            extract: {
                enumerable: !1,
                get() {
                    return Qt("7.0.0", "renderer.plugins.extract has moved to renderer.extract"),
                    t.extract
                }
            },
            prepare: {
                enumerable: !1,
                get() {
                    return Qt("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"),
                    t.prepare
                }
            },
            interaction: {
                enumerable: !1,
                get() {
                    return Qt("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"),
                    t.events
                }
            }
        })
    }
    init(t) {
        for (const i in t)
            this.plugins[i] = new t[i](this.renderer)
    }
    destroy() {
        for (const t in this.plugins)
            this.plugins[t].destroy(),
            this.plugins[t] = null
    }
}
J_.extension = {
    type: [lt.RendererSystem, lt.CanvasRendererSystem],
    name: "_plugin"
};
vt.add(J_);
class Q_ {
    constructor(t) {
        this.renderer = t,
        this.destinationFrame = null,
        this.sourceFrame = null,
        this.defaultFrame = null,
        this.projectionMatrix = new pe,
        this.transform = null
    }
    update(t, i, s, n) {
        this.destinationFrame = t || this.destinationFrame || this.defaultFrame,
        this.sourceFrame = i || this.sourceFrame || t,
        this.calculateProjection(this.destinationFrame, this.sourceFrame, s, n),
        this.transform && this.projectionMatrix.append(this.transform);
        const r = this.renderer;
        r.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix,
        r.globalUniforms.update(),
        r.shader.shader && r.shader.syncUniformGroup(r.shader.shader.uniforms.globals)
    }
    calculateProjection(t, i, s, n) {
        const r = this.projectionMatrix
          , o = n ? -1 : 1;
        r.identity(),
        r.a = 1 / i.width * 2,
        r.d = o * (1 / i.height * 2),
        r.tx = -1 - i.x * r.a,
        r.ty = -o - i.y * r.d
    }
    setTransform(t) {}
    destroy() {
        this.renderer = null
    }
}
Q_.extension = {
    type: lt.RendererSystem,
    name: "projection"
};
vt.add(Q_);
const K4 = new uh;
class t1 {
    constructor(t) {
        this.renderer = t,
        this._tempMatrix = new pe
    }
    generateTexture(t, i) {
        const {region: s, ...n} = i || {}
          , r = s || t.getLocalBounds(null, !0);
        r.width === 0 && (r.width = 1),
        r.height === 0 && (r.height = 1);
        const o = fs.create({
            width: r.width,
            height: r.height,
            ...n
        });
        this._tempMatrix.tx = -r.x,
        this._tempMatrix.ty = -r.y;
        const a = t.transform;
        return t.transform = K4,
        this.renderer.render(t, {
            renderTexture: o,
            transform: this._tempMatrix,
            skipUpdateTransform: !!t.parent,
            blit: !0
        }),
        t.transform = a,
        o
    }
    destroy() {}
}
t1.extension = {
    type: [lt.RendererSystem, lt.CanvasRendererSystem],
    name: "textureGenerator"
};
vt.add(t1);
const Hn = new qt
  , ta = new qt;
class e1 {
    constructor(t) {
        this.renderer = t,
        this.defaultMaskStack = [],
        this.current = null,
        this.sourceFrame = new qt,
        this.destinationFrame = new qt,
        this.viewportFrame = new qt
    }
    bind(t=null, i, s) {
        const n = this.renderer;
        this.current = t;
        let r, o, a;
        t ? (r = t.baseTexture,
        a = r.resolution,
        i || (Hn.width = t.frame.width,
        Hn.height = t.frame.height,
        i = Hn),
        s || (ta.x = t.frame.x,
        ta.y = t.frame.y,
        ta.width = i.width,
        ta.height = i.height,
        s = ta),
        o = r.framebuffer) : (a = n.resolution,
        i || (Hn.width = n._view.screen.width,
        Hn.height = n._view.screen.height,
        i = Hn),
        s || (s = Hn,
        s.width = i.width,
        s.height = i.height));
        const l = this.viewportFrame;
        l.x = s.x * a,
        l.y = s.y * a,
        l.width = s.width * a,
        l.height = s.height * a,
        t || (l.y = n.view.height - (l.y + l.height)),
        l.ceil(),
        this.renderer.framebuffer.bind(o, l),
        this.renderer.projection.update(s, i, a, !o),
        t ? this.renderer.mask.setMaskStack(r.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack),
        this.sourceFrame.copyFrom(i),
        this.destinationFrame.copyFrom(s)
    }
    clear(t, i) {
        this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.renderer.background.colorRgba;
        const s = this.destinationFrame
          , n = this.current ? this.current.baseTexture : this.renderer._view.screen
          , r = s.width !== n.width || s.height !== n.height;
        if (r) {
            let {x: o, y: a, width: l, height: c} = this.viewportFrame;
            o = Math.round(o),
            a = Math.round(a),
            l = Math.round(l),
            c = Math.round(c),
            this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST),
            this.renderer.gl.scissor(o, a, l, c)
        }
        this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], i),
        r && this.renderer.scissor.pop()
    }
    resize() {
        this.bind(null)
    }
    reset() {
        this.bind(null)
    }
    destroy() {
        this.renderer = null
    }
}
e1.extension = {
    type: lt.RendererSystem,
    name: "renderTexture"
};
vt.add(e1);
class Z4 {
    constructor(t, i) {
        this.program = t,
        this.uniformData = i,
        this.uniformGroups = {},
        this.uniformDirtyGroups = {},
        this.uniformBufferBindings = {}
    }
    destroy() {
        this.uniformData = null,
        this.uniformGroups = null,
        this.uniformDirtyGroups = null,
        this.uniformBufferBindings = null,
        this.program = null
    }
}
function q4(e, t) {
    const i = {}
      , s = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
    for (let n = 0; n < s; n++) {
        const r = t.getActiveAttrib(e, n);
        if (r.name.startsWith("gl_"))
            continue;
        const o = F_(t, r.type)
          , a = {
            type: o,
            name: r.name,
            size: N_(o),
            location: t.getAttribLocation(e, r.name)
        };
        i[r.name] = a
    }
    return i
}
function J4(e, t) {
    const i = {}
      , s = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let n = 0; n < s; n++) {
        const r = t.getActiveUniform(e, n)
          , o = r.name.replace(/\[.*?\]$/, "")
          , a = !!r.name.match(/\[.*?\]$/)
          , l = F_(t, r.type);
        i[o] = {
            name: o,
            index: n,
            type: l,
            size: r.size,
            isArray: a,
            value: O_(l, r.size)
        }
    }
    return i
}
function Q4(e, t) {
    const i = og(e, e.VERTEX_SHADER, t.vertexSrc)
      , s = og(e, e.FRAGMENT_SHADER, t.fragmentSrc)
      , n = e.createProgram();
    e.attachShader(n, i),
    e.attachShader(n, s);
    const r = t.extra?.transformFeedbackVaryings;
    if (r && (typeof e.transformFeedbackVaryings != "function" ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : e.transformFeedbackVaryings(n, r.names, r.bufferMode === "separate" ? e.SEPARATE_ATTRIBS : e.INTERLEAVED_ATTRIBS)),
    e.linkProgram(n),
    e.getProgramParameter(n, e.LINK_STATUS) || I4(e, n, i, s),
    t.attributeData = q4(n, e),
    t.uniformData = J4(n, e),
    !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
        const l = Object.keys(t.attributeData);
        l.sort((c,h)=>c > h ? 1 : -1);
        for (let c = 0; c < l.length; c++)
            t.attributeData[l[c]].location = c,
            e.bindAttribLocation(n, c, l[c]);
        e.linkProgram(n)
    }
    e.deleteShader(i),
    e.deleteShader(s);
    const o = {};
    for (const l in t.uniformData) {
        const c = t.uniformData[l];
        o[l] = {
            location: e.getUniformLocation(n, l),
            value: O_(c.type, c.size)
        }
    }
    return new Z4(n,o)
}
function t6(e, t, i, s, n) {
    i.buffer.update(n)
}
const e6 = {
    float: `
        data[offset] = v;
    `,
    vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
    vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
    vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
    mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
    mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
    mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
}
  , i1 = {
    float: 4,
    vec2: 8,
    vec3: 12,
    vec4: 16,
    int: 4,
    ivec2: 8,
    ivec3: 12,
    ivec4: 16,
    uint: 4,
    uvec2: 8,
    uvec3: 12,
    uvec4: 16,
    bool: 4,
    bvec2: 8,
    bvec3: 12,
    bvec4: 16,
    mat2: 16 * 2,
    mat3: 16 * 3,
    mat4: 16 * 4
};
function i6(e) {
    const t = e.map(r=>({
        data: r,
        offset: 0,
        dataLen: 0,
        dirty: 0
    }));
    let i = 0
      , s = 0
      , n = 0;
    for (let r = 0; r < t.length; r++) {
        const o = t[r];
        if (i = i1[o.data.type],
        o.data.size > 1 && (i = Math.max(i, 16) * o.data.size),
        o.dataLen = i,
        s % i !== 0 && s < 16) {
            const a = s % i % 16;
            s += a,
            n += a
        }
        s + i > 16 ? (n = Math.ceil(n / 16) * 16,
        o.offset = n,
        n += i,
        s = i) : (o.offset = n,
        s += i,
        n += i)
    }
    return n = Math.ceil(n / 16) * 16,
    {
        uboElements: t,
        size: n
    }
}
function s6(e, t) {
    const i = [];
    for (const s in e)
        t[s] && i.push(t[s]);
    return i.sort((s,n)=>s.index - n.index),
    i
}
function n6(e, t) {
    if (!e.autoManage)
        return {
            size: 0,
            syncFunc: t6
        };
    const i = s6(e.uniforms, t)
      , {uboElements: s, size: n} = i6(i)
      , r = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
    for (let o = 0; o < s.length; o++) {
        const a = s[o]
          , l = e.uniforms[a.data.name]
          , c = a.data.name;
        let h = !1;
        for (let u = 0; u < _o.length; u++) {
            const d = _o[u];
            if (d.codeUbo && d.test(a.data, l)) {
                r.push(`offset = ${a.offset / 4};`, _o[u].codeUbo(a.data.name, l)),
                h = !0;
                break
            }
        }
        if (!h)
            if (a.data.size > 1) {
                const u = N_(a.data.type)
                  , d = Math.max(i1[a.data.type] / 16, 1)
                  , f = u / d
                  , p = (4 - f % 4) % 4;
                r.push(`
                cv = ud.${c}.value;
                v = uv.${c};
                offset = ${a.offset / 4};

                t = 0;

                for(var i=0; i < ${a.data.size * d}; i++)
                {
                    for(var j = 0; j < ${f}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${p};
                }

                `)
            } else {
                const u = e6[a.data.type];
                r.push(`
                cv = ud.${c}.value;
                v = uv.${c};
                offset = ${a.offset / 4};
                ${u};
                `)
            }
    }
    return r.push(`
       renderer.buffer.update(buffer);
    `),
    {
        size: n,
        syncFunc: new Function("ud","uv","renderer","syncData","buffer",r.join(`
`))
    }
}
let r6 = 0;
const Ml = {
    textureCount: 0,
    uboCount: 0
};
class s1 {
    constructor(t) {
        this.destroyed = !1,
        this.renderer = t,
        this.systemCheck(),
        this.gl = null,
        this.shader = null,
        this.program = null,
        this.cache = {},
        this._uboCache = {},
        this.id = r6++
    }
    systemCheck() {
        if (!R4())
            throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
    }
    contextChange(t) {
        this.gl = t,
        this.reset()
    }
    bind(t, i) {
        t.disposeRunner.add(this),
        t.uniforms.globals = this.renderer.globalUniforms;
        const s = t.program
          , n = s.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
        return this.shader = t,
        this.program !== s && (this.program = s,
        this.gl.useProgram(n.program)),
        i || (Ml.textureCount = 0,
        Ml.uboCount = 0,
        this.syncUniformGroup(t.uniformGroup, Ml)),
        n
    }
    setUniforms(t) {
        const i = this.shader.program
          , s = i.glPrograms[this.renderer.CONTEXT_UID];
        i.syncUniforms(s.uniformData, t, this.renderer)
    }
    syncUniformGroup(t, i) {
        const s = this.getGlProgram();
        (!t.static || t.dirtyId !== s.uniformDirtyGroups[t.id]) && (s.uniformDirtyGroups[t.id] = t.dirtyId,
        this.syncUniforms(t, s, i))
    }
    syncUniforms(t, i, s) {
        (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(i.uniformData, t.uniforms, this.renderer, s)
    }
    createSyncGroups(t) {
        const i = this.getSignature(t, this.shader.program.uniformData, "u");
        return this.cache[i] || (this.cache[i] = S4(t, this.shader.program.uniformData)),
        t.syncUniforms[this.shader.program.id] = this.cache[i],
        t.syncUniforms[this.shader.program.id]
    }
    syncUniformBufferGroup(t, i) {
        const s = this.getGlProgram();
        if (!t.static || t.dirtyId !== 0 || !s.uniformGroups[t.id]) {
            t.dirtyId = 0;
            const n = s.uniformGroups[t.id] || this.createSyncBufferGroup(t, s, i);
            t.buffer.update(),
            n(s.uniformData, t.uniforms, this.renderer, Ml, t.buffer)
        }
        this.renderer.buffer.bindBufferBase(t.buffer, s.uniformBufferBindings[i])
    }
    createSyncBufferGroup(t, i, s) {
        const {gl: n} = this.renderer;
        this.renderer.buffer.bind(t.buffer);
        const r = this.gl.getUniformBlockIndex(i.program, s);
        i.uniformBufferBindings[s] = this.shader.uniformBindCount,
        n.uniformBlockBinding(i.program, r, this.shader.uniformBindCount),
        this.shader.uniformBindCount++;
        const o = this.getSignature(t, this.shader.program.uniformData, "ubo");
        let a = this._uboCache[o];
        if (a || (a = this._uboCache[o] = n6(t, this.shader.program.uniformData)),
        t.autoManage) {
            const l = new Float32Array(a.size / 4);
            t.buffer.update(l)
        }
        return i.uniformGroups[t.id] = a.syncFunc,
        i.uniformGroups[t.id]
    }
    getSignature(t, i, s) {
        const n = t.uniforms
          , r = [`${s}-`];
        for (const o in n)
            r.push(o),
            i[o] && r.push(i[o].type);
        return r.join("-")
    }
    getGlProgram() {
        return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
    }
    generateProgram(t) {
        const i = this.gl
          , s = t.program
          , n = Q4(i, s);
        return s.glPrograms[this.renderer.CONTEXT_UID] = n,
        n
    }
    reset() {
        this.program = null,
        this.shader = null
    }
    disposeShader(t) {
        this.shader === t && (this.shader = null)
    }
    destroy() {
        this.renderer = null,
        this.destroyed = !0
    }
}
s1.extension = {
    type: lt.RendererSystem,
    name: "shader"
};
vt.add(s1);
class n1 {
    constructor(t) {
        this.renderer = t
    }
    run(t) {
        const i = this.renderer;
        i.emitWithCustomOptions(i.runners.init, t),
        t.hello && console.log(`PixiJS 7.1.2 - ${i.rendererLogId} - https://pixijs.com`),
        i.resize(this.renderer.screen.width, this.renderer.screen.height)
    }
    destroy() {}
}
n1.extension = {
    type: [lt.RendererSystem, lt.CanvasRendererSystem],
    name: "startup"
};
vt.add(n1);
function o6(e, t=[]) {
    return t[j.NORMAL] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.ADD] = [e.ONE, e.ONE],
    t[j.MULTIPLY] = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.SCREEN] = [e.ONE, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.OVERLAY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.DARKEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.LIGHTEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.COLOR_DODGE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.COLOR_BURN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.HARD_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.SOFT_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.DIFFERENCE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.EXCLUSION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.HUE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.SATURATION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.COLOR] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.LUMINOSITY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.NONE] = [0, 0],
    t[j.NORMAL_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.ADD_NPM] = [e.SRC_ALPHA, e.ONE, e.ONE, e.ONE],
    t[j.SCREEN_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA],
    t[j.SRC_IN] = [e.DST_ALPHA, e.ZERO],
    t[j.SRC_OUT] = [e.ONE_MINUS_DST_ALPHA, e.ZERO],
    t[j.SRC_ATOP] = [e.DST_ALPHA, e.ONE_MINUS_SRC_ALPHA],
    t[j.DST_OVER] = [e.ONE_MINUS_DST_ALPHA, e.ONE],
    t[j.DST_IN] = [e.ZERO, e.SRC_ALPHA],
    t[j.DST_OUT] = [e.ZERO, e.ONE_MINUS_SRC_ALPHA],
    t[j.DST_ATOP] = [e.ONE_MINUS_DST_ALPHA, e.SRC_ALPHA],
    t[j.XOR] = [e.ONE_MINUS_DST_ALPHA, e.ONE_MINUS_SRC_ALPHA],
    t[j.SUBTRACT] = [e.ONE, e.ONE, e.ONE, e.ONE, e.FUNC_REVERSE_SUBTRACT, e.FUNC_ADD],
    t
}
const a6 = 0
  , l6 = 1
  , c6 = 2
  , h6 = 3
  , u6 = 4
  , d6 = 5
  , fd = class {
    constructor() {
        this.gl = null,
        this.stateId = 0,
        this.polygonOffset = 0,
        this.blendMode = j.NONE,
        this._blendEq = !1,
        this.map = [],
        this.map[a6] = this.setBlend,
        this.map[l6] = this.setOffset,
        this.map[c6] = this.setCullFace,
        this.map[h6] = this.setDepthTest,
        this.map[u6] = this.setFrontFace,
        this.map[d6] = this.setDepthMask,
        this.checks = [],
        this.defaultState = new rn,
        this.defaultState.blend = !0
    }
    contextChange(e) {
        this.gl = e,
        this.blendModes = o6(e),
        this.set(this.defaultState),
        this.reset()
    }
    set(e) {
        if (e = e || this.defaultState,
        this.stateId !== e.data) {
            let t = this.stateId ^ e.data
              , i = 0;
            for (; t; )
                t & 1 && this.map[i].call(this, !!(e.data & 1 << i)),
                t = t >> 1,
                i++;
            this.stateId = e.data
        }
        for (let t = 0; t < this.checks.length; t++)
            this.checks[t](this, e)
    }
    forceState(e) {
        e = e || this.defaultState;
        for (let t = 0; t < this.map.length; t++)
            this.map[t].call(this, !!(e.data & 1 << t));
        for (let t = 0; t < this.checks.length; t++)
            this.checks[t](this, e);
        this.stateId = e.data
    }
    setBlend(e) {
        this.updateCheck(fd.checkBlendMode, e),
        this.gl[e ? "enable" : "disable"](this.gl.BLEND)
    }
    setOffset(e) {
        this.updateCheck(fd.checkPolygonOffset, e),
        this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
    }
    setDepthTest(e) {
        this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST)
    }
    setDepthMask(e) {
        this.gl.depthMask(e)
    }
    setCullFace(e) {
        this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE)
    }
    setFrontFace(e) {
        this.gl.frontFace(this.gl[e ? "CW" : "CCW"])
    }
    setBlendMode(e) {
        if (e === this.blendMode)
            return;
        this.blendMode = e;
        const t = this.blendModes[e]
          , i = this.gl;
        t.length === 2 ? i.blendFunc(t[0], t[1]) : i.blendFuncSeparate(t[0], t[1], t[2], t[3]),
        t.length === 6 ? (this._blendEq = !0,
        i.blendEquationSeparate(t[4], t[5])) : this._blendEq && (this._blendEq = !1,
        i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD))
    }
    setPolygonOffset(e, t) {
        this.gl.polygonOffset(e, t)
    }
    reset() {
        this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1),
        this.forceState(this.defaultState),
        this._blendEq = !0,
        this.blendMode = -1,
        this.setBlendMode(0)
    }
    updateCheck(e, t) {
        const i = this.checks.indexOf(e);
        t && i === -1 ? this.checks.push(e) : !t && i !== -1 && this.checks.splice(i, 1)
    }
    static checkBlendMode(e, t) {
        e.setBlendMode(t.blendMode)
    }
    static checkPolygonOffset(e, t) {
        e.setPolygonOffset(1, t.polygonOffset)
    }
    destroy() {
        this.gl = null
    }
}
;
let r1 = fd;
r1.extension = {
    type: lt.RendererSystem,
    name: "state"
};
vt.add(r1);
class o1 extends $o {
    constructor() {
        super(...arguments),
        this.runners = {},
        this._systemsHash = {}
    }
    setup(t) {
        this.addRunners(...t.runners);
        const i = (t.priority ?? []).filter(n=>t.systems[n])
          , s = [...i, ...Object.keys(t.systems).filter(n=>!i.includes(n))];
        for (const n of s)
            this.addSystem(t.systems[n], n)
    }
    addRunners(...t) {
        t.forEach(i=>{
            this.runners[i] = new cs(i)
        }
        )
    }
    addSystem(t, i) {
        const s = new t(this);
        if (this[i])
            throw new Error(`Whoops! The name "${i}" is already in use`);
        this[i] = s,
        this._systemsHash[i] = s;
        for (const n in this.runners)
            this.runners[n].add(s);
        return this
    }
    emitWithCustomOptions(t, i) {
        const s = Object.keys(this._systemsHash);
        t.items.forEach(n=>{
            const r = s.find(o=>this._systemsHash[o] === n);
            n[t.name](i[r])
        }
        )
    }
    destroy() {
        Object.values(this.runners).forEach(t=>{
            t.destroy()
        }
        ),
        this._systemsHash = {}
    }
}
const Jl = class {
    constructor(e) {
        this.renderer = e,
        this.count = 0,
        this.checkCount = 0,
        this.maxIdle = Jl.defaultMaxIdle,
        this.checkCountMax = Jl.defaultCheckCountMax,
        this.mode = Jl.defaultMode
    }
    postrender() {
        !this.renderer.objectRenderer.renderingToScreen || (this.count++,
        this.mode !== Df.MANUAL && (this.checkCount++,
        this.checkCount > this.checkCountMax && (this.checkCount = 0,
        this.run())))
    }
    run() {
        const e = this.renderer.texture
          , t = e.managedTextures;
        let i = !1;
        for (let s = 0; s < t.length; s++) {
            const n = t[s];
            !n.framebuffer && this.count - n.touched > this.maxIdle && (e.destroyTexture(n, !0),
            t[s] = null,
            i = !0)
        }
        if (i) {
            let s = 0;
            for (let n = 0; n < t.length; n++)
                t[n] !== null && (t[s++] = t[n]);
            t.length = s
        }
    }
    unload(e) {
        const t = this.renderer.texture
          , i = e._texture;
        i && !i.framebuffer && t.destroyTexture(i);
        for (let s = e.children.length - 1; s >= 0; s--)
            this.unload(e.children[s])
    }
    destroy() {
        this.renderer = null
    }
}
;
let ns = Jl;
ns.defaultMode = Df.AUTO;
ns.defaultMaxIdle = 60 * 60;
ns.defaultCheckCountMax = 60 * 10;
ns.extension = {
    type: lt.RendererSystem,
    name: "textureGC"
};
vt.add(ns);
class su {
    constructor(t) {
        this.texture = t,
        this.width = -1,
        this.height = -1,
        this.dirtyId = -1,
        this.dirtyStyleId = -1,
        this.mipmap = !1,
        this.wrapMode = 33071,
        this.type = Rt.UNSIGNED_BYTE,
        this.internalFormat = ot.RGBA,
        this.samplerType = 0
    }
}
function f6(e) {
    let t;
    return "WebGL2RenderingContext"in globalThis && e instanceof globalThis.WebGL2RenderingContext ? t = {
        [Rt.UNSIGNED_BYTE]: {
            [ot.RGBA]: e.RGBA8,
            [ot.RGB]: e.RGB8,
            [ot.RG]: e.RG8,
            [ot.RED]: e.R8,
            [ot.RGBA_INTEGER]: e.RGBA8UI,
            [ot.RGB_INTEGER]: e.RGB8UI,
            [ot.RG_INTEGER]: e.RG8UI,
            [ot.RED_INTEGER]: e.R8UI,
            [ot.ALPHA]: e.ALPHA,
            [ot.LUMINANCE]: e.LUMINANCE,
            [ot.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
        },
        [Rt.BYTE]: {
            [ot.RGBA]: e.RGBA8_SNORM,
            [ot.RGB]: e.RGB8_SNORM,
            [ot.RG]: e.RG8_SNORM,
            [ot.RED]: e.R8_SNORM,
            [ot.RGBA_INTEGER]: e.RGBA8I,
            [ot.RGB_INTEGER]: e.RGB8I,
            [ot.RG_INTEGER]: e.RG8I,
            [ot.RED_INTEGER]: e.R8I
        },
        [Rt.UNSIGNED_SHORT]: {
            [ot.RGBA_INTEGER]: e.RGBA16UI,
            [ot.RGB_INTEGER]: e.RGB16UI,
            [ot.RG_INTEGER]: e.RG16UI,
            [ot.RED_INTEGER]: e.R16UI,
            [ot.DEPTH_COMPONENT]: e.DEPTH_COMPONENT16
        },
        [Rt.SHORT]: {
            [ot.RGBA_INTEGER]: e.RGBA16I,
            [ot.RGB_INTEGER]: e.RGB16I,
            [ot.RG_INTEGER]: e.RG16I,
            [ot.RED_INTEGER]: e.R16I
        },
        [Rt.UNSIGNED_INT]: {
            [ot.RGBA_INTEGER]: e.RGBA32UI,
            [ot.RGB_INTEGER]: e.RGB32UI,
            [ot.RG_INTEGER]: e.RG32UI,
            [ot.RED_INTEGER]: e.R32UI,
            [ot.DEPTH_COMPONENT]: e.DEPTH_COMPONENT24
        },
        [Rt.INT]: {
            [ot.RGBA_INTEGER]: e.RGBA32I,
            [ot.RGB_INTEGER]: e.RGB32I,
            [ot.RG_INTEGER]: e.RG32I,
            [ot.RED_INTEGER]: e.R32I
        },
        [Rt.FLOAT]: {
            [ot.RGBA]: e.RGBA32F,
            [ot.RGB]: e.RGB32F,
            [ot.RG]: e.RG32F,
            [ot.RED]: e.R32F,
            [ot.DEPTH_COMPONENT]: e.DEPTH_COMPONENT32F
        },
        [Rt.HALF_FLOAT]: {
            [ot.RGBA]: e.RGBA16F,
            [ot.RGB]: e.RGB16F,
            [ot.RG]: e.RG16F,
            [ot.RED]: e.R16F
        },
        [Rt.UNSIGNED_SHORT_5_6_5]: {
            [ot.RGB]: e.RGB565
        },
        [Rt.UNSIGNED_SHORT_4_4_4_4]: {
            [ot.RGBA]: e.RGBA4
        },
        [Rt.UNSIGNED_SHORT_5_5_5_1]: {
            [ot.RGBA]: e.RGB5_A1
        },
        [Rt.UNSIGNED_INT_2_10_10_10_REV]: {
            [ot.RGBA]: e.RGB10_A2,
            [ot.RGBA_INTEGER]: e.RGB10_A2UI
        },
        [Rt.UNSIGNED_INT_10F_11F_11F_REV]: {
            [ot.RGB]: e.R11F_G11F_B10F
        },
        [Rt.UNSIGNED_INT_5_9_9_9_REV]: {
            [ot.RGB]: e.RGB9_E5
        },
        [Rt.UNSIGNED_INT_24_8]: {
            [ot.DEPTH_STENCIL]: e.DEPTH24_STENCIL8
        },
        [Rt.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
            [ot.DEPTH_STENCIL]: e.DEPTH32F_STENCIL8
        }
    } : t = {
        [Rt.UNSIGNED_BYTE]: {
            [ot.RGBA]: e.RGBA,
            [ot.RGB]: e.RGB,
            [ot.ALPHA]: e.ALPHA,
            [ot.LUMINANCE]: e.LUMINANCE,
            [ot.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
        },
        [Rt.UNSIGNED_SHORT_5_6_5]: {
            [ot.RGB]: e.RGB
        },
        [Rt.UNSIGNED_SHORT_4_4_4_4]: {
            [ot.RGBA]: e.RGBA
        },
        [Rt.UNSIGNED_SHORT_5_5_5_1]: {
            [ot.RGBA]: e.RGBA
        }
    },
    t
}
class a1 {
    constructor(t) {
        this.renderer = t,
        this.boundTextures = [],
        this.currentLocation = -1,
        this.managedTextures = [],
        this._unknownBoundTextures = !1,
        this.unknownTexture = new Ot,
        this.hasIntegerTextures = !1
    }
    contextChange() {
        const t = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID,
        this.webGLVersion = this.renderer.context.webGLVersion,
        this.internalFormats = f6(t);
        const i = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = i;
        for (let n = 0; n < i; n++)
            this.boundTextures[n] = null;
        this.emptyTextures = {};
        const s = new su(t.createTexture());
        t.bindTexture(t.TEXTURE_2D, s.texture),
        t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)),
        this.emptyTextures[t.TEXTURE_2D] = s,
        this.emptyTextures[t.TEXTURE_CUBE_MAP] = new su(t.createTexture()),
        t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
        for (let n = 0; n < 6; n++)
            t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
        t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR),
        t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
        for (let n = 0; n < this.boundTextures.length; n++)
            this.bind(null, n)
    }
    bind(t, i=0) {
        const {gl: s} = this;
        if (t = t?.castToBaseTexture(),
        t?.valid && !t.parentTextureArray) {
            t.touched = this.renderer.textureGC.count;
            const n = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
            this.boundTextures[i] !== t && (this.currentLocation !== i && (this.currentLocation = i,
            s.activeTexture(s.TEXTURE0 + i)),
            s.bindTexture(t.target, n.texture)),
            n.dirtyId !== t.dirtyId ? (this.currentLocation !== i && (this.currentLocation = i,
            s.activeTexture(s.TEXTURE0 + i)),
            this.updateTexture(t)) : n.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t),
            this.boundTextures[i] = t
        } else
            this.currentLocation !== i && (this.currentLocation = i,
            s.activeTexture(s.TEXTURE0 + i)),
            s.bindTexture(s.TEXTURE_2D, this.emptyTextures[s.TEXTURE_2D].texture),
            this.boundTextures[i] = null
    }
    reset() {
        this._unknownBoundTextures = !0,
        this.hasIntegerTextures = !1,
        this.currentLocation = -1;
        for (let t = 0; t < this.boundTextures.length; t++)
            this.boundTextures[t] = this.unknownTexture
    }
    unbind(t) {
        const {gl: i, boundTextures: s} = this;
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = !1;
            for (let n = 0; n < s.length; n++)
                s[n] === this.unknownTexture && this.bind(null, n)
        }
        for (let n = 0; n < s.length; n++)
            s[n] === t && (this.currentLocation !== n && (i.activeTexture(i.TEXTURE0 + n),
            this.currentLocation = n),
            i.bindTexture(t.target, this.emptyTextures[t.target].texture),
            s[n] = null)
    }
    ensureSamplerType(t) {
        const {boundTextures: i, hasIntegerTextures: s, CONTEXT_UID: n} = this;
        if (!!s)
            for (let r = t - 1; r >= 0; --r) {
                const o = i[r];
                o && o._glTextures[n].samplerType !== Ku.FLOAT && this.renderer.texture.unbind(o)
            }
    }
    initTexture(t) {
        const i = new su(this.gl.createTexture());
        return i.dirtyId = -1,
        t._glTextures[this.CONTEXT_UID] = i,
        this.managedTextures.push(t),
        t.on("dispose", this.destroyTexture, this),
        i
    }
    initTextureType(t, i) {
        i.internalFormat = this.internalFormats[t.type]?.[t.format] ?? t.format,
        this.webGLVersion === 2 && t.type === Rt.HALF_FLOAT ? i.type = this.gl.HALF_FLOAT : i.type = t.type
    }
    updateTexture(t) {
        const i = t._glTextures[this.CONTEXT_UID];
        if (!i)
            return;
        const s = this.renderer;
        if (this.initTextureType(t, i),
        t.resource?.upload(s, t, i))
            i.samplerType !== Ku.FLOAT && (this.hasIntegerTextures = !0);
        else {
            const n = t.realWidth
              , r = t.realHeight
              , o = s.gl;
            (i.width !== n || i.height !== r || i.dirtyId < 0) && (i.width = n,
            i.height = r,
            o.texImage2D(t.target, 0, i.internalFormat, n, r, 0, t.format, i.type, null))
        }
        t.dirtyStyleId !== i.dirtyStyleId && this.updateTextureStyle(t),
        i.dirtyId = t.dirtyId
    }
    destroyTexture(t, i) {
        const {gl: s} = this;
        if (t = t.castToBaseTexture(),
        t._glTextures[this.CONTEXT_UID] && (this.unbind(t),
        s.deleteTexture(t._glTextures[this.CONTEXT_UID].texture),
        t.off("dispose", this.destroyTexture, this),
        delete t._glTextures[this.CONTEXT_UID],
        !i)) {
            const n = this.managedTextures.indexOf(t);
            n !== -1 && wr(this.managedTextures, n, 1)
        }
    }
    updateTextureStyle(t) {
        const i = t._glTextures[this.CONTEXT_UID];
        !i || ((t.mipmap === ds.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? i.mipmap = !1 : i.mipmap = t.mipmap >= 1,
        this.webGLVersion !== 2 && !t.isPowerOfTwo ? i.wrapMode = Zs.CLAMP : i.wrapMode = t.wrapMode,
        t.resource?.style(this.renderer, t, i) || this.setStyle(t, i),
        i.dirtyStyleId = t.dirtyStyleId)
    }
    setStyle(t, i) {
        const s = this.gl;
        if (i.mipmap && t.mipmap !== ds.ON_MANUAL && s.generateMipmap(t.target),
        s.texParameteri(t.target, s.TEXTURE_WRAP_S, i.wrapMode),
        s.texParameteri(t.target, s.TEXTURE_WRAP_T, i.wrapMode),
        i.mipmap) {
            s.texParameteri(t.target, s.TEXTURE_MIN_FILTER, t.scaleMode === Hi.LINEAR ? s.LINEAR_MIPMAP_LINEAR : s.NEAREST_MIPMAP_NEAREST);
            const n = this.renderer.context.extensions.anisotropicFiltering;
            if (n && t.anisotropicLevel > 0 && t.scaleMode === Hi.LINEAR) {
                const r = Math.min(t.anisotropicLevel, s.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                s.texParameterf(t.target, n.TEXTURE_MAX_ANISOTROPY_EXT, r)
            }
        } else
            s.texParameteri(t.target, s.TEXTURE_MIN_FILTER, t.scaleMode === Hi.LINEAR ? s.LINEAR : s.NEAREST);
        s.texParameteri(t.target, s.TEXTURE_MAG_FILTER, t.scaleMode === Hi.LINEAR ? s.LINEAR : s.NEAREST)
    }
    destroy() {
        this.renderer = null
    }
}
a1.extension = {
    type: lt.RendererSystem,
    name: "texture"
};
vt.add(a1);
class l1 {
    constructor(t) {
        this.renderer = t
    }
    contextChange() {
        this.gl = this.renderer.gl,
        this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(t) {
        const {gl: i, CONTEXT_UID: s} = this
          , n = t._glTransformFeedbacks[s] || this.createGLTransformFeedback(t);
        i.bindTransformFeedback(i.TRANSFORM_FEEDBACK, n)
    }
    unbind() {
        const {gl: t} = this;
        t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null)
    }
    beginTransformFeedback(t, i) {
        const {gl: s, renderer: n} = this;
        i && n.shader.bind(i),
        s.beginTransformFeedback(t)
    }
    endTransformFeedback() {
        const {gl: t} = this;
        t.endTransformFeedback()
    }
    createGLTransformFeedback(t) {
        const {gl: i, renderer: s, CONTEXT_UID: n} = this
          , r = i.createTransformFeedback();
        t._glTransformFeedbacks[n] = r,
        i.bindTransformFeedback(i.TRANSFORM_FEEDBACK, r);
        for (let o = 0; o < t.buffers.length; o++) {
            const a = t.buffers[o];
            !a || (s.buffer.update(a),
            a._glBuffers[n].refCount++,
            i.bindBufferBase(i.TRANSFORM_FEEDBACK_BUFFER, o, a._glBuffers[n].buffer || null))
        }
        return i.bindTransformFeedback(i.TRANSFORM_FEEDBACK, null),
        t.disposeRunner.add(this),
        r
    }
    disposeTransformFeedback(t, i) {
        const s = t._glTransformFeedbacks[this.CONTEXT_UID]
          , n = this.gl;
        t.disposeRunner.remove(this);
        const r = this.renderer.buffer;
        if (r)
            for (let o = 0; o < t.buffers.length; o++) {
                const a = t.buffers[o];
                if (!a)
                    continue;
                const l = a._glBuffers[this.CONTEXT_UID];
                l && (l.refCount--,
                l.refCount === 0 && !i && r.dispose(a, i))
            }
        !s || (i || n.deleteTransformFeedback(s),
        delete t._glTransformFeedbacks[this.CONTEXT_UID])
    }
    destroy() {
        this.renderer = null
    }
}
l1.extension = {
    type: lt.RendererSystem,
    name: "transformFeedback"
};
vt.add(l1);
class c1 {
    constructor(t) {
        this.renderer = t
    }
    init(t) {
        this.screen = new qt(0,0,t.width,t.height),
        this.element = t.view || ft.ADAPTER.createCanvas(),
        this.resolution = t.resolution || ft.RESOLUTION,
        this.autoDensity = !!t.autoDensity
    }
    resizeView(t, i) {
        this.element.width = Math.round(t * this.resolution),
        this.element.height = Math.round(i * this.resolution);
        const s = this.element.width / this.resolution
          , n = this.element.height / this.resolution;
        this.screen.width = s,
        this.screen.height = n,
        this.autoDensity && (this.element.style.width = `${s}px`,
        this.element.style.height = `${n}px`),
        this.renderer.emit("resize", s, n),
        this.renderer.runners.resize.emit(this.screen.width, this.screen.height)
    }
    destroy(t) {
        t && this.element.parentNode?.removeChild(this.element),
        this.renderer = null,
        this.element = null,
        this.screen = null
    }
}
c1.extension = {
    type: [lt.RendererSystem, lt.CanvasRendererSystem],
    name: "_view"
};
vt.add(c1);
ft.PREFER_ENV = Lr.WEBGL2;
ft.STRICT_TEXTURE_CACHE = !1;
Object.defineProperties(ft, {
    WRAP_MODE: {
        get() {
            return Ot.defaultOptions.wrapMode
        },
        set(e) {
            Qt("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTexture.defaultOptions.wrapMode"),
            Ot.defaultOptions.wrapMode = e
        }
    },
    SCALE_MODE: {
        get() {
            return Ot.defaultOptions.scaleMode
        },
        set(e) {
            Qt("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTexture.defaultOptions.scaleMode"),
            Ot.defaultOptions.scaleMode = e
        }
    },
    MIPMAP_TEXTURES: {
        get() {
            return Ot.defaultOptions.mipmap
        },
        set(e) {
            Qt("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTexture.defaultOptions.mipmap"),
            Ot.defaultOptions.mipmap = e
        }
    },
    ANISOTROPIC_LEVEL: {
        get() {
            return Ot.defaultOptions.anisotropicLevel
        },
        set(e) {
            Qt("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTexture.defaultOptions.anisotropicLevel"),
            Ot.defaultOptions.anisotropicLevel = e
        }
    },
    FILTER_RESOLUTION: {
        get() {
            return Qt("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"),
            qe.defaultResolution
        },
        set(e) {
            qe.defaultResolution = e
        }
    },
    FILTER_MULTISAMPLE: {
        get() {
            return Qt("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"),
            qe.defaultMultisample
        },
        set(e) {
            qe.defaultMultisample = e
        }
    },
    SPRITE_MAX_TEXTURES: {
        get() {
            return ss.defaultMaxTextures
        },
        set(e) {
            Qt("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"),
            ss.defaultMaxTextures = e
        }
    },
    SPRITE_BATCH_SIZE: {
        get() {
            return ss.defaultBatchSize
        },
        set(e) {
            Qt("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"),
            ss.defaultBatchSize = e
        }
    },
    CAN_UPLOAD_SAME_BUFFER: {
        get() {
            return ss.canUploadSameBuffer
        },
        set(e) {
            Qt("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"),
            ss.canUploadSameBuffer = e
        }
    },
    GC_MODE: {
        get() {
            return ns.defaultMode
        },
        set(e) {
            Qt("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"),
            ns.defaultMode = e
        }
    },
    GC_MAX_IDLE: {
        get() {
            return ns.defaultMaxIdle
        },
        set(e) {
            Qt("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"),
            ns.defaultMaxIdle = e
        }
    },
    GC_MAX_CHECK_COUNT: {
        get() {
            return ns.defaultCheckCountMax
        },
        set(e) {
            Qt("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"),
            ns.defaultCheckCountMax = e
        }
    },
    PRECISION_VERTEX: {
        get() {
            return os.defaultVertexPrecision
        },
        set(e) {
            Qt("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"),
            os.defaultVertexPrecision = e
        }
    },
    PRECISION_FRAGMENT: {
        get() {
            return os.defaultFragmentPrecision
        },
        set(e) {
            Qt("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"),
            os.defaultFragmentPrecision = e
        }
    }
});
var Lo = (e=>(e[e.HIGH = 25] = "HIGH",
e[e.NORMAL = 0] = "NORMAL",
e[e.LOW = -25] = "LOW",
e[e.UTILITY = -50] = "UTILITY",
e))(Lo || {});
class nu {
    constructor(t, i=null, s=0, n=!1) {
        this.next = null,
        this.previous = null,
        this._destroyed = !1,
        this.fn = t,
        this.context = i,
        this.priority = s,
        this.once = n
    }
    match(t, i=null) {
        return this.fn === t && this.context === i
    }
    emit(t) {
        this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
        const i = this.next;
        return this.once && this.destroy(!0),
        this._destroyed && (this.next = null),
        i
    }
    connect(t) {
        this.previous = t,
        t.next && (t.next.previous = this),
        this.next = t.next,
        t.next = this
    }
    destroy(t=!1) {
        this._destroyed = !0,
        this.fn = null,
        this.context = null,
        this.previous && (this.previous.next = this.next),
        this.next && (this.next.previous = this.previous);
        const i = this.next;
        return this.next = t ? null : i,
        this.previous = null,
        i
    }
}
const Ei = class {
    constructor() {
        this.autoStart = !1,
        this.deltaTime = 1,
        this.lastTime = -1,
        this.speed = 1,
        this.started = !1,
        this._requestId = null,
        this._maxElapsedMS = 100,
        this._minElapsedMS = 0,
        this._protected = !1,
        this._lastFrame = -1,
        this._head = new nu(null,null,1 / 0),
        this.deltaMS = 1 / Ei.targetFPMS,
        this.elapsedMS = 1 / Ei.targetFPMS,
        this._tick = e=>{
            this._requestId = null,
            this.started && (this.update(e),
            this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
        }
    }
    _requestIfNeeded() {
        this._requestId === null && this._head.next && (this.lastTime = performance.now(),
        this._lastFrame = this.lastTime,
        this._requestId = requestAnimationFrame(this._tick))
    }
    _cancelIfNeeded() {
        this._requestId !== null && (cancelAnimationFrame(this._requestId),
        this._requestId = null)
    }
    _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
    }
    add(e, t, i=Lo.NORMAL) {
        return this._addListener(new nu(e,t,i))
    }
    addOnce(e, t, i=Lo.NORMAL) {
        return this._addListener(new nu(e,t,i,!0))
    }
    _addListener(e) {
        let t = this._head.next
          , i = this._head;
        if (!t)
            e.connect(i);
        else {
            for (; t; ) {
                if (e.priority > t.priority) {
                    e.connect(i);
                    break
                }
                i = t,
                t = t.next
            }
            e.previous || e.connect(i)
        }
        return this._startIfPossible(),
        this
    }
    remove(e, t) {
        let i = this._head.next;
        for (; i; )
            i.match(e, t) ? i = i.destroy() : i = i.next;
        return this._head.next || this._cancelIfNeeded(),
        this
    }
    get count() {
        if (!this._head)
            return 0;
        let e = 0
          , t = this._head;
        for (; t = t.next; )
            e++;
        return e
    }
    start() {
        this.started || (this.started = !0,
        this._requestIfNeeded())
    }
    stop() {
        this.started && (this.started = !1,
        this._cancelIfNeeded())
    }
    destroy() {
        if (!this._protected) {
            this.stop();
            let e = this._head.next;
            for (; e; )
                e = e.destroy(!0);
            this._head.destroy(),
            this._head = null
        }
    }
    update(e=performance.now()) {
        let t;
        if (e > this.lastTime) {
            if (t = this.elapsedMS = e - this.lastTime,
            t > this._maxElapsedMS && (t = this._maxElapsedMS),
            t *= this.speed,
            this._minElapsedMS) {
                const n = e - this._lastFrame | 0;
                if (n < this._minElapsedMS)
                    return;
                this._lastFrame = e - n % this._minElapsedMS
            }
            this.deltaMS = t,
            this.deltaTime = this.deltaMS * Ei.targetFPMS;
            const i = this._head;
            let s = i.next;
            for (; s; )
                s = s.emit(this.deltaTime);
            i.next || this._cancelIfNeeded()
        } else
            this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = e
    }
    get FPS() {
        return 1e3 / this.elapsedMS
    }
    get minFPS() {
        return 1e3 / this._maxElapsedMS
    }
    set minFPS(e) {
        const t = Math.min(this.maxFPS, e)
          , i = Math.min(Math.max(0, t) / 1e3, Ei.targetFPMS);
        this._maxElapsedMS = 1 / i
    }
    get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
    }
    set maxFPS(e) {
        if (e === 0)
            this._minElapsedMS = 0;
        else {
            const t = Math.max(this.minFPS, e);
            this._minElapsedMS = 1 / (t / 1e3)
        }
    }
    static get shared() {
        if (!Ei._shared) {
            const e = Ei._shared = new Ei;
            e.autoStart = !0,
            e._protected = !0
        }
        return Ei._shared
    }
    static get system() {
        if (!Ei._system) {
            const e = Ei._system = new Ei;
            e.autoStart = !0,
            e._protected = !0
        }
        return Ei._system
    }
}
;
let gi = Ei;
gi.targetFPMS = .06;
Object.defineProperties(ft, {
    TARGET_FPMS: {
        get() {
            return gi.targetFPMS
        },
        set(e) {
            Qt("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"),
            gi.targetFPMS = e
        }
    }
});
class h1 {
    static init(t) {
        t = Object.assign({
            autoStart: !0,
            sharedTicker: !1
        }, t),
        Object.defineProperty(this, "ticker", {
            set(i) {
                this._ticker && this._ticker.remove(this.render, this),
                this._ticker = i,
                i && i.add(this.render, this, Lo.LOW)
            },
            get() {
                return this._ticker
            }
        }),
        this.stop = ()=>{
            this._ticker.stop()
        }
        ,
        this.start = ()=>{
            this._ticker.start()
        }
        ,
        this._ticker = null,
        this.ticker = t.sharedTicker ? gi.shared : new gi,
        t.autoStart && this.start()
    }
    static destroy() {
        if (this._ticker) {
            const t = this._ticker;
            this.ticker = null,
            t.destroy()
        }
    }
}
h1.extension = lt.Application;
vt.add(h1);
const u1 = [];
vt.handleByList(lt.Renderer, u1);
function ma(e) {
    for (const t of u1)
        if (t.test(e))
            return new t(e);
    throw new Error("Unable to auto-detect a suitable renderer.")
}
var p6 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`
  , m6 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const g6 = p6
  , d1 = m6;
class f1 {
    constructor(t) {
        this.renderer = t
    }
    contextChange(t) {
        let i;
        if (this.renderer.context.webGLVersion === 1) {
            const s = t.getParameter(t.FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.FRAMEBUFFER, null),
            i = t.getParameter(t.SAMPLES),
            t.bindFramebuffer(t.FRAMEBUFFER, s)
        } else {
            const s = t.getParameter(t.DRAW_FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null),
            i = t.getParameter(t.SAMPLES),
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, s)
        }
        i >= De.HIGH ? this.multisample = De.HIGH : i >= De.MEDIUM ? this.multisample = De.MEDIUM : i >= De.LOW ? this.multisample = De.LOW : this.multisample = De.NONE
    }
    destroy() {}
}
f1.extension = {
    type: lt.RendererSystem,
    name: "_multisample"
};
vt.add(f1);
class v6 {
    constructor(t) {
        this.buffer = t || null,
        this.updateID = -1,
        this.byteLength = -1,
        this.refCount = 0
    }
}
class p1 {
    constructor(t) {
        this.renderer = t,
        this.managedBuffers = {},
        this.boundBufferBases = {}
    }
    destroy() {
        this.renderer = null
    }
    contextChange() {
        this.disposeAll(!0),
        this.gl = this.renderer.gl,
        this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(t) {
        const {gl: i, CONTEXT_UID: s} = this
          , n = t._glBuffers[s] || this.createGLBuffer(t);
        i.bindBuffer(t.type, n.buffer)
    }
    unbind(t) {
        const {gl: i} = this;
        i.bindBuffer(t, null)
    }
    bindBufferBase(t, i) {
        const {gl: s, CONTEXT_UID: n} = this;
        if (this.boundBufferBases[i] !== t) {
            const r = t._glBuffers[n] || this.createGLBuffer(t);
            this.boundBufferBases[i] = t,
            s.bindBufferBase(s.UNIFORM_BUFFER, i, r.buffer)
        }
    }
    bindBufferRange(t, i, s) {
        const {gl: n, CONTEXT_UID: r} = this;
        s = s || 0;
        const o = t._glBuffers[r] || this.createGLBuffer(t);
        n.bindBufferRange(n.UNIFORM_BUFFER, i || 0, o.buffer, s * 256, 256)
    }
    update(t) {
        const {gl: i, CONTEXT_UID: s} = this
          , n = t._glBuffers[s] || this.createGLBuffer(t);
        if (t._updateID !== n.updateID)
            if (n.updateID = t._updateID,
            i.bindBuffer(t.type, n.buffer),
            n.byteLength >= t.data.byteLength)
                i.bufferSubData(t.type, 0, t.data);
            else {
                const r = t.static ? i.STATIC_DRAW : i.DYNAMIC_DRAW;
                n.byteLength = t.data.byteLength,
                i.bufferData(t.type, t.data, r)
            }
    }
    dispose(t, i) {
        if (!this.managedBuffers[t.id])
            return;
        delete this.managedBuffers[t.id];
        const s = t._glBuffers[this.CONTEXT_UID]
          , n = this.gl;
        t.disposeRunner.remove(this),
        s && (i || n.deleteBuffer(s.buffer),
        delete t._glBuffers[this.CONTEXT_UID])
    }
    disposeAll(t) {
        const i = Object.keys(this.managedBuffers);
        for (let s = 0; s < i.length; s++)
            this.dispose(this.managedBuffers[i[s]], t)
    }
    createGLBuffer(t) {
        const {CONTEXT_UID: i, gl: s} = this;
        return t._glBuffers[i] = new v6(s.createBuffer()),
        this.managedBuffers[t.id] = t,
        t.disposeRunner.add(this),
        t._glBuffers[i]
    }
}
p1.extension = {
    type: lt.RendererSystem,
    name: "buffer"
};
vt.add(p1);
class m1 {
    constructor(t) {
        this.renderer = t
    }
    render(t, i) {
        const s = this.renderer;
        let n, r, o, a;
        if (i && (n = i.renderTexture,
        r = i.clear,
        o = i.transform,
        a = i.skipUpdateTransform),
        this.renderingToScreen = !n,
        s.runners.prerender.emit(),
        s.emit("prerender"),
        s.projection.transform = o,
        !s.context.isLost) {
            if (n || (this.lastObjectRendered = t),
            !a) {
                const l = t.enableTempParent();
                t.updateTransform(),
                t.disableTempParent(l)
            }
            s.renderTexture.bind(n),
            s.batch.currentRenderer.start(),
            (r ?? s.background.clearBeforeRender) && s.renderTexture.clear(),
            t.render(s),
            s.batch.currentRenderer.flush(),
            n && (i.blit && s.framebuffer.blit(),
            n.baseTexture.update()),
            s.runners.postrender.emit(),
            s.projection.transform = null,
            s.emit("postrender")
        }
    }
    destroy() {
        this.renderer = null,
        this.lastObjectRendered = null
    }
}
m1.extension = {
    type: lt.RendererSystem,
    name: "objectRenderer"
};
vt.add(m1);
const pd = class extends o1 {
    constructor(e) {
        super(),
        e = Object.assign({}, ft.RENDER_OPTIONS, e),
        this.gl = null,
        this.CONTEXT_UID = 0,
        this.globalUniforms = new hs({
            projectionMatrix: new pe
        },!0);
        const t = {
            runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
            systems: pd.__systems,
            priority: ["_view", "textureGenerator", "background", "_plugin", "startup", "context", "state", "texture", "buffer", "geometry", "framebuffer", "transformFeedback", "mask", "scissor", "stencil", "projection", "textureGC", "filter", "renderTexture", "batch", "objectRenderer", "_multisample"]
        };
        this.setup(t),
        "useContextAlpha"in e && (Qt("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"),
        e.premultipliedAlpha = e.useContextAlpha && e.useContextAlpha !== "notMultiplied",
        e.backgroundAlpha = e.useContextAlpha === !1 ? 1 : e.backgroundAlpha);
        const i = {
            hello: e.hello,
            _plugin: pd.__plugins,
            background: {
                alpha: e.backgroundAlpha,
                color: e.background ?? e.backgroundColor,
                clearBeforeRender: e.clearBeforeRender
            },
            _view: {
                height: e.height,
                width: e.width,
                autoDensity: e.autoDensity,
                resolution: e.resolution,
                view: e.view
            },
            context: {
                antialias: e.antialias,
                context: e.context,
                powerPreference: e.powerPreference,
                premultipliedAlpha: e.premultipliedAlpha,
                preserveDrawingBuffer: e.preserveDrawingBuffer
            }
        };
        this.options = e,
        this.startup.run(i)
    }
    static test(e) {
        return e?.forceCanvas ? !1 : w_()
    }
    render(e, t) {
        this.objectRenderer.render(e, t)
    }
    resize(e, t) {
        this._view.resizeView(e, t)
    }
    reset() {
        return this.runners.reset.emit(),
        this
    }
    clear() {
        this.renderTexture.bind(),
        this.renderTexture.clear()
    }
    destroy(e=!1) {
        this.runners.destroy.items.reverse(),
        this.emitWithCustomOptions(this.runners.destroy, {
            _view: e
        }),
        super.destroy()
    }
    get plugins() {
        return this._plugin.plugins
    }
    get multisample() {
        return this._multisample.multisample
    }
    get width() {
        return this._view.element.width
    }
    get height() {
        return this._view.element.height
    }
    get resolution() {
        return this._view.resolution
    }
    set resolution(e) {
        this._view.resolution = e,
        this.runners.resolutionChange.emit(e)
    }
    get autoDensity() {
        return this._view.autoDensity
    }
    get view() {
        return this._view.element
    }
    get screen() {
        return this._view.screen
    }
    get lastObjectRendered() {
        return this.objectRenderer.lastObjectRendered
    }
    get renderingToScreen() {
        return this.objectRenderer.renderingToScreen
    }
    get rendererLogId() {
        return `WebGL ${this.context.webGLVersion}`
    }
    get clearBeforeRender() {
        return Qt("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."),
        this.background.clearBeforeRender
    }
    get useContextAlpha() {
        return Qt("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."),
        this.context.useContextAlpha
    }
    get preserveDrawingBuffer() {
        return Qt("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"),
        this.context.preserveDrawingBuffer
    }
    get backgroundColor() {
        return Qt("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
        this.background.color
    }
    set backgroundColor(e) {
        Qt("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
        this.background.color = e
    }
    get backgroundAlpha() {
        return Qt("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
        this.background.color
    }
    set backgroundAlpha(e) {
        Qt("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
        this.background.alpha = e
    }
    get powerPreference() {
        return Qt("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"),
        this.context.powerPreference
    }
    generateTexture(e, t) {
        return this.textureGenerator.generateTexture(e, t)
    }
}
;
let jo = pd;
jo.extension = {
    type: lt.Renderer,
    priority: 1
};
jo.__plugins = {};
jo.__systems = {};
vt.handleByMap(lt.RendererPlugin, jo.__plugins);
vt.handleByMap(lt.RendererSystem, jo.__systems);
vt.add(jo);
class g1 extends Ua {
    constructor(t, i) {
        const {width: s, height: n} = i || {};
        super(s, n),
        this.items = [],
        this.itemDirtyIds = [];
        for (let r = 0; r < t; r++) {
            const o = new Ot;
            this.items.push(o),
            this.itemDirtyIds.push(-2)
        }
        this.length = t,
        this._load = null,
        this.baseTexture = null
    }
    initFromArray(t, i) {
        for (let s = 0; s < this.length; s++)
            !t[s] || (t[s].castToBaseTexture ? this.addBaseTextureAt(t[s].castToBaseTexture(), s) : t[s]instanceof Ua ? this.addResourceAt(t[s], s) : this.addResourceAt(R_(t[s], i), s))
    }
    dispose() {
        for (let t = 0, i = this.length; t < i; t++)
            this.items[t].destroy();
        this.items = null,
        this.itemDirtyIds = null,
        this._load = null
    }
    addResourceAt(t, i) {
        if (!this.items[i])
            throw new Error(`Index ${i} is out of bounds`);
        return t.valid && !this.valid && this.resize(t.width, t.height),
        this.items[i].setResource(t),
        this
    }
    bind(t) {
        if (this.baseTexture !== null)
            throw new Error("Only one base texture per TextureArray is allowed");
        super.bind(t);
        for (let i = 0; i < this.length; i++)
            this.items[i].parentTextureArray = t,
            this.items[i].on("update", t.update, t)
    }
    unbind(t) {
        super.unbind(t);
        for (let i = 0; i < this.length; i++)
            this.items[i].parentTextureArray = null,
            this.items[i].off("update", t.update, t)
    }
    load() {
        if (this._load)
            return this._load;
        const i = this.items.map(s=>s.resource).filter(s=>s).map(s=>s.load());
        return this._load = Promise.all(i).then(()=>{
            const {realWidth: s, realHeight: n} = this.items[0];
            return this.resize(s, n),
            Promise.resolve(this)
        }
        ),
        this._load
    }
}
class _6 extends g1 {
    constructor(t, i) {
        const {width: s, height: n} = i || {};
        let r, o;
        Array.isArray(t) ? (r = t,
        o = t.length) : o = t,
        super(o, {
            width: s,
            height: n
        }),
        r && this.initFromArray(r, i)
    }
    addBaseTextureAt(t, i) {
        if (t.resource)
            this.addResourceAt(t.resource, i);
        else
            throw new Error("ArrayResource does not support RenderTexture");
        return this
    }
    bind(t) {
        super.bind(t),
        t.target = mo.TEXTURE_2D_ARRAY
    }
    upload(t, i, s) {
        const {length: n, itemDirtyIds: r, items: o} = this
          , {gl: a} = t;
        s.dirtyId < 0 && a.texImage3D(a.TEXTURE_2D_ARRAY, 0, s.internalFormat, this._width, this._height, n, 0, i.format, s.type, null);
        for (let l = 0; l < n; l++) {
            const c = o[l];
            r[l] < c.dirtyId && (r[l] = c.dirtyId,
            c.valid && a.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, l, c.resource.width, c.resource.height, 1, i.format, s.type, c.resource.source))
        }
        return !0
    }
}
class v1 extends Dn {
    constructor(t) {
        super(t)
    }
    static test(t) {
        const {OffscreenCanvas: i} = globalThis;
        return i && t instanceof i ? !0 : globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement
    }
}
const ga = class extends g1 {
    constructor(e, t) {
        const {width: i, height: s, autoLoad: n, linkBaseTexture: r} = t || {};
        if (e && e.length !== ga.SIDES)
            throw new Error(`Invalid length. Got ${e.length}, expected 6`);
        super(6, {
            width: i,
            height: s
        });
        for (let o = 0; o < ga.SIDES; o++)
            this.items[o].target = mo.TEXTURE_CUBE_MAP_POSITIVE_X + o;
        this.linkBaseTexture = r !== !1,
        e && this.initFromArray(e, t),
        n !== !1 && this.load()
    }
    bind(e) {
        super.bind(e),
        e.target = mo.TEXTURE_CUBE_MAP
    }
    addBaseTextureAt(e, t, i) {
        if (i === void 0 && (i = this.linkBaseTexture),
        !this.items[t])
            throw new Error(`Index ${t} is out of bounds`);
        if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)
            if (e.resource)
                this.addResourceAt(e.resource, t);
            else
                throw new Error("CubeResource does not support copying of renderTexture.");
        else
            e.target = mo.TEXTURE_CUBE_MAP_POSITIVE_X + t,
            e.parentTextureArray = this.baseTexture,
            this.items[t] = e;
        return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight),
        this.items[t] = e,
        this
    }
    upload(e, t, i) {
        const s = this.itemDirtyIds;
        for (let n = 0; n < ga.SIDES; n++) {
            const r = this.items[n];
            (s[n] < r.dirtyId || i.dirtyId < t.dirtyId) && (r.valid && r.resource ? (r.resource.upload(e, r, i),
            s[n] = r.dirtyId) : s[n] < -1 && (e.gl.texImage2D(r.target, 0, i.internalFormat, t.realWidth, t.realHeight, 0, t.format, i.type, null),
            s[n] = -1))
        }
        return !0
    }
    static test(e) {
        return Array.isArray(e) && e.length === ga.SIDES
    }
}
;
let _1 = ga;
_1.SIDES = 6;
class ao extends Dn {
    constructor(t, i) {
        i = i || {};
        let s, n;
        typeof t == "string" ? (s = ao.EMPTY,
        n = t) : (s = t,
        n = null),
        super(s),
        this.url = n,
        this.crossOrigin = i.crossOrigin ?? !0,
        this.alphaMode = typeof i.alphaMode == "number" ? i.alphaMode : null,
        this._load = null,
        i.autoLoad !== !1 && this.load()
    }
    load() {
        return this._load ? this._load : (this._load = new Promise(async(t,i)=>{
            if (this.url === null) {
                t(this);
                return
            }
            try {
                const s = await ft.ADAPTER.fetch(this.url, {
                    mode: this.crossOrigin ? "cors" : "no-cors"
                });
                if (this.destroyed)
                    return;
                const n = await s.blob();
                if (this.destroyed)
                    return;
                const r = await createImageBitmap(n, {
                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === _s.UNPACK ? "premultiply" : "none"
                });
                if (this.destroyed)
                    return;
                this.source = r,
                this.update(),
                t(this)
            } catch (s) {
                if (this.destroyed)
                    return;
                i(s),
                this.onError.emit(s)
            }
        }
        ),
        this._load)
    }
    upload(t, i, s) {
        return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (i.alphaMode = this.alphaMode),
        super.upload(t, i, s)) : (this.load(),
        !1)
    }
    dispose() {
        this.source instanceof ImageBitmap && this.source.close(),
        super.dispose(),
        this._load = null
    }
    static test(t) {
        return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && (typeof t == "string" || t instanceof ImageBitmap)
    }
    static get EMPTY() {
        return ao._EMPTY = ao._EMPTY ?? ft.ADAPTER.createCanvas(0, 0),
        ao._EMPTY
    }
}
const Ql = class extends Dn {
    constructor(e, t) {
        t = t || {},
        super(ft.ADAPTER.createCanvas()),
        this._width = 0,
        this._height = 0,
        this.svg = e,
        this.scale = t.scale || 1,
        this._overrideWidth = t.width,
        this._overrideHeight = t.height,
        this._resolve = null,
        this._crossorigin = t.crossorigin,
        this._load = null,
        t.autoLoad !== !1 && this.load()
    }
    load() {
        return this._load ? this._load : (this._load = new Promise(e=>{
            if (this._resolve = ()=>{
                this.resize(this.source.width, this.source.height),
                e(this)
            }
            ,
            Ql.SVG_XML.test(this.svg.trim())) {
                if (!btoa)
                    throw new Error("Your browser doesn't support base64 conversions.");
                this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`
            }
            this._loadSvg()
        }
        ),
        this._load)
    }
    _loadSvg() {
        const e = new Image;
        Dn.crossOrigin(e, this.svg, this._crossorigin),
        e.src = this.svg,
        e.onerror = t=>{
            !this._resolve || (e.onerror = null,
            this.onError.emit(t))
        }
        ,
        e.onload = ()=>{
            if (!this._resolve)
                return;
            const t = e.width
              , i = e.height;
            if (!t || !i)
                throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
            let s = t * this.scale
              , n = i * this.scale;
            (this._overrideWidth || this._overrideHeight) && (s = this._overrideWidth || this._overrideHeight / i * t,
            n = this._overrideHeight || this._overrideWidth / t * i),
            s = Math.round(s),
            n = Math.round(n);
            const r = this.source;
            r.width = s,
            r.height = n,
            r._pixiId = `canvas_${Ln()}`,
            r.getContext("2d").drawImage(e, 0, 0, t, i, 0, 0, s, n),
            this._resolve(),
            this._resolve = null
        }
    }
    static getSize(e) {
        const t = Ql.SVG_SIZE.exec(e)
          , i = {};
        return t && (i[t[1]] = Math.round(parseFloat(t[3])),
        i[t[5]] = Math.round(parseFloat(t[7]))),
        i
    }
    dispose() {
        super.dispose(),
        this._resolve = null,
        this._crossorigin = null
    }
    static test(e, t) {
        return t === "svg" || typeof e == "string" && e.startsWith("data:image/svg+xml") || typeof e == "string" && Ql.SVG_XML.test(e)
    }
}
;
let Ga = Ql;
Ga.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
Ga.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
const md = class extends Dn {
    constructor(e, t) {
        if (t = t || {},
        !(e instanceof HTMLVideoElement)) {
            const i = document.createElement("video");
            i.setAttribute("preload", "auto"),
            i.setAttribute("webkit-playsinline", ""),
            i.setAttribute("playsinline", ""),
            typeof e == "string" && (e = [e]);
            const s = e[0].src || e[0];
            Dn.crossOrigin(i, s, t.crossorigin);
            for (let n = 0; n < e.length; ++n) {
                const r = document.createElement("source");
                let {src: o, mime: a} = e[n];
                o = o || e[n];
                const l = o.split("?").shift().toLowerCase()
                  , c = l.slice(l.lastIndexOf(".") + 1);
                a = a || md.MIME_TYPES[c] || `video/${c}`,
                r.src = o,
                r.type = a,
                i.appendChild(r)
            }
            e = i
        }
        super(e),
        this.noSubImage = !0,
        this._autoUpdate = !0,
        this._isConnectedToTicker = !1,
        this._updateFPS = t.updateFPS || 0,
        this._msToNextUpdate = 0,
        this.autoPlay = t.autoPlay !== !1,
        this._load = null,
        this._resolve = null,
        this._onCanPlay = this._onCanPlay.bind(this),
        this._onError = this._onError.bind(this),
        t.autoLoad !== !1 && this.load()
    }
    update(e=0) {
        if (!this.destroyed) {
            const t = gi.shared.elapsedMS * this.source.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - t),
            (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(),
            this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
        }
    }
    load() {
        if (this._load)
            return this._load;
        const e = this.source;
        return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0),
        e.addEventListener("play", this._onPlayStart.bind(this)),
        e.addEventListener("pause", this._onPlayStop.bind(this)),
        this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay),
        e.addEventListener("canplaythrough", this._onCanPlay),
        e.addEventListener("error", this._onError, !0)),
        this._load = new Promise(t=>{
            this.valid ? t(this) : (this._resolve = t,
            e.load())
        }
        ),
        this._load
    }
    _onError(e) {
        this.source.removeEventListener("error", this._onError, !0),
        this.onError.emit(e)
    }
    _isSourcePlaying() {
        const e = this.source;
        return !e.paused && !e.ended && this._isSourceReady()
    }
    _isSourceReady() {
        return this.source.readyState > 2
    }
    _onPlayStart() {
        this.valid || this._onCanPlay(),
        this.autoUpdate && !this._isConnectedToTicker && (gi.shared.add(this.update, this),
        this._isConnectedToTicker = !0)
    }
    _onPlayStop() {
        this._isConnectedToTicker && (gi.shared.remove(this.update, this),
        this._isConnectedToTicker = !1)
    }
    _onCanPlay() {
        const e = this.source;
        e.removeEventListener("canplay", this._onCanPlay),
        e.removeEventListener("canplaythrough", this._onCanPlay);
        const t = this.valid;
        this.resize(e.videoWidth, e.videoHeight),
        !t && this._resolve && (this._resolve(this),
        this._resolve = null),
        this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play()
    }
    dispose() {
        this._isConnectedToTicker && (gi.shared.remove(this.update, this),
        this._isConnectedToTicker = !1);
        const e = this.source;
        e && (e.removeEventListener("error", this._onError, !0),
        e.pause(),
        e.src = "",
        e.load()),
        super.dispose()
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(e) {
        e !== this._autoUpdate && (this._autoUpdate = e,
        !this._autoUpdate && this._isConnectedToTicker ? (gi.shared.remove(this.update, this),
        this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (gi.shared.add(this.update, this),
        this._isConnectedToTicker = !0))
    }
    get updateFPS() {
        return this._updateFPS
    }
    set updateFPS(e) {
        e !== this._updateFPS && (this._updateFPS = e)
    }
    static test(e, t) {
        return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || md.TYPES.includes(t)
    }
}
;
let Wf = md;
Wf.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
Wf.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
};
ld.push(ao, H_, v1, Wf, Ga, qa, _1, _6);
class Ec {
    constructor() {
        this.minX = 1 / 0,
        this.minY = 1 / 0,
        this.maxX = -1 / 0,
        this.maxY = -1 / 0,
        this.rect = null,
        this.updateID = -1
    }
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY
    }
    clear() {
        this.minX = 1 / 0,
        this.minY = 1 / 0,
        this.maxX = -1 / 0,
        this.maxY = -1 / 0
    }
    getRectangle(t) {
        return this.minX > this.maxX || this.minY > this.maxY ? qt.EMPTY : (t = t || new qt(0,0,1,1),
        t.x = this.minX,
        t.y = this.minY,
        t.width = this.maxX - this.minX,
        t.height = this.maxY - this.minY,
        t)
    }
    addPoint(t) {
        this.minX = Math.min(this.minX, t.x),
        this.maxX = Math.max(this.maxX, t.x),
        this.minY = Math.min(this.minY, t.y),
        this.maxY = Math.max(this.maxY, t.y)
    }
    addPointMatrix(t, i) {
        const {a: s, b: n, c: r, d: o, tx: a, ty: l} = t
          , c = s * i.x + r * i.y + a
          , h = n * i.x + o * i.y + l;
        this.minX = Math.min(this.minX, c),
        this.maxX = Math.max(this.maxX, c),
        this.minY = Math.min(this.minY, h),
        this.maxY = Math.max(this.maxY, h)
    }
    addQuad(t) {
        let i = this.minX
          , s = this.minY
          , n = this.maxX
          , r = this.maxY
          , o = t[0]
          , a = t[1];
        i = o < i ? o : i,
        s = a < s ? a : s,
        n = o > n ? o : n,
        r = a > r ? a : r,
        o = t[2],
        a = t[3],
        i = o < i ? o : i,
        s = a < s ? a : s,
        n = o > n ? o : n,
        r = a > r ? a : r,
        o = t[4],
        a = t[5],
        i = o < i ? o : i,
        s = a < s ? a : s,
        n = o > n ? o : n,
        r = a > r ? a : r,
        o = t[6],
        a = t[7],
        i = o < i ? o : i,
        s = a < s ? a : s,
        n = o > n ? o : n,
        r = a > r ? a : r,
        this.minX = i,
        this.minY = s,
        this.maxX = n,
        this.maxY = r
    }
    addFrame(t, i, s, n, r) {
        this.addFrameMatrix(t.worldTransform, i, s, n, r)
    }
    addFrameMatrix(t, i, s, n, r) {
        const o = t.a
          , a = t.b
          , l = t.c
          , c = t.d
          , h = t.tx
          , u = t.ty;
        let d = this.minX
          , f = this.minY
          , p = this.maxX
          , m = this.maxY
          , g = o * i + l * s + h
          , y = a * i + c * s + u;
        d = g < d ? g : d,
        f = y < f ? y : f,
        p = g > p ? g : p,
        m = y > m ? y : m,
        g = o * n + l * s + h,
        y = a * n + c * s + u,
        d = g < d ? g : d,
        f = y < f ? y : f,
        p = g > p ? g : p,
        m = y > m ? y : m,
        g = o * i + l * r + h,
        y = a * i + c * r + u,
        d = g < d ? g : d,
        f = y < f ? y : f,
        p = g > p ? g : p,
        m = y > m ? y : m,
        g = o * n + l * r + h,
        y = a * n + c * r + u,
        d = g < d ? g : d,
        f = y < f ? y : f,
        p = g > p ? g : p,
        m = y > m ? y : m,
        this.minX = d,
        this.minY = f,
        this.maxX = p,
        this.maxY = m
    }
    addVertexData(t, i, s) {
        let n = this.minX
          , r = this.minY
          , o = this.maxX
          , a = this.maxY;
        for (let l = i; l < s; l += 2) {
            const c = t[l]
              , h = t[l + 1];
            n = c < n ? c : n,
            r = h < r ? h : r,
            o = c > o ? c : o,
            a = h > a ? h : a
        }
        this.minX = n,
        this.minY = r,
        this.maxX = o,
        this.maxY = a
    }
    addVertices(t, i, s, n) {
        this.addVerticesMatrix(t.worldTransform, i, s, n)
    }
    addVerticesMatrix(t, i, s, n, r=0, o=r) {
        const a = t.a
          , l = t.b
          , c = t.c
          , h = t.d
          , u = t.tx
          , d = t.ty;
        let f = this.minX
          , p = this.minY
          , m = this.maxX
          , g = this.maxY;
        for (let y = s; y < n; y += 2) {
            const x = i[y]
              , v = i[y + 1]
              , _ = a * x + c * v + u
              , C = h * v + l * x + d;
            f = Math.min(f, _ - r),
            m = Math.max(m, _ + r),
            p = Math.min(p, C - o),
            g = Math.max(g, C + o)
        }
        this.minX = f,
        this.minY = p,
        this.maxX = m,
        this.maxY = g
    }
    addBounds(t) {
        const i = this.minX
          , s = this.minY
          , n = this.maxX
          , r = this.maxY;
        this.minX = t.minX < i ? t.minX : i,
        this.minY = t.minY < s ? t.minY : s,
        this.maxX = t.maxX > n ? t.maxX : n,
        this.maxY = t.maxY > r ? t.maxY : r
    }
    addBoundsMask(t, i) {
        const s = t.minX > i.minX ? t.minX : i.minX
          , n = t.minY > i.minY ? t.minY : i.minY
          , r = t.maxX < i.maxX ? t.maxX : i.maxX
          , o = t.maxY < i.maxY ? t.maxY : i.maxY;
        if (s <= r && n <= o) {
            const a = this.minX
              , l = this.minY
              , c = this.maxX
              , h = this.maxY;
            this.minX = s < a ? s : a,
            this.minY = n < l ? n : l,
            this.maxX = r > c ? r : c,
            this.maxY = o > h ? o : h
        }
    }
    addBoundsMatrix(t, i) {
        this.addFrameMatrix(i, t.minX, t.minY, t.maxX, t.maxY)
    }
    addBoundsArea(t, i) {
        const s = t.minX > i.x ? t.minX : i.x
          , n = t.minY > i.y ? t.minY : i.y
          , r = t.maxX < i.x + i.width ? t.maxX : i.x + i.width
          , o = t.maxY < i.y + i.height ? t.maxY : i.y + i.height;
        if (s <= r && n <= o) {
            const a = this.minX
              , l = this.minY
              , c = this.maxX
              , h = this.maxY;
            this.minX = s < a ? s : a,
            this.minY = n < l ? n : l,
            this.maxX = r > c ? r : c,
            this.maxY = o > h ? o : h
        }
    }
    pad(t=0, i=t) {
        this.isEmpty() || (this.minX -= t,
        this.maxX += t,
        this.minY -= i,
        this.maxY += i)
    }
    addFramePad(t, i, s, n, r, o) {
        t -= r,
        i -= o,
        s += r,
        n += o,
        this.minX = this.minX < t ? this.minX : t,
        this.maxX = this.maxX > s ? this.maxX : s,
        this.minY = this.minY < i ? this.minY : i,
        this.maxY = this.maxY > n ? this.maxY : n
    }
}
class Ae extends $o {
    constructor() {
        super(),
        this.tempDisplayObjectParent = null,
        this.transform = new uh,
        this.alpha = 1,
        this.visible = !0,
        this.renderable = !0,
        this.cullable = !1,
        this.cullArea = null,
        this.parent = null,
        this.worldAlpha = 1,
        this._lastSortedIndex = 0,
        this._zIndex = 0,
        this.filterArea = null,
        this.filters = null,
        this._enabledFilters = null,
        this._bounds = new Ec,
        this._localBounds = null,
        this._boundsID = 0,
        this._boundsRect = null,
        this._localBoundsRect = null,
        this._mask = null,
        this._maskRefCount = 0,
        this._destroyed = !1,
        this.isSprite = !1,
        this.isMask = !1
    }
    static mixin(t) {
        const i = Object.keys(t);
        for (let s = 0; s < i.length; ++s) {
            const n = i[s];
            Object.defineProperty(Ae.prototype, n, Object.getOwnPropertyDescriptor(t, n))
        }
    }
    get destroyed() {
        return this._destroyed
    }
    _recursivePostUpdateTransform() {
        this.parent ? (this.parent._recursivePostUpdateTransform(),
        this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
    }
    updateTransform() {
        this._boundsID++,
        this.transform.updateTransform(this.parent.transform),
        this.worldAlpha = this.alpha * this.parent.worldAlpha
    }
    getBounds(t, i) {
        return t || (this.parent ? (this._recursivePostUpdateTransform(),
        this.updateTransform()) : (this.parent = this._tempDisplayObjectParent,
        this.updateTransform(),
        this.parent = null)),
        this._bounds.updateID !== this._boundsID && (this.calculateBounds(),
        this._bounds.updateID = this._boundsID),
        i || (this._boundsRect || (this._boundsRect = new qt),
        i = this._boundsRect),
        this._bounds.getRectangle(i)
    }
    getLocalBounds(t) {
        t || (this._localBoundsRect || (this._localBoundsRect = new qt),
        t = this._localBoundsRect),
        this._localBounds || (this._localBounds = new Ec);
        const i = this.transform
          , s = this.parent;
        this.parent = null,
        this.transform = this._tempDisplayObjectParent.transform;
        const n = this._bounds
          , r = this._boundsID;
        this._bounds = this._localBounds;
        const o = this.getBounds(!1, t);
        return this.parent = s,
        this.transform = i,
        this._bounds = n,
        this._bounds.updateID += this._boundsID - r,
        o
    }
    toGlobal(t, i, s=!1) {
        return s || (this._recursivePostUpdateTransform(),
        this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent,
        this.displayObjectUpdateTransform(),
        this.parent = null)),
        this.worldTransform.apply(t, i)
    }
    toLocal(t, i, s, n) {
        return i && (t = i.toGlobal(t, s, n)),
        n || (this._recursivePostUpdateTransform(),
        this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent,
        this.displayObjectUpdateTransform(),
        this.parent = null)),
        this.worldTransform.applyInverse(t, s)
    }
    setParent(t) {
        if (!t || !t.addChild)
            throw new Error("setParent: Argument must be a Container");
        return t.addChild(this),
        t
    }
    removeFromParent() {
        this.parent?.removeChild(this)
    }
    setTransform(t=0, i=0, s=1, n=1, r=0, o=0, a=0, l=0, c=0) {
        return this.position.x = t,
        this.position.y = i,
        this.scale.x = s || 1,
        this.scale.y = n || 1,
        this.rotation = r,
        this.skew.x = o,
        this.skew.y = a,
        this.pivot.x = l,
        this.pivot.y = c,
        this
    }
    destroy(t) {
        this.removeFromParent(),
        this._destroyed = !0,
        this.transform = null,
        this.parent = null,
        this._bounds = null,
        this.mask = null,
        this.cullArea = null,
        this.filters = null,
        this.filterArea = null,
        this.hitArea = null,
        this.interactive = !1,
        this.interactiveChildren = !1,
        this.emit("destroyed"),
        this.removeAllListeners()
    }
    get _tempDisplayObjectParent() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new y6),
        this.tempDisplayObjectParent
    }
    enableTempParent() {
        const t = this.parent;
        return this.parent = this._tempDisplayObjectParent,
        t
    }
    disableTempParent(t) {
        this.parent = t
    }
    get x() {
        return this.position.x
    }
    set x(t) {
        this.transform.position.x = t
    }
    get y() {
        return this.position.y
    }
    set y(t) {
        this.transform.position.y = t
    }
    get worldTransform() {
        return this.transform.worldTransform
    }
    get localTransform() {
        return this.transform.localTransform
    }
    get position() {
        return this.transform.position
    }
    set position(t) {
        this.transform.position.copyFrom(t)
    }
    get scale() {
        return this.transform.scale
    }
    set scale(t) {
        this.transform.scale.copyFrom(t)
    }
    get pivot() {
        return this.transform.pivot
    }
    set pivot(t) {
        this.transform.pivot.copyFrom(t)
    }
    get skew() {
        return this.transform.skew
    }
    set skew(t) {
        this.transform.skew.copyFrom(t)
    }
    get rotation() {
        return this.transform.rotation
    }
    set rotation(t) {
        this.transform.rotation = t
    }
    get angle() {
        return this.transform.rotation * _4
    }
    set angle(t) {
        this.transform.rotation = t * y4
    }
    get zIndex() {
        return this._zIndex
    }
    set zIndex(t) {
        this._zIndex = t,
        this.parent && (this.parent.sortDirty = !0)
    }
    get worldVisible() {
        let t = this;
        do {
            if (!t.visible)
                return !1;
            t = t.parent
        } while (t);
        return !0
    }
    get mask() {
        return this._mask
    }
    set mask(t) {
        if (this._mask !== t) {
            if (this._mask) {
                const i = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                i && (i._maskRefCount--,
                i._maskRefCount === 0 && (i.renderable = !0,
                i.isMask = !1))
            }
            if (this._mask = t,
            this._mask) {
                const i = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                i && (i._maskRefCount === 0 && (i.renderable = !1,
                i.isMask = !0),
                i._maskRefCount++)
            }
        }
    }
}
class y6 extends Ae {
    constructor() {
        super(...arguments),
        this.sortDirty = null
    }
}
Ae.prototype.displayObjectUpdateTransform = Ae.prototype.updateTransform;
const b6 = new pe;
function x6(e, t) {
    return e.zIndex === t.zIndex ? e._lastSortedIndex - t._lastSortedIndex : e.zIndex - t.zIndex
}
const gd = class extends Ae {
    constructor() {
        super(),
        this.children = [],
        this.sortableChildren = gd.defaultSortableChildren,
        this.sortDirty = !1
    }
    onChildrenChange(e) {}
    addChild(...e) {
        if (e.length > 1)
            for (let t = 0; t < e.length; t++)
                this.addChild(e[t]);
        else {
            const t = e[0];
            t.parent && t.parent.removeChild(t),
            t.parent = this,
            this.sortDirty = !0,
            t.transform._parentID = -1,
            this.children.push(t),
            this._boundsID++,
            this.onChildrenChange(this.children.length - 1),
            this.emit("childAdded", t, this, this.children.length - 1),
            t.emit("added", this)
        }
        return e[0]
    }
    addChildAt(e, t) {
        if (t < 0 || t > this.children.length)
            throw new Error(`${e}addChildAt: The index ${t} supplied is out of bounds ${this.children.length}`);
        return e.parent && e.parent.removeChild(e),
        e.parent = this,
        this.sortDirty = !0,
        e.transform._parentID = -1,
        this.children.splice(t, 0, e),
        this._boundsID++,
        this.onChildrenChange(t),
        e.emit("added", this),
        this.emit("childAdded", e, this, t),
        e
    }
    swapChildren(e, t) {
        if (e === t)
            return;
        const i = this.getChildIndex(e)
          , s = this.getChildIndex(t);
        this.children[i] = t,
        this.children[s] = e,
        this.onChildrenChange(i < s ? i : s)
    }
    getChildIndex(e) {
        const t = this.children.indexOf(e);
        if (t === -1)
            throw new Error("The supplied DisplayObject must be a child of the caller");
        return t
    }
    setChildIndex(e, t) {
        if (t < 0 || t >= this.children.length)
            throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
        const i = this.getChildIndex(e);
        wr(this.children, i, 1),
        this.children.splice(t, 0, e),
        this.onChildrenChange(t)
    }
    getChildAt(e) {
        if (e < 0 || e >= this.children.length)
            throw new Error(`getChildAt: Index (${e}) does not exist.`);
        return this.children[e]
    }
    removeChild(...e) {
        if (e.length > 1)
            for (let t = 0; t < e.length; t++)
                this.removeChild(e[t]);
        else {
            const t = e[0]
              , i = this.children.indexOf(t);
            if (i === -1)
                return null;
            t.parent = null,
            t.transform._parentID = -1,
            wr(this.children, i, 1),
            this._boundsID++,
            this.onChildrenChange(i),
            t.emit("removed", this),
            this.emit("childRemoved", t, this, i)
        }
        return e[0]
    }
    removeChildAt(e) {
        const t = this.getChildAt(e);
        return t.parent = null,
        t.transform._parentID = -1,
        wr(this.children, e, 1),
        this._boundsID++,
        this.onChildrenChange(e),
        t.emit("removed", this),
        this.emit("childRemoved", t, this, e),
        t
    }
    removeChildren(e=0, t=this.children.length) {
        const i = e
          , s = t
          , n = s - i;
        let r;
        if (n > 0 && n <= s) {
            r = this.children.splice(i, n);
            for (let o = 0; o < r.length; ++o)
                r[o].parent = null,
                r[o].transform && (r[o].transform._parentID = -1);
            this._boundsID++,
            this.onChildrenChange(e);
            for (let o = 0; o < r.length; ++o)
                r[o].emit("removed", this),
                this.emit("childRemoved", r[o], this, o);
            return r
        } else if (n === 0 && this.children.length === 0)
            return [];
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
    }
    sortChildren() {
        let e = !1;
        for (let t = 0, i = this.children.length; t < i; ++t) {
            const s = this.children[t];
            s._lastSortedIndex = t,
            !e && s.zIndex !== 0 && (e = !0)
        }
        e && this.children.length > 1 && this.children.sort(x6),
        this.sortDirty = !1
    }
    updateTransform() {
        this.sortableChildren && this.sortDirty && this.sortChildren(),
        this._boundsID++,
        this.transform.updateTransform(this.parent.transform),
        this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (let e = 0, t = this.children.length; e < t; ++e) {
            const i = this.children[e];
            i.visible && i.updateTransform()
        }
    }
    calculateBounds() {
        this._bounds.clear(),
        this._calculateBounds();
        for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            if (!(!t.visible || !t.renderable))
                if (t.calculateBounds(),
                t._mask) {
                    const i = t._mask.isMaskData ? t._mask.maskObject : t._mask;
                    i ? (i.calculateBounds(),
                    this._bounds.addBoundsMask(t._bounds, i._bounds)) : this._bounds.addBounds(t._bounds)
                } else
                    t.filterArea ? this._bounds.addBoundsArea(t._bounds, t.filterArea) : this._bounds.addBounds(t._bounds)
        }
        this._bounds.updateID = this._boundsID
    }
    getLocalBounds(e, t=!1) {
        const i = super.getLocalBounds(e);
        if (!t)
            for (let s = 0, n = this.children.length; s < n; ++s) {
                const r = this.children[s];
                r.visible && r.updateTransform()
            }
        return i
    }
    _calculateBounds() {}
    _renderWithCulling(e) {
        const t = e.renderTexture.sourceFrame;
        if (!(t.width > 0 && t.height > 0))
            return;
        let i, s;
        this.cullArea ? (i = this.cullArea,
        s = this.worldTransform) : this._render !== gd.prototype._render && (i = this.getBounds(!0));
        const n = e.projection.transform;
        if (n && (s ? (s = b6.copyFrom(s),
        s.prepend(n)) : s = n),
        i && t.intersects(i, s))
            this._render(e);
        else if (this.cullArea)
            return;
        for (let r = 0, o = this.children.length; r < o; ++r) {
            const a = this.children[r]
              , l = a.cullable;
            a.cullable = l || !this.cullArea,
            a.render(e),
            a.cullable = l
        }
    }
    render(e) {
        if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
            if (this._mask || this.filters?.length)
                this.renderAdvanced(e);
            else if (this.cullable)
                this._renderWithCulling(e);
            else {
                this._render(e);
                for (let t = 0, i = this.children.length; t < i; ++t)
                    this.children[t].render(e)
            }
    }
    renderAdvanced(e) {
        const t = this.filters
          , i = this._mask;
        if (t) {
            this._enabledFilters || (this._enabledFilters = []),
            this._enabledFilters.length = 0;
            for (let n = 0; n < t.length; n++)
                t[n].enabled && this._enabledFilters.push(t[n])
        }
        const s = t && this._enabledFilters?.length || i && (!i.isMaskData || i.enabled && (i.autoDetect || i.type !== Ue.NONE));
        if (s && e.batch.flush(),
        t && this._enabledFilters?.length && e.filter.push(this, this._enabledFilters),
        i && e.mask.push(this, this._mask),
        this.cullable)
            this._renderWithCulling(e);
        else {
            this._render(e);
            for (let n = 0, r = this.children.length; n < r; ++n)
                this.children[n].render(e)
        }
        s && e.batch.flush(),
        i && e.mask.pop(this),
        t && this._enabledFilters?.length && e.filter.pop()
    }
    _render(e) {}
    destroy(e) {
        super.destroy(),
        this.sortDirty = !1;
        const t = typeof e == "boolean" ? e : e?.children
          , i = this.removeChildren(0, this.children.length);
        if (t)
            for (let s = 0; s < i.length; ++s)
                i[s].destroy(e)
    }
    get width() {
        return this.scale.x * this.getLocalBounds().width
    }
    set width(e) {
        const t = this.getLocalBounds().width;
        t !== 0 ? this.scale.x = e / t : this.scale.x = 1,
        this._width = e
    }
    get height() {
        return this.scale.y * this.getLocalBounds().height
    }
    set height(e) {
        const t = this.getLocalBounds().height;
        t !== 0 ? this.scale.y = e / t : this.scale.y = 1,
        this._height = e
    }
}
;
let ae = gd;
ae.defaultSortableChildren = !1;
ae.prototype.containerUpdateTransform = ae.prototype.updateTransform;
Object.defineProperties(ft, {
    SORTABLE_CHILDREN: {
        get() {
            return ae.defaultSortableChildren
        },
        set(e) {
            Qt("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"),
            ae.defaultSortableChildren = e
        }
    }
});
const ea = new Zt
  , w6 = new Uint16Array([0, 1, 2, 0, 2, 3]);
class hi extends ae {
    constructor(t) {
        super(),
        this._anchor = new wn(this._onAnchorUpdate,this,t ? t.defaultAnchor.x : 0,t ? t.defaultAnchor.y : 0),
        this._texture = null,
        this._width = 0,
        this._height = 0,
        this._tint = null,
        this._tintRGB = null,
        this.tint = 16777215,
        this.blendMode = j.NORMAL,
        this._cachedTint = 16777215,
        this.uvs = null,
        this.texture = t || ht.EMPTY,
        this.vertexData = new Float32Array(8),
        this.vertexTrimmedData = null,
        this._transformID = -1,
        this._textureID = -1,
        this._transformTrimmedID = -1,
        this._textureTrimmedID = -1,
        this.indices = w6,
        this.pluginName = "batch",
        this.isSprite = !0,
        this._roundPixels = ft.ROUND_PIXELS
    }
    _onTextureUpdate() {
        this._textureID = -1,
        this._textureTrimmedID = -1,
        this._cachedTint = 16777215,
        this._width && (this.scale.x = rr(this.scale.x) * this._width / this._texture.orig.width),
        this._height && (this.scale.y = rr(this.scale.y) * this._height / this._texture.orig.height)
    }
    _onAnchorUpdate() {
        this._transformID = -1,
        this._transformTrimmedID = -1
    }
    calculateVertices() {
        const t = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === t._updateID)
            return;
        this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32),
        this._transformID = this.transform._worldID,
        this._textureID = t._updateID;
        const i = this.transform.worldTransform
          , s = i.a
          , n = i.b
          , r = i.c
          , o = i.d
          , a = i.tx
          , l = i.ty
          , c = this.vertexData
          , h = t.trim
          , u = t.orig
          , d = this._anchor;
        let f = 0
          , p = 0
          , m = 0
          , g = 0;
        if (h ? (p = h.x - d._x * u.width,
        f = p + h.width,
        g = h.y - d._y * u.height,
        m = g + h.height) : (p = -d._x * u.width,
        f = p + u.width,
        g = -d._y * u.height,
        m = g + u.height),
        c[0] = s * p + r * g + a,
        c[1] = o * g + n * p + l,
        c[2] = s * f + r * g + a,
        c[3] = o * g + n * f + l,
        c[4] = s * f + r * m + a,
        c[5] = o * m + n * f + l,
        c[6] = s * p + r * m + a,
        c[7] = o * m + n * p + l,
        this._roundPixels) {
            const y = ft.RESOLUTION;
            for (let x = 0; x < c.length; ++x)
                c[x] = Math.round(c[x] * y) / y
        }
    }
    calculateTrimmedVertices() {
        if (!this.vertexTrimmedData)
            this.vertexTrimmedData = new Float32Array(8);
        else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID)
            return;
        this._transformTrimmedID = this.transform._worldID,
        this._textureTrimmedID = this._texture._updateID;
        const t = this._texture
          , i = this.vertexTrimmedData
          , s = t.orig
          , n = this._anchor
          , r = this.transform.worldTransform
          , o = r.a
          , a = r.b
          , l = r.c
          , c = r.d
          , h = r.tx
          , u = r.ty
          , d = -n._x * s.width
          , f = d + s.width
          , p = -n._y * s.height
          , m = p + s.height;
        i[0] = o * d + l * p + h,
        i[1] = c * p + a * d + u,
        i[2] = o * f + l * p + h,
        i[3] = c * p + a * f + u,
        i[4] = o * f + l * m + h,
        i[5] = c * m + a * f + u,
        i[6] = o * d + l * m + h,
        i[7] = c * m + a * d + u
    }
    _render(t) {
        this.calculateVertices(),
        t.batch.setObjectRenderer(t.plugins[this.pluginName]),
        t.plugins[this.pluginName].render(this)
    }
    _calculateBounds() {
        const t = this._texture.trim
          , i = this._texture.orig;
        !t || t.width === i.width && t.height === i.height ? (this.calculateVertices(),
        this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(),
        this._bounds.addQuad(this.vertexTrimmedData))
    }
    getLocalBounds(t) {
        return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Ec),
        this._localBounds.minX = this._texture.orig.width * -this._anchor._x,
        this._localBounds.minY = this._texture.orig.height * -this._anchor._y,
        this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x),
        this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y),
        t || (this._localBoundsRect || (this._localBoundsRect = new qt),
        t = this._localBoundsRect),
        this._localBounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
    }
    containsPoint(t) {
        this.worldTransform.applyInverse(t, ea);
        const i = this._texture.orig.width
          , s = this._texture.orig.height
          , n = -i * this.anchor.x;
        let r = 0;
        return ea.x >= n && ea.x < n + i && (r = -s * this.anchor.y,
        ea.y >= r && ea.y < r + s)
    }
    destroy(t) {
        if (super.destroy(t),
        this._texture.off("update", this._onTextureUpdate, this),
        this._anchor = null,
        typeof t == "boolean" ? t : t?.texture) {
            const s = typeof t == "boolean" ? t : t?.baseTexture;
            this._texture.destroy(!!s)
        }
        this._texture = null
    }
    static from(t, i) {
        const s = t instanceof ht ? t : ht.from(t, i);
        return new hi(s)
    }
    set roundPixels(t) {
        this._roundPixels !== t && (this._transformID = -1),
        this._roundPixels = t
    }
    get roundPixels() {
        return this._roundPixels
    }
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(t) {
        const i = rr(this.scale.x) || 1;
        this.scale.x = i * t / this._texture.orig.width,
        this._width = t
    }
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(t) {
        const i = rr(this.scale.y) || 1;
        this.scale.y = i * t / this._texture.orig.height,
        this._height = t
    }
    get anchor() {
        return this._anchor
    }
    set anchor(t) {
        this._anchor.copyFrom(t)
    }
    get tint() {
        return this._tint
    }
    set tint(t) {
        this._tint = t,
        this._tintRGB = (t >> 16) + (t & 65280) + ((t & 255) << 16)
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this),
        this._texture = t || ht.EMPTY,
        this._cachedTint = 16777215,
        this._textureID = -1,
        this._textureTrimmedID = -1,
        t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
    }
}
const y1 = new pe;
Ae.prototype._cacheAsBitmap = !1;
Ae.prototype._cacheData = null;
Ae.prototype._cacheAsBitmapResolution = null;
Ae.prototype._cacheAsBitmapMultisample = null;
class T6 {
    constructor() {
        this.textureCacheId = null,
        this.originalRender = null,
        this.originalRenderCanvas = null,
        this.originalCalculateBounds = null,
        this.originalGetLocalBounds = null,
        this.originalUpdateTransform = null,
        this.originalDestroy = null,
        this.originalMask = null,
        this.originalFilterArea = null,
        this.originalContainsPoint = null,
        this.sprite = null
    }
}
Object.defineProperties(Ae.prototype, {
    cacheAsBitmapResolution: {
        get() {
            return this._cacheAsBitmapResolution
        },
        set(e) {
            e !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = e,
            this.cacheAsBitmap && (this.cacheAsBitmap = !1,
            this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmapMultisample: {
        get() {
            return this._cacheAsBitmapMultisample
        },
        set(e) {
            e !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = e,
            this.cacheAsBitmap && (this.cacheAsBitmap = !1,
            this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmap: {
        get() {
            return this._cacheAsBitmap
        },
        set(e) {
            if (this._cacheAsBitmap === e)
                return;
            this._cacheAsBitmap = e;
            let t;
            e ? (this._cacheData || (this._cacheData = new T6),
            t = this._cacheData,
            t.originalRender = this.render,
            t.originalRenderCanvas = this.renderCanvas,
            t.originalUpdateTransform = this.updateTransform,
            t.originalCalculateBounds = this.calculateBounds,
            t.originalGetLocalBounds = this.getLocalBounds,
            t.originalDestroy = this.destroy,
            t.originalContainsPoint = this.containsPoint,
            t.originalMask = this._mask,
            t.originalFilterArea = this.filterArea,
            this.render = this._renderCached,
            this.renderCanvas = this._renderCachedCanvas,
            this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData,
            t.sprite && this._destroyCachedDisplayObject(),
            this.render = t.originalRender,
            this.renderCanvas = t.originalRenderCanvas,
            this.calculateBounds = t.originalCalculateBounds,
            this.getLocalBounds = t.originalGetLocalBounds,
            this.destroy = t.originalDestroy,
            this.updateTransform = t.originalUpdateTransform,
            this.containsPoint = t.originalContainsPoint,
            this._mask = t.originalMask,
            this.filterArea = t.originalFilterArea)
        }
    }
});
Ae.prototype._renderCached = function(t) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t),
    this._cacheData.sprite.transform._worldID = this.transform._worldID,
    this._cacheData.sprite.worldAlpha = this.worldAlpha,
    this._cacheData.sprite._render(t))
}
;
Ae.prototype._initCachedDisplayObject = function(t) {
    if (this._cacheData?.sprite)
        return;
    const i = this.alpha;
    this.alpha = 1,
    t.batch.flush();
    const s = this.getLocalBounds(null, !0).clone();
    if (this.filters?.length) {
        const d = this.filters[0].padding;
        s.pad(d)
    }
    s.ceil(ft.RESOLUTION);
    const n = t.renderTexture.current
      , r = t.renderTexture.sourceFrame.clone()
      , o = t.renderTexture.destinationFrame.clone()
      , a = t.projection.transform
      , l = fs.create({
        width: s.width,
        height: s.height,
        resolution: this.cacheAsBitmapResolution || t.resolution,
        multisample: this.cacheAsBitmapMultisample ?? t.multisample
    })
      , c = `cacheAsBitmap_${Ln()}`;
    this._cacheData.textureCacheId = c,
    Ot.addToCache(l.baseTexture, c),
    ht.addToCache(l, c);
    const h = this.transform.localTransform.copyTo(y1).invert().translate(-s.x, -s.y);
    this.render = this._cacheData.originalRender,
    t.render(this, {
        renderTexture: l,
        clear: !0,
        transform: h,
        skipUpdateTransform: !1
    }),
    t.framebuffer.blit(),
    t.projection.transform = a,
    t.renderTexture.bind(n, r, o),
    this.render = this._renderCached,
    this.updateTransform = this.displayObjectUpdateTransform,
    this.calculateBounds = this._calculateCachedBounds,
    this.getLocalBounds = this._getCachedLocalBounds,
    this._mask = null,
    this.filterArea = null,
    this.alpha = i;
    const u = new hi(l);
    u.transform.worldTransform = this.transform.worldTransform,
    u.anchor.x = -(s.x / s.width),
    u.anchor.y = -(s.y / s.height),
    u.alpha = i,
    u._bounds = this._bounds,
    this._cacheData.sprite = u,
    this.transform._parentID = -1,
    this.parent ? this.updateTransform() : (this.enableTempParent(),
    this.updateTransform(),
    this.disableTempParent(null)),
    this.containsPoint = u.containsPoint.bind(u)
}
;
Ae.prototype._renderCachedCanvas = function(t) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t),
    this._cacheData.sprite.worldAlpha = this.worldAlpha,
    this._cacheData.sprite._renderCanvas(t))
}
;
Ae.prototype._initCachedDisplayObjectCanvas = function(t) {
    if (this._cacheData?.sprite)
        return;
    const i = this.getLocalBounds(null, !0)
      , s = this.alpha;
    this.alpha = 1;
    const n = t.canvasContext.activeContext
      , r = t._projTransform;
    i.ceil(ft.RESOLUTION);
    const o = fs.create({
        width: i.width,
        height: i.height
    })
      , a = `cacheAsBitmap_${Ln()}`;
    this._cacheData.textureCacheId = a,
    Ot.addToCache(o.baseTexture, a),
    ht.addToCache(o, a);
    const l = y1;
    this.transform.localTransform.copyTo(l),
    l.invert(),
    l.tx -= i.x,
    l.ty -= i.y,
    this.renderCanvas = this._cacheData.originalRenderCanvas,
    t.render(this, {
        renderTexture: o,
        clear: !0,
        transform: l,
        skipUpdateTransform: !1
    }),
    t.canvasContext.activeContext = n,
    t._projTransform = r,
    this.renderCanvas = this._renderCachedCanvas,
    this.updateTransform = this.displayObjectUpdateTransform,
    this.calculateBounds = this._calculateCachedBounds,
    this.getLocalBounds = this._getCachedLocalBounds,
    this._mask = null,
    this.filterArea = null,
    this.alpha = s;
    const c = new hi(o);
    c.transform.worldTransform = this.transform.worldTransform,
    c.anchor.x = -(i.x / i.width),
    c.anchor.y = -(i.y / i.height),
    c.alpha = s,
    c._bounds = this._bounds,
    this._cacheData.sprite = c,
    this.transform._parentID = -1,
    this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent,
    this.updateTransform(),
    this.parent = null),
    this.containsPoint = c.containsPoint.bind(c)
}
;
Ae.prototype._calculateCachedBounds = function() {
    this._bounds.clear(),
    this._cacheData.sprite.transform._worldID = this.transform._worldID,
    this._cacheData.sprite._calculateBounds(),
    this._bounds.updateID = this._boundsID
}
;
Ae.prototype._getCachedLocalBounds = function() {
    return this._cacheData.sprite.getLocalBounds(null)
}
;
Ae.prototype._destroyCachedDisplayObject = function() {
    this._cacheData.sprite._texture.destroy(!0),
    this._cacheData.sprite = null,
    Ot.removeFromCache(this._cacheData.textureCacheId),
    ht.removeFromCache(this._cacheData.textureCacheId),
    this._cacheData.textureCacheId = null
}
;
Ae.prototype._cacheAsBitmapDestroy = function(t) {
    this.cacheAsBitmap = !1,
    this.destroy(t)
}
;
Ae.prototype.name = null;
ae.prototype.getChildByName = function(t, i) {
    for (let s = 0, n = this.children.length; s < n; s++)
        if (this.children[s].name === t)
            return this.children[s];
    if (i)
        for (let s = 0, n = this.children.length; s < n; s++) {
            const r = this.children[s];
            if (!r.getChildByName)
                continue;
            const o = r.getChildByName(t, !0);
            if (o)
                return o
        }
    return null
}
;
Ae.prototype.getGlobalPosition = function(t=new Zt, i=!1) {
    return this.parent ? this.parent.toGlobal(this.position, t, i) : (t.x = this.position.x,
    t.y = this.position.y),
    t
}
;
var E6 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
class S6 extends qe {
    constructor(t=1) {
        super(g6, E6, {
            uAlpha: 1
        }),
        this.alpha = t
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
const C6 = {
    5: [.153388, .221461, .250301],
    7: [.071303, .131514, .189879, .214607],
    9: [.028532, .067234, .124009, .179044, .20236],
    11: [.0093, .028002, .065984, .121703, .175713, .198596],
    13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
    15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
}
  , A6 = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join(`
`);
function I6(e) {
    const t = C6[e]
      , i = t.length;
    let s = A6
      , n = "";
    const r = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
    let o;
    for (let a = 0; a < e; a++) {
        let l = r.replace("%index%", a.toString());
        o = a,
        a >= i && (o = e - a - 1),
        l = l.replace("%value%", t[o].toString()),
        n += l,
        n += `
`
    }
    return s = s.replace("%blur%", n),
    s = s.replace("%size%", e.toString()),
    s
}
const M6 = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;
function R6(e, t) {
    const i = Math.ceil(e / 2);
    let s = M6, n = "", r;
    t ? r = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : r = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
    for (let o = 0; o < e; o++) {
        let a = r.replace("%index%", o.toString());
        a = a.replace("%sampleIndex%", `${o - (i - 1)}.0`),
        n += a,
        n += `
`
    }
    return s = s.replace("%blur%", n),
    s = s.replace("%size%", e.toString()),
    s
}
class vd extends qe {
    constructor(t, i=8, s=4, n=qe.defaultResolution, r=5) {
        const o = R6(r, t)
          , a = I6(r);
        super(o, a),
        this.horizontal = t,
        this.resolution = n,
        this._quality = 0,
        this.quality = s,
        this.blur = i
    }
    apply(t, i, s, n) {
        if (s ? this.horizontal ? this.uniforms.strength = 1 / s.width * (s.width / i.width) : this.uniforms.strength = 1 / s.height * (s.height / i.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / i.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / i.height),
        this.uniforms.strength *= this.strength,
        this.uniforms.strength /= this.passes,
        this.passes === 1)
            t.applyFilter(this, i, s, n);
        else {
            const r = t.getFilterTexture()
              , o = t.renderer;
            let a = i
              , l = r;
            this.state.blend = !1,
            t.applyFilter(this, a, l, Ss.CLEAR);
            for (let c = 1; c < this.passes - 1; c++) {
                t.bindAndClear(a, Ss.BLIT),
                this.uniforms.uSampler = l;
                const h = l;
                l = a,
                a = h,
                o.shader.bind(this),
                o.geometry.draw(5)
            }
            this.state.blend = !0,
            t.applyFilter(this, l, s, n),
            t.returnFilterTexture(r)
        }
    }
    get blur() {
        return this.strength
    }
    set blur(t) {
        this.padding = 1 + Math.abs(t) * 2,
        this.strength = t
    }
    get quality() {
        return this._quality
    }
    set quality(t) {
        this._quality = t,
        this.passes = t
    }
}
class k6 extends qe {
    constructor(t=8, i=4, s=qe.defaultResolution, n=5) {
        super(),
        this.blurXFilter = new vd(!0,t,i,s,n),
        this.blurYFilter = new vd(!1,t,i,s,n),
        this.resolution = s,
        this.quality = i,
        this.blur = t,
        this.repeatEdgePixels = !1
    }
    apply(t, i, s, n) {
        const r = Math.abs(this.blurXFilter.strength)
          , o = Math.abs(this.blurYFilter.strength);
        if (r && o) {
            const a = t.getFilterTexture();
            this.blurXFilter.apply(t, i, a, Ss.CLEAR),
            this.blurYFilter.apply(t, a, s, n),
            t.returnFilterTexture(a)
        } else
            o ? this.blurYFilter.apply(t, i, s, n) : this.blurXFilter.apply(t, i, s, n)
    }
    updatePadding() {
        this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2
    }
    get blur() {
        return this.blurXFilter.blur
    }
    set blur(t) {
        this.blurXFilter.blur = this.blurYFilter.blur = t,
        this.updatePadding()
    }
    get quality() {
        return this.blurXFilter.quality
    }
    set quality(t) {
        this.blurXFilter.quality = this.blurYFilter.quality = t
    }
    get blurX() {
        return this.blurXFilter.blur
    }
    set blurX(t) {
        this.blurXFilter.blur = t,
        this.updatePadding()
    }
    get blurY() {
        return this.blurYFilter.blur
    }
    set blurY(t) {
        this.blurYFilter.blur = t,
        this.updatePadding()
    }
    get blendMode() {
        return this.blurYFilter.blendMode
    }
    set blendMode(t) {
        this.blurYFilter.blendMode = t
    }
    get repeatEdgePixels() {
        return this._repeatEdgePixels
    }
    set repeatEdgePixels(t) {
        this._repeatEdgePixels = t,
        this.updatePadding()
    }
}
var P6 = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;
class _d extends qe {
    constructor() {
        const t = {
            m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
            uAlpha: 1
        };
        super(d1, P6, t),
        this.alpha = 1
    }
    _loadMatrix(t, i=!1) {
        let s = t;
        i && (this._multiply(s, this.uniforms.m, t),
        s = this._colorMatrix(s)),
        this.uniforms.m = s
    }
    _multiply(t, i, s) {
        return t[0] = i[0] * s[0] + i[1] * s[5] + i[2] * s[10] + i[3] * s[15],
        t[1] = i[0] * s[1] + i[1] * s[6] + i[2] * s[11] + i[3] * s[16],
        t[2] = i[0] * s[2] + i[1] * s[7] + i[2] * s[12] + i[3] * s[17],
        t[3] = i[0] * s[3] + i[1] * s[8] + i[2] * s[13] + i[3] * s[18],
        t[4] = i[0] * s[4] + i[1] * s[9] + i[2] * s[14] + i[3] * s[19] + i[4],
        t[5] = i[5] * s[0] + i[6] * s[5] + i[7] * s[10] + i[8] * s[15],
        t[6] = i[5] * s[1] + i[6] * s[6] + i[7] * s[11] + i[8] * s[16],
        t[7] = i[5] * s[2] + i[6] * s[7] + i[7] * s[12] + i[8] * s[17],
        t[8] = i[5] * s[3] + i[6] * s[8] + i[7] * s[13] + i[8] * s[18],
        t[9] = i[5] * s[4] + i[6] * s[9] + i[7] * s[14] + i[8] * s[19] + i[9],
        t[10] = i[10] * s[0] + i[11] * s[5] + i[12] * s[10] + i[13] * s[15],
        t[11] = i[10] * s[1] + i[11] * s[6] + i[12] * s[11] + i[13] * s[16],
        t[12] = i[10] * s[2] + i[11] * s[7] + i[12] * s[12] + i[13] * s[17],
        t[13] = i[10] * s[3] + i[11] * s[8] + i[12] * s[13] + i[13] * s[18],
        t[14] = i[10] * s[4] + i[11] * s[9] + i[12] * s[14] + i[13] * s[19] + i[14],
        t[15] = i[15] * s[0] + i[16] * s[5] + i[17] * s[10] + i[18] * s[15],
        t[16] = i[15] * s[1] + i[16] * s[6] + i[17] * s[11] + i[18] * s[16],
        t[17] = i[15] * s[2] + i[16] * s[7] + i[17] * s[12] + i[18] * s[17],
        t[18] = i[15] * s[3] + i[16] * s[8] + i[17] * s[13] + i[18] * s[18],
        t[19] = i[15] * s[4] + i[16] * s[9] + i[17] * s[14] + i[18] * s[19] + i[19],
        t
    }
    _colorMatrix(t) {
        const i = new Float32Array(t);
        return i[4] /= 255,
        i[9] /= 255,
        i[14] /= 255,
        i[19] /= 255,
        i
    }
    brightness(t, i) {
        const s = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, i)
    }
    tint(t, i) {
        const s = t >> 16 & 255
          , n = t >> 8 & 255
          , r = t & 255
          , o = [s / 255, 0, 0, 0, 0, 0, n / 255, 0, 0, 0, 0, 0, r / 255, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(o, i)
    }
    greyscale(t, i) {
        const s = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, i)
    }
    blackAndWhite(t) {
        const i = [.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    hue(t, i) {
        t = (t || 0) / 180 * Math.PI;
        const s = Math.cos(t)
          , n = Math.sin(t)
          , r = Math.sqrt
          , o = 1 / 3
          , a = r(o)
          , l = s + (1 - s) * o
          , c = o * (1 - s) - a * n
          , h = o * (1 - s) + a * n
          , u = o * (1 - s) + a * n
          , d = s + o * (1 - s)
          , f = o * (1 - s) - a * n
          , p = o * (1 - s) - a * n
          , m = o * (1 - s) + a * n
          , g = s + o * (1 - s)
          , y = [l, c, h, 0, 0, u, d, f, 0, 0, p, m, g, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(y, i)
    }
    contrast(t, i) {
        const s = (t || 0) + 1
          , n = -.5 * (s - 1)
          , r = [s, 0, 0, 0, n, 0, s, 0, 0, n, 0, 0, s, 0, n, 0, 0, 0, 1, 0];
        this._loadMatrix(r, i)
    }
    saturate(t=0, i) {
        const s = t * 2 / 3 + 1
          , n = (s - 1) * -.5
          , r = [s, n, n, 0, 0, n, s, n, 0, 0, n, n, s, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, i)
    }
    desaturate() {
        this.saturate(-1)
    }
    negative(t) {
        const i = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    sepia(t) {
        const i = [.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    technicolor(t) {
        const i = [1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    polaroid(t) {
        const i = [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    toBGR(t) {
        const i = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    kodachrome(t) {
        const i = [1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    browni(t) {
        const i = [.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    vintage(t) {
        const i = [.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    colorTone(t, i, s, n, r) {
        t = t || .2,
        i = i || .15,
        s = s || 16770432,
        n = n || 3375104;
        const o = (s >> 16 & 255) / 255
          , a = (s >> 8 & 255) / 255
          , l = (s & 255) / 255
          , c = (n >> 16 & 255) / 255
          , h = (n >> 8 & 255) / 255
          , u = (n & 255) / 255
          , d = [.3, .59, .11, 0, 0, o, a, l, t, 0, c, h, u, i, 0, o - c, a - h, l - u, 0, 0];
        this._loadMatrix(d, r)
    }
    night(t, i) {
        t = t || .1;
        const s = [t * -2, -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, t * 2, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, i)
    }
    predator(t, i) {
        const s = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
        this._loadMatrix(s, i)
    }
    lsd(t) {
        const i = [2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    reset() {
        const t = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(t, !1)
    }
    get matrix() {
        return this.uniforms.m
    }
    set matrix(t) {
        this.uniforms.m = t
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
_d.prototype.grayscale = _d.prototype.greyscale;
var L6 = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`
  , O6 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
class D6 extends qe {
    constructor(t, i) {
        const s = new pe;
        t.renderable = !1,
        super(O6, L6, {
            mapSampler: t._texture,
            filterMatrix: s,
            scale: {
                x: 1,
                y: 1
            },
            rotation: new Float32Array([1, 0, 0, 1])
        }),
        this.maskSprite = t,
        this.maskMatrix = s,
        i == null && (i = 20),
        this.scale = new Zt(i,i)
    }
    apply(t, i, s, n) {
        this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite),
        this.uniforms.scale.x = this.scale.x,
        this.uniforms.scale.y = this.scale.y;
        const r = this.maskSprite.worldTransform
          , o = Math.sqrt(r.a * r.a + r.b * r.b)
          , a = Math.sqrt(r.c * r.c + r.d * r.d);
        o !== 0 && a !== 0 && (this.uniforms.rotation[0] = r.a / o,
        this.uniforms.rotation[1] = r.b / o,
        this.uniforms.rotation[2] = r.c / a,
        this.uniforms.rotation[3] = r.d / a),
        t.applyFilter(this, i, s, n)
    }
    get map() {
        return this.uniforms.mapSampler
    }
    set map(t) {
        this.uniforms.mapSampler = t
    }
}
var N6 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`
  , F6 = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;
class B6 extends qe {
    constructor() {
        super(F6, N6)
    }
}
var U6 = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
class G6 extends qe {
    constructor(t=.5, i=Math.random()) {
        super(d1, U6, {
            uNoise: 0,
            uSeed: 0
        }),
        this.noise = t,
        this.seed = i
    }
    get noise() {
        return this.uniforms.uNoise
    }
    set noise(t) {
        this.uniforms.uNoise = t
    }
    get seed() {
        return this.uniforms.uSeed
    }
    set seed(t) {
        this.uniforms.uSeed = t
    }
}
const mg = {
    AlphaFilter: S6,
    BlurFilter: k6,
    BlurFilterPass: vd,
    ColorMatrixFilter: _d,
    DisplacementFilter: D6,
    FXAAFilter: B6,
    NoiseFilter: G6
};
Object.entries(mg).forEach(([e,t])=>{
    Object.defineProperty(mg, e, {
        get() {
            return Qt("7.1.0", `filters.${e} has moved to ${e}`),
            t
        }
    })
}
);
class Ja {
    constructor(t) {
        this.bubbles = !0,
        this.cancelBubble = !0,
        this.cancelable = !1,
        this.composed = !1,
        this.defaultPrevented = !1,
        this.eventPhase = Ja.prototype.NONE,
        this.propagationStopped = !1,
        this.propagationImmediatelyStopped = !1,
        this.layer = new Zt,
        this.page = new Zt,
        this.AT_TARGET = 1,
        this.BUBBLING_PHASE = 2,
        this.CAPTURING_PHASE = 3,
        this.NONE = 0,
        this.manager = t
    }
    get layerX() {
        return this.layer.x
    }
    get layerY() {
        return this.layer.y
    }
    get pageX() {
        return this.page.x
    }
    get pageY() {
        return this.page.y
    }
    get data() {
        return this
    }
    composedPath() {
        return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []),
        this.path
    }
    initEvent(t, i, s) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    initUIEvent(t, i, s, n, r) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(),
        this.defaultPrevented = !0
    }
    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0
    }
    stopPropagation() {
        this.propagationStopped = !0
    }
}
class Sc extends Ja {
    constructor() {
        super(...arguments),
        this.client = new Zt,
        this.movement = new Zt,
        this.offset = new Zt,
        this.global = new Zt,
        this.screen = new Zt
    }
    get clientX() {
        return this.client.x
    }
    get clientY() {
        return this.client.y
    }
    get x() {
        return this.clientX
    }
    get y() {
        return this.clientY
    }
    get movementX() {
        return this.movement.x
    }
    get movementY() {
        return this.movement.y
    }
    get offsetX() {
        return this.offset.x
    }
    get offsetY() {
        return this.offset.y
    }
    get globalX() {
        return this.global.x
    }
    get globalY() {
        return this.global.y
    }
    get screenX() {
        return this.screen.x
    }
    get screenY() {
        return this.screen.y
    }
    getModifierState(t) {
        return "getModifierState"in this.nativeEvent && this.nativeEvent.getModifierState(t)
    }
    initMouseEvent(t, i, s, n, r, o, a, l, c, h, u, d, f, p, m) {
        throw new Error("Method not implemented.")
    }
}
class Ji extends Sc {
    constructor() {
        super(...arguments),
        this.width = 0,
        this.height = 0,
        this.isPrimary = !1
    }
    getCoalescedEvents() {
        return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : []
    }
    getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!")
    }
}
class yd extends Sc {
    constructor() {
        super(...arguments),
        this.DOM_DELTA_LINE = 0,
        this.DOM_DELTA_PAGE = 1,
        this.DOM_DELTA_PIXEL = 2
    }
}
const H6 = 2048
  , V6 = new Zt
  , ru = new Zt;
class z6 {
    constructor(t) {
        this.dispatch = new $o,
        this.moveOnAll = !1,
        this.mappingState = {
            trackingData: {}
        },
        this.eventPool = new Map,
        this.rootTarget = t,
        this.hitPruneFn = this.hitPruneFn.bind(this),
        this.hitTestFn = this.hitTestFn.bind(this),
        this.mapPointerDown = this.mapPointerDown.bind(this),
        this.mapPointerMove = this.mapPointerMove.bind(this),
        this.mapPointerOut = this.mapPointerOut.bind(this),
        this.mapPointerOver = this.mapPointerOver.bind(this),
        this.mapPointerUp = this.mapPointerUp.bind(this),
        this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this),
        this.mapWheel = this.mapWheel.bind(this),
        this.mappingTable = {},
        this.addEventMapping("pointerdown", this.mapPointerDown),
        this.addEventMapping("pointermove", this.mapPointerMove),
        this.addEventMapping("pointerout", this.mapPointerOut),
        this.addEventMapping("pointerleave", this.mapPointerOut),
        this.addEventMapping("pointerover", this.mapPointerOver),
        this.addEventMapping("pointerup", this.mapPointerUp),
        this.addEventMapping("pointerupoutside", this.mapPointerUpOutside),
        this.addEventMapping("wheel", this.mapWheel)
    }
    addEventMapping(t, i) {
        this.mappingTable[t] || (this.mappingTable[t] = []),
        this.mappingTable[t].push({
            fn: i,
            priority: 0
        }),
        this.mappingTable[t].sort((s,n)=>s.priority - n.priority)
    }
    dispatchEvent(t, i) {
        t.propagationStopped = !1,
        t.propagationImmediatelyStopped = !1,
        this.propagate(t, i),
        this.dispatch.emit(i || t.type, t)
    }
    mapEvent(t) {
        if (!this.rootTarget)
            return;
        const i = this.mappingTable[t.type];
        if (i)
            for (let s = 0, n = i.length; s < n; s++)
                i[s].fn(t);
        else
            console.warn(`[EventBoundary]: Event mapping not defined for ${t.type}`)
    }
    hitTest(t, i) {
        const s = this.hitTestRecursive(this.rootTarget, this.rootTarget.interactive, V6.set(t, i), this.hitTestFn, this.hitPruneFn);
        return s && s[0]
    }
    propagate(t, i) {
        if (!t.target)
            return;
        const s = t.composedPath();
        t.eventPhase = t.CAPTURING_PHASE;
        for (let n = 0, r = s.length - 1; n < r; n++)
            if (t.currentTarget = s[n],
            this.notifyTarget(t, i),
            t.propagationStopped || t.propagationImmediatelyStopped)
                return;
        if (t.eventPhase = t.AT_TARGET,
        t.currentTarget = t.target,
        this.notifyTarget(t, i),
        !(t.propagationStopped || t.propagationImmediatelyStopped)) {
            t.eventPhase = t.BUBBLING_PHASE;
            for (let n = s.length - 2; n >= 0; n--)
                if (t.currentTarget = s[n],
                this.notifyTarget(t, i),
                t.propagationStopped || t.propagationImmediatelyStopped)
                    return
        }
    }
    all(t, i, s=this.rootTarget) {
        t.eventPhase = t.BUBBLING_PHASE;
        const n = s.children;
        if (n)
            for (let r = 0; r < n.length; r++)
                this.all(t, i, n[r]);
        t.currentTarget = s,
        this.notifyTarget(t, i)
    }
    propagationPath(t) {
        const i = [t];
        for (let s = 0; s < H6 && t !== this.rootTarget; s++) {
            if (!t.parent)
                throw new Error("Cannot find propagation path to disconnected target");
            i.push(t.parent),
            t = t.parent
        }
        return i.reverse(),
        i
    }
    hitTestRecursive(t, i, s, n, r) {
        if (!t || !t.visible || r(t, s))
            return null;
        if (t.interactiveChildren && t.children) {
            const o = t.children;
            for (let a = o.length - 1; a >= 0; a--) {
                const l = o[a]
                  , c = this.hitTestRecursive(l, i || l.interactive, s, n, r);
                if (c) {
                    if (c.length > 0 && !c[c.length - 1].parent)
                        continue;
                    return (c.length > 0 || t.interactive) && c.push(t),
                    c
                }
            }
        }
        return i && n(t, s) ? t.interactive ? [t] : [] : null
    }
    hitPruneFn(t, i) {
        if (t.hitArea && (t.worldTransform.applyInverse(i, ru),
        !t.hitArea.contains(ru.x, ru.y)))
            return !0;
        if (t._mask) {
            const s = t._mask.isMaskData ? t._mask.maskObject : t._mask;
            if (s && !s.containsPoint?.(i))
                return !0
        }
        return !1
    }
    hitTestFn(t, i) {
        return t.hitArea ? !0 : t.containsPoint ? t.containsPoint(i) : !1
    }
    notifyTarget(t, i) {
        i = i ?? t.type;
        const s = `on${i}`;
        t.currentTarget[s]?.(t);
        const n = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${i}capture` : i;
        this.notifyListeners(t, n),
        t.eventPhase === t.AT_TARGET && this.notifyListeners(t, i)
    }
    mapPointerDown(t) {
        if (!(t instanceof Ji)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const i = this.createPointerEvent(t);
        if (this.dispatchEvent(i, "pointerdown"),
        i.pointerType === "touch")
            this.dispatchEvent(i, "touchstart");
        else if (i.pointerType === "mouse" || i.pointerType === "pen") {
            const n = i.button === 2;
            this.dispatchEvent(i, n ? "rightdown" : "mousedown")
        }
        const s = this.trackingData(t.pointerId);
        s.pressTargetsByButton[t.button] = i.composedPath(),
        this.freeEvent(i)
    }
    mapPointerMove(t) {
        if (!(t instanceof Ji)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const i = this.createPointerEvent(t)
          , s = i.pointerType === "mouse" || i.pointerType === "pen"
          , n = this.trackingData(t.pointerId)
          , r = this.findMountedTarget(n.overTargets);
        if (n.overTargets?.length > 0 && r !== i.target) {
            const a = t.type === "mousemove" ? "mouseout" : "pointerout"
              , l = this.createPointerEvent(t, a, r);
            if (this.dispatchEvent(l, "pointerout"),
            s && this.dispatchEvent(l, "mouseout"),
            !i.composedPath().includes(r)) {
                const c = this.createPointerEvent(t, "pointerleave", r);
                for (c.eventPhase = c.AT_TARGET; c.target && !i.composedPath().includes(c.target); )
                    c.currentTarget = c.target,
                    this.notifyTarget(c),
                    s && this.notifyTarget(c, "mouseleave"),
                    c.target = c.target.parent;
                this.freeEvent(c)
            }
            this.freeEvent(l)
        }
        if (r !== i.target) {
            const a = t.type === "mousemove" ? "mouseover" : "pointerover"
              , l = this.clonePointerEvent(i, a);
            this.dispatchEvent(l, "pointerover"),
            s && this.dispatchEvent(l, "mouseover");
            let c = r?.parent;
            for (; c && c !== this.rootTarget.parent && c !== i.target; )
                c = c.parent;
            if (!c || c === this.rootTarget.parent) {
                const u = this.clonePointerEvent(i, "pointerenter");
                for (u.eventPhase = u.AT_TARGET; u.target && u.target !== r && u.target !== this.rootTarget.parent; )
                    u.currentTarget = u.target,
                    this.notifyTarget(u),
                    s && this.notifyTarget(u, "mouseenter"),
                    u.target = u.target.parent;
                this.freeEvent(u)
            }
            this.freeEvent(l)
        }
        const o = this.moveOnAll ? "all" : "dispatchEvent";
        this[o](i, "pointermove"),
        this.all(i, "globalpointermove"),
        i.pointerType === "touch" && (this[o](i, "touchmove"),
        this.all(i, "globaltouchmove")),
        s && (this[o](i, "mousemove"),
        this.all(i, "globalmousemove"),
        this.cursor = i.target?.cursor),
        n.overTargets = i.composedPath(),
        this.freeEvent(i)
    }
    mapPointerOver(t) {
        if (!(t instanceof Ji)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const i = this.trackingData(t.pointerId)
          , s = this.createPointerEvent(t)
          , n = s.pointerType === "mouse" || s.pointerType === "pen";
        this.dispatchEvent(s, "pointerover"),
        n && this.dispatchEvent(s, "mouseover"),
        s.pointerType === "mouse" && (this.cursor = s.target?.cursor);
        const r = this.clonePointerEvent(s, "pointerenter");
        for (r.eventPhase = r.AT_TARGET; r.target && r.target !== this.rootTarget.parent; )
            r.currentTarget = r.target,
            this.notifyTarget(r),
            n && this.notifyTarget(r, "mouseenter"),
            r.target = r.target.parent;
        i.overTargets = s.composedPath(),
        this.freeEvent(s),
        this.freeEvent(r)
    }
    mapPointerOut(t) {
        if (!(t instanceof Ji)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const i = this.trackingData(t.pointerId);
        if (i.overTargets) {
            const s = t.pointerType === "mouse" || t.pointerType === "pen"
              , n = this.findMountedTarget(i.overTargets)
              , r = this.createPointerEvent(t, "pointerout", n);
            this.dispatchEvent(r),
            s && this.dispatchEvent(r, "mouseout");
            const o = this.createPointerEvent(t, "pointerleave", n);
            for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent; )
                o.currentTarget = o.target,
                this.notifyTarget(o),
                s && this.notifyTarget(o, "mouseleave"),
                o.target = o.target.parent;
            i.overTargets = null,
            this.freeEvent(r),
            this.freeEvent(o)
        }
        this.cursor = null
    }
    mapPointerUp(t) {
        if (!(t instanceof Ji)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const i = performance.now()
          , s = this.createPointerEvent(t);
        if (this.dispatchEvent(s, "pointerup"),
        s.pointerType === "touch")
            this.dispatchEvent(s, "touchend");
        else if (s.pointerType === "mouse" || s.pointerType === "pen") {
            const a = s.button === 2;
            this.dispatchEvent(s, a ? "rightup" : "mouseup")
        }
        const n = this.trackingData(t.pointerId)
          , r = this.findMountedTarget(n.pressTargetsByButton[t.button]);
        let o = r;
        if (r && !s.composedPath().includes(r)) {
            let a = r;
            for (; a && !s.composedPath().includes(a); ) {
                if (s.currentTarget = a,
                this.notifyTarget(s, "pointerupoutside"),
                s.pointerType === "touch")
                    this.notifyTarget(s, "touchendoutside");
                else if (s.pointerType === "mouse" || s.pointerType === "pen") {
                    const l = s.button === 2;
                    this.notifyTarget(s, l ? "rightupoutside" : "mouseupoutside")
                }
                a = a.parent
            }
            delete n.pressTargetsByButton[t.button],
            o = a
        }
        if (o) {
            const a = this.clonePointerEvent(s, "click");
            a.target = o,
            a.path = null,
            n.clicksByButton[t.button] || (n.clicksByButton[t.button] = {
                clickCount: 0,
                target: a.target,
                timeStamp: i
            });
            const l = n.clicksByButton[t.button];
            l.target === a.target && i - l.timeStamp < 200 ? ++l.clickCount : l.clickCount = 1,
            l.target = a.target,
            l.timeStamp = i,
            a.detail = l.clickCount,
            a.pointerType === "mouse" ? this.dispatchEvent(a, "click") : a.pointerType === "touch" && this.dispatchEvent(a, "tap"),
            this.dispatchEvent(a, "pointertap"),
            this.freeEvent(a)
        }
        this.freeEvent(s)
    }
    mapPointerUpOutside(t) {
        if (!(t instanceof Ji)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const i = this.trackingData(t.pointerId)
          , s = this.findMountedTarget(i.pressTargetsByButton[t.button])
          , n = this.createPointerEvent(t);
        if (s) {
            let r = s;
            for (; r; )
                n.currentTarget = r,
                this.notifyTarget(n, "pointerupoutside"),
                n.pointerType === "touch" ? this.notifyTarget(n, "touchendoutside") : (n.pointerType === "mouse" || n.pointerType === "pen") && this.notifyTarget(n, n.button === 2 ? "rightupoutside" : "mouseupoutside"),
                r = r.parent;
            delete i.pressTargetsByButton[t.button]
        }
        this.freeEvent(n)
    }
    mapWheel(t) {
        if (!(t instanceof yd)) {
            console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return
        }
        const i = this.createWheelEvent(t);
        this.dispatchEvent(i),
        this.freeEvent(i)
    }
    findMountedTarget(t) {
        if (!t)
            return null;
        let i = t[0];
        for (let s = 1; s < t.length && t[s].parent === i; s++)
            i = t[s];
        return i
    }
    createPointerEvent(t, i, s) {
        const n = this.allocateEvent(Ji);
        return this.copyPointerData(t, n),
        this.copyMouseData(t, n),
        this.copyData(t, n),
        n.nativeEvent = t.nativeEvent,
        n.originalEvent = t,
        n.target = s ?? this.hitTest(n.global.x, n.global.y),
        typeof i == "string" && (n.type = i),
        n
    }
    createWheelEvent(t) {
        const i = this.allocateEvent(yd);
        return this.copyWheelData(t, i),
        this.copyMouseData(t, i),
        this.copyData(t, i),
        i.nativeEvent = t.nativeEvent,
        i.originalEvent = t,
        i.target = this.hitTest(i.global.x, i.global.y),
        i
    }
    clonePointerEvent(t, i) {
        const s = this.allocateEvent(Ji);
        return s.nativeEvent = t.nativeEvent,
        s.originalEvent = t.originalEvent,
        this.copyPointerData(t, s),
        this.copyMouseData(t, s),
        this.copyData(t, s),
        s.target = t.target,
        s.path = t.composedPath().slice(),
        s.type = i ?? s.type,
        s
    }
    copyWheelData(t, i) {
        i.deltaMode = t.deltaMode,
        i.deltaX = t.deltaX,
        i.deltaY = t.deltaY,
        i.deltaZ = t.deltaZ
    }
    copyPointerData(t, i) {
        t instanceof Ji && i instanceof Ji && (i.pointerId = t.pointerId,
        i.width = t.width,
        i.height = t.height,
        i.isPrimary = t.isPrimary,
        i.pointerType = t.pointerType,
        i.pressure = t.pressure,
        i.tangentialPressure = t.tangentialPressure,
        i.tiltX = t.tiltX,
        i.tiltY = t.tiltY,
        i.twist = t.twist)
    }
    copyMouseData(t, i) {
        t instanceof Sc && i instanceof Sc && (i.altKey = t.altKey,
        i.button = t.button,
        i.buttons = t.buttons,
        i.client.copyFrom(t.client),
        i.ctrlKey = t.ctrlKey,
        i.metaKey = t.metaKey,
        i.movement.copyFrom(t.movement),
        i.screen.copyFrom(t.screen),
        i.global.copyFrom(t.global))
    }
    copyData(t, i) {
        i.isTrusted = t.isTrusted,
        i.srcElement = t.srcElement,
        i.timeStamp = performance.now(),
        i.type = t.type,
        i.detail = t.detail,
        i.view = t.view,
        i.which = t.which,
        i.layer.copyFrom(t.layer),
        i.page.copyFrom(t.page)
    }
    trackingData(t) {
        return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
        }),
        this.mappingState.trackingData[t]
    }
    allocateEvent(t) {
        this.eventPool.has(t) || this.eventPool.set(t, []);
        const i = this.eventPool.get(t).pop() || new t(this);
        return i.eventPhase = i.NONE,
        i.currentTarget = null,
        i.path = null,
        i.target = null,
        i
    }
    freeEvent(t) {
        if (t.manager !== this)
            throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const i = t.constructor;
        this.eventPool.has(i) || this.eventPool.set(i, []),
        this.eventPool.get(i).push(t)
    }
    notifyListeners(t, i) {
        const s = t.currentTarget._events[i];
        if (!!s)
            if ("fn"in s)
                s.fn.call(s.context, t);
            else
                for (let n = 0, r = s.length; n < r && !t.propagationImmediatelyStopped; n++)
                    s[n].fn.call(s[n].context, t)
    }
}
const $6 = 1
  , j6 = {
    touchstart: "pointerdown",
    touchend: "pointerup",
    touchendoutside: "pointerupoutside",
    touchmove: "pointermove",
    touchcancel: "pointercancel"
};
class b1 {
    constructor(t) {
        this.supportsTouchEvents = "ontouchstart"in globalThis,
        this.supportsPointerEvents = !!globalThis.PointerEvent,
        this.domElement = null,
        this.resolution = 1,
        this.renderer = t,
        this.rootBoundary = new z6(null),
        this.autoPreventDefault = !0,
        this.eventsAdded = !1,
        this.rootPointerEvent = new Ji(null),
        this.rootWheelEvent = new yd(null),
        this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
        },
        this.onPointerDown = this.onPointerDown.bind(this),
        this.onPointerMove = this.onPointerMove.bind(this),
        this.onPointerUp = this.onPointerUp.bind(this),
        this.onPointerOverOut = this.onPointerOverOut.bind(this),
        this.onWheel = this.onWheel.bind(this)
    }
    init() {
        const {view: t, resolution: i} = this.renderer;
        this.setTargetElement(t),
        this.resolution = i
    }
    resolutionChange(t) {
        this.resolution = t
    }
    destroy() {
        this.setTargetElement(null),
        this.renderer = null
    }
    setCursor(t) {
        t = t || "default";
        let i = !0;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (i = !1),
        this.currentCursor === t)
            return;
        this.currentCursor = t;
        const s = this.cursorStyles[t];
        if (s)
            switch (typeof s) {
            case "string":
                i && (this.domElement.style.cursor = s);
                break;
            case "function":
                s(t);
                break;
            case "object":
                i && Object.assign(this.domElement.style, s);
                break
            }
        else
            i && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t)
    }
    onPointerDown(t) {
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        this.supportsTouchEvents && t.pointerType === "touch")
            return;
        const i = this.normalizeToPointerData(t);
        this.autoPreventDefault && i[0].isNormalized && (t.cancelable || !("cancelable"in t)) && t.preventDefault();
        for (let s = 0, n = i.length; s < n; s++) {
            const r = i[s]
              , o = this.bootstrapEvent(this.rootPointerEvent, r);
            this.rootBoundary.mapEvent(o)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerMove(t) {
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        this.supportsTouchEvents && t.pointerType === "touch")
            return;
        const i = this.normalizeToPointerData(t);
        for (let s = 0, n = i.length; s < n; s++) {
            const r = this.bootstrapEvent(this.rootPointerEvent, i[s]);
            this.rootBoundary.mapEvent(r)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerUp(t) {
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        this.supportsTouchEvents && t.pointerType === "touch")
            return;
        let i = t.target;
        t.composedPath && t.composedPath().length > 0 && (i = t.composedPath()[0]);
        const s = i !== this.domElement ? "outside" : ""
          , n = this.normalizeToPointerData(t);
        for (let r = 0, o = n.length; r < o; r++) {
            const a = this.bootstrapEvent(this.rootPointerEvent, n[r]);
            a.type += s,
            this.rootBoundary.mapEvent(a)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerOverOut(t) {
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        this.supportsTouchEvents && t.pointerType === "touch")
            return;
        const i = this.normalizeToPointerData(t);
        for (let s = 0, n = i.length; s < n; s++) {
            const r = this.bootstrapEvent(this.rootPointerEvent, i[s]);
            this.rootBoundary.mapEvent(r)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onWheel(t) {
        const i = this.normalizeWheelEvent(t);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered,
        this.rootBoundary.mapEvent(i)
    }
    setTargetElement(t) {
        this.removeEvents(),
        this.domElement = t,
        this.addEvents()
    }
    addEvents() {
        if (this.eventsAdded || !this.domElement)
            return;
        const t = this.domElement.style;
        t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none",
        t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")),
        this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0),
        this.domElement.addEventListener("pointerdown", this.onPointerDown, !0),
        this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0),
        this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0),
        globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0),
        this.domElement.addEventListener("mousedown", this.onPointerDown, !0),
        this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0),
        this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0),
        globalThis.addEventListener("mouseup", this.onPointerUp, !0)),
        this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0),
        this.domElement.addEventListener("touchend", this.onPointerUp, !0),
        this.domElement.addEventListener("touchmove", this.onPointerMove, !0)),
        this.domElement.addEventListener("wheel", this.onWheel, {
            passive: !0,
            capture: !0
        }),
        this.eventsAdded = !0
    }
    removeEvents() {
        if (!this.eventsAdded || !this.domElement)
            return;
        const t = this.domElement.style;
        globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "",
        t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""),
        this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0),
        this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0),
        this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0),
        this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0),
        globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0),
        this.domElement.removeEventListener("mousedown", this.onPointerDown, !0),
        this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0),
        this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0),
        globalThis.removeEventListener("mouseup", this.onPointerUp, !0)),
        this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0),
        this.domElement.removeEventListener("touchend", this.onPointerUp, !0),
        this.domElement.removeEventListener("touchmove", this.onPointerMove, !0)),
        this.domElement.removeEventListener("wheel", this.onWheel, !0),
        this.domElement = null,
        this.eventsAdded = !1
    }
    mapPositionToPoint(t, i, s) {
        let n;
        this.domElement.parentElement ? n = this.domElement.getBoundingClientRect() : n = {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
        };
        const r = 1 / this.resolution;
        t.x = (i - n.left) * (this.domElement.width / n.width) * r,
        t.y = (s - n.top) * (this.domElement.height / n.height) * r
    }
    normalizeToPointerData(t) {
        const i = [];
        if (this.supportsTouchEvents && t instanceof TouchEvent)
            for (let s = 0, n = t.changedTouches.length; s < n; s++) {
                const r = t.changedTouches[s];
                typeof r.button > "u" && (r.button = 0),
                typeof r.buttons > "u" && (r.buttons = 1),
                typeof r.isPrimary > "u" && (r.isPrimary = t.touches.length === 1 && t.type === "touchstart"),
                typeof r.width > "u" && (r.width = r.radiusX || 1),
                typeof r.height > "u" && (r.height = r.radiusY || 1),
                typeof r.tiltX > "u" && (r.tiltX = 0),
                typeof r.tiltY > "u" && (r.tiltY = 0),
                typeof r.pointerType > "u" && (r.pointerType = "touch"),
                typeof r.pointerId > "u" && (r.pointerId = r.identifier || 0),
                typeof r.pressure > "u" && (r.pressure = r.force || .5),
                typeof r.twist > "u" && (r.twist = 0),
                typeof r.tangentialPressure > "u" && (r.tangentialPressure = 0),
                typeof r.layerX > "u" && (r.layerX = r.offsetX = r.clientX),
                typeof r.layerY > "u" && (r.layerY = r.offsetY = r.clientY),
                r.isNormalized = !0,
                r.type = t.type,
                i.push(r)
            }
        else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) {
            const s = t;
            typeof s.isPrimary > "u" && (s.isPrimary = !0),
            typeof s.width > "u" && (s.width = 1),
            typeof s.height > "u" && (s.height = 1),
            typeof s.tiltX > "u" && (s.tiltX = 0),
            typeof s.tiltY > "u" && (s.tiltY = 0),
            typeof s.pointerType > "u" && (s.pointerType = "mouse"),
            typeof s.pointerId > "u" && (s.pointerId = $6),
            typeof s.pressure > "u" && (s.pressure = .5),
            typeof s.twist > "u" && (s.twist = 0),
            typeof s.tangentialPressure > "u" && (s.tangentialPressure = 0),
            s.isNormalized = !0,
            i.push(s)
        } else
            i.push(t);
        return i
    }
    normalizeWheelEvent(t) {
        const i = this.rootWheelEvent;
        return this.transferMouseData(i, t),
        i.deltaX = t.deltaX,
        i.deltaY = t.deltaY,
        i.deltaZ = t.deltaZ,
        i.deltaMode = t.deltaMode,
        this.mapPositionToPoint(i.screen, t.clientX, t.clientY),
        i.global.copyFrom(i.screen),
        i.offset.copyFrom(i.screen),
        i.nativeEvent = t,
        i.type = t.type,
        i
    }
    bootstrapEvent(t, i) {
        return t.originalEvent = null,
        t.nativeEvent = i,
        t.pointerId = i.pointerId,
        t.width = i.width,
        t.height = i.height,
        t.isPrimary = i.isPrimary,
        t.pointerType = i.pointerType,
        t.pressure = i.pressure,
        t.tangentialPressure = i.tangentialPressure,
        t.tiltX = i.tiltX,
        t.tiltY = i.tiltY,
        t.twist = i.twist,
        this.transferMouseData(t, i),
        this.mapPositionToPoint(t.screen, i.clientX, i.clientY),
        t.global.copyFrom(t.screen),
        t.offset.copyFrom(t.screen),
        t.isTrusted = i.isTrusted,
        t.type === "pointerleave" && (t.type = "pointerout"),
        t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")),
        t.type.startsWith("touch") && (t.type = j6[t.type] || t.type),
        t
    }
    transferMouseData(t, i) {
        t.isTrusted = i.isTrusted,
        t.srcElement = i.srcElement,
        t.timeStamp = performance.now(),
        t.type = i.type,
        t.altKey = i.altKey,
        t.button = i.button,
        t.buttons = i.buttons,
        t.client.x = i.clientX,
        t.client.y = i.clientY,
        t.ctrlKey = i.ctrlKey,
        t.metaKey = i.metaKey,
        t.movement.x = i.movementX,
        t.movement.y = i.movementY,
        t.page.x = i.pageX,
        t.page.y = i.pageY,
        t.relatedTarget = null,
        t.shiftKey = i.shiftKey
    }
}
b1.extension = {
    name: "events",
    type: [lt.RendererSystem, lt.CanvasRendererSystem]
};
vt.add(b1);
const W6 = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onglobalmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onglobalpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    onglobaltouchmove: null,
    ontouchstart: null,
    onwheel: null,
    interactive: !1,
    interactiveChildren: !0,
    hitArea: null,
    addEventListener(e, t, i) {
        const s = typeof i == "boolean" && i || typeof i == "object" && i.capture
          , n = typeof t == "function" ? void 0 : t;
        e = s ? `${e}capture` : e,
        t = typeof t == "function" ? t : t.handleEvent,
        this.on(e, t, n)
    },
    removeEventListener(e, t, i) {
        const s = typeof i == "boolean" && i || typeof i == "object" && i.capture
          , n = typeof t == "function" ? void 0 : t;
        e = s ? `${e}capture` : e,
        t = typeof t == "function" ? t : t.handleEvent,
        this.off(e, t, n)
    },
    dispatchEvent(e) {
        if (!(e instanceof Ja))
            throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
        return e.defaultPrevented = !1,
        e.path = null,
        e.target = this,
        e.manager.dispatchEvent(e),
        !e.defaultPrevented
    }
};
Ae.mixin(W6);
const X6 = {
    accessible: !1,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: !1,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: !0,
    renderId: -1
};
Ae.mixin(X6);
const Y6 = 9
  , Rl = 100
  , K6 = 0
  , Z6 = 0
  , gg = 2
  , vg = 1
  , q6 = -1e3
  , J6 = -1e3
  , Q6 = 2;
class x1 {
    constructor(t) {
        this.debug = !1,
        this._isActive = !1,
        this._isMobileAccessibility = !1,
        this.pool = [],
        this.renderId = 0,
        this.children = [],
        this.androidUpdateCount = 0,
        this.androidUpdateFrequency = 500,
        this._hookDiv = null,
        (Is.tablet || Is.phone) && this.createTouchHook();
        const i = document.createElement("div");
        i.style.width = `${Rl}px`,
        i.style.height = `${Rl}px`,
        i.style.position = "absolute",
        i.style.top = `${K6}px`,
        i.style.left = `${Z6}px`,
        i.style.zIndex = gg.toString(),
        this.div = i,
        this.renderer = t,
        this._onKeyDown = this._onKeyDown.bind(this),
        this._onMouseMove = this._onMouseMove.bind(this),
        globalThis.addEventListener("keydown", this._onKeyDown, !1)
    }
    get isActive() {
        return this._isActive
    }
    get isMobileAccessibility() {
        return this._isMobileAccessibility
    }
    createTouchHook() {
        const t = document.createElement("button");
        t.style.width = `${vg}px`,
        t.style.height = `${vg}px`,
        t.style.position = "absolute",
        t.style.top = `${q6}px`,
        t.style.left = `${J6}px`,
        t.style.zIndex = Q6.toString(),
        t.style.backgroundColor = "#FF0000",
        t.title = "select to enable accessibility for this content",
        t.addEventListener("focus", ()=>{
            this._isMobileAccessibility = !0,
            this.activate(),
            this.destroyTouchHook()
        }
        ),
        document.body.appendChild(t),
        this._hookDiv = t
    }
    destroyTouchHook() {
        !this._hookDiv || (document.body.removeChild(this._hookDiv),
        this._hookDiv = null)
    }
    activate() {
        this._isActive || (this._isActive = !0,
        globalThis.document.addEventListener("mousemove", this._onMouseMove, !0),
        globalThis.removeEventListener("keydown", this._onKeyDown, !1),
        this.renderer.on("postrender", this.update, this),
        this.renderer.view.parentNode?.appendChild(this.div))
    }
    deactivate() {
        !this._isActive || this._isMobileAccessibility || (this._isActive = !1,
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
        globalThis.addEventListener("keydown", this._onKeyDown, !1),
        this.renderer.off("postrender", this.update),
        this.div.parentNode?.removeChild(this.div))
    }
    updateAccessibleObjects(t) {
        if (!t.visible || !t.accessibleChildren)
            return;
        t.accessible && t.interactive && (t._accessibleActive || this.addChild(t),
        t.renderId = this.renderId);
        const i = t.children;
        if (i)
            for (let s = 0; s < i.length; s++)
                this.updateAccessibleObjects(i[s])
    }
    update() {
        const t = performance.now();
        if (Is.android.device && t < this.androidUpdateCount || (this.androidUpdateCount = t + this.androidUpdateFrequency,
        !this.renderer.renderingToScreen))
            return;
        this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
        const {x: i, y: s, width: n, height: r} = this.renderer.view.getBoundingClientRect()
          , {width: o, height: a, resolution: l} = this.renderer
          , c = n / o * l
          , h = r / a * l;
        let u = this.div;
        u.style.left = `${i}px`,
        u.style.top = `${s}px`,
        u.style.width = `${o}px`,
        u.style.height = `${a}px`;
        for (let d = 0; d < this.children.length; d++) {
            const f = this.children[d];
            if (f.renderId !== this.renderId)
                f._accessibleActive = !1,
                wr(this.children, d, 1),
                this.div.removeChild(f._accessibleDiv),
                this.pool.push(f._accessibleDiv),
                f._accessibleDiv = null,
                d--;
            else {
                u = f._accessibleDiv;
                let p = f.hitArea;
                const m = f.worldTransform;
                f.hitArea ? (u.style.left = `${(m.tx + p.x * m.a) * c}px`,
                u.style.top = `${(m.ty + p.y * m.d) * h}px`,
                u.style.width = `${p.width * m.a * c}px`,
                u.style.height = `${p.height * m.d * h}px`) : (p = f.getBounds(),
                this.capHitArea(p),
                u.style.left = `${p.x * c}px`,
                u.style.top = `${p.y * h}px`,
                u.style.width = `${p.width * c}px`,
                u.style.height = `${p.height * h}px`,
                u.title !== f.accessibleTitle && f.accessibleTitle !== null && (u.title = f.accessibleTitle),
                u.getAttribute("aria-label") !== f.accessibleHint && f.accessibleHint !== null && u.setAttribute("aria-label", f.accessibleHint)),
                (f.accessibleTitle !== u.title || f.tabIndex !== u.tabIndex) && (u.title = f.accessibleTitle,
                u.tabIndex = f.tabIndex,
                this.debug && this.updateDebugHTML(u))
            }
        }
        this.renderId++
    }
    updateDebugHTML(t) {
        t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`
    }
    capHitArea(t) {
        t.x < 0 && (t.width += t.x,
        t.x = 0),
        t.y < 0 && (t.height += t.y,
        t.y = 0);
        const {width: i, height: s} = this.renderer;
        t.x + t.width > i && (t.width = i - t.x),
        t.y + t.height > s && (t.height = s - t.y)
    }
    addChild(t) {
        let i = this.pool.pop();
        i || (i = document.createElement("button"),
        i.style.width = `${Rl}px`,
        i.style.height = `${Rl}px`,
        i.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent",
        i.style.position = "absolute",
        i.style.zIndex = gg.toString(),
        i.style.borderStyle = "none",
        navigator.userAgent.toLowerCase().includes("chrome") ? i.setAttribute("aria-live", "off") : i.setAttribute("aria-live", "polite"),
        navigator.userAgent.match(/rv:.*Gecko\//) ? i.setAttribute("aria-relevant", "additions") : i.setAttribute("aria-relevant", "text"),
        i.addEventListener("click", this._onClick.bind(this)),
        i.addEventListener("focus", this._onFocus.bind(this)),
        i.addEventListener("focusout", this._onFocusOut.bind(this))),
        i.style.pointerEvents = t.accessiblePointerEvents,
        i.type = t.accessibleType,
        t.accessibleTitle && t.accessibleTitle !== null ? i.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (i.title = `displayObject ${t.tabIndex}`),
        t.accessibleHint && t.accessibleHint !== null && i.setAttribute("aria-label", t.accessibleHint),
        this.debug && this.updateDebugHTML(i),
        t._accessibleActive = !0,
        t._accessibleDiv = i,
        i.displayObject = t,
        this.children.push(t),
        this.div.appendChild(t._accessibleDiv),
        t._accessibleDiv.tabIndex = t.tabIndex
    }
    _dispatchEvent(t, i) {
        const {displayObject: s} = t.target
          , n = this.renderer.events.rootBoundary
          , r = Object.assign(new Ja(n), {
            target: s
        });
        n.rootTarget = this.renderer.lastObjectRendered,
        i.forEach(o=>n.dispatchEvent(r, o))
    }
    _onClick(t) {
        this._dispatchEvent(t, ["click", "pointertap", "tap"])
    }
    _onFocus(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"),
        this._dispatchEvent(t, ["mouseover"])
    }
    _onFocusOut(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"),
        this._dispatchEvent(t, ["mouseout"])
    }
    _onKeyDown(t) {
        t.keyCode === Y6 && this.activate()
    }
    _onMouseMove(t) {
        t.movementX === 0 && t.movementY === 0 || this.deactivate()
    }
    destroy() {
        this.destroyTouchHook(),
        this.div = null,
        globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0),
        globalThis.removeEventListener("keydown", this._onKeyDown),
        this.pool = null,
        this.children = null,
        this.renderer = null
    }
}
x1.extension = {
    name: "accessibility",
    type: [lt.RendererPlugin, lt.CanvasRendererPlugin]
};
vt.add(x1);
const bd = class {
    constructor(e) {
        this.stage = new ae,
        e = Object.assign({
            forceCanvas: !1
        }, e),
        this.renderer = ma(e),
        bd._plugins.forEach(t=>{
            t.init.call(this, e)
        }
        )
    }
    render() {
        this.renderer.render(this.stage)
    }
    get view() {
        return this.renderer.view
    }
    get screen() {
        return this.renderer.screen
    }
    destroy(e, t) {
        const i = bd._plugins.slice(0);
        i.reverse(),
        i.forEach(s=>{
            s.destroy.call(this)
        }
        ),
        this.stage.destroy(t),
        this.stage = null,
        this.renderer.destroy(e),
        this.renderer = null
    }
}
;
let w1 = bd;
w1._plugins = [];
vt.handleByList(lt.Application, w1._plugins);
class T1 {
    static init(t) {
        Object.defineProperty(this, "resizeTo", {
            set(i) {
                globalThis.removeEventListener("resize", this.queueResize),
                this._resizeTo = i,
                i && (globalThis.addEventListener("resize", this.queueResize),
                this.resize())
            },
            get() {
                return this._resizeTo
            }
        }),
        this.queueResize = ()=>{
            !this._resizeTo || (this.cancelResize(),
            this._resizeId = requestAnimationFrame(()=>this.resize()))
        }
        ,
        this.cancelResize = ()=>{
            this._resizeId && (cancelAnimationFrame(this._resizeId),
            this._resizeId = null)
        }
        ,
        this.resize = ()=>{
            if (!this._resizeTo)
                return;
            this.cancelResize();
            let i, s;
            if (this._resizeTo === globalThis.window)
                i = globalThis.innerWidth,
                s = globalThis.innerHeight;
            else {
                const {clientWidth: n, clientHeight: r} = this._resizeTo;
                i = n,
                s = r
            }
            this.renderer.resize(i, s),
            this.render()
        }
        ,
        this._resizeId = null,
        this._resizeTo = null,
        this.resizeTo = t.resizeTo || null
    }
    static destroy() {
        globalThis.removeEventListener("resize", this.queueResize),
        this.cancelResize(),
        this.cancelResize = null,
        this.queueResize = null,
        this.resizeTo = null,
        this.resize = null
    }
}
T1.extension = lt.Application;
vt.add(T1);
const _g = {
    loader: lt.LoadParser,
    resolver: lt.ResolveParser,
    cache: lt.CacheParser,
    detection: lt.DetectionParser
};
vt.handle(lt.Asset, e=>{
    const t = e.ref;
    Object.entries(_g).filter(([i])=>!!t[i]).forEach(([i,s])=>vt.add(Object.assign(t[i], {
        extension: t[i].extension ?? s
    })))
}
, e=>{
    const t = e.ref;
    Object.keys(_g).filter(i=>!!t[i]).forEach(i=>vt.remove(t[i]))
}
);
class tI {
    constructor(t, i=!1) {
        this._loader = t,
        this._assetList = [],
        this._isLoading = !1,
        this._maxConcurrent = 1,
        this.verbose = i
    }
    add(t) {
        t.forEach(i=>{
            this._assetList.push(i)
        }
        ),
        this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList),
        this._isActive && !this._isLoading && this._next()
    }
    async _next() {
        if (this._assetList.length && this._isActive) {
            this._isLoading = !0;
            const t = []
              , i = Math.min(this._assetList.length, this._maxConcurrent);
            for (let s = 0; s < i; s++)
                t.push(this._assetList.pop());
            await this._loader.load(t),
            this._isLoading = !1,
            this._next()
        }
    }
    get active() {
        return this._isActive
    }
    set active(t) {
        this._isActive !== t && (this._isActive = t,
        t && !this._isLoading && this._next())
    }
}
function E1(e, t) {
    if (Array.isArray(t)) {
        for (const i of t)
            if (e.startsWith(`data:${i}`))
                return !0;
        return !1
    }
    return e.startsWith(`data:${t}`)
}
function fh(e, t) {
    const i = e.split("?")[0]
      , s = Xe.extname(i).toLowerCase();
    return Array.isArray(t) ? t.includes(s) : s === t
}
const qs = (e,t)=>(Array.isArray(e) || (e = [e]),
t ? e.map(i=>typeof i == "string" ? t(i) : i) : e)
  , xd = (e,t)=>{
    const i = t.split("?")[1];
    return i && (e += `?${i}`),
    e
}
;
function S1(e, t, i, s, n) {
    const r = t[i];
    for (let o = 0; o < r.length; o++) {
        const a = r[o];
        i < t.length - 1 ? S1(e.replace(s[i], a), t, i + 1, s, n) : n.push(e.replace(s[i], a))
    }
}
function eI(e) {
    const t = /\{(.*?)\}/g
      , i = e.match(t)
      , s = [];
    if (i) {
        const n = [];
        i.forEach(r=>{
            const o = r.substring(1, r.length - 1).split(",");
            n.push(o)
        }
        ),
        S1(e, n, 0, i, s)
    } else
        s.push(e);
    return s
}
const Cc = e=>!Array.isArray(e);
class iI {
    constructor() {
        this._parsers = [],
        this._cache = new Map,
        this._cacheMap = new Map
    }
    reset() {
        this._cacheMap.clear(),
        this._cache.clear()
    }
    has(t) {
        return this._cache.has(t)
    }
    get(t) {
        const i = this._cache.get(t);
        return i || console.warn(`[Assets] Asset id ${t} was not found in the Cache`),
        i
    }
    set(t, i) {
        const s = qs(t);
        let n;
        for (let a = 0; a < this.parsers.length; a++) {
            const l = this.parsers[a];
            if (l.test(i)) {
                n = l.getCacheableAssets(s, i);
                break
            }
        }
        n || (n = {},
        s.forEach(a=>{
            n[a] = i
        }
        ));
        const r = Object.keys(n)
          , o = {
            cacheKeys: r,
            keys: s
        };
        if (s.forEach(a=>{
            this._cacheMap.set(a, o)
        }
        ),
        r.forEach(a=>{
            this._cache.has(a) && this._cache.get(a) !== i && console.warn("[Cache] already has key:", a),
            this._cache.set(a, n[a])
        }
        ),
        i instanceof ht) {
            const a = i;
            s.forEach(l=>{
                a.baseTexture !== ht.EMPTY.baseTexture && Ot.addToCache(a.baseTexture, l),
                ht.addToCache(a, l)
            }
            )
        }
    }
    remove(t) {
        if (this._cacheMap.get(t),
        !this._cacheMap.has(t)) {
            console.warn(`[Assets] Asset id ${t} was not found in the Cache`);
            return
        }
        const i = this._cacheMap.get(t);
        i.cacheKeys.forEach(n=>{
            this._cache.delete(n)
        }
        ),
        i.keys.forEach(n=>{
            this._cacheMap.delete(n)
        }
        )
    }
    get parsers() {
        return this._parsers
    }
}
const ia = new iI;
class sI {
    constructor() {
        this._parsers = [],
        this.promiseCache = {}
    }
    reset() {
        this.promiseCache = {}
    }
    _getLoadPromiseAndParser(t, i) {
        const s = {
            promise: null,
            parser: null
        };
        return s.promise = (async()=>{
            let n = null;
            for (let r = 0; r < this.parsers.length; r++) {
                const o = this.parsers[r];
                if (o.load && o.test?.(t, i, this)) {
                    n = await o.load(t, i, this),
                    s.parser = o;
                    break
                }
            }
            if (!s.parser)
                return console.warn(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has being added`),
                null;
            for (let r = 0; r < this.parsers.length; r++) {
                const o = this.parsers[r];
                o.parse && o.parse && await o.testParse?.(n, i, this) && (n = await o.parse(n, i, this) || n,
                s.parser = o)
            }
            return n
        }
        )(),
        s
    }
    async load(t, i) {
        let s = 0;
        const n = {}
          , r = Cc(t)
          , o = qs(t, c=>({
            src: c
        }))
          , a = o.length
          , l = o.map(async c=>{
            const h = Xe.toAbsolute(c.src);
            if (!n[c.src])
                try {
                    this.promiseCache[h] || (this.promiseCache[h] = this._getLoadPromiseAndParser(h, c)),
                    n[c.src] = await this.promiseCache[h].promise,
                    i && i(++s / a)
                } catch (u) {
                    throw delete this.promiseCache[h],
                    delete n[c.src],
                    new Error(`[Loader.load] Failed to load ${h}.
${u}`)
                }
        }
        );
        return await Promise.all(l),
        r ? n[o[0].src] : n
    }
    async unload(t) {
        const s = qs(t, n=>({
            src: n
        })).map(async n=>{
            const r = Xe.toAbsolute(n.src)
              , o = this.promiseCache[r];
            if (o) {
                const a = await o.promise;
                o.parser?.unload?.(a, n, this),
                delete this.promiseCache[r]
            }
        }
        );
        await Promise.all(s)
    }
    get parsers() {
        return this._parsers
    }
}
var Us = (e=>(e[e.Low = 0] = "Low",
e[e.Normal = 1] = "Normal",
e[e.High = 2] = "High",
e))(Us || {});
const nI = {
    extension: {
        type: lt.LoadParser,
        priority: Us.Low
    },
    test(e) {
        return Xe.extname(e).toLowerCase() === ".json"
    },
    async load(e) {
        return await (await ft.ADAPTER.fetch(e)).json()
    }
};
vt.add(nI);
const rI = {
    extension: {
        type: lt.LoadParser,
        priority: Us.Low
    },
    test(e) {
        return Xe.extname(e).toLowerCase() === ".txt"
    },
    async load(e) {
        return await (await ft.ADAPTER.fetch(e)).text()
    }
};
vt.add(rI);
const oI = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"]
  , aI = [".ttf", ".otf", ".woff", ".woff2"]
  , lI = ["font/ttf", "font/otf", "font/woff", "font/woff2"];
function cI(e) {
    const t = Xe.extname(e);
    return Xe.basename(e, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(r=>r.charAt(0).toUpperCase() + r.slice(1)).join(" ")
}
const hI = {
    extension: {
        type: lt.LoadParser,
        priority: Us.Low
    },
    test(e) {
        return E1(e, lI) || fh(e, aI)
    },
    async load(e, t) {
        const i = ft.ADAPTER.getFontFaceSet();
        if (i) {
            const s = []
              , n = t.data?.family ?? cI(e)
              , r = t.data?.weights?.filter(a=>oI.includes(a)) ?? ["normal"]
              , o = t.data ?? {};
            for (let a = 0; a < r.length; a++) {
                const l = r[a]
                  , c = new FontFace(n,`url(${encodeURI(e)})`,{
                    ...o,
                    weight: l
                });
                await c.load(),
                i.add(c),
                s.push(c)
            }
            return s.length === 1 ? s[0] : s
        }
        return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"),
        null
    },
    unload(e) {
        (Array.isArray(e) ? e : [e]).forEach(t=>ft.ADAPTER.getFontFaceSet().delete(t))
    }
};
vt.add(hI);
let yg = 0, ou;
const uI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII="
  , dI = {
    id: "checkImageBitmap",
    code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${uI}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
}
  , fI = {
    id: "loadImageBitmap",
    code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
};
let au;
class pI {
    constructor() {
        this._initialized = !1,
        this._createdWorkers = 0,
        this.workerPool = [],
        this.queue = [],
        this.resolveHash = {}
    }
    isImageBitmapSupported() {
        return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(t=>{
            const i = URL.createObjectURL(new Blob([dI.code],{
                type: "application/javascript"
            }))
              , s = new Worker(i);
            s.addEventListener("message", n=>{
                s.terminate(),
                URL.revokeObjectURL(i),
                t(n.data)
            }
            )
        }
        ),
        this._isImageBitmapSupported)
    }
    loadImageBitmap(t) {
        return this._run("loadImageBitmap", [t])
    }
    async _initWorkers() {
        this._initialized || (this._initialized = !0)
    }
    getWorker() {
        ou === void 0 && (ou = navigator.hardwareConcurrency || 4);
        let t = this.workerPool.pop();
        return !t && this._createdWorkers < ou && (au || (au = URL.createObjectURL(new Blob([fI.code],{
            type: "application/javascript"
        }))),
        this._createdWorkers++,
        t = new Worker(au),
        t.addEventListener("message", i=>{
            this.complete(i.data),
            this.returnWorker(i.target),
            this.next()
        }
        )),
        t
    }
    returnWorker(t) {
        this.workerPool.push(t)
    }
    complete(t) {
        t.error !== void 0 ? this.resolveHash[t.uuid].reject(t.error) : this.resolveHash[t.uuid].resolve(t.data),
        this.resolveHash[t.uuid] = null
    }
    async _run(t, i) {
        await this._initWorkers();
        const s = new Promise((n,r)=>{
            this.queue.push({
                id: t,
                arguments: i,
                resolve: n,
                reject: r
            })
        }
        );
        return this.next(),
        s
    }
    next() {
        if (!this.queue.length)
            return;
        const t = this.getWorker();
        if (!t)
            return;
        const i = this.queue.pop()
          , s = i.id;
        this.resolveHash[yg] = {
            resolve: i.resolve,
            reject: i.reject
        },
        t.postMessage({
            data: i.arguments,
            uuid: yg++,
            id: s
        })
    }
}
const bg = new pI;
function ph(e, t, i) {
    const s = new ht(e);
    return s.baseTexture.on("dispose", ()=>{
        delete t.promiseCache[i]
    }
    ),
    s
}
const mI = [".jpeg", ".jpg", ".png", ".webp", ".avif"]
  , gI = ["image/jpeg", "image/png", "image/webp", "image/avif"];
async function vI(e) {
    const t = await ft.ADAPTER.fetch(e);
    if (!t.ok)
        throw new Error(`[loadImageBitmap] Failed to fetch ${e}: ${t.status} ${t.statusText}`);
    const i = await t.blob();
    return await createImageBitmap(i)
}
const Ha = {
    extension: {
        type: lt.LoadParser,
        priority: Us.High
    },
    config: {
        preferWorkers: !0
    },
    test(e) {
        return E1(e, gI) || fh(e, mI)
    },
    async load(e, t, i) {
        let s = null;
        globalThis.createImageBitmap ? this.config.preferWorkers && await bg.isImageBitmapSupported() ? s = await bg.loadImageBitmap(e) : s = await vI(e) : s = await new Promise(r=>{
            s = new Image,
            s.crossOrigin = "anonymous",
            s.src = e,
            s.complete ? r(s) : s.onload = ()=>{
                r(s)
            }
        }
        );
        const n = new Ot(s,{
            resolution: en(e),
            ...t.data
        });
        return n.resource.src = e,
        ph(n, i, e)
    },
    unload(e) {
        e.destroy(!0)
    }
};
vt.add(Ha);
const _I = {
    extension: {
        type: lt.LoadParser,
        priority: Us.High
    },
    test(e) {
        return Xe.extname(e).toLowerCase() === ".svg"
    },
    async testParse(e) {
        return Ga.test(e)
    },
    async parse(e, t, i) {
        const s = new Ga(e,t?.data?.resourceOptions)
          , n = new Ot(s,{
            resolution: en(e),
            ...t?.data
        });
        n.resource.src = e;
        const r = ph(n, i, e);
        return t?.data?.resourceOptions?.autoLoad || await s.load(),
        r
    },
    async load(e, t) {
        return (await ft.ADAPTER.fetch(e)).text()
    },
    unload: Ha.unload
};
vt.add(_I);
class yI {
    constructor() {
        this._defaultBundleIdentifierOptions = {
            connector: "-",
            createBundleAssetId: (t,i)=>`${t}${this._bundleIdConnector}${i}`,
            extractAssetIdFromBundle: (t,i)=>i.replace(`${t}${this._bundleIdConnector}`, "")
        },
        this._bundleIdConnector = this._defaultBundleIdentifierOptions.connector,
        this._createBundleAssetId = this._defaultBundleIdentifierOptions.createBundleAssetId,
        this._extractAssetIdFromBundle = this._defaultBundleIdentifierOptions.extractAssetIdFromBundle,
        this._assetMap = {},
        this._preferredOrder = [],
        this._parsers = [],
        this._resolverHash = {},
        this._bundles = {}
    }
    setBundleIdentifier(t) {
        if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector,
        this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId,
        this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle,
        this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar")
            throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
    }
    prefer(...t) {
        t.forEach(i=>{
            this._preferredOrder.push(i),
            i.priority || (i.priority = Object.keys(i.params))
        }
        ),
        this._resolverHash = {}
    }
    set basePath(t) {
        this._basePath = t
    }
    get basePath() {
        return this._basePath
    }
    set rootPath(t) {
        this._rootPath = t
    }
    get rootPath() {
        return this._rootPath
    }
    get parsers() {
        return this._parsers
    }
    reset() {
        this.setBundleIdentifier(this._defaultBundleIdentifierOptions),
        this._assetMap = {},
        this._preferredOrder = [],
        this._resolverHash = {},
        this._rootPath = null,
        this._basePath = null,
        this._manifest = null,
        this._bundles = {},
        this._defaultSearchParams = null
    }
    setDefaultSearchParams(t) {
        if (typeof t == "string")
            this._defaultSearchParams = t;
        else {
            const i = t;
            this._defaultSearchParams = Object.keys(i).map(s=>`${encodeURIComponent(s)}=${encodeURIComponent(i[s])}`).join("&")
        }
    }
    addManifest(t) {
        this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"),
        this._manifest = t,
        t.bundles.forEach(i=>{
            this.addBundle(i.name, i.assets)
        }
        )
    }
    addBundle(t, i) {
        const s = [];
        Array.isArray(i) ? i.forEach(n=>{
            if (typeof n.name == "string") {
                const r = this._createBundleAssetId(t, n.name);
                s.push(r),
                this.add([n.name, r], n.srcs, n.data)
            } else {
                const r = n.name.map(o=>this._createBundleAssetId(t, o));
                r.forEach(o=>{
                    s.push(o)
                }
                ),
                this.add([...n.name, ...r], n.srcs)
            }
        }
        ) : Object.keys(i).forEach(n=>{
            s.push(this._createBundleAssetId(t, n)),
            this.add([n, this._createBundleAssetId(t, n)], i[n])
        }
        ),
        this._bundles[t] = s
    }
    add(t, i, s) {
        const n = qs(t);
        n.forEach(o=>{
            this.hasKey(o) && console.warn(`[Resolver] already has key: ${o} overwriting`)
        }
        ),
        Array.isArray(i) || (typeof i == "string" ? i = eI(i) : i = [i]);
        const r = i.map(o=>{
            let a = o;
            if (typeof o == "string") {
                let l = !1;
                for (let c = 0; c < this._parsers.length; c++) {
                    const h = this._parsers[c];
                    if (h.test(o)) {
                        a = h.parse(o),
                        l = !0;
                        break
                    }
                }
                l || (a = {
                    src: o
                })
            }
            return a.format || (a.format = a.src.split(".").pop()),
            a.alias || (a.alias = n),
            (this._basePath || this._rootPath) && (a.src = Xe.toAbsolute(a.src, this._basePath, this._rootPath)),
            a.src = this._appendDefaultSearchParams(a.src),
            a.data = a.data ?? s,
            a
        }
        );
        n.forEach(o=>{
            this._assetMap[o] = r
        }
        )
    }
    resolveBundle(t) {
        const i = Cc(t);
        t = qs(t);
        const s = {};
        return t.forEach(n=>{
            const r = this._bundles[n];
            if (r) {
                const o = this.resolve(r)
                  , a = {};
                for (const l in o) {
                    const c = o[l];
                    a[this._extractAssetIdFromBundle(n, l)] = c
                }
                s[n] = a
            }
        }
        ),
        i ? s[t[0]] : s
    }
    resolveUrl(t) {
        const i = this.resolve(t);
        if (typeof t != "string") {
            const s = {};
            for (const n in i)
                s[n] = i[n].src;
            return s
        }
        return i.src
    }
    resolve(t) {
        const i = Cc(t);
        t = qs(t);
        const s = {};
        return t.forEach(n=>{
            if (!this._resolverHash[n])
                if (this._assetMap[n]) {
                    let r = this._assetMap[n];
                    const o = this._getPreferredOrder(r)
                      , a = r[0];
                    o?.priority.forEach(l=>{
                        o.params[l].forEach(c=>{
                            const h = r.filter(u=>u[l] ? u[l] === c : !1);
                            h.length && (r = h)
                        }
                        )
                    }
                    ),
                    this._resolverHash[n] = r[0] ?? a
                } else {
                    let r = n;
                    (this._basePath || this._rootPath) && (r = Xe.toAbsolute(r, this._basePath, this._rootPath)),
                    r = this._appendDefaultSearchParams(r),
                    this._resolverHash[n] = {
                        src: r
                    }
                }
            s[n] = this._resolverHash[n]
        }
        ),
        i ? s[t[0]] : s
    }
    hasKey(t) {
        return !!this._assetMap[t]
    }
    hasBundle(t) {
        return !!this._bundles[t]
    }
    _getPreferredOrder(t) {
        for (let i = 0; i < t.length; i++) {
            const s = t[0]
              , n = this._preferredOrder.find(r=>r.params.format.includes(s.format));
            if (n)
                return n
        }
        return this._preferredOrder[0]
    }
    _appendDefaultSearchParams(t) {
        if (!this._defaultSearchParams)
            return t;
        const i = /\?/.test(t) ? "&" : "?";
        return `${t}${i}${this._defaultSearchParams}`
    }
}
class bI {
    constructor() {
        this._detections = [],
        this._initialized = !1,
        this.resolver = new yI,
        this.loader = new sI,
        this.cache = ia,
        this._backgroundLoader = new tI(this.loader),
        this._backgroundLoader.active = !0,
        this.reset()
    }
    async init(t={}) {
        if (this._initialized) {
            console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
            return
        }
        if (this._initialized = !0,
        t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams),
        t.basePath && (this.resolver.basePath = t.basePath),
        t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier),
        t.manifest) {
            let r = t.manifest;
            typeof r == "string" && (r = await this.load(r)),
            this.resolver.addManifest(r)
        }
        const i = t.texturePreference?.resolution ?? 1
          , s = typeof i == "number" ? [i] : i;
        let n = [];
        if (t.texturePreference?.format) {
            const r = t.texturePreference?.format;
            n = typeof r == "string" ? [r] : r;
            for (const o of this._detections)
                await o.test() || (n = await o.remove(n))
        } else
            for (const r of this._detections)
                await r.test() && (n = await r.add(n));
        this.resolver.prefer({
            params: {
                format: n,
                resolution: s
            }
        })
    }
    add(t, i, s) {
        this.resolver.add(t, i, s)
    }
    async load(t, i) {
        this._initialized || await this.init();
        const s = Cc(t)
          , n = qs(t).map(a=>typeof a != "string" ? (this.resolver.add(a.src, a),
        a.src) : (this.resolver.hasKey(a) || this.resolver.add(a, a),
        a))
          , r = this.resolver.resolve(n)
          , o = await this._mapLoadToResolve(r, i);
        return s ? o[n[0]] : o
    }
    addBundle(t, i) {
        this.resolver.addBundle(t, i)
    }
    async loadBundle(t, i) {
        this._initialized || await this.init();
        let s = !1;
        typeof t == "string" && (s = !0,
        t = [t]);
        const n = this.resolver.resolveBundle(t)
          , r = {}
          , o = Object.keys(n);
        let a = 0
          , l = 0;
        const c = ()=>{
            i?.(++a / l)
        }
          , h = o.map(u=>{
            const d = n[u];
            return l += Object.keys(d).length,
            this._mapLoadToResolve(d, c).then(f=>{
                r[u] = f
            }
            )
        }
        );
        return await Promise.all(h),
        s ? r[t[0]] : r
    }
    async backgroundLoad(t) {
        this._initialized || await this.init(),
        typeof t == "string" && (t = [t]);
        const i = this.resolver.resolve(t);
        this._backgroundLoader.add(Object.values(i))
    }
    async backgroundLoadBundle(t) {
        this._initialized || await this.init(),
        typeof t == "string" && (t = [t]);
        const i = this.resolver.resolveBundle(t);
        Object.values(i).forEach(s=>{
            this._backgroundLoader.add(Object.values(s))
        }
        )
    }
    reset() {
        this.resolver.reset(),
        this.loader.reset(),
        this.cache.reset(),
        this._initialized = !1
    }
    get(t) {
        if (typeof t == "string")
            return ia.get(t);
        const i = {};
        for (let s = 0; s < t.length; s++)
            i[s] = ia.get(t[s]);
        return i
    }
    async _mapLoadToResolve(t, i) {
        const s = Object.values(t)
          , n = Object.keys(t);
        this._backgroundLoader.active = !1;
        const r = await this.loader.load(s, i);
        this._backgroundLoader.active = !0;
        const o = {};
        return s.forEach((a,l)=>{
            const c = r[a.src]
              , h = [a.src];
            a.alias && h.push(...a.alias),
            o[n[l]] = c,
            ia.set(h, c)
        }
        ),
        o
    }
    async unload(t) {
        this._initialized || await this.init();
        const i = qs(t).map(n=>typeof n != "string" ? n.src : n)
          , s = this.resolver.resolve(i);
        await this._unloadFromResolved(s)
    }
    async unloadBundle(t) {
        this._initialized || await this.init(),
        t = qs(t);
        const i = this.resolver.resolveBundle(t)
          , s = Object.keys(i).map(n=>this._unloadFromResolved(i[n]));
        await Promise.all(s)
    }
    async _unloadFromResolved(t) {
        const i = Object.values(t);
        i.forEach(s=>{
            ia.remove(s.src)
        }
        ),
        await this.loader.unload(i)
    }
    get detections() {
        return this._detections
    }
    get preferWorkers() {
        return Ha.config.preferWorkers
    }
    set preferWorkers(t) {
        Ha.config.preferWorkers = t
    }
}
const kl = new bI;
vt.handleByList(lt.LoadParser, kl.loader.parsers).handleByList(lt.ResolveParser, kl.resolver.parsers).handleByList(lt.CacheParser, kl.cache.parsers).handleByList(lt.DetectionParser, kl.detections);
const xI = {
    extension: lt.CacheParser,
    test: e=>Array.isArray(e) && e.every(t=>t instanceof ht),
    getCacheableAssets: (e,t)=>{
        const i = {};
        return e.forEach(s=>{
            t.forEach((n,r)=>{
                i[s + (r === 0 ? "" : r + 1)] = n
            }
            )
        }
        ),
        i
    }
};
vt.add(xI);
const wI = {
    extension: {
        type: lt.DetectionParser,
        priority: 1
    },
    test: async()=>{
        if (!globalThis.createImageBitmap)
            return !1;
        const e = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A="
          , t = await ft.ADAPTER.fetch(e).then(i=>i.blob());
        return createImageBitmap(t).then(()=>!0, ()=>!1)
    }
    ,
    add: async e=>[...e, "avif"],
    remove: async e=>e.filter(t=>t !== "avif")
};
vt.add(wI);
const TI = {
    extension: {
        type: lt.DetectionParser,
        priority: 0
    },
    test: async()=>{
        if (!globalThis.createImageBitmap)
            return !1;
        const e = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA="
          , t = await ft.ADAPTER.fetch(e).then(i=>i.blob());
        return createImageBitmap(t).then(()=>!0, ()=>!1)
    }
    ,
    add: async e=>[...e, "webp"],
    remove: async e=>e.filter(t=>t !== "webp")
};
vt.add(TI);
const xg = ["png", "jpg", "jpeg"]
  , EI = {
    extension: {
        type: lt.DetectionParser,
        priority: -1
    },
    test: ()=>Promise.resolve(!0),
    add: async e=>[...e, ...xg],
    remove: async e=>e.filter(t=>!xg.includes(t))
};
vt.add(EI);
const SI = {
    extension: lt.ResolveParser,
    test: Ha.test,
    parse: e=>({
        resolution: parseFloat(ft.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
        format: e.split(".").pop(),
        src: e
    })
};
vt.add(SI);
var Si = (e=>(e[e.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT",
e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT",
e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT",
e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT",
e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT",
e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT",
e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT",
e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT",
e[e.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC",
e[e.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC",
e[e.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC",
e[e.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC",
e[e.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2",
e[e.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC",
e[e.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2",
e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC",
e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2",
e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2",
e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG",
e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG",
e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG",
e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG",
e[e.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL",
e[e.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL",
e[e.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL",
e[e.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL",
e[e.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR",
e))(Si || {});
const Ac = {
    [33776]: .5,
    [33777]: .5,
    [33778]: 1,
    [33779]: 1,
    [35916]: .5,
    [35917]: .5,
    [35918]: 1,
    [35919]: 1,
    [37488]: .5,
    [37489]: .5,
    [37490]: 1,
    [37491]: 1,
    [37492]: .5,
    [37496]: 1,
    [37493]: .5,
    [37497]: 1,
    [37494]: .5,
    [37495]: .5,
    [35840]: .5,
    [35842]: .5,
    [35841]: .25,
    [35843]: .25,
    [36196]: .5,
    [35986]: .5,
    [35986]: 1,
    [34798]: 1,
    [37808]: 1
};
let Hs, so;
function wg() {
    so = {
        s3tc: Hs.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: Hs.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: Hs.getExtension("WEBGL_compressed_texture_etc"),
        etc1: Hs.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: Hs.getExtension("WEBGL_compressed_texture_pvrtc") || Hs.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: Hs.getExtension("WEBGL_compressed_texture_atc"),
        astc: Hs.getExtension("WEBGL_compressed_texture_astc")
    }
}
const CI = {
    extension: {
        type: lt.DetectionParser,
        priority: 2
    },
    test: async()=>{
        const t = ft.ADAPTER.createCanvas().getContext("webgl");
        return t ? (Hs = t,
        !0) : (console.warn("WebGL not available for compressed textures."),
        !1)
    }
    ,
    add: async e=>{
        so || wg();
        const t = [];
        for (const i in so)
            !so[i] || t.push(i);
        return [...t, ...e]
    }
    ,
    remove: async e=>(so || wg(),
    e.filter(t=>!(t in so)))
};
vt.add(CI);
class AI extends qa {
    constructor(t, i={
        width: 1,
        height: 1,
        autoLoad: !0
    }) {
        let s, n;
        typeof t == "string" ? (s = t,
        n = new Uint8Array) : (s = null,
        n = t),
        super(n, i),
        this.origin = s,
        this.buffer = n ? new ad(n) : null,
        this.origin && i.autoLoad !== !1 && this.load(),
        n?.length && (this.loaded = !0,
        this.onBlobLoaded(this.buffer.rawBinaryData))
    }
    onBlobLoaded(t) {}
    async load() {
        const s = await (await (await fetch(this.origin)).blob()).arrayBuffer();
        return this.data = new Uint32Array(s),
        this.buffer = new ad(s),
        this.loaded = !0,
        this.onBlobLoaded(s),
        this.update(),
        this
    }
}
class Tr extends AI {
    constructor(t, i) {
        super(t, i),
        this.format = i.format,
        this.levels = i.levels || 1,
        this._width = i.width,
        this._height = i.height,
        this._extension = Tr._formatToExtension(this.format),
        (i.levelBuffers || this.buffer) && (this._levelBuffers = i.levelBuffers || Tr._createLevelBuffers(t instanceof Uint8Array ? t : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height))
    }
    upload(t, i, s) {
        const n = t.gl;
        if (!t.context.extensions[this._extension])
            throw new Error(`${this._extension} textures are not supported on the current machine`);
        if (!this._levelBuffers)
            return !1;
        for (let o = 0, a = this.levels; o < a; o++) {
            const {levelID: l, levelWidth: c, levelHeight: h, levelBuffer: u} = this._levelBuffers[o];
            n.compressedTexImage2D(n.TEXTURE_2D, l, this.format, c, h, 0, u)
        }
        return !0
    }
    onBlobLoaded() {
        this._levelBuffers = Tr._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
    }
    static _formatToExtension(t) {
        if (t >= 33776 && t <= 33779)
            return "s3tc";
        if (t >= 37488 && t <= 37497)
            return "etc";
        if (t >= 35840 && t <= 35843)
            return "pvrtc";
        if (t >= 36196)
            return "etc1";
        if (t >= 35986 && t <= 34798)
            return "atc";
        throw new Error("Invalid (compressed) texture format given!")
    }
    static _createLevelBuffers(t, i, s, n, r, o, a) {
        const l = new Array(s);
        let c = t.byteOffset
          , h = o
          , u = a
          , d = h + n - 1 & ~(n - 1)
          , f = u + r - 1 & ~(r - 1)
          , p = d * f * Ac[i];
        for (let m = 0; m < s; m++)
            l[m] = {
                levelID: m,
                levelWidth: s > 1 ? h : d,
                levelHeight: s > 1 ? u : f,
                levelBuffer: new Uint8Array(t.buffer,c,p)
            },
            c += p,
            h = h >> 1 || 1,
            u = u >> 1 || 1,
            d = h + n - 1 & ~(n - 1),
            f = u + r - 1 & ~(r - 1),
            p = d * f * Ac[i];
        return l
    }
}
const lu = 4
  , Pl = 124
  , II = 32
  , Tg = 20
  , MI = 542327876
  , Ll = {
    SIZE: 1,
    FLAGS: 2,
    HEIGHT: 3,
    WIDTH: 4,
    MIPMAP_COUNT: 7,
    PIXEL_FORMAT: 19
}
  , RI = {
    SIZE: 0,
    FLAGS: 1,
    FOURCC: 2,
    RGB_BITCOUNT: 3,
    R_BIT_MASK: 4,
    G_BIT_MASK: 5,
    B_BIT_MASK: 6,
    A_BIT_MASK: 7
}
  , Ol = {
    DXGI_FORMAT: 0,
    RESOURCE_DIMENSION: 1,
    MISC_FLAG: 2,
    ARRAY_SIZE: 3,
    MISC_FLAGS2: 4
}
  , kI = 1
  , PI = 2
  , LI = 4
  , OI = 64
  , DI = 512
  , NI = 131072
  , FI = 827611204
  , BI = 861165636
  , UI = 894720068
  , GI = 808540228
  , HI = 4
  , VI = {
    [FI]: Si.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    [BI]: Si.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    [UI]: Si.COMPRESSED_RGBA_S3TC_DXT5_EXT
}
  , zI = {
    [70]: Si.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    [71]: Si.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    [73]: Si.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    [74]: Si.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    [76]: Si.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    [77]: Si.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    [72]: Si.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
    [75]: Si.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
    [78]: Si.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
};
function $I(e) {
    const t = new Uint32Array(e);
    if (t[0] !== MI)
        throw new Error("Invalid DDS file magic word");
    const s = new Uint32Array(e,0,Pl / Uint32Array.BYTES_PER_ELEMENT)
      , n = s[Ll.HEIGHT]
      , r = s[Ll.WIDTH]
      , o = s[Ll.MIPMAP_COUNT]
      , a = new Uint32Array(e,Ll.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT,II / Uint32Array.BYTES_PER_ELEMENT)
      , l = a[kI];
    if (l & LI) {
        const c = a[RI.FOURCC];
        if (c !== GI) {
            const v = VI[c]
              , _ = lu + Pl
              , C = new Uint8Array(e,_);
            return [new Tr(C,{
                format: v,
                width: r,
                height: n,
                levels: o
            })]
        }
        const h = lu + Pl
          , u = new Uint32Array(t.buffer,h,Tg / Uint32Array.BYTES_PER_ELEMENT)
          , d = u[Ol.DXGI_FORMAT]
          , f = u[Ol.RESOURCE_DIMENSION]
          , p = u[Ol.MISC_FLAG]
          , m = u[Ol.ARRAY_SIZE]
          , g = zI[d];
        if (g === void 0)
            throw new Error(`DDSParser cannot parse texture data with DXGI format ${d}`);
        if (p === HI)
            throw new Error("DDSParser does not support cubemap textures");
        if (f === 6)
            throw new Error("DDSParser does not supported 3D texture data");
        const y = new Array
          , x = lu + Pl + Tg;
        if (m === 1)
            y.push(new Uint8Array(e,x));
        else {
            const v = Ac[g];
            let _ = 0
              , C = r
              , k = n;
            for (let T = 0; T < o; T++) {
                const L = Math.max(1, C + 3 & -4)
                  , D = Math.max(1, k + 3 & -4);
                _ += L * D * v,
                C = C >>> 1,
                k = k >>> 1
            }
            let S = x;
            for (let T = 0; T < m; T++)
                y.push(new Uint8Array(e,S,_)),
                S += _
        }
        return y.map(v=>new Tr(v,{
            format: g,
            width: r,
            height: n,
            levels: o
        }))
    }
    throw l & OI ? new Error("DDSParser does not support uncompressed texture data.") : l & DI ? new Error("DDSParser does not supported YUV uncompressed texture data.") : l & NI ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : l & PI ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!")
}
const Eg = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]
  , jI = 67305985
  , Zi = {
    FILE_IDENTIFIER: 0,
    ENDIANNESS: 12,
    GL_TYPE: 16,
    GL_TYPE_SIZE: 20,
    GL_FORMAT: 24,
    GL_INTERNAL_FORMAT: 28,
    GL_BASE_INTERNAL_FORMAT: 32,
    PIXEL_WIDTH: 36,
    PIXEL_HEIGHT: 40,
    PIXEL_DEPTH: 44,
    NUMBER_OF_ARRAY_ELEMENTS: 48,
    NUMBER_OF_FACES: 52,
    NUMBER_OF_MIPMAP_LEVELS: 56,
    BYTES_OF_KEY_VALUE_DATA: 60
}
  , wd = 64
  , Sg = {
    [Rt.UNSIGNED_BYTE]: 1,
    [Rt.UNSIGNED_SHORT]: 2,
    [Rt.INT]: 4,
    [Rt.UNSIGNED_INT]: 4,
    [Rt.FLOAT]: 4,
    [Rt.HALF_FLOAT]: 8
}
  , WI = {
    [ot.RGBA]: 4,
    [ot.RGB]: 3,
    [ot.RG]: 2,
    [ot.RED]: 1,
    [ot.LUMINANCE]: 1,
    [ot.LUMINANCE_ALPHA]: 2,
    [ot.ALPHA]: 1
}
  , XI = {
    [Rt.UNSIGNED_SHORT_4_4_4_4]: 2,
    [Rt.UNSIGNED_SHORT_5_5_5_1]: 2,
    [Rt.UNSIGNED_SHORT_5_6_5]: 2
};
function YI(e, t, i=!1) {
    const s = new DataView(t);
    if (!KI(e, s))
        return null;
    const n = s.getUint32(Zi.ENDIANNESS, !0) === jI
      , r = s.getUint32(Zi.GL_TYPE, n)
      , o = s.getUint32(Zi.GL_FORMAT, n)
      , a = s.getUint32(Zi.GL_INTERNAL_FORMAT, n)
      , l = s.getUint32(Zi.PIXEL_WIDTH, n)
      , c = s.getUint32(Zi.PIXEL_HEIGHT, n) || 1
      , h = s.getUint32(Zi.PIXEL_DEPTH, n) || 1
      , u = s.getUint32(Zi.NUMBER_OF_ARRAY_ELEMENTS, n) || 1
      , d = s.getUint32(Zi.NUMBER_OF_FACES, n)
      , f = s.getUint32(Zi.NUMBER_OF_MIPMAP_LEVELS, n)
      , p = s.getUint32(Zi.BYTES_OF_KEY_VALUE_DATA, n);
    if (c === 0 || h !== 1)
        throw new Error("Only 2D textures are supported");
    if (d !== 1)
        throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (u !== 1)
        throw new Error("WebGL does not support array textures");
    const m = 4
      , g = 4
      , y = l + 3 & -4
      , x = c + 3 & -4
      , v = new Array(u);
    let _ = l * c;
    r === 0 && (_ = y * x);
    let C;
    if (r !== 0 ? Sg[r] ? C = Sg[r] * WI[o] : C = XI[r] : C = Ac[a],
    C === void 0)
        throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    const k = i ? qI(s, p, n) : null;
    let T = _ * C
      , L = l
      , D = c
      , O = y
      , K = x
      , P = wd + p;
    for (let N = 0; N < f; N++) {
        const W = s.getUint32(P, n);
        let V = P + 4;
        for (let Q = 0; Q < u; Q++) {
            let pt = v[Q];
            pt || (pt = v[Q] = new Array(f)),
            pt[N] = {
                levelID: N,
                levelWidth: f > 1 || r !== 0 ? L : O,
                levelHeight: f > 1 || r !== 0 ? D : K,
                levelBuffer: new Uint8Array(t,V,T)
            },
            V += T
        }
        P += W + 4,
        P = P % 4 !== 0 ? P + 4 - P % 4 : P,
        L = L >> 1 || 1,
        D = D >> 1 || 1,
        O = L + m - 1 & ~(m - 1),
        K = D + g - 1 & ~(g - 1),
        T = O * K * C
    }
    return r !== 0 ? {
        uncompressed: v.map(N=>{
            let W = N[0].levelBuffer
              , V = !1;
            return r === Rt.FLOAT ? W = new Float32Array(N[0].levelBuffer.buffer,N[0].levelBuffer.byteOffset,N[0].levelBuffer.byteLength / 4) : r === Rt.UNSIGNED_INT ? (V = !0,
            W = new Uint32Array(N[0].levelBuffer.buffer,N[0].levelBuffer.byteOffset,N[0].levelBuffer.byteLength / 4)) : r === Rt.INT && (V = !0,
            W = new Int32Array(N[0].levelBuffer.buffer,N[0].levelBuffer.byteOffset,N[0].levelBuffer.byteLength / 4)),
            {
                resource: new qa(W,{
                    width: N[0].levelWidth,
                    height: N[0].levelHeight
                }),
                type: r,
                format: V ? ZI(o) : o
            }
        }
        ),
        kvData: k
    } : {
        compressed: v.map(N=>new Tr(null,{
            format: a,
            width: l,
            height: c,
            levels: f,
            levelBuffers: N
        })),
        kvData: k
    }
}
function KI(e, t) {
    for (let i = 0; i < Eg.length; i++)
        if (t.getUint8(i) !== Eg[i])
            return console.error(`${e} is not a valid *.ktx file!`),
            !1;
    return !0
}
function ZI(e) {
    switch (e) {
    case ot.RGBA:
        return ot.RGBA_INTEGER;
    case ot.RGB:
        return ot.RGB_INTEGER;
    case ot.RG:
        return ot.RG_INTEGER;
    case ot.RED:
        return ot.RED_INTEGER;
    default:
        return e
    }
}
function qI(e, t, i) {
    const s = new Map;
    let n = 0;
    for (; n < t; ) {
        const r = e.getUint32(wd + n, i)
          , o = wd + n + 4
          , a = 3 - (r + 3) % 4;
        if (r === 0 || r > t - n) {
            console.error("KTXLoader: keyAndValueByteSize out of bounds");
            break
        }
        let l = 0;
        for (; l < r && e.getUint8(o + l) !== 0; l++)
            ;
        if (l === -1) {
            console.error("KTXLoader: Failed to find null byte terminating kvData key");
            break
        }
        const c = new TextDecoder().decode(new Uint8Array(e.buffer,o,l))
          , h = new DataView(e.buffer,o + l + 1,r - l - 1);
        s.set(c, h),
        n += 4 + r + a
    }
    return s
}
const JI = {
    extension: {
        type: lt.LoadParser,
        priority: Us.High
    },
    test(e) {
        return fh(e, ".dds")
    },
    async load(e, t, i) {
        const n = await (await ft.ADAPTER.fetch(e)).arrayBuffer()
          , o = $I(n).map(a=>{
            const l = new Ot(a,{
                mipmap: ds.OFF,
                alphaMode: _s.NO_PREMULTIPLIED_ALPHA,
                resolution: en(e),
                ...t.data
            });
            return ph(l, i, e)
        }
        );
        return o.length === 1 ? o[0] : o
    },
    unload(e) {
        Array.isArray(e) ? e.forEach(t=>t.destroy(!0)) : e.destroy(!0)
    }
};
vt.add(JI);
const QI = {
    extension: {
        type: lt.LoadParser,
        priority: Us.High
    },
    test(e) {
        return fh(e, ".ktx")
    },
    async load(e, t, i) {
        const n = await (await ft.ADAPTER.fetch(e)).arrayBuffer()
          , {compressed: r, uncompressed: o, kvData: a} = YI(e, n)
          , l = r ?? o
          , c = {
            mipmap: ds.OFF,
            alphaMode: _s.NO_PREMULTIPLIED_ALPHA,
            resolution: en(e),
            ...t.data
        }
          , h = l.map(u=>{
            l === o && Object.assign(c, {
                type: u.type,
                format: u.format
            });
            const d = new Ot(u,c);
            return d.ktxKeyValueData = a,
            ph(d, i, e)
        }
        );
        return h.length === 1 ? h[0] : h
    },
    unload(e) {
        Array.isArray(e) ? e.forEach(t=>t.destroy(!0)) : e.destroy(!0)
    }
};
vt.add(QI);
const tM = {
    extension: lt.ResolveParser,
    test: e=>{
        const i = e.split("?")[0].split(".").pop();
        return ["basis", "ktx", "dds"].includes(i)
    }
    ,
    parse: e=>{
        if (e.split("?")[0].split(".").pop() === "ktx") {
            const s = [".s3tc.ktx", ".s3tc_sRGB.ktx", ".etc.ktx", ".etc1.ktx", ".pvrt.ktx", ".atc.ktx", ".astc.ktx"];
            if (s.some(n=>e.endsWith(n)))
                return {
                    resolution: parseFloat(ft.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
                    format: s.find(n=>e.endsWith(n)),
                    src: e
                }
        }
        return {
            resolution: parseFloat(ft.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
            format: e.split(".").pop(),
            src: e
        }
    }
};
vt.add(tM);
const eM = new qt
  , iM = 4
  , Td = class {
    constructor(e) {
        this.renderer = e
    }
    async image(e, t, i) {
        const s = new Image;
        return s.src = await this.base64(e, t, i),
        s
    }
    async base64(e, t, i) {
        const s = this.canvas(e);
        if (s.toDataURL !== void 0)
            return s.toDataURL(t, i);
        if (s.convertToBlob !== void 0) {
            const n = await s.convertToBlob({
                type: t,
                quality: i
            });
            return await new Promise(r=>{
                const o = new FileReader;
                o.onload = ()=>r(o.result),
                o.readAsDataURL(n)
            }
            )
        }
        throw new Error("Extract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented")
    }
    canvas(e, t) {
        const {pixels: i, width: s, height: n, flipY: r} = this._rawPixels(e, t);
        let o = new Po(s,n,1);
        const a = o.context.getImageData(0, 0, s, n);
        if (Td.arrayPostDivide(i, a.data),
        o.context.putImageData(a, 0, 0),
        r) {
            const l = new Po(o.width,o.height,1);
            l.context.scale(1, -1),
            l.context.drawImage(o.canvas, 0, -n),
            o.destroy(),
            o = l
        }
        return o.canvas
    }
    pixels(e, t) {
        const {pixels: i} = this._rawPixels(e, t);
        return Td.arrayPostDivide(i, i),
        i
    }
    _rawPixels(e, t) {
        const i = this.renderer;
        let s, n = !1, r, o = !1;
        if (e)
            if (e instanceof fs)
                r = e;
            else {
                const u = i.context.webGLVersion >= 2 ? i.multisample : De.NONE;
                if (r = this.renderer.generateTexture(e, {
                    multisample: u
                }),
                u !== De.NONE) {
                    const d = fs.create({
                        width: r.width,
                        height: r.height
                    });
                    i.framebuffer.bind(r.framebuffer),
                    i.framebuffer.blit(d.framebuffer),
                    i.framebuffer.bind(null),
                    r.destroy(!0),
                    r = d
                }
                o = !0
            }
        r ? (s = r.baseTexture.resolution,
        t = t ?? r.frame,
        n = !1,
        i.renderTexture.bind(r)) : (s = i.resolution,
        t || (t = eM,
        t.width = i.width,
        t.height = i.height),
        n = !0,
        i.renderTexture.bind(null));
        const a = Math.round(t.width * s)
          , l = Math.round(t.height * s)
          , c = new Uint8Array(iM * a * l)
          , h = i.gl;
        return h.readPixels(Math.round(t.x * s), Math.round(t.y * s), a, l, h.RGBA, h.UNSIGNED_BYTE, c),
        o && r.destroy(!0),
        {
            pixels: c,
            width: a,
            height: l,
            flipY: n
        }
    }
    destroy() {
        this.renderer = null
    }
    static arrayPostDivide(e, t) {
        for (let i = 0; i < e.length; i += 4) {
            const s = t[i + 3] = e[i + 3];
            s !== 0 ? (t[i] = Math.round(Math.min(e[i] * 255 / s, 255)),
            t[i + 1] = Math.round(Math.min(e[i + 1] * 255 / s, 255)),
            t[i + 2] = Math.round(Math.min(e[i + 2] * 255 / s, 255))) : (t[i] = e[i],
            t[i + 1] = e[i + 1],
            t[i + 2] = e[i + 2])
        }
    }
}
;
let C1 = Td;
C1.extension = {
    name: "extract",
    type: lt.RendererSystem
};
vt.add(C1);
const Ic = {
    build(e) {
        const t = e.points;
        let i, s, n, r, o, a;
        if (e.type === we.CIRC) {
            const p = e.shape;
            i = p.x,
            s = p.y,
            o = a = p.radius,
            n = r = 0
        } else if (e.type === we.ELIP) {
            const p = e.shape;
            i = p.x,
            s = p.y,
            o = p.width,
            a = p.height,
            n = r = 0
        } else {
            const p = e.shape
              , m = p.width / 2
              , g = p.height / 2;
            i = p.x + m,
            s = p.y + g,
            o = a = Math.max(0, Math.min(p.radius, Math.min(m, g))),
            n = m - o,
            r = g - a
        }
        if (!(o >= 0 && a >= 0 && n >= 0 && r >= 0)) {
            t.length = 0;
            return
        }
        const l = Math.ceil(2.3 * Math.sqrt(o + a))
          , c = l * 8 + (n ? 4 : 0) + (r ? 4 : 0);
        if (t.length = c,
        c === 0)
            return;
        if (l === 0) {
            t.length = 8,
            t[0] = t[6] = i + n,
            t[1] = t[3] = s + r,
            t[2] = t[4] = i - n,
            t[5] = t[7] = s - r;
            return
        }
        let h = 0
          , u = l * 4 + (n ? 2 : 0) + 2
          , d = u
          , f = c;
        {
            const p = n + o
              , m = r
              , g = i + p
              , y = i - p
              , x = s + m;
            if (t[h++] = g,
            t[h++] = x,
            t[--u] = x,
            t[--u] = y,
            r) {
                const v = s - m;
                t[d++] = y,
                t[d++] = v,
                t[--f] = v,
                t[--f] = g
            }
        }
        for (let p = 1; p < l; p++) {
            const m = Math.PI / 2 * (p / l)
              , g = n + Math.cos(m) * o
              , y = r + Math.sin(m) * a
              , x = i + g
              , v = i - g
              , _ = s + y
              , C = s - y;
            t[h++] = x,
            t[h++] = _,
            t[--u] = _,
            t[--u] = v,
            t[d++] = v,
            t[d++] = C,
            t[--f] = C,
            t[--f] = x
        }
        {
            const p = n
              , m = r + a
              , g = i + p
              , y = i - p
              , x = s + m
              , v = s - m;
            t[h++] = g,
            t[h++] = x,
            t[--f] = v,
            t[--f] = g,
            n && (t[h++] = y,
            t[h++] = x,
            t[--f] = v,
            t[--f] = y)
        }
    },
    triangulate(e, t) {
        const i = e.points
          , s = t.points
          , n = t.indices;
        if (i.length === 0)
            return;
        let r = s.length / 2;
        const o = r;
        let a, l;
        if (e.type !== we.RREC) {
            const h = e.shape;
            a = h.x,
            l = h.y
        } else {
            const h = e.shape;
            a = h.x + h.width / 2,
            l = h.y + h.height / 2
        }
        const c = e.matrix;
        s.push(e.matrix ? c.a * a + c.c * l + c.tx : a, e.matrix ? c.b * a + c.d * l + c.ty : l),
        r++,
        s.push(i[0], i[1]);
        for (let h = 2; h < i.length; h += 2)
            s.push(i[h], i[h + 1]),
            n.push(r++, o, r);
        n.push(o + 1, o, r)
    }
};
function Cg(e, t=!1) {
    const i = e.length;
    if (i < 6)
        return;
    let s = 0;
    for (let n = 0, r = e[i - 2], o = e[i - 1]; n < i; n += 2) {
        const a = e[n]
          , l = e[n + 1];
        s += (a - r) * (l + o),
        r = a,
        o = l
    }
    if (!t && s > 0 || t && s <= 0) {
        const n = i / 2;
        for (let r = n + n % 2; r < i; r += 2) {
            const o = i - r - 2
              , a = i - r - 1
              , l = r
              , c = r + 1;
            [e[o],e[l]] = [e[l], e[o]],
            [e[a],e[c]] = [e[c], e[a]]
        }
    }
}
const A1 = {
    build(e) {
        e.points = e.shape.points.slice()
    },
    triangulate(e, t) {
        let i = e.points;
        const s = e.holes
          , n = t.points
          , r = t.indices;
        if (i.length >= 6) {
            Cg(i, !1);
            const o = [];
            for (let c = 0; c < s.length; c++) {
                const h = s[c];
                Cg(h.points, !0),
                o.push(i.length / 2),
                i = i.concat(h.points)
            }
            const a = b_(i, o, 2);
            if (!a)
                return;
            const l = n.length / 2;
            for (let c = 0; c < a.length; c += 3)
                r.push(a[c] + l),
                r.push(a[c + 1] + l),
                r.push(a[c + 2] + l);
            for (let c = 0; c < i.length; c++)
                n.push(i[c])
        }
    }
}
  , sM = {
    build(e) {
        const t = e.shape
          , i = t.x
          , s = t.y
          , n = t.width
          , r = t.height
          , o = e.points;
        o.length = 0,
        n >= 0 && r >= 0 && o.push(i, s, i + n, s, i + n, s + r, i, s + r)
    },
    triangulate(e, t) {
        const i = e.points
          , s = t.points;
        if (i.length === 0)
            return;
        const n = s.length / 2;
        s.push(i[0], i[1], i[2], i[3], i[6], i[7], i[4], i[5]),
        t.indices.push(n, n + 1, n + 2, n + 1, n + 2, n + 3)
    }
}
  , nM = {
    build(e) {
        Ic.build(e)
    },
    triangulate(e, t) {
        Ic.triangulate(e, t)
    }
};
var bn = (e=>(e.MITER = "miter",
e.BEVEL = "bevel",
e.ROUND = "round",
e))(bn || {})
  , or = (e=>(e.BUTT = "butt",
e.ROUND = "round",
e.SQUARE = "square",
e))(or || {});
const Oo = {
    adaptive: !0,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    epsilon: 1e-4,
    _segmentsCount(e, t=20) {
        if (!this.adaptive || !e || isNaN(e))
            return t;
        let i = Math.ceil(e / this.maxLength);
        return i < this.minSegments ? i = this.minSegments : i > this.maxSegments && (i = this.maxSegments),
        i
    }
};
class Ag {
    static curveTo(t, i, s, n, r, o) {
        const a = o[o.length - 2]
          , c = o[o.length - 1] - i
          , h = a - t
          , u = n - i
          , d = s - t
          , f = Math.abs(c * d - h * u);
        if (f < 1e-8 || r === 0)
            return (o[o.length - 2] !== t || o[o.length - 1] !== i) && o.push(t, i),
            null;
        const p = c * c + h * h
          , m = u * u + d * d
          , g = c * u + h * d
          , y = r * Math.sqrt(p) / f
          , x = r * Math.sqrt(m) / f
          , v = y * g / p
          , _ = x * g / m
          , C = y * d + x * h
          , k = y * u + x * c
          , S = h * (x + v)
          , T = c * (x + v)
          , L = d * (y + _)
          , D = u * (y + _)
          , O = Math.atan2(T - k, S - C)
          , K = Math.atan2(D - k, L - C);
        return {
            cx: C + t,
            cy: k + i,
            radius: r,
            startAngle: O,
            endAngle: K,
            anticlockwise: h * u > d * c
        }
    }
    static arc(t, i, s, n, r, o, a, l, c) {
        const h = a - o
          , u = Oo._segmentsCount(Math.abs(h) * r, Math.ceil(Math.abs(h) / Tc) * 40)
          , d = h / (u * 2)
          , f = d * 2
          , p = Math.cos(d)
          , m = Math.sin(d)
          , g = u - 1
          , y = g % 1 / g;
        for (let x = 0; x <= g; ++x) {
            const v = x + y * x
              , _ = d + o + f * v
              , C = Math.cos(_)
              , k = -Math.sin(_);
            c.push((p * C + m * k) * r + s, (p * -k + m * C) * r + n)
        }
    }
}
class rM {
    constructor() {
        this.reset()
    }
    begin(t, i, s) {
        this.reset(),
        this.style = t,
        this.start = i,
        this.attribStart = s
    }
    end(t, i) {
        this.attribSize = i - this.attribStart,
        this.size = t - this.start
    }
    reset() {
        this.style = null,
        this.size = 0,
        this.start = 0,
        this.attribStart = 0,
        this.attribSize = 0
    }
}
class Xf {
    static curveLength(t, i, s, n, r, o, a, l) {
        let h = 0
          , u = 0
          , d = 0
          , f = 0
          , p = 0
          , m = 0
          , g = 0
          , y = 0
          , x = 0
          , v = 0
          , _ = 0
          , C = t
          , k = i;
        for (let S = 1; S <= 10; ++S)
            u = S / 10,
            d = u * u,
            f = d * u,
            p = 1 - u,
            m = p * p,
            g = m * p,
            y = g * t + 3 * m * u * s + 3 * p * d * r + f * a,
            x = g * i + 3 * m * u * n + 3 * p * d * o + f * l,
            v = C - y,
            _ = k - x,
            C = y,
            k = x,
            h += Math.sqrt(v * v + _ * _);
        return h
    }
    static curveTo(t, i, s, n, r, o, a) {
        const l = a[a.length - 2]
          , c = a[a.length - 1];
        a.length -= 2;
        const h = Oo._segmentsCount(Xf.curveLength(l, c, t, i, s, n, r, o));
        let u = 0
          , d = 0
          , f = 0
          , p = 0
          , m = 0;
        a.push(l, c);
        for (let g = 1, y = 0; g <= h; ++g)
            y = g / h,
            u = 1 - y,
            d = u * u,
            f = d * u,
            p = y * y,
            m = p * y,
            a.push(f * l + 3 * d * y * t + 3 * u * p * s + m * r, f * c + 3 * d * y * i + 3 * u * p * n + m * o)
    }
}
function Ig(e, t, i, s, n, r, o, a) {
    const l = e - i * n
      , c = t - s * n
      , h = e + i * r
      , u = t + s * r;
    let d, f;
    o ? (d = s,
    f = -i) : (d = -s,
    f = i);
    const p = l + d
      , m = c + f
      , g = h + d
      , y = u + f;
    return a.push(p, m),
    a.push(g, y),
    2
}
function Vn(e, t, i, s, n, r, o, a) {
    const l = i - e
      , c = s - t;
    let h = Math.atan2(l, c)
      , u = Math.atan2(n - e, r - t);
    a && h < u ? h += Math.PI * 2 : !a && h > u && (u += Math.PI * 2);
    let d = h;
    const f = u - h
      , p = Math.abs(f)
      , m = Math.sqrt(l * l + c * c)
      , g = (15 * p * Math.sqrt(m) / Math.PI >> 0) + 1
      , y = f / g;
    if (d += y,
    a) {
        o.push(e, t),
        o.push(i, s);
        for (let x = 1, v = d; x < g; x++,
        v += y)
            o.push(e, t),
            o.push(e + Math.sin(v) * m, t + Math.cos(v) * m);
        o.push(e, t),
        o.push(n, r)
    } else {
        o.push(i, s),
        o.push(e, t);
        for (let x = 1, v = d; x < g; x++,
        v += y)
            o.push(e + Math.sin(v) * m, t + Math.cos(v) * m),
            o.push(e, t);
        o.push(n, r),
        o.push(e, t)
    }
    return g * 2
}
function oM(e, t) {
    const i = e.shape;
    let s = e.points || i.points.slice();
    const n = t.closePointEps;
    if (s.length === 0)
        return;
    const r = e.lineStyle
      , o = new Zt(s[0],s[1])
      , a = new Zt(s[s.length - 2],s[s.length - 1])
      , l = i.type !== we.POLY || i.closeStroke
      , c = Math.abs(o.x - a.x) < n && Math.abs(o.y - a.y) < n;
    if (l) {
        s = s.slice(),
        c && (s.pop(),
        s.pop(),
        a.set(s[s.length - 2], s[s.length - 1]));
        const Q = (o.x + a.x) * .5
          , pt = (a.y + o.y) * .5;
        s.unshift(Q, pt),
        s.push(Q, pt)
    }
    const h = t.points
      , u = s.length / 2;
    let d = s.length;
    const f = h.length / 2
      , p = r.width / 2
      , m = p * p
      , g = r.miterLimit * r.miterLimit;
    let y = s[0]
      , x = s[1]
      , v = s[2]
      , _ = s[3]
      , C = 0
      , k = 0
      , S = -(x - _)
      , T = y - v
      , L = 0
      , D = 0
      , O = Math.sqrt(S * S + T * T);
    S /= O,
    T /= O,
    S *= p,
    T *= p;
    const K = r.alignment
      , P = (1 - K) * 2
      , N = K * 2;
    l || (r.cap === or.ROUND ? d += Vn(y - S * (P - N) * .5, x - T * (P - N) * .5, y - S * P, x - T * P, y + S * N, x + T * N, h, !0) + 2 : r.cap === or.SQUARE && (d += Ig(y, x, S, T, P, N, !0, h))),
    h.push(y - S * P, x - T * P),
    h.push(y + S * N, x + T * N);
    for (let Q = 1; Q < u - 1; ++Q) {
        y = s[(Q - 1) * 2],
        x = s[(Q - 1) * 2 + 1],
        v = s[Q * 2],
        _ = s[Q * 2 + 1],
        C = s[(Q + 1) * 2],
        k = s[(Q + 1) * 2 + 1],
        S = -(x - _),
        T = y - v,
        O = Math.sqrt(S * S + T * T),
        S /= O,
        T /= O,
        S *= p,
        T *= p,
        L = -(_ - k),
        D = v - C,
        O = Math.sqrt(L * L + D * D),
        L /= O,
        D /= O,
        L *= p,
        D *= p;
        const pt = v - y
          , bt = x - _
          , ct = v - C
          , gt = k - _
          , xt = pt * ct + bt * gt
          , It = bt * ct - gt * pt
          , St = It < 0;
        if (Math.abs(It) < .001 * Math.abs(xt)) {
            h.push(v - S * P, _ - T * P),
            h.push(v + S * N, _ + T * N),
            xt >= 0 && (r.join === bn.ROUND ? d += Vn(v, _, v - S * P, _ - T * P, v - L * P, _ - D * P, h, !1) + 4 : d += 2,
            h.push(v - L * N, _ - D * N),
            h.push(v + L * P, _ + D * P));
            continue
        }
        const J = (-S + y) * (-T + _) - (-S + v) * (-T + x)
          , wt = (-L + C) * (-D + _) - (-L + v) * (-D + k)
          , Tt = (pt * wt - ct * J) / It
          , Bt = (gt * J - bt * wt) / It
          , kt = (Tt - v) * (Tt - v) + (Bt - _) * (Bt - _)
          , re = v + (Tt - v) * P
          , Xt = _ + (Bt - _) * P
          , ce = v - (Tt - v) * N
          , E = _ - (Bt - _) * N
          , M = Math.min(pt * pt + bt * bt, ct * ct + gt * gt)
          , F = St ? P : N
          , $ = M + F * F * m;
        kt <= $ ? r.join === bn.BEVEL || kt / m > g ? (St ? (h.push(re, Xt),
        h.push(v + S * N, _ + T * N),
        h.push(re, Xt),
        h.push(v + L * N, _ + D * N)) : (h.push(v - S * P, _ - T * P),
        h.push(ce, E),
        h.push(v - L * P, _ - D * P),
        h.push(ce, E)),
        d += 2) : r.join === bn.ROUND ? St ? (h.push(re, Xt),
        h.push(v + S * N, _ + T * N),
        d += Vn(v, _, v + S * N, _ + T * N, v + L * N, _ + D * N, h, !0) + 4,
        h.push(re, Xt),
        h.push(v + L * N, _ + D * N)) : (h.push(v - S * P, _ - T * P),
        h.push(ce, E),
        d += Vn(v, _, v - S * P, _ - T * P, v - L * P, _ - D * P, h, !1) + 4,
        h.push(v - L * P, _ - D * P),
        h.push(ce, E)) : (h.push(re, Xt),
        h.push(ce, E)) : (h.push(v - S * P, _ - T * P),
        h.push(v + S * N, _ + T * N),
        r.join === bn.ROUND ? St ? d += Vn(v, _, v + S * N, _ + T * N, v + L * N, _ + D * N, h, !0) + 2 : d += Vn(v, _, v - S * P, _ - T * P, v - L * P, _ - D * P, h, !1) + 2 : r.join === bn.MITER && kt / m <= g && (St ? (h.push(ce, E),
        h.push(ce, E)) : (h.push(re, Xt),
        h.push(re, Xt)),
        d += 2),
        h.push(v - L * P, _ - D * P),
        h.push(v + L * N, _ + D * N),
        d += 2)
    }
    y = s[(u - 2) * 2],
    x = s[(u - 2) * 2 + 1],
    v = s[(u - 1) * 2],
    _ = s[(u - 1) * 2 + 1],
    S = -(x - _),
    T = y - v,
    O = Math.sqrt(S * S + T * T),
    S /= O,
    T /= O,
    S *= p,
    T *= p,
    h.push(v - S * P, _ - T * P),
    h.push(v + S * N, _ + T * N),
    l || (r.cap === or.ROUND ? d += Vn(v - S * (P - N) * .5, _ - T * (P - N) * .5, v - S * P, _ - T * P, v + S * N, _ + T * N, h, !1) + 2 : r.cap === or.SQUARE && (d += Ig(v, _, S, T, P, N, !1, h)));
    const W = t.indices
      , V = Oo.epsilon * Oo.epsilon;
    for (let Q = f; Q < d + f - 2; ++Q)
        y = h[Q * 2],
        x = h[Q * 2 + 1],
        v = h[(Q + 1) * 2],
        _ = h[(Q + 1) * 2 + 1],
        C = h[(Q + 2) * 2],
        k = h[(Q + 2) * 2 + 1],
        !(Math.abs(y * (_ - k) + v * (k - x) + C * (x - _)) < V) && W.push(Q, Q + 1, Q + 2)
}
function aM(e, t) {
    let i = 0;
    const s = e.shape
      , n = e.points || s.points
      , r = s.type !== we.POLY || s.closeStroke;
    if (n.length === 0)
        return;
    const o = t.points
      , a = t.indices
      , l = n.length / 2
      , c = o.length / 2;
    let h = c;
    for (o.push(n[0], n[1]),
    i = 1; i < l; i++)
        o.push(n[i * 2], n[i * 2 + 1]),
        a.push(h, h + 1),
        h++;
    r && a.push(h, c)
}
function Mg(e, t) {
    e.lineStyle.native ? aM(e, t) : oM(e, t)
}
class Yf {
    static curveLength(t, i, s, n, r, o) {
        const a = t - 2 * s + r
          , l = i - 2 * n + o
          , c = 2 * s - 2 * t
          , h = 2 * n - 2 * i
          , u = 4 * (a * a + l * l)
          , d = 4 * (a * c + l * h)
          , f = c * c + h * h
          , p = 2 * Math.sqrt(u + d + f)
          , m = Math.sqrt(u)
          , g = 2 * u * m
          , y = 2 * Math.sqrt(f)
          , x = d / m;
        return (g * p + m * d * (p - y) + (4 * f * u - d * d) * Math.log((2 * m + x + p) / (x + y))) / (4 * g)
    }
    static curveTo(t, i, s, n, r) {
        const o = r[r.length - 2]
          , a = r[r.length - 1]
          , l = Oo._segmentsCount(Yf.curveLength(o, a, t, i, s, n));
        let c = 0
          , h = 0;
        for (let u = 1; u <= l; ++u) {
            const d = u / l;
            c = o + (t - o) * d,
            h = a + (i - a) * d,
            r.push(c + (t + (s - t) * d - c) * d, h + (i + (n - i) * d - h) * d)
        }
    }
}
const cu = {
    [we.POLY]: A1,
    [we.CIRC]: Ic,
    [we.ELIP]: Ic,
    [we.RECT]: sM,
    [we.RREC]: nM
}
  , Rg = []
  , Dl = [];
class Mc {
    constructor(t, i=null, s=null, n=null) {
        this.points = [],
        this.holes = [],
        this.shape = t,
        this.lineStyle = s,
        this.fillStyle = i,
        this.matrix = n,
        this.type = t.type
    }
    clone() {
        return new Mc(this.shape,this.fillStyle,this.lineStyle,this.matrix)
    }
    destroy() {
        this.shape = null,
        this.holes.length = 0,
        this.holes = null,
        this.points.length = 0,
        this.points = null,
        this.lineStyle = null,
        this.fillStyle = null
    }
}
const Gr = new Zt
  , I1 = class extends k_ {
    constructor() {
        super(),
        this.closePointEps = 1e-4,
        this.boundsPadding = 0,
        this.uvsFloat32 = null,
        this.indicesUint16 = null,
        this.batchable = !1,
        this.points = [],
        this.colors = [],
        this.uvs = [],
        this.indices = [],
        this.textureIds = [],
        this.graphicsData = [],
        this.drawCalls = [],
        this.batchDirty = -1,
        this.batches = [],
        this.dirty = 0,
        this.cacheDirty = -1,
        this.clearDirty = 0,
        this.shapeIndex = 0,
        this._bounds = new Ec,
        this.boundsDirty = -1
    }
    get bounds() {
        return this.updateBatches(),
        this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty,
        this.calculateBounds()),
        this._bounds
    }
    invalidate() {
        this.boundsDirty = -1,
        this.dirty++,
        this.batchDirty++,
        this.shapeIndex = 0,
        this.points.length = 0,
        this.colors.length = 0,
        this.uvs.length = 0,
        this.indices.length = 0,
        this.textureIds.length = 0;
        for (let e = 0; e < this.drawCalls.length; e++)
            this.drawCalls[e].texArray.clear(),
            Dl.push(this.drawCalls[e]);
        this.drawCalls.length = 0;
        for (let e = 0; e < this.batches.length; e++) {
            const t = this.batches[e];
            t.reset(),
            Rg.push(t)
        }
        this.batches.length = 0
    }
    clear() {
        return this.graphicsData.length > 0 && (this.invalidate(),
        this.clearDirty++,
        this.graphicsData.length = 0),
        this
    }
    drawShape(e, t=null, i=null, s=null) {
        const n = new Mc(e,t,i,s);
        return this.graphicsData.push(n),
        this.dirty++,
        this
    }
    drawHole(e, t=null) {
        if (!this.graphicsData.length)
            return null;
        const i = new Mc(e,null,null,t)
          , s = this.graphicsData[this.graphicsData.length - 1];
        return i.lineStyle = s.lineStyle,
        s.holes.push(i),
        this.dirty++,
        this
    }
    destroy() {
        super.destroy();
        for (let e = 0; e < this.graphicsData.length; ++e)
            this.graphicsData[e].destroy();
        this.points.length = 0,
        this.points = null,
        this.colors.length = 0,
        this.colors = null,
        this.uvs.length = 0,
        this.uvs = null,
        this.indices.length = 0,
        this.indices = null,
        this.indexBuffer.destroy(),
        this.indexBuffer = null,
        this.graphicsData.length = 0,
        this.graphicsData = null,
        this.drawCalls.length = 0,
        this.drawCalls = null,
        this.batches.length = 0,
        this.batches = null,
        this._bounds = null
    }
    containsPoint(e) {
        const t = this.graphicsData;
        for (let i = 0; i < t.length; ++i) {
            const s = t[i];
            if (!!s.fillStyle.visible && s.shape && (s.matrix ? s.matrix.applyInverse(e, Gr) : Gr.copyFrom(e),
            s.shape.contains(Gr.x, Gr.y))) {
                let n = !1;
                if (s.holes) {
                    for (let r = 0; r < s.holes.length; r++)
                        if (s.holes[r].shape.contains(Gr.x, Gr.y)) {
                            n = !0;
                            break
                        }
                }
                if (!n)
                    return !0
            }
        }
        return !1
    }
    updateBatches() {
        if (!this.graphicsData.length) {
            this.batchable = !0;
            return
        }
        if (!this.validateBatching())
            return;
        this.cacheDirty = this.dirty;
        const e = this.uvs
          , t = this.graphicsData;
        let i = null
          , s = null;
        this.batches.length > 0 && (i = this.batches[this.batches.length - 1],
        s = i.style);
        for (let a = this.shapeIndex; a < t.length; a++) {
            this.shapeIndex++;
            const l = t[a]
              , c = l.fillStyle
              , h = l.lineStyle;
            cu[l.type].build(l),
            l.matrix && this.transformPoints(l.points, l.matrix),
            (c.visible || h.visible) && this.processHoles(l.holes);
            for (let d = 0; d < 2; d++) {
                const f = d === 0 ? c : h;
                if (!f.visible)
                    continue;
                const p = f.texture.baseTexture
                  , m = this.indices.length
                  , g = this.points.length / 2;
                p.wrapMode = Zs.REPEAT,
                d === 0 ? this.processFill(l) : this.processLine(l);
                const y = this.points.length / 2 - g;
                y !== 0 && (i && !this._compareStyles(s, f) && (i.end(m, g),
                i = null),
                i || (i = Rg.pop() || new rM,
                i.begin(f, m, g),
                this.batches.push(i),
                s = f),
                this.addUvs(this.points, e, f.texture, g, y, f.matrix))
            }
        }
        const n = this.indices.length
          , r = this.points.length / 2;
        if (i && i.end(n, r),
        this.batches.length === 0) {
            this.batchable = !0;
            return
        }
        const o = r > 65535;
        this.indicesUint16 && this.indices.length === this.indicesUint16.length && o === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = o ? new Uint32Array(this.indices) : new Uint16Array(this.indices),
        this.batchable = this.isBatchable(),
        this.batchable ? this.packBatches() : this.buildDrawCalls()
    }
    _compareStyles(e, t) {
        return !(!e || !t || e.texture.baseTexture !== t.texture.baseTexture || e.color + e.alpha !== t.color + t.alpha || !!e.native != !!t.native)
    }
    validateBatching() {
        if (this.dirty === this.cacheDirty || !this.graphicsData.length)
            return !1;
        for (let e = 0, t = this.graphicsData.length; e < t; e++) {
            const i = this.graphicsData[e]
              , s = i.fillStyle
              , n = i.lineStyle;
            if (s && !s.texture.baseTexture.valid || n && !n.texture.baseTexture.valid)
                return !1
        }
        return !0
    }
    packBatches() {
        this.batchDirty++,
        this.uvsFloat32 = new Float32Array(this.uvs);
        const e = this.batches;
        for (let t = 0, i = e.length; t < i; t++) {
            const s = e[t];
            for (let n = 0; n < s.size; n++) {
                const r = s.start + n;
                this.indicesUint16[r] = this.indicesUint16[r] - s.attribStart
            }
        }
    }
    isBatchable() {
        if (this.points.length > 65535 * 2)
            return !1;
        const e = this.batches;
        for (let t = 0; t < e.length; t++)
            if (e[t].style.native)
                return !1;
        return this.points.length < I1.BATCHABLE_SIZE * 2
    }
    buildDrawCalls() {
        let e = ++Ot._globalBatch;
        for (let h = 0; h < this.drawCalls.length; h++)
            this.drawCalls[h].texArray.clear(),
            Dl.push(this.drawCalls[h]);
        this.drawCalls.length = 0;
        const t = this.colors
          , i = this.textureIds;
        let s = Dl.pop();
        s || (s = new cd,
        s.texArray = new ud),
        s.texArray.count = 0,
        s.start = 0,
        s.size = 0,
        s.type = rs.TRIANGLES;
        let n = 0
          , r = null
          , o = 0
          , a = !1
          , l = rs.TRIANGLES
          , c = 0;
        this.drawCalls.push(s);
        for (let h = 0; h < this.batches.length; h++) {
            const u = this.batches[h]
              , d = 8
              , f = u.style
              , p = f.texture.baseTexture;
            a !== !!f.native && (a = !!f.native,
            l = a ? rs.LINES : rs.TRIANGLES,
            r = null,
            n = d,
            e++),
            r !== p && (r = p,
            p._batchEnabled !== e && (n === d && (e++,
            n = 0,
            s.size > 0 && (s = Dl.pop(),
            s || (s = new cd,
            s.texArray = new ud),
            this.drawCalls.push(s)),
            s.start = c,
            s.size = 0,
            s.texArray.count = 0,
            s.type = l),
            p.touched = 1,
            p._batchEnabled = e,
            p._batchLocation = n,
            p.wrapMode = Zs.REPEAT,
            s.texArray.elements[s.texArray.count++] = p,
            n++)),
            s.size += u.size,
            c += u.size,
            o = p._batchLocation,
            this.addColors(t, f.color, f.alpha, u.attribSize, u.attribStart),
            this.addTextureIds(i, o, u.attribSize, u.attribStart)
        }
        Ot._globalBatch = e,
        this.packAttributes()
    }
    packAttributes() {
        const e = this.points
          , t = this.uvs
          , i = this.colors
          , s = this.textureIds
          , n = new ArrayBuffer(e.length * 3 * 4)
          , r = new Float32Array(n)
          , o = new Uint32Array(n);
        let a = 0;
        for (let l = 0; l < e.length / 2; l++)
            r[a++] = e[l * 2],
            r[a++] = e[l * 2 + 1],
            r[a++] = t[l * 2],
            r[a++] = t[l * 2 + 1],
            o[a++] = i[l],
            r[a++] = s[l];
        this._buffer.update(n),
        this._indexBuffer.update(this.indicesUint16)
    }
    processFill(e) {
        e.holes.length ? A1.triangulate(e, this) : cu[e.type].triangulate(e, this)
    }
    processLine(e) {
        Mg(e, this);
        for (let t = 0; t < e.holes.length; t++)
            Mg(e.holes[t], this)
    }
    processHoles(e) {
        for (let t = 0; t < e.length; t++) {
            const i = e[t];
            cu[i.type].build(i),
            i.matrix && this.transformPoints(i.points, i.matrix)
        }
    }
    calculateBounds() {
        const e = this._bounds;
        e.clear(),
        e.addVertexData(this.points, 0, this.points.length),
        e.pad(this.boundsPadding, this.boundsPadding)
    }
    transformPoints(e, t) {
        for (let i = 0; i < e.length / 2; i++) {
            const s = e[i * 2]
              , n = e[i * 2 + 1];
            e[i * 2] = t.a * s + t.c * n + t.tx,
            e[i * 2 + 1] = t.b * s + t.d * n + t.ty
        }
    }
    addColors(e, t, i, s, n=0) {
        const r = (t >> 16) + (t & 65280) + ((t & 255) << 16)
          , o = ch(r, i);
        e.length = Math.max(e.length, n + s);
        for (let a = 0; a < s; a++)
            e[n + a] = o
    }
    addTextureIds(e, t, i, s=0) {
        e.length = Math.max(e.length, s + i);
        for (let n = 0; n < i; n++)
            e[s + n] = t
    }
    addUvs(e, t, i, s, n, r=null) {
        let o = 0;
        const a = t.length
          , l = i.frame;
        for (; o < n; ) {
            let h = e[(s + o) * 2]
              , u = e[(s + o) * 2 + 1];
            if (r) {
                const d = r.a * h + r.c * u + r.tx;
                u = r.b * h + r.d * u + r.ty,
                h = d
            }
            o++,
            t.push(h / l.width, u / l.height)
        }
        const c = i.baseTexture;
        (l.width < c.width || l.height < c.height) && this.adjustUvs(t, i, a, n)
    }
    adjustUvs(e, t, i, s) {
        const n = t.baseTexture
          , r = 1e-6
          , o = i + s * 2
          , a = t.frame
          , l = a.width / n.width
          , c = a.height / n.height;
        let h = a.x / a.width
          , u = a.y / a.height
          , d = Math.floor(e[i] + r)
          , f = Math.floor(e[i + 1] + r);
        for (let p = i + 2; p < o; p += 2)
            d = Math.min(d, Math.floor(e[p] + r)),
            f = Math.min(f, Math.floor(e[p + 1] + r));
        h -= d,
        u -= f;
        for (let p = i; p < o; p += 2)
            e[p] = (e[p] + h) * l,
            e[p + 1] = (e[p + 1] + u) * c
    }
}
;
let M1 = I1;
M1.BATCHABLE_SIZE = 100;
class mh {
    constructor() {
        this.color = 16777215,
        this.alpha = 1,
        this.texture = ht.WHITE,
        this.matrix = null,
        this.visible = !1,
        this.reset()
    }
    clone() {
        const t = new mh;
        return t.color = this.color,
        t.alpha = this.alpha,
        t.texture = this.texture,
        t.matrix = this.matrix,
        t.visible = this.visible,
        t
    }
    reset() {
        this.color = 16777215,
        this.alpha = 1,
        this.texture = ht.WHITE,
        this.matrix = null,
        this.visible = !1
    }
    destroy() {
        this.texture = null,
        this.matrix = null
    }
}
class Kf extends mh {
    constructor() {
        super(...arguments),
        this.width = 0,
        this.alignment = .5,
        this.native = !1,
        this.cap = or.BUTT,
        this.join = bn.MITER,
        this.miterLimit = 10
    }
    clone() {
        const t = new Kf;
        return t.color = this.color,
        t.alpha = this.alpha,
        t.texture = this.texture,
        t.matrix = this.matrix,
        t.visible = this.visible,
        t.width = this.width,
        t.alignment = this.alignment,
        t.native = this.native,
        t.cap = this.cap,
        t.join = this.join,
        t.miterLimit = this.miterLimit,
        t
    }
    reset() {
        super.reset(),
        this.color = 0,
        this.alignment = .5,
        this.width = 0,
        this.native = !1
    }
}
const lM = new Float32Array(3)
  , hu = {}
  , tc = class extends ae {
    constructor(e=null) {
        super(),
        this.shader = null,
        this.pluginName = "batch",
        this.currentPath = null,
        this.batches = [],
        this.batchTint = -1,
        this.batchDirty = -1,
        this.vertexData = null,
        this._fillStyle = new mh,
        this._lineStyle = new Kf,
        this._matrix = null,
        this._holeMode = !1,
        this.state = rn.for2d(),
        this._geometry = e || new M1,
        this._geometry.refCount++,
        this._transformID = -1,
        this.tint = 16777215,
        this.blendMode = j.NORMAL
    }
    get geometry() {
        return this._geometry
    }
    clone() {
        return this.finishPoly(),
        new tc(this._geometry)
    }
    set blendMode(e) {
        this.state.blendMode = e
    }
    get blendMode() {
        return this.state.blendMode
    }
    get tint() {
        return this._tint
    }
    set tint(e) {
        this._tint = e
    }
    get fill() {
        return this._fillStyle
    }
    get line() {
        return this._lineStyle
    }
    lineStyle(e=null, t=0, i=1, s=.5, n=!1) {
        return typeof e == "number" && (e = {
            width: e,
            color: t,
            alpha: i,
            alignment: s,
            native: n
        }),
        this.lineTextureStyle(e)
    }
    lineTextureStyle(e) {
        e = Object.assign({
            width: 0,
            texture: ht.WHITE,
            color: e?.texture ? 16777215 : 0,
            alpha: 1,
            matrix: null,
            alignment: .5,
            native: !1,
            cap: or.BUTT,
            join: bn.MITER,
            miterLimit: 10
        }, e),
        this.currentPath && this.startPoly();
        const t = e.width > 0 && e.alpha > 0;
        return t ? (e.matrix && (e.matrix = e.matrix.clone(),
        e.matrix.invert()),
        Object.assign(this._lineStyle, {
            visible: t
        }, e)) : this._lineStyle.reset(),
        this
    }
    startPoly() {
        if (this.currentPath) {
            const e = this.currentPath.points
              , t = this.currentPath.points.length;
            t > 2 && (this.drawShape(this.currentPath),
            this.currentPath = new vo,
            this.currentPath.closeStroke = !1,
            this.currentPath.points.push(e[t - 2], e[t - 1]))
        } else
            this.currentPath = new vo,
            this.currentPath.closeStroke = !1
    }
    finishPoly() {
        this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath),
        this.currentPath = null) : this.currentPath.points.length = 0)
    }
    moveTo(e, t) {
        return this.startPoly(),
        this.currentPath.points[0] = e,
        this.currentPath.points[1] = t,
        this
    }
    lineTo(e, t) {
        this.currentPath || this.moveTo(0, 0);
        const i = this.currentPath.points
          , s = i[i.length - 2]
          , n = i[i.length - 1];
        return (s !== e || n !== t) && i.push(e, t),
        this
    }
    _initCurve(e=0, t=0) {
        this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, t]) : this.moveTo(e, t)
    }
    quadraticCurveTo(e, t, i, s) {
        this._initCurve();
        const n = this.currentPath.points;
        return n.length === 0 && this.moveTo(0, 0),
        Yf.curveTo(e, t, i, s, n),
        this
    }
    bezierCurveTo(e, t, i, s, n, r) {
        return this._initCurve(),
        Xf.curveTo(e, t, i, s, n, r, this.currentPath.points),
        this
    }
    arcTo(e, t, i, s, n) {
        this._initCurve(e, t);
        const r = this.currentPath.points
          , o = Ag.curveTo(e, t, i, s, n, r);
        if (o) {
            const {cx: a, cy: l, radius: c, startAngle: h, endAngle: u, anticlockwise: d} = o;
            this.arc(a, l, c, h, u, d)
        }
        return this
    }
    arc(e, t, i, s, n, r=!1) {
        if (s === n)
            return this;
        if (!r && n <= s ? n += Tc : r && s <= n && (s += Tc),
        n - s === 0)
            return this;
        const a = e + Math.cos(s) * i
          , l = t + Math.sin(s) * i
          , c = this._geometry.closePointEps;
        let h = this.currentPath ? this.currentPath.points : null;
        if (h) {
            const u = Math.abs(h[h.length - 2] - a)
              , d = Math.abs(h[h.length - 1] - l);
            u < c && d < c || h.push(a, l)
        } else
            this.moveTo(a, l),
            h = this.currentPath.points;
        return Ag.arc(a, l, e, t, i, s, n, r, h),
        this
    }
    beginFill(e=0, t=1) {
        return this.beginTextureFill({
            texture: ht.WHITE,
            color: e,
            alpha: t
        })
    }
    beginTextureFill(e) {
        e = Object.assign({
            texture: ht.WHITE,
            color: 16777215,
            alpha: 1,
            matrix: null
        }, e),
        this.currentPath && this.startPoly();
        const t = e.alpha > 0;
        return t ? (e.matrix && (e.matrix = e.matrix.clone(),
        e.matrix.invert()),
        Object.assign(this._fillStyle, {
            visible: t
        }, e)) : this._fillStyle.reset(),
        this
    }
    endFill() {
        return this.finishPoly(),
        this._fillStyle.reset(),
        this
    }
    drawRect(e, t, i, s) {
        return this.drawShape(new qt(e,t,i,s))
    }
    drawRoundedRect(e, t, i, s, n) {
        return this.drawShape(new zf(e,t,i,s,n))
    }
    drawCircle(e, t, i) {
        return this.drawShape(new Hf(e,t,i))
    }
    drawEllipse(e, t, i, s) {
        return this.drawShape(new Vf(e,t,i,s))
    }
    drawPolygon(...e) {
        let t, i = !0;
        const s = e[0];
        s.points ? (i = s.closeStroke,
        t = s.points) : Array.isArray(e[0]) ? t = e[0] : t = e;
        const n = new vo(t);
        return n.closeStroke = i,
        this.drawShape(n),
        this
    }
    drawShape(e) {
        return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix),
        this
    }
    clear() {
        return this._geometry.clear(),
        this._lineStyle.reset(),
        this._fillStyle.reset(),
        this._boundsID++,
        this._matrix = null,
        this._holeMode = !1,
        this.currentPath = null,
        this
    }
    isFastRect() {
        const e = this._geometry.graphicsData;
        return e.length === 1 && e[0].shape.type === we.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width)
    }
    _render(e) {
        this.finishPoly();
        const t = this._geometry;
        t.updateBatches(),
        t.batchable ? (this.batchDirty !== t.batchDirty && this._populateBatches(),
        this._renderBatched(e)) : (e.batch.flush(),
        this._renderDirect(e))
    }
    _populateBatches() {
        const e = this._geometry
          , t = this.blendMode
          , i = e.batches.length;
        this.batchTint = -1,
        this._transformID = -1,
        this.batchDirty = e.batchDirty,
        this.batches.length = i,
        this.vertexData = new Float32Array(e.points);
        for (let s = 0; s < i; s++) {
            const n = e.batches[s]
              , r = n.style.color
              , o = new Float32Array(this.vertexData.buffer,n.attribStart * 4 * 2,n.attribSize * 2)
              , a = new Float32Array(e.uvsFloat32.buffer,n.attribStart * 4 * 2,n.attribSize * 2)
              , l = new Uint16Array(e.indicesUint16.buffer,n.start * 2,n.size)
              , c = {
                vertexData: o,
                blendMode: t,
                indices: l,
                uvs: a,
                _batchRGB: tn(r),
                _tintRGB: r,
                _texture: n.style.texture,
                alpha: n.style.alpha,
                worldAlpha: 1
            };
            this.batches[s] = c
        }
    }
    _renderBatched(e) {
        if (!!this.batches.length) {
            e.batch.setObjectRenderer(e.plugins[this.pluginName]),
            this.calculateVertices(),
            this.calculateTints();
            for (let t = 0, i = this.batches.length; t < i; t++) {
                const s = this.batches[t];
                s.worldAlpha = this.worldAlpha * s.alpha,
                e.plugins[this.pluginName].render(s)
            }
        }
    }
    _renderDirect(e) {
        const t = this._resolveDirectShader(e)
          , i = this._geometry
          , s = this.tint
          , n = this.worldAlpha
          , r = t.uniforms
          , o = i.drawCalls;
        r.translationMatrix = this.transform.worldTransform,
        r.tint[0] = (s >> 16 & 255) / 255 * n,
        r.tint[1] = (s >> 8 & 255) / 255 * n,
        r.tint[2] = (s & 255) / 255 * n,
        r.tint[3] = n,
        e.shader.bind(t),
        e.geometry.bind(i, t),
        e.state.set(this.state);
        for (let a = 0, l = o.length; a < l; a++)
            this._renderDrawCallDirect(e, i.drawCalls[a])
    }
    _renderDrawCallDirect(e, t) {
        const {texArray: i, type: s, size: n, start: r} = t
          , o = i.count;
        for (let a = 0; a < o; a++)
            e.texture.bind(i.elements[a], a);
        e.geometry.draw(s, n, r)
    }
    _resolveDirectShader(e) {
        let t = this.shader;
        const i = this.pluginName;
        if (!t) {
            if (!hu[i]) {
                const {maxTextures: s} = e.plugins[i]
                  , n = new Int32Array(s);
                for (let a = 0; a < s; a++)
                    n[a] = a;
                const r = {
                    tint: new Float32Array([1, 1, 1, 1]),
                    translationMatrix: new pe,
                    default: hs.from({
                        uSamplers: n
                    }, !0)
                }
                  , o = e.plugins[i]._shader.program;
                hu[i] = new Ls(o,r)
            }
            t = hu[i]
        }
        return t
    }
    _calculateBounds() {
        this.finishPoly();
        const e = this._geometry;
        if (!e.graphicsData.length)
            return;
        const {minX: t, minY: i, maxX: s, maxY: n} = e.bounds;
        this._bounds.addFrame(this.transform, t, i, s, n)
    }
    containsPoint(e) {
        return this.worldTransform.applyInverse(e, tc._TEMP_POINT),
        this._geometry.containsPoint(tc._TEMP_POINT)
    }
    calculateTints() {
        if (this.batchTint !== this.tint) {
            this.batchTint = this.tint;
            const e = tn(this.tint, lM);
            for (let t = 0; t < this.batches.length; t++) {
                const i = this.batches[t]
                  , s = i._batchRGB
                  , n = e[0] * s[0] * 255
                  , r = e[1] * s[1] * 255
                  , o = e[2] * s[2] * 255
                  , a = (n << 16) + (r << 8) + (o | 0);
                i._tintRGB = (a >> 16) + (a & 65280) + ((a & 255) << 16)
            }
        }
    }
    calculateVertices() {
        const e = this.transform._worldID;
        if (this._transformID === e)
            return;
        this._transformID = e;
        const t = this.transform.worldTransform
          , i = t.a
          , s = t.b
          , n = t.c
          , r = t.d
          , o = t.tx
          , a = t.ty
          , l = this._geometry.points
          , c = this.vertexData;
        let h = 0;
        for (let u = 0; u < l.length; u += 2) {
            const d = l[u]
              , f = l[u + 1];
            c[h++] = i * d + n * f + o,
            c[h++] = r * f + s * d + a
        }
    }
    closePath() {
        const e = this.currentPath;
        return e && (e.closeStroke = !0,
        this.finishPoly()),
        this
    }
    setMatrix(e) {
        return this._matrix = e,
        this
    }
    beginHole() {
        return this.finishPoly(),
        this._holeMode = !0,
        this
    }
    endHole() {
        return this.finishPoly(),
        this._holeMode = !1,
        this
    }
    destroy(e) {
        this._geometry.refCount--,
        this._geometry.refCount === 0 && this._geometry.dispose(),
        this._matrix = null,
        this.currentPath = null,
        this._lineStyle.destroy(),
        this._lineStyle = null,
        this._fillStyle.destroy(),
        this._fillStyle = null,
        this._geometry = null,
        this.shader = null,
        this.vertexData = null,
        this.batches.length = 0,
        this.batches = null,
        super.destroy(e)
    }
}
;
let ke = tc;
ke.curves = Oo;
ke._TEMP_POINT = new Zt;
class cM {
    constructor(t, i) {
        this.uvBuffer = t,
        this.uvMatrix = i,
        this.data = null,
        this._bufferUpdateId = -1,
        this._textureUpdateId = -1,
        this._updateID = 0
    }
    update(t) {
        if (!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID)
            return;
        this._bufferUpdateId = this.uvBuffer._updateID,
        this._textureUpdateId = this.uvMatrix._updateID;
        const i = this.uvBuffer.data;
        (!this.data || this.data.length !== i.length) && (this.data = new Float32Array(i.length)),
        this.uvMatrix.multiplyUvs(i, this.data),
        this._updateID++
    }
}
const uu = new Zt
  , kg = new vo
  , R1 = class extends ae {
    constructor(e, t, i, s=rs.TRIANGLES) {
        super(),
        this.geometry = e,
        this.shader = t,
        this.state = i || rn.for2d(),
        this.drawMode = s,
        this.start = 0,
        this.size = 0,
        this.uvs = null,
        this.indices = null,
        this.vertexData = new Float32Array(1),
        this.vertexDirty = -1,
        this._transformID = -1,
        this._roundPixels = ft.ROUND_PIXELS,
        this.batchUvs = null
    }
    get geometry() {
        return this._geometry
    }
    set geometry(e) {
        this._geometry !== e && (this._geometry && (this._geometry.refCount--,
        this._geometry.refCount === 0 && this._geometry.dispose()),
        this._geometry = e,
        this._geometry && this._geometry.refCount++,
        this.vertexDirty = -1)
    }
    get uvBuffer() {
        return this.geometry.buffers[1]
    }
    get verticesBuffer() {
        return this.geometry.buffers[0]
    }
    set material(e) {
        this.shader = e
    }
    get material() {
        return this.shader
    }
    set blendMode(e) {
        this.state.blendMode = e
    }
    get blendMode() {
        return this.state.blendMode
    }
    set roundPixels(e) {
        this._roundPixels !== e && (this._transformID = -1),
        this._roundPixels = e
    }
    get roundPixels() {
        return this._roundPixels
    }
    get tint() {
        return "tint"in this.shader ? this.shader.tint : null
    }
    set tint(e) {
        this.shader.tint = e
    }
    get texture() {
        return "texture"in this.shader ? this.shader.texture : null
    }
    set texture(e) {
        this.shader.texture = e
    }
    _render(e) {
        const t = this.geometry.buffers[0].data;
        this.shader.batchable && this.drawMode === rs.TRIANGLES && t.length < R1.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e)
    }
    _renderDefault(e) {
        const t = this.shader;
        t.alpha = this.worldAlpha,
        t.update && t.update(),
        e.batch.flush(),
        t.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0),
        e.shader.bind(t),
        e.state.set(this.state),
        e.geometry.bind(this.geometry, t),
        e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
    }
    _renderToBatch(e) {
        const t = this.geometry
          , i = this.shader;
        i.uvMatrix && (i.uvMatrix.update(),
        this.calculateUvs()),
        this.calculateVertices(),
        this.indices = t.indexBuffer.data,
        this._tintRGB = i._tintRGB,
        this._texture = i.texture;
        const s = this.material.pluginName;
        e.batch.setObjectRenderer(e.plugins[s]),
        e.plugins[s].render(this)
    }
    calculateVertices() {
        const t = this.geometry.buffers[0]
          , i = t.data
          , s = t._updateID;
        if (s === this.vertexDirty && this._transformID === this.transform._worldID)
            return;
        this._transformID = this.transform._worldID,
        this.vertexData.length !== i.length && (this.vertexData = new Float32Array(i.length));
        const n = this.transform.worldTransform
          , r = n.a
          , o = n.b
          , a = n.c
          , l = n.d
          , c = n.tx
          , h = n.ty
          , u = this.vertexData;
        for (let d = 0; d < u.length / 2; d++) {
            const f = i[d * 2]
              , p = i[d * 2 + 1];
            u[d * 2] = r * f + a * p + c,
            u[d * 2 + 1] = o * f + l * p + h
        }
        if (this._roundPixels) {
            const d = ft.RESOLUTION;
            for (let f = 0; f < u.length; ++f)
                u[f] = Math.round(u[f] * d) / d
        }
        this.vertexDirty = s
    }
    calculateUvs() {
        const e = this.geometry.buffers[1]
          , t = this.shader;
        t.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new cM(e,t.uvMatrix)),
        this.batchUvs.update(),
        this.uvs = this.batchUvs.data)
    }
    _calculateBounds() {
        this.calculateVertices(),
        this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
    }
    containsPoint(e) {
        if (!this.getBounds().contains(e.x, e.y))
            return !1;
        this.worldTransform.applyInverse(e, uu);
        const t = this.geometry.getBuffer("aVertexPosition").data
          , i = kg.points
          , s = this.geometry.getIndex().data
          , n = s.length
          , r = this.drawMode === 4 ? 3 : 1;
        for (let o = 0; o + 2 < n; o += r) {
            const a = s[o] * 2
              , l = s[o + 1] * 2
              , c = s[o + 2] * 2;
            if (i[0] = t[a],
            i[1] = t[a + 1],
            i[2] = t[l],
            i[3] = t[l + 1],
            i[4] = t[c],
            i[5] = t[c + 1],
            kg.contains(uu.x, uu.y))
                return !0
        }
        return !1
    }
    destroy(e) {
        super.destroy(e),
        this._cachedTexture && (this._cachedTexture.destroy(),
        this._cachedTexture = null),
        this.geometry = null,
        this.shader = null,
        this.state = null,
        this.uvs = null,
        this.indices = null,
        this.vertexData = null
    }
}
;
let ii = R1;
ii.BATCHABLE_SIZE = 100;
class gh extends On {
    constructor(t, i, s) {
        super();
        const n = new Fe(t)
          , r = new Fe(i,!0)
          , o = new Fe(s,!0,!0);
        this.addAttribute("aVertexPosition", n, 2, !1, Rt.FLOAT).addAttribute("aTextureCoord", r, 2, !1, Rt.FLOAT).addIndex(o),
        this._updateId = -1
    }
    get vertexDirtyId() {
        return this.buffers[0]._updateID
    }
}
var hM = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`
  , uM = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
class Do extends Ls {
    constructor(t, i) {
        const s = {
            uSampler: t,
            alpha: 1,
            uTextureMatrix: pe.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1])
        };
        i = Object.assign({
            tint: 16777215,
            alpha: 1,
            pluginName: "batch"
        }, i),
        i.uniforms && Object.assign(s, i.uniforms),
        super(i.program || os.from(uM, hM), s),
        this._colorDirty = !1,
        this.uvMatrix = new jf(t),
        this.batchable = i.program === void 0,
        this.pluginName = i.pluginName,
        this.tint = i.tint,
        this.alpha = i.alpha
    }
    get texture() {
        return this.uniforms.uSampler
    }
    set texture(t) {
        this.uniforms.uSampler !== t && (!this.uniforms.uSampler.baseTexture.alphaMode != !t.baseTexture.alphaMode && (this._colorDirty = !0),
        this.uniforms.uSampler = t,
        this.uvMatrix.texture = t)
    }
    set alpha(t) {
        t !== this._alpha && (this._alpha = t,
        this._colorDirty = !0)
    }
    get alpha() {
        return this._alpha
    }
    set tint(t) {
        t !== this._tint && (this._tint = t,
        this._tintRGB = (t >> 16) + (t & 65280) + ((t & 255) << 16),
        this._colorDirty = !0)
    }
    get tint() {
        return this._tint
    }
    update() {
        if (this._colorDirty) {
            this._colorDirty = !1;
            const t = this.texture.baseTexture;
            Gf(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode)
        }
        this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
    }
}
class dM extends gh {
    constructor(t=100, i=100, s=10, n=10) {
        super(),
        this.segWidth = s,
        this.segHeight = n,
        this.width = t,
        this.height = i,
        this.build()
    }
    build() {
        const t = this.segWidth * this.segHeight
          , i = []
          , s = []
          , n = []
          , r = this.segWidth - 1
          , o = this.segHeight - 1
          , a = this.width / r
          , l = this.height / o;
        for (let h = 0; h < t; h++) {
            const u = h % this.segWidth
              , d = h / this.segWidth | 0;
            i.push(u * a, d * l),
            s.push(u / r, d / o)
        }
        const c = r * o;
        for (let h = 0; h < c; h++) {
            const u = h % r
              , d = h / r | 0
              , f = d * this.segWidth + u
              , p = d * this.segWidth + u + 1
              , m = (d + 1) * this.segWidth + u
              , g = (d + 1) * this.segWidth + u + 1;
            n.push(f, p, m, p, g, m)
        }
        this.buffers[0].data = new Float32Array(i),
        this.buffers[1].data = new Float32Array(s),
        this.indexBuffer.data = new Uint16Array(n),
        this.buffers[0].update(),
        this.buffers[1].update(),
        this.indexBuffer.update()
    }
}
class fM extends gh {
    constructor(t=200, i, s=0) {
        super(new Float32Array(i.length * 4), new Float32Array(i.length * 4), new Uint16Array((i.length - 1) * 6)),
        this.points = i,
        this._width = t,
        this.textureScale = s,
        this.build()
    }
    get width() {
        return this._width
    }
    build() {
        const t = this.points;
        if (!t)
            return;
        const i = this.getBuffer("aVertexPosition")
          , s = this.getBuffer("aTextureCoord")
          , n = this.getIndex();
        if (t.length < 1)
            return;
        i.data.length / 4 !== t.length && (i.data = new Float32Array(t.length * 4),
        s.data = new Float32Array(t.length * 4),
        n.data = new Uint16Array((t.length - 1) * 6));
        const r = s.data
          , o = n.data;
        r[0] = 0,
        r[1] = 0,
        r[2] = 0,
        r[3] = 1;
        let a = 0
          , l = t[0];
        const c = this._width * this.textureScale
          , h = t.length;
        for (let d = 0; d < h; d++) {
            const f = d * 4;
            if (this.textureScale > 0) {
                const p = l.x - t[d].x
                  , m = l.y - t[d].y
                  , g = Math.sqrt(p * p + m * m);
                l = t[d],
                a += g / c
            } else
                a = d / (h - 1);
            r[f] = a,
            r[f + 1] = 0,
            r[f + 2] = a,
            r[f + 3] = 1
        }
        let u = 0;
        for (let d = 0; d < h - 1; d++) {
            const f = d * 2;
            o[u++] = f,
            o[u++] = f + 1,
            o[u++] = f + 2,
            o[u++] = f + 2,
            o[u++] = f + 1,
            o[u++] = f + 3
        }
        s.update(),
        n.update(),
        this.updateVertices()
    }
    updateVertices() {
        const t = this.points;
        if (t.length < 1)
            return;
        let i = t[0], s, n = 0, r = 0;
        const o = this.buffers[0].data
          , a = t.length;
        for (let l = 0; l < a; l++) {
            const c = t[l]
              , h = l * 4;
            l < t.length - 1 ? s = t[l + 1] : s = c,
            r = -(s.x - i.x),
            n = s.y - i.y;
            const u = Math.sqrt(n * n + r * r)
              , d = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
            n /= u,
            r /= u,
            n *= d,
            r *= d,
            o[h] = c.x + n,
            o[h + 1] = c.y + r,
            o[h + 2] = c.x - n,
            o[h + 3] = c.y - r,
            i = c
        }
        this.buffers[0].update()
    }
    update() {
        this.textureScale > 0 ? this.build() : this.updateVertices()
    }
}
class pM extends ii {
    constructor(t, i, s) {
        const n = new dM(t.width,t.height,i,s)
          , r = new Do(ht.WHITE);
        super(n, r),
        this.texture = t,
        this.autoResize = !0
    }
    textureUpdated() {
        this._textureID = this.shader.texture._updateID;
        const t = this.geometry
          , {width: i, height: s} = this.shader.texture;
        this.autoResize && (t.width !== i || t.height !== s) && (t.width = this.shader.texture.width,
        t.height = this.shader.texture.height,
        t.build())
    }
    set texture(t) {
        this.shader.texture !== t && (this.shader.texture = t,
        this._textureID = -1,
        t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this))
    }
    get texture() {
        return this.shader.texture
    }
    _render(t) {
        this._textureID !== this.shader.texture._updateID && this.textureUpdated(),
        super._render(t)
    }
    destroy(t) {
        this.shader.texture.off("update", this.textureUpdated, this),
        super.destroy(t)
    }
}
const Nl = 10;
class vh extends pM {
    constructor(t, i=Nl, s=Nl, n=Nl, r=Nl) {
        super(ht.WHITE, 4, 4),
        this._origWidth = t.orig.width,
        this._origHeight = t.orig.height,
        this._width = this._origWidth,
        this._height = this._origHeight,
        this._leftWidth = i,
        this._rightWidth = n,
        this._topHeight = s,
        this._bottomHeight = r,
        this.texture = t
    }
    textureUpdated() {
        this._textureID = this.shader.texture._updateID,
        this._refresh()
    }
    get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data
    }
    set vertices(t) {
        this.geometry.getBuffer("aVertexPosition").data = t
    }
    updateHorizontalVertices() {
        const t = this.vertices
          , i = this._getMinScale();
        t[9] = t[11] = t[13] = t[15] = this._topHeight * i,
        t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * i,
        t[25] = t[27] = t[29] = t[31] = this._height
    }
    updateVerticalVertices() {
        const t = this.vertices
          , i = this._getMinScale();
        t[2] = t[10] = t[18] = t[26] = this._leftWidth * i,
        t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * i,
        t[6] = t[14] = t[22] = t[30] = this._width
    }
    _getMinScale() {
        const t = this._leftWidth + this._rightWidth
          , i = this._width > t ? 1 : this._width / t
          , s = this._topHeight + this._bottomHeight
          , n = this._height > s ? 1 : this._height / s;
        return Math.min(i, n)
    }
    get width() {
        return this._width
    }
    set width(t) {
        this._width = t,
        this._refresh()
    }
    get height() {
        return this._height
    }
    set height(t) {
        this._height = t,
        this._refresh()
    }
    get leftWidth() {
        return this._leftWidth
    }
    set leftWidth(t) {
        this._leftWidth = t,
        this._refresh()
    }
    get rightWidth() {
        return this._rightWidth
    }
    set rightWidth(t) {
        this._rightWidth = t,
        this._refresh()
    }
    get topHeight() {
        return this._topHeight
    }
    set topHeight(t) {
        this._topHeight = t,
        this._refresh()
    }
    get bottomHeight() {
        return this._bottomHeight
    }
    set bottomHeight(t) {
        this._bottomHeight = t,
        this._refresh()
    }
    _refresh() {
        const t = this.texture
          , i = this.geometry.buffers[1].data;
        this._origWidth = t.orig.width,
        this._origHeight = t.orig.height;
        const s = 1 / this._origWidth
          , n = 1 / this._origHeight;
        i[0] = i[8] = i[16] = i[24] = 0,
        i[1] = i[3] = i[5] = i[7] = 0,
        i[6] = i[14] = i[22] = i[30] = 1,
        i[25] = i[27] = i[29] = i[31] = 1,
        i[2] = i[10] = i[18] = i[26] = s * this._leftWidth,
        i[4] = i[12] = i[20] = i[28] = 1 - s * this._rightWidth,
        i[9] = i[11] = i[13] = i[15] = n * this._topHeight,
        i[17] = i[19] = i[21] = i[23] = 1 - n * this._bottomHeight,
        this.updateHorizontalVertices(),
        this.updateVerticalVertices(),
        this.geometry.buffers[0].update(),
        this.geometry.buffers[1].update()
    }
}
class mM extends ii {
    constructor(t=ht.EMPTY, i, s, n, r) {
        const o = new gh(i,s,n);
        o.getBuffer("aVertexPosition").static = !1;
        const a = new Do(t);
        super(o, a, null, r),
        this.autoUpdate = !0
    }
    get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data
    }
    set vertices(t) {
        this.geometry.getBuffer("aVertexPosition").data = t
    }
    _render(t) {
        this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(),
        super._render(t)
    }
}
class gM extends ii {
    constructor(t, i, s=0) {
        const n = new fM(t.height,i,s)
          , r = new Do(t);
        s > 0 && (t.baseTexture.wrapMode = Zs.REPEAT),
        super(n, r),
        this.autoUpdate = !0
    }
    _render(t) {
        const i = this.geometry;
        (this.autoUpdate || i._width !== this.shader.texture.height) && (i._width = this.shader.texture.height,
        i.update()),
        super._render(t)
    }
}
class Ed extends ae {
    constructor(t=1500, i, s=16384, n=!1) {
        super();
        const r = 16384;
        s > r && (s = r),
        this._properties = [!1, !0, !1, !1, !1],
        this._maxSize = t,
        this._batchSize = s,
        this._buffers = null,
        this._bufferUpdateIDs = [],
        this._updateID = 0,
        this.interactiveChildren = !1,
        this.blendMode = j.NORMAL,
        this.autoResize = n,
        this.roundPixels = !0,
        this.baseTexture = null,
        this.setProperties(i),
        this._tint = 0,
        this.tintRgb = new Float32Array(4),
        this.tint = 16777215
    }
    setProperties(t) {
        t && (this._properties[0] = "vertices"in t || "scale"in t ? !!t.vertices || !!t.scale : this._properties[0],
        this._properties[1] = "position"in t ? !!t.position : this._properties[1],
        this._properties[2] = "rotation"in t ? !!t.rotation : this._properties[2],
        this._properties[3] = "uvs"in t ? !!t.uvs : this._properties[3],
        this._properties[4] = "tint"in t || "alpha"in t ? !!t.tint || !!t.alpha : this._properties[4])
    }
    updateTransform() {
        this.displayObjectUpdateTransform()
    }
    get tint() {
        return this._tint
    }
    set tint(t) {
        this._tint = t,
        tn(t, this.tintRgb)
    }
    render(t) {
        !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture,
        this.baseTexture.valid || this.baseTexture.once("update", ()=>this.onChildrenChange(0))),
        t.batch.setObjectRenderer(t.plugins.particle),
        t.plugins.particle.render(this))
    }
    onChildrenChange(t) {
        const i = Math.floor(t / this._batchSize);
        for (; this._bufferUpdateIDs.length < i; )
            this._bufferUpdateIDs.push(0);
        this._bufferUpdateIDs[i] = ++this._updateID
    }
    dispose() {
        if (this._buffers) {
            for (let t = 0; t < this._buffers.length; ++t)
                this._buffers[t].destroy();
            this._buffers = null
        }
    }
    destroy(t) {
        super.destroy(t),
        this.dispose(),
        this._properties = null,
        this._buffers = null,
        this._bufferUpdateIDs = null
    }
}
class Pg {
    constructor(t, i, s) {
        this.geometry = new On,
        this.indexBuffer = null,
        this.size = s,
        this.dynamicProperties = [],
        this.staticProperties = [];
        for (let n = 0; n < t.length; ++n) {
            let r = t[n];
            r = {
                attributeName: r.attributeName,
                size: r.size,
                uploadFunction: r.uploadFunction,
                type: r.type || Rt.FLOAT,
                offset: r.offset
            },
            i[n] ? this.dynamicProperties.push(r) : this.staticProperties.push(r)
        }
        this.staticStride = 0,
        this.staticBuffer = null,
        this.staticData = null,
        this.staticDataUint32 = null,
        this.dynamicStride = 0,
        this.dynamicBuffer = null,
        this.dynamicData = null,
        this.dynamicDataUint32 = null,
        this._updateID = 0,
        this.initBuffers()
    }
    initBuffers() {
        const t = this.geometry;
        let i = 0;
        this.indexBuffer = new Fe(S_(this.size),!0,!0),
        t.addIndex(this.indexBuffer),
        this.dynamicStride = 0;
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const a = this.dynamicProperties[o];
            a.offset = i,
            i += a.size,
            this.dynamicStride += a.size
        }
        const s = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(s),
        this.dynamicDataUint32 = new Uint32Array(s),
        this.dynamicBuffer = new Fe(this.dynamicData,!1,!1);
        let n = 0;
        this.staticStride = 0;
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const a = this.staticProperties[o];
            a.offset = n,
            n += a.size,
            this.staticStride += a.size
        }
        const r = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(r),
        this.staticDataUint32 = new Uint32Array(r),
        this.staticBuffer = new Fe(this.staticData,!0,!1);
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const a = this.dynamicProperties[o];
            t.addAttribute(a.attributeName, this.dynamicBuffer, 0, a.type === Rt.UNSIGNED_BYTE, a.type, this.dynamicStride * 4, a.offset * 4)
        }
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const a = this.staticProperties[o];
            t.addAttribute(a.attributeName, this.staticBuffer, 0, a.type === Rt.UNSIGNED_BYTE, a.type, this.staticStride * 4, a.offset * 4)
        }
    }
    uploadDynamic(t, i, s) {
        for (let n = 0; n < this.dynamicProperties.length; n++) {
            const r = this.dynamicProperties[n];
            r.uploadFunction(t, i, s, r.type === Rt.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, r.offset)
        }
        this.dynamicBuffer._updateID++
    }
    uploadStatic(t, i, s) {
        for (let n = 0; n < this.staticProperties.length; n++) {
            const r = this.staticProperties[n];
            r.uploadFunction(t, i, s, r.type === Rt.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, r.offset)
        }
        this.staticBuffer._updateID++
    }
    destroy() {
        this.indexBuffer = null,
        this.dynamicProperties = null,
        this.dynamicBuffer = null,
        this.dynamicData = null,
        this.dynamicDataUint32 = null,
        this.staticProperties = null,
        this.staticBuffer = null,
        this.staticData = null,
        this.staticDataUint32 = null,
        this.geometry.destroy()
    }
}
var vM = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`
  , _M = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;
class k1 extends dh {
    constructor(t) {
        super(t),
        this.shader = null,
        this.properties = null,
        this.tempMatrix = new pe,
        this.properties = [{
            attributeName: "aVertexPosition",
            size: 2,
            uploadFunction: this.uploadVertices,
            offset: 0
        }, {
            attributeName: "aPositionCoord",
            size: 2,
            uploadFunction: this.uploadPosition,
            offset: 0
        }, {
            attributeName: "aRotation",
            size: 1,
            uploadFunction: this.uploadRotation,
            offset: 0
        }, {
            attributeName: "aTextureCoord",
            size: 2,
            uploadFunction: this.uploadUvs,
            offset: 0
        }, {
            attributeName: "aColor",
            size: 1,
            type: Rt.UNSIGNED_BYTE,
            uploadFunction: this.uploadTint,
            offset: 0
        }],
        this.shader = Ls.from(_M, vM, {}),
        this.state = rn.for2d()
    }
    render(t) {
        const i = t.children
          , s = t._maxSize
          , n = t._batchSize
          , r = this.renderer;
        let o = i.length;
        if (o === 0)
            return;
        o > s && !t.autoResize && (o = s);
        let a = t._buffers;
        a || (a = t._buffers = this.generateBuffers(t));
        const l = i[0]._texture.baseTexture
          , c = l.alphaMode > 0;
        this.state.blendMode = Uf(t.blendMode, c),
        r.state.set(this.state);
        const h = r.gl
          , u = t.worldTransform.copyTo(this.tempMatrix);
        u.prepend(r.globalUniforms.uniforms.projectionMatrix),
        this.shader.uniforms.translationMatrix = u.toArray(!0),
        this.shader.uniforms.uColor = T_(t.tintRgb, t.worldAlpha, this.shader.uniforms.uColor, c),
        this.shader.uniforms.uSampler = l,
        this.renderer.shader.bind(this.shader);
        let d = !1;
        for (let f = 0, p = 0; f < o; f += n,
        p += 1) {
            let m = o - f;
            m > n && (m = n),
            p >= a.length && a.push(this._generateOneMoreBuffer(t));
            const g = a[p];
            g.uploadDynamic(i, f, m);
            const y = t._bufferUpdateIDs[p] || 0;
            d = d || g._updateID < y,
            d && (g._updateID = t._updateID,
            g.uploadStatic(i, f, m)),
            r.geometry.bind(g.geometry),
            h.drawElements(h.TRIANGLES, m * 6, h.UNSIGNED_SHORT, 0)
        }
    }
    generateBuffers(t) {
        const i = []
          , s = t._maxSize
          , n = t._batchSize
          , r = t._properties;
        for (let o = 0; o < s; o += n)
            i.push(new Pg(this.properties,r,n));
        return i
    }
    _generateOneMoreBuffer(t) {
        const i = t._batchSize
          , s = t._properties;
        return new Pg(this.properties,s,i)
    }
    uploadVertices(t, i, s, n, r, o) {
        let a = 0
          , l = 0
          , c = 0
          , h = 0;
        for (let u = 0; u < s; ++u) {
            const d = t[i + u]
              , f = d._texture
              , p = d.scale.x
              , m = d.scale.y
              , g = f.trim
              , y = f.orig;
            g ? (l = g.x - d.anchor.x * y.width,
            a = l + g.width,
            h = g.y - d.anchor.y * y.height,
            c = h + g.height) : (a = y.width * (1 - d.anchor.x),
            l = y.width * -d.anchor.x,
            c = y.height * (1 - d.anchor.y),
            h = y.height * -d.anchor.y),
            n[o] = l * p,
            n[o + 1] = h * m,
            n[o + r] = a * p,
            n[o + r + 1] = h * m,
            n[o + r * 2] = a * p,
            n[o + r * 2 + 1] = c * m,
            n[o + r * 3] = l * p,
            n[o + r * 3 + 1] = c * m,
            o += r * 4
        }
    }
    uploadPosition(t, i, s, n, r, o) {
        for (let a = 0; a < s; a++) {
            const l = t[i + a].position;
            n[o] = l.x,
            n[o + 1] = l.y,
            n[o + r] = l.x,
            n[o + r + 1] = l.y,
            n[o + r * 2] = l.x,
            n[o + r * 2 + 1] = l.y,
            n[o + r * 3] = l.x,
            n[o + r * 3 + 1] = l.y,
            o += r * 4
        }
    }
    uploadRotation(t, i, s, n, r, o) {
        for (let a = 0; a < s; a++) {
            const l = t[i + a].rotation;
            n[o] = l,
            n[o + r] = l,
            n[o + r * 2] = l,
            n[o + r * 3] = l,
            o += r * 4
        }
    }
    uploadUvs(t, i, s, n, r, o) {
        for (let a = 0; a < s; ++a) {
            const l = t[i + a]._texture._uvs;
            l ? (n[o] = l.x0,
            n[o + 1] = l.y0,
            n[o + r] = l.x1,
            n[o + r + 1] = l.y1,
            n[o + r * 2] = l.x2,
            n[o + r * 2 + 1] = l.y2,
            n[o + r * 3] = l.x3,
            n[o + r * 3 + 1] = l.y3,
            o += r * 4) : (n[o] = 0,
            n[o + 1] = 0,
            n[o + r] = 0,
            n[o + r + 1] = 0,
            n[o + r * 2] = 0,
            n[o + r * 2 + 1] = 0,
            n[o + r * 3] = 0,
            n[o + r * 3 + 1] = 0,
            o += r * 4)
        }
    }
    uploadTint(t, i, s, n, r, o) {
        for (let a = 0; a < s; ++a) {
            const l = t[i + a]
              , c = l._texture.baseTexture.alphaMode > 0
              , h = l.alpha
              , u = h < 1 && c ? ch(l._tintRGB, h) : l._tintRGB + (h * 255 << 24);
            n[o] = u,
            n[o + r] = u,
            n[o + r * 2] = u,
            n[o + r * 3] = u,
            o += r * 4
        }
    }
    destroy() {
        super.destroy(),
        this.shader && (this.shader.destroy(),
        this.shader = null),
        this.tempMatrix = null
    }
}
k1.extension = {
    name: "particle",
    type: lt.RendererPlugin
};
vt.add(k1);
var _h = (e=>(e[e.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL",
e[e.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL",
e))(_h || {});
const Fl = {
    willReadFrequently: !0
}
  , Et = class {
    static get experimentalLetterSpacingSupported() {
        let e = Et._experimentalLetterSpacingSupported;
        if (e !== void 0) {
            const t = ft.ADAPTER.getCanvasRenderingContext2D().prototype;
            e = Et._experimentalLetterSpacingSupported = "letterSpacing"in t || "textLetterSpacing"in t
        }
        return e
    }
    constructor(e, t, i, s, n, r, o, a, l) {
        this.text = e,
        this.style = t,
        this.width = i,
        this.height = s,
        this.lines = n,
        this.lineWidths = r,
        this.lineHeight = o,
        this.maxLineWidth = a,
        this.fontProperties = l
    }
    static measureText(e, t, i, s=Et._canvas) {
        i = i ?? t.wordWrap;
        const n = t.toFontString()
          , r = Et.measureFont(n);
        r.fontSize === 0 && (r.fontSize = t.fontSize,
        r.ascent = t.fontSize);
        const o = s.getContext("2d", Fl);
        o.font = n;
        const l = (i ? Et.wordWrap(e, t, s) : e).split(/(?:\r\n|\r|\n)/)
          , c = new Array(l.length);
        let h = 0;
        for (let p = 0; p < l.length; p++) {
            const m = Et._measureText(l[p], t.letterSpacing, o);
            c[p] = m,
            h = Math.max(h, m)
        }
        let u = h + t.strokeThickness;
        t.dropShadow && (u += t.dropShadowDistance);
        const d = t.lineHeight || r.fontSize + t.strokeThickness;
        let f = Math.max(d, r.fontSize + t.strokeThickness * 2) + (l.length - 1) * (d + t.leading);
        return t.dropShadow && (f += t.dropShadowDistance),
        new Et(e,t,u,f,l,c,d + t.leading,h,r)
    }
    static _measureText(e, t, i) {
        let s = !1;
        Et.experimentalLetterSpacingSupported && (Et.experimentalLetterSpacing ? (i.letterSpacing = `${t}px`,
        i.textLetterSpacing = `${t}px`,
        s = !0) : (i.letterSpacing = "0px",
        i.textLetterSpacing = "0px"));
        let n = i.measureText(e).width;
        return n > 0 && (s ? n -= t : n += (Et.graphemeSegmenter(e).length - 1) * t),
        n
    }
    static wordWrap(e, t, i=Et._canvas) {
        const s = i.getContext("2d", Fl);
        let n = 0
          , r = ""
          , o = "";
        const a = Object.create(null)
          , {letterSpacing: l, whiteSpace: c} = t
          , h = Et.collapseSpaces(c)
          , u = Et.collapseNewlines(c);
        let d = !h;
        const f = t.wordWrapWidth + l
          , p = Et.tokenize(e);
        for (let m = 0; m < p.length; m++) {
            let g = p[m];
            if (Et.isNewline(g)) {
                if (!u) {
                    o += Et.addLine(r),
                    d = !h,
                    r = "",
                    n = 0;
                    continue
                }
                g = " "
            }
            if (h) {
                const x = Et.isBreakingSpace(g)
                  , v = Et.isBreakingSpace(r[r.length - 1]);
                if (x && v)
                    continue
            }
            const y = Et.getFromCache(g, l, a, s);
            if (y > f)
                if (r !== "" && (o += Et.addLine(r),
                r = "",
                n = 0),
                Et.canBreakWords(g, t.breakWords)) {
                    const x = Et.wordWrapSplit(g);
                    for (let v = 0; v < x.length; v++) {
                        let _ = x[v]
                          , C = _
                          , k = 1;
                        for (; x[v + k]; ) {
                            const T = x[v + k];
                            if (!Et.canBreakChars(C, T, g, v, t.breakWords))
                                _ += T;
                            else
                                break;
                            C = T,
                            k++
                        }
                        v += k - 1;
                        const S = Et.getFromCache(_, l, a, s);
                        S + n > f && (o += Et.addLine(r),
                        d = !1,
                        r = "",
                        n = 0),
                        r += _,
                        n += S
                    }
                } else {
                    r.length > 0 && (o += Et.addLine(r),
                    r = "",
                    n = 0);
                    const x = m === p.length - 1;
                    o += Et.addLine(g, !x),
                    d = !1,
                    r = "",
                    n = 0
                }
            else
                y + n > f && (d = !1,
                o += Et.addLine(r),
                r = "",
                n = 0),
                (r.length > 0 || !Et.isBreakingSpace(g) || d) && (r += g,
                n += y)
        }
        return o += Et.addLine(r, !1),
        o
    }
    static addLine(e, t=!0) {
        return e = Et.trimRight(e),
        e = t ? `${e}
` : e,
        e
    }
    static getFromCache(e, t, i, s) {
        let n = i[e];
        return typeof n != "number" && (n = Et._measureText(e, t, s) + t,
        i[e] = n),
        n
    }
    static collapseSpaces(e) {
        return e === "normal" || e === "pre-line"
    }
    static collapseNewlines(e) {
        return e === "normal"
    }
    static trimRight(e) {
        if (typeof e != "string")
            return "";
        for (let t = e.length - 1; t >= 0; t--) {
            const i = e[t];
            if (!Et.isBreakingSpace(i))
                break;
            e = e.slice(0, -1)
        }
        return e
    }
    static isNewline(e) {
        return typeof e != "string" ? !1 : Et._newlines.includes(e.charCodeAt(0))
    }
    static isBreakingSpace(e, t) {
        return typeof e != "string" ? !1 : Et._breakingSpaces.includes(e.charCodeAt(0))
    }
    static tokenize(e) {
        const t = [];
        let i = "";
        if (typeof e != "string")
            return t;
        for (let s = 0; s < e.length; s++) {
            const n = e[s]
              , r = e[s + 1];
            if (Et.isBreakingSpace(n, r) || Et.isNewline(n)) {
                i !== "" && (t.push(i),
                i = ""),
                t.push(n);
                continue
            }
            i += n
        }
        return i !== "" && t.push(i),
        t
    }
    static canBreakWords(e, t) {
        return t
    }
    static canBreakChars(e, t, i, s, n) {
        return !0
    }
    static wordWrapSplit(e) {
        return Et.graphemeSegmenter(e)
    }
    static measureFont(e) {
        if (Et._fonts[e])
            return Et._fonts[e];
        const t = {
            ascent: 0,
            descent: 0,
            fontSize: 0
        }
          , i = Et._canvas
          , s = Et._context;
        s.font = e;
        const n = Et.METRICS_STRING + Et.BASELINE_SYMBOL
          , r = Math.ceil(s.measureText(n).width);
        let o = Math.ceil(s.measureText(Et.BASELINE_SYMBOL).width);
        const a = Math.ceil(Et.HEIGHT_MULTIPLIER * o);
        if (o = o * Et.BASELINE_MULTIPLIER | 0,
        r === 0 || a === 0)
            return Et._fonts[e] = t,
            t;
        i.width = r,
        i.height = a,
        s.fillStyle = "#f00",
        s.fillRect(0, 0, r, a),
        s.font = e,
        s.textBaseline = "alphabetic",
        s.fillStyle = "#000",
        s.fillText(n, 0, o);
        const l = s.getImageData(0, 0, r, a).data
          , c = l.length
          , h = r * 4;
        let u = 0
          , d = 0
          , f = !1;
        for (u = 0; u < o; ++u) {
            for (let p = 0; p < h; p += 4)
                if (l[d + p] !== 255) {
                    f = !0;
                    break
                }
            if (!f)
                d += h;
            else
                break
        }
        for (t.ascent = o - u,
        d = c - h,
        f = !1,
        u = a; u > o; --u) {
            for (let p = 0; p < h; p += 4)
                if (l[d + p] !== 255) {
                    f = !0;
                    break
                }
            if (!f)
                d -= h;
            else
                break
        }
        return t.descent = u - o,
        t.fontSize = t.ascent + t.descent,
        Et._fonts[e] = t,
        t
    }
    static clearMetrics(e="") {
        e ? delete Et._fonts[e] : Et._fonts = {}
    }
    static get _canvas() {
        if (!Et.__canvas) {
            let e;
            try {
                const t = new OffscreenCanvas(0,0);
                if (t.getContext("2d", Fl)?.measureText)
                    return Et.__canvas = t,
                    t;
                e = ft.ADAPTER.createCanvas()
            } catch {
                e = ft.ADAPTER.createCanvas()
            }
            e.width = e.height = 10,
            Et.__canvas = e
        }
        return Et.__canvas
    }
    static get _context() {
        return Et.__context || (Et.__context = Et._canvas.getContext("2d", Fl)),
        Et.__context
    }
}
;
let He = Et;
He.METRICS_STRING = "|\xC9q\xC5";
He.BASELINE_SYMBOL = "M";
He.BASELINE_MULTIPLIER = 1.4;
He.HEIGHT_MULTIPLIER = 2;
He.graphemeSegmenter = (()=>{
    if (typeof Intl?.Segmenter == "function") {
        const e = new Intl.Segmenter;
        return t=>[...e.segment(t)].map(i=>i.segment)
    }
    return e=>[...e]
}
)();
He.experimentalLetterSpacing = !1;
He._fonts = {};
He._newlines = [10, 13];
He._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
const yM = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"]
  , va = class {
    constructor(e) {
        this.styleID = 0,
        this.reset(),
        fu(this, e, e)
    }
    clone() {
        const e = {};
        return fu(e, this, va.defaultStyle),
        new va(e)
    }
    reset() {
        fu(this, va.defaultStyle, va.defaultStyle)
    }
    get align() {
        return this._align
    }
    set align(e) {
        this._align !== e && (this._align = e,
        this.styleID++)
    }
    get breakWords() {
        return this._breakWords
    }
    set breakWords(e) {
        this._breakWords !== e && (this._breakWords = e,
        this.styleID++)
    }
    get dropShadow() {
        return this._dropShadow
    }
    set dropShadow(e) {
        this._dropShadow !== e && (this._dropShadow = e,
        this.styleID++)
    }
    get dropShadowAlpha() {
        return this._dropShadowAlpha
    }
    set dropShadowAlpha(e) {
        this._dropShadowAlpha !== e && (this._dropShadowAlpha = e,
        this.styleID++)
    }
    get dropShadowAngle() {
        return this._dropShadowAngle
    }
    set dropShadowAngle(e) {
        this._dropShadowAngle !== e && (this._dropShadowAngle = e,
        this.styleID++)
    }
    get dropShadowBlur() {
        return this._dropShadowBlur
    }
    set dropShadowBlur(e) {
        this._dropShadowBlur !== e && (this._dropShadowBlur = e,
        this.styleID++)
    }
    get dropShadowColor() {
        return this._dropShadowColor
    }
    set dropShadowColor(e) {
        const t = du(e);
        this._dropShadowColor !== t && (this._dropShadowColor = t,
        this.styleID++)
    }
    get dropShadowDistance() {
        return this._dropShadowDistance
    }
    set dropShadowDistance(e) {
        this._dropShadowDistance !== e && (this._dropShadowDistance = e,
        this.styleID++)
    }
    get fill() {
        return this._fill
    }
    set fill(e) {
        const t = du(e);
        this._fill !== t && (this._fill = t,
        this.styleID++)
    }
    get fillGradientType() {
        return this._fillGradientType
    }
    set fillGradientType(e) {
        this._fillGradientType !== e && (this._fillGradientType = e,
        this.styleID++)
    }
    get fillGradientStops() {
        return this._fillGradientStops
    }
    set fillGradientStops(e) {
        bM(this._fillGradientStops, e) || (this._fillGradientStops = e,
        this.styleID++)
    }
    get fontFamily() {
        return this._fontFamily
    }
    set fontFamily(e) {
        this.fontFamily !== e && (this._fontFamily = e,
        this.styleID++)
    }
    get fontSize() {
        return this._fontSize
    }
    set fontSize(e) {
        this._fontSize !== e && (this._fontSize = e,
        this.styleID++)
    }
    get fontStyle() {
        return this._fontStyle
    }
    set fontStyle(e) {
        this._fontStyle !== e && (this._fontStyle = e,
        this.styleID++)
    }
    get fontVariant() {
        return this._fontVariant
    }
    set fontVariant(e) {
        this._fontVariant !== e && (this._fontVariant = e,
        this.styleID++)
    }
    get fontWeight() {
        return this._fontWeight
    }
    set fontWeight(e) {
        this._fontWeight !== e && (this._fontWeight = e,
        this.styleID++)
    }
    get letterSpacing() {
        return this._letterSpacing
    }
    set letterSpacing(e) {
        this._letterSpacing !== e && (this._letterSpacing = e,
        this.styleID++)
    }
    get lineHeight() {
        return this._lineHeight
    }
    set lineHeight(e) {
        this._lineHeight !== e && (this._lineHeight = e,
        this.styleID++)
    }
    get leading() {
        return this._leading
    }
    set leading(e) {
        this._leading !== e && (this._leading = e,
        this.styleID++)
    }
    get lineJoin() {
        return this._lineJoin
    }
    set lineJoin(e) {
        this._lineJoin !== e && (this._lineJoin = e,
        this.styleID++)
    }
    get miterLimit() {
        return this._miterLimit
    }
    set miterLimit(e) {
        this._miterLimit !== e && (this._miterLimit = e,
        this.styleID++)
    }
    get padding() {
        return this._padding
    }
    set padding(e) {
        this._padding !== e && (this._padding = e,
        this.styleID++)
    }
    get stroke() {
        return this._stroke
    }
    set stroke(e) {
        const t = du(e);
        this._stroke !== t && (this._stroke = t,
        this.styleID++)
    }
    get strokeThickness() {
        return this._strokeThickness
    }
    set strokeThickness(e) {
        this._strokeThickness !== e && (this._strokeThickness = e,
        this.styleID++)
    }
    get textBaseline() {
        return this._textBaseline
    }
    set textBaseline(e) {
        this._textBaseline !== e && (this._textBaseline = e,
        this.styleID++)
    }
    get trim() {
        return this._trim
    }
    set trim(e) {
        this._trim !== e && (this._trim = e,
        this.styleID++)
    }
    get whiteSpace() {
        return this._whiteSpace
    }
    set whiteSpace(e) {
        this._whiteSpace !== e && (this._whiteSpace = e,
        this.styleID++)
    }
    get wordWrap() {
        return this._wordWrap
    }
    set wordWrap(e) {
        this._wordWrap !== e && (this._wordWrap = e,
        this.styleID++)
    }
    get wordWrapWidth() {
        return this._wordWrapWidth
    }
    set wordWrapWidth(e) {
        this._wordWrapWidth !== e && (this._wordWrapWidth = e,
        this.styleID++)
    }
    toFontString() {
        const e = typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;
        let t = this.fontFamily;
        Array.isArray(this.fontFamily) || (t = this.fontFamily.split(","));
        for (let i = t.length - 1; i >= 0; i--) {
            let s = t[i].trim();
            !/([\"\'])[^\'\"]+\1/.test(s) && !yM.includes(s) && (s = `"${s}"`),
            t[i] = s
        }
        return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${e} ${t.join(",")}`
    }
}
;
let ki = va;
ki.defaultStyle = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: _h.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: !1,
    whiteSpace: "pre",
    wordWrap: !1,
    wordWrapWidth: 100
};
function Lg(e) {
    return typeof e == "number" ? ah(e) : (typeof e == "string" && e.startsWith("0x") && (e = e.replace("0x", "#")),
    e)
}
function du(e) {
    if (Array.isArray(e)) {
        for (let t = 0; t < e.length; ++t)
            e[t] = Lg(e[t]);
        return e
    } else
        return Lg(e)
}
function bM(e, t) {
    if (!Array.isArray(e) || !Array.isArray(t) || e.length !== t.length)
        return !1;
    for (let i = 0; i < e.length; ++i)
        if (e[i] !== t[i])
            return !1;
    return !0
}
function fu(e, t, i) {
    for (const s in i)
        Array.isArray(t[s]) ? e[s] = t[s].slice() : e[s] = t[s]
}
const xM = {
    texture: !0,
    children: !1,
    baseTexture: !0
}
  , Sd = class extends hi {
    constructor(e, t, i) {
        let s = !1;
        i || (i = ft.ADAPTER.createCanvas(),
        s = !0),
        i.width = 3,
        i.height = 3;
        const n = ht.from(i);
        n.orig = new qt,
        n.trim = new qt,
        super(n),
        this._ownCanvas = s,
        this.canvas = i,
        this.context = i.getContext("2d", {
            willReadFrequently: !0
        }),
        this._resolution = Sd.defaultResolution ?? ft.RESOLUTION,
        this._autoResolution = Sd.defaultAutoResolution,
        this._text = null,
        this._style = null,
        this._styleListener = null,
        this._font = "",
        this.text = e,
        this.style = t,
        this.localStyleID = -1
    }
    static get experimentalLetterSpacing() {
        return He.experimentalLetterSpacing
    }
    static set experimentalLetterSpacing(e) {
        Qt("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"),
        He.experimentalLetterSpacing = e
    }
    updateText(e) {
        const t = this._style;
        if (this.localStyleID !== t.styleID && (this.dirty = !0,
        this.localStyleID = t.styleID),
        !this.dirty && e)
            return;
        this._font = this._style.toFontString();
        const i = this.context
          , s = He.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas)
          , n = s.width
          , r = s.height
          , o = s.lines
          , a = s.lineHeight
          , l = s.lineWidths
          , c = s.maxLineWidth
          , h = s.fontProperties;
        this.canvas.width = Math.ceil(Math.ceil(Math.max(1, n) + t.padding * 2) * this._resolution),
        this.canvas.height = Math.ceil(Math.ceil(Math.max(1, r) + t.padding * 2) * this._resolution),
        i.scale(this._resolution, this._resolution),
        i.clearRect(0, 0, this.canvas.width, this.canvas.height),
        i.font = this._font,
        i.lineWidth = t.strokeThickness,
        i.textBaseline = t.textBaseline,
        i.lineJoin = t.lineJoin,
        i.miterLimit = t.miterLimit;
        let u, d;
        const f = t.dropShadow ? 2 : 1;
        for (let p = 0; p < f; ++p) {
            const m = t.dropShadow && p === 0
              , g = m ? Math.ceil(Math.max(1, r) + t.padding * 2) : 0
              , y = g * this._resolution;
            if (m) {
                i.fillStyle = "black",
                i.strokeStyle = "black";
                const v = t.dropShadowColor
                  , _ = tn(typeof v == "number" ? v : lh(v))
                  , C = t.dropShadowBlur * this._resolution
                  , k = t.dropShadowDistance * this._resolution;
                i.shadowColor = `rgba(${_[0] * 255},${_[1] * 255},${_[2] * 255},${t.dropShadowAlpha})`,
                i.shadowBlur = C,
                i.shadowOffsetX = Math.cos(t.dropShadowAngle) * k,
                i.shadowOffsetY = Math.sin(t.dropShadowAngle) * k + y
            } else
                i.fillStyle = this._generateFillStyle(t, o, s),
                i.strokeStyle = t.stroke,
                i.shadowColor = "black",
                i.shadowBlur = 0,
                i.shadowOffsetX = 0,
                i.shadowOffsetY = 0;
            let x = (a - h.fontSize) / 2;
            a - h.fontSize < 0 && (x = 0);
            for (let v = 0; v < o.length; v++)
                u = t.strokeThickness / 2,
                d = t.strokeThickness / 2 + v * a + h.ascent + x,
                t.align === "right" ? u += c - l[v] : t.align === "center" && (u += (c - l[v]) / 2),
                t.stroke && t.strokeThickness && this.drawLetterSpacing(o[v], u + t.padding, d + t.padding - g, !0),
                t.fill && this.drawLetterSpacing(o[v], u + t.padding, d + t.padding - g)
        }
        this.updateTexture()
    }
    drawLetterSpacing(e, t, i, s=!1) {
        const r = this._style.letterSpacing;
        let o = !1;
        if (He.experimentalLetterSpacingSupported && (He.experimentalLetterSpacing ? (this.context.letterSpacing = `${r}px`,
        this.context.textLetterSpacing = `${r}px`,
        o = !0) : (this.context.letterSpacing = "0px",
        this.context.textLetterSpacing = "0px")),
        r === 0 || o) {
            s ? this.context.strokeText(e, t, i) : this.context.fillText(e, t, i);
            return
        }
        let a = t;
        const l = He.graphemeSegmenter(e);
        let c = this.context.measureText(e).width
          , h = 0;
        for (let u = 0; u < l.length; ++u) {
            const d = l[u];
            s ? this.context.strokeText(d, a, i) : this.context.fillText(d, a, i);
            let f = "";
            for (let p = u + 1; p < l.length; ++p)
                f += l[p];
            h = this.context.measureText(f).width,
            a += c - h + r,
            c = h
        }
    }
    updateTexture() {
        const e = this.canvas;
        if (this._style.trim) {
            const r = I_(e);
            r.data && (e.width = r.width,
            e.height = r.height,
            this.context.putImageData(r.data, 0, 0))
        }
        const t = this._texture
          , i = this._style
          , s = i.trim ? 0 : i.padding
          , n = t.baseTexture;
        t.trim.width = t._frame.width = e.width / this._resolution,
        t.trim.height = t._frame.height = e.height / this._resolution,
        t.trim.x = -s,
        t.trim.y = -s,
        t.orig.width = t._frame.width - s * 2,
        t.orig.height = t._frame.height - s * 2,
        this._onTextureUpdate(),
        n.setRealSize(e.width, e.height, this._resolution),
        t.updateUvs(),
        this.dirty = !1
    }
    _render(e) {
        this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution,
        this.dirty = !0),
        this.updateText(!0),
        super._render(e)
    }
    updateTransform() {
        this.updateText(!0),
        super.updateTransform()
    }
    getBounds(e, t) {
        return this.updateText(!0),
        this._textureID === -1 && (e = !1),
        super.getBounds(e, t)
    }
    getLocalBounds(e) {
        return this.updateText(!0),
        super.getLocalBounds.call(this, e)
    }
    _calculateBounds() {
        this.calculateVertices(),
        this._bounds.addQuad(this.vertexData)
    }
    _generateFillStyle(e, t, i) {
        const s = e.fill;
        if (Array.isArray(s)) {
            if (s.length === 1)
                return s[0]
        } else
            return s;
        let n;
        const r = e.dropShadow ? e.dropShadowDistance : 0
          , o = e.padding || 0
          , a = this.canvas.width / this._resolution - r - o * 2
          , l = this.canvas.height / this._resolution - r - o * 2
          , c = s.slice()
          , h = e.fillGradientStops.slice();
        if (!h.length) {
            const u = c.length + 1;
            for (let d = 1; d < u; ++d)
                h.push(d / u)
        }
        if (c.unshift(s[0]),
        h.unshift(0),
        c.push(s[s.length - 1]),
        h.push(1),
        e.fillGradientType === _h.LINEAR_VERTICAL) {
            n = this.context.createLinearGradient(a / 2, o, a / 2, l + o);
            const u = i.fontProperties.fontSize + e.strokeThickness;
            for (let d = 0; d < t.length; d++) {
                const f = i.lineHeight * (d - 1) + u
                  , p = i.lineHeight * d;
                let m = p;
                d > 0 && f > p && (m = (p + f) / 2);
                const g = p + u
                  , y = i.lineHeight * (d + 1);
                let x = g;
                d + 1 < t.length && y < g && (x = (g + y) / 2);
                const v = (x - m) / l;
                for (let _ = 0; _ < c.length; _++) {
                    let C = 0;
                    typeof h[_] == "number" ? C = h[_] : C = _ / c.length;
                    let k = Math.min(1, Math.max(0, m / l + C * v));
                    k = Number(k.toFixed(5)),
                    n.addColorStop(k, c[_])
                }
            }
        } else {
            n = this.context.createLinearGradient(o, l / 2, a + o, l / 2);
            const u = c.length + 1;
            let d = 1;
            for (let f = 0; f < c.length; f++) {
                let p;
                typeof h[f] == "number" ? p = h[f] : p = d / u,
                n.addColorStop(p, c[f]),
                d++
            }
        }
        return n
    }
    destroy(e) {
        typeof e == "boolean" && (e = {
            children: e
        }),
        e = Object.assign({}, xM, e),
        super.destroy(e),
        this._ownCanvas && (this.canvas.height = this.canvas.width = 0),
        this.context = null,
        this.canvas = null,
        this._style = null
    }
    get width() {
        return this.updateText(!0),
        Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(e) {
        this.updateText(!0);
        const t = rr(this.scale.x) || 1;
        this.scale.x = t * e / this._texture.orig.width,
        this._width = e
    }
    get height() {
        return this.updateText(!0),
        Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(e) {
        this.updateText(!0);
        const t = rr(this.scale.y) || 1;
        this.scale.y = t * e / this._texture.orig.height,
        this._height = e
    }
    get style() {
        return this._style
    }
    set style(e) {
        e = e || {},
        e instanceof ki ? this._style = e : this._style = new ki(e),
        this.localStyleID = -1,
        this.dirty = !0
    }
    get text() {
        return this._text
    }
    set text(e) {
        e = String(e ?? ""),
        this._text !== e && (this._text = e,
        this.dirty = !0)
    }
    get resolution() {
        return this._resolution
    }
    set resolution(e) {
        this._autoResolution = !1,
        this._resolution !== e && (this._resolution = e,
        this.dirty = !0)
    }
}
;
let ys = Sd;
ys.defaultAutoResolution = !0;
class wM {
    constructor(t) {
        this.maxItemsPerFrame = t,
        this.itemsLeft = 0
    }
    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame
    }
    allowedToUpload() {
        return this.itemsLeft-- > 0
    }
}
function TM(e, t) {
    let i = !1;
    if (e?._textures?.length) {
        for (let s = 0; s < e._textures.length; s++)
            if (e._textures[s]instanceof ht) {
                const n = e._textures[s].baseTexture;
                t.includes(n) || (t.push(n),
                i = !0)
            }
    }
    return i
}
function EM(e, t) {
    if (e.baseTexture instanceof Ot) {
        const i = e.baseTexture;
        return t.includes(i) || t.push(i),
        !0
    }
    return !1
}
function SM(e, t) {
    if (e._texture && e._texture instanceof ht) {
        const i = e._texture.baseTexture;
        return t.includes(i) || t.push(i),
        !0
    }
    return !1
}
function CM(e, t) {
    return t instanceof ys ? (t.updateText(!0),
    !0) : !1
}
function AM(e, t) {
    if (t instanceof ki) {
        const i = t.toFontString();
        return He.measureFont(i),
        !0
    }
    return !1
}
function IM(e, t) {
    if (e instanceof ys) {
        t.includes(e.style) || t.push(e.style),
        t.includes(e) || t.push(e);
        const i = e._texture.baseTexture;
        return t.includes(i) || t.push(i),
        !0
    }
    return !1
}
function MM(e, t) {
    return e instanceof ki ? (t.includes(e) || t.push(e),
    !0) : !1
}
const P1 = class {
    constructor(e) {
        this.limiter = new wM(P1.uploadsPerFrame),
        this.renderer = e,
        this.uploadHookHelper = null,
        this.queue = [],
        this.addHooks = [],
        this.uploadHooks = [],
        this.completes = [],
        this.ticking = !1,
        this.delayedTick = ()=>{
            !this.queue || this.prepareItems()
        }
        ,
        this.registerFindHook(IM),
        this.registerFindHook(MM),
        this.registerFindHook(TM),
        this.registerFindHook(EM),
        this.registerFindHook(SM),
        this.registerUploadHook(CM),
        this.registerUploadHook(AM)
    }
    upload(e) {
        return new Promise(t=>{
            e && this.add(e),
            this.queue.length ? (this.completes.push(t),
            this.ticking || (this.ticking = !0,
            gi.system.addOnce(this.tick, this, Lo.UTILITY))) : t()
        }
        )
    }
    tick() {
        setTimeout(this.delayedTick, 0)
    }
    prepareItems() {
        for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload(); ) {
            const e = this.queue[0];
            let t = !1;
            if (e && !e._destroyed) {
                for (let i = 0, s = this.uploadHooks.length; i < s; i++)
                    if (this.uploadHooks[i](this.uploadHookHelper, e)) {
                        this.queue.shift(),
                        t = !0;
                        break
                    }
            }
            t || this.queue.shift()
        }
        if (this.queue.length)
            gi.system.addOnce(this.tick, this, Lo.UTILITY);
        else {
            this.ticking = !1;
            const e = this.completes.slice(0);
            this.completes.length = 0;
            for (let t = 0, i = e.length; t < i; t++)
                e[t]()
        }
    }
    registerFindHook(e) {
        return e && this.addHooks.push(e),
        this
    }
    registerUploadHook(e) {
        return e && this.uploadHooks.push(e),
        this
    }
    add(e) {
        for (let t = 0, i = this.addHooks.length; t < i && !this.addHooks[t](e, this.queue); t++)
            ;
        if (e instanceof ae)
            for (let t = e.children.length - 1; t >= 0; t--)
                this.add(e.children[t]);
        return this
    }
    destroy() {
        this.ticking && gi.system.remove(this.tick, this),
        this.ticking = !1,
        this.addHooks = null,
        this.uploadHooks = null,
        this.renderer = null,
        this.completes = null,
        this.queue = null,
        this.limiter = null,
        this.uploadHookHelper = null
    }
}
;
let Va = P1;
Va.uploadsPerFrame = 4;
Object.defineProperties(ft, {
    UPLOADS_PER_FRAME: {
        get() {
            return Va.uploadsPerFrame
        },
        set(e) {
            Qt("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"),
            Va.uploadsPerFrame = e
        }
    }
});
function L1(e, t) {
    return t instanceof Ot ? (t._glTextures[e.CONTEXT_UID] || e.texture.bind(t),
    !0) : !1
}
function RM(e, t) {
    if (!(t instanceof ke))
        return !1;
    const {geometry: i} = t;
    t.finishPoly(),
    i.updateBatches();
    const {batches: s} = i;
    for (let n = 0; n < s.length; n++) {
        const {texture: r} = s[n].style;
        r && L1(e, r.baseTexture)
    }
    return i.batchable || e.geometry.bind(i, t._resolveDirectShader(e)),
    !0
}
function kM(e, t) {
    return e instanceof ke ? (t.push(e),
    !0) : !1
}
class O1 extends Va {
    constructor(t) {
        super(t),
        this.uploadHookHelper = this.renderer,
        this.registerFindHook(kM),
        this.registerUploadHook(L1),
        this.registerUploadHook(RM)
    }
}
O1.extension = {
    name: "prepare",
    type: lt.RendererSystem
};
vt.add(O1);
const sa = new Zt;
class Zf extends hi {
    constructor(t, i=100, s=100) {
        super(t),
        this.tileTransform = new uh,
        this._width = i,
        this._height = s,
        this.uvMatrix = this.texture.uvMatrix || new jf(t),
        this.pluginName = "tilingSprite",
        this.uvRespectAnchor = !1
    }
    get clampMargin() {
        return this.uvMatrix.clampMargin
    }
    set clampMargin(t) {
        this.uvMatrix.clampMargin = t,
        this.uvMatrix.update(!0)
    }
    get tileScale() {
        return this.tileTransform.scale
    }
    set tileScale(t) {
        this.tileTransform.scale.copyFrom(t)
    }
    get tilePosition() {
        return this.tileTransform.position
    }
    set tilePosition(t) {
        this.tileTransform.position.copyFrom(t)
    }
    _onTextureUpdate() {
        this.uvMatrix && (this.uvMatrix.texture = this._texture),
        this._cachedTint = 16777215
    }
    _render(t) {
        const i = this._texture;
        !i || !i.valid || (this.tileTransform.updateLocalTransform(),
        this.uvMatrix.update(),
        t.batch.setObjectRenderer(t.plugins[this.pluginName]),
        t.plugins[this.pluginName].render(this))
    }
    _calculateBounds() {
        const t = this._width * -this._anchor._x
          , i = this._height * -this._anchor._y
          , s = this._width * (1 - this._anchor._x)
          , n = this._height * (1 - this._anchor._y);
        this._bounds.addFrame(this.transform, t, i, s, n)
    }
    getLocalBounds(t) {
        return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x,
        this._bounds.minY = this._height * -this._anchor._y,
        this._bounds.maxX = this._width * (1 - this._anchor._x),
        this._bounds.maxY = this._height * (1 - this._anchor._y),
        t || (this._localBoundsRect || (this._localBoundsRect = new qt),
        t = this._localBoundsRect),
        this._bounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
    }
    containsPoint(t) {
        this.worldTransform.applyInverse(t, sa);
        const i = this._width
          , s = this._height
          , n = -i * this.anchor._x;
        if (sa.x >= n && sa.x < n + i) {
            const r = -s * this.anchor._y;
            if (sa.y >= r && sa.y < r + s)
                return !0
        }
        return !1
    }
    destroy(t) {
        super.destroy(t),
        this.tileTransform = null,
        this.uvMatrix = null
    }
    static from(t, i) {
        const s = t instanceof ht ? t : ht.from(t, i);
        return new Zf(s,i.width,i.height)
    }
    get width() {
        return this._width
    }
    set width(t) {
        this._width = t
    }
    get height() {
        return this._height
    }
    set height(t) {
        this._height = t
    }
}
var PM = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`
  , LM = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`
  , OM = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`
  , Og = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`
  , DM = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
const Bl = new pe;
class D1 extends dh {
    constructor(t) {
        super(t),
        t.runners.contextChange.add(this),
        this.quad = new $_,
        this.state = rn.for2d()
    }
    contextChange() {
        const t = this.renderer
          , i = {
            globals: t.globalUniforms
        };
        this.simpleShader = Ls.from(Og, DM, i),
        this.shader = t.context.webGLVersion > 1 ? Ls.from(LM, PM, i) : Ls.from(Og, OM, i)
    }
    render(t) {
        const i = this.renderer
          , s = this.quad;
        let n = s.vertices;
        n[0] = n[6] = t._width * -t.anchor.x,
        n[1] = n[3] = t._height * -t.anchor.y,
        n[2] = n[4] = t._width * (1 - t.anchor.x),
        n[5] = n[7] = t._height * (1 - t.anchor.y);
        const r = t.uvRespectAnchor ? t.anchor.x : 0
          , o = t.uvRespectAnchor ? t.anchor.y : 0;
        n = s.uvs,
        n[0] = n[6] = -r,
        n[1] = n[3] = -o,
        n[2] = n[4] = 1 - r,
        n[5] = n[7] = 1 - o,
        s.invalidate();
        const a = t._texture
          , l = a.baseTexture
          , c = l.alphaMode > 0
          , h = t.tileTransform.localTransform
          , u = t.uvMatrix;
        let d = l.isPowerOfTwo && a.frame.width === l.width && a.frame.height === l.height;
        d && (l._glTextures[i.CONTEXT_UID] ? d = l.wrapMode !== Zs.CLAMP : l.wrapMode === Zs.CLAMP && (l.wrapMode = Zs.REPEAT));
        const f = d ? this.simpleShader : this.shader
          , p = a.width
          , m = a.height
          , g = t._width
          , y = t._height;
        Bl.set(h.a * p / g, h.b * p / y, h.c * m / g, h.d * m / y, h.tx / g, h.ty / y),
        Bl.invert(),
        d ? Bl.prepend(u.mapCoord) : (f.uniforms.uMapCoord = u.mapCoord.toArray(!0),
        f.uniforms.uClampFrame = u.uClampFrame,
        f.uniforms.uClampOffset = u.uClampOffset),
        f.uniforms.uTransform = Bl.toArray(!0),
        f.uniforms.uColor = Gf(t.tint, t.worldAlpha, f.uniforms.uColor, c),
        f.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0),
        f.uniforms.uSampler = a,
        i.shader.bind(f),
        i.geometry.bind(s),
        this.state.blendMode = Uf(t.blendMode, c),
        i.state.set(this.state),
        i.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
    }
}
D1.extension = {
    name: "tilingSprite",
    type: lt.RendererPlugin
};
vt.add(D1);
const _a = class {
    constructor(e, t, i=null) {
        this.linkedSheets = [],
        this._texture = e instanceof ht ? e : null,
        this.baseTexture = e instanceof Ot ? e : this._texture.baseTexture,
        this.textures = {},
        this.animations = {},
        this.data = t;
        const s = this.baseTexture.resource;
        this.resolution = this._updateResolution(i || (s ? s.url : null)),
        this._frames = this.data.frames,
        this._frameKeys = Object.keys(this._frames),
        this._batchIndex = 0,
        this._callback = null
    }
    _updateResolution(e=null) {
        const {scale: t} = this.data.meta;
        let i = en(e, null);
        return i === null && (i = parseFloat(t ?? "1")),
        i !== 1 && this.baseTexture.setResolution(i),
        i
    }
    parse() {
        return new Promise(e=>{
            this._callback = e,
            this._batchIndex = 0,
            this._frameKeys.length <= _a.BATCH_SIZE ? (this._processFrames(0),
            this._processAnimations(),
            this._parseComplete()) : this._nextBatch()
        }
        )
    }
    _processFrames(e) {
        let t = e;
        const i = _a.BATCH_SIZE;
        for (; t - e < i && t < this._frameKeys.length; ) {
            const s = this._frameKeys[t]
              , n = this._frames[s]
              , r = n.frame;
            if (r) {
                let o = null
                  , a = null;
                const l = n.trimmed !== !1 && n.sourceSize ? n.sourceSize : n.frame
                  , c = new qt(0,0,Math.floor(l.w) / this.resolution,Math.floor(l.h) / this.resolution);
                n.rotated ? o = new qt(Math.floor(r.x) / this.resolution,Math.floor(r.y) / this.resolution,Math.floor(r.h) / this.resolution,Math.floor(r.w) / this.resolution) : o = new qt(Math.floor(r.x) / this.resolution,Math.floor(r.y) / this.resolution,Math.floor(r.w) / this.resolution,Math.floor(r.h) / this.resolution),
                n.trimmed !== !1 && n.spriteSourceSize && (a = new qt(Math.floor(n.spriteSourceSize.x) / this.resolution,Math.floor(n.spriteSourceSize.y) / this.resolution,Math.floor(r.w) / this.resolution,Math.floor(r.h) / this.resolution)),
                this.textures[s] = new ht(this.baseTexture,o,c,a,n.rotated ? 2 : 0,n.anchor),
                ht.addToCache(this.textures[s], s)
            }
            t++
        }
    }
    _processAnimations() {
        const e = this.data.animations || {};
        for (const t in e) {
            this.animations[t] = [];
            for (let i = 0; i < e[t].length; i++) {
                const s = e[t][i];
                this.animations[t].push(this.textures[s])
            }
        }
    }
    _parseComplete() {
        const e = this._callback;
        this._callback = null,
        this._batchIndex = 0,
        e.call(this, this.textures)
    }
    _nextBatch() {
        this._processFrames(this._batchIndex * _a.BATCH_SIZE),
        this._batchIndex++,
        setTimeout(()=>{
            this._batchIndex * _a.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(),
            this._parseComplete())
        }
        , 0)
    }
    destroy(e=!1) {
        for (const t in this.textures)
            this.textures[t].destroy();
        this._frames = null,
        this._frameKeys = null,
        this.data = null,
        this.textures = null,
        e && (this._texture?.destroy(),
        this.baseTexture.destroy()),
        this._texture = null,
        this.baseTexture = null,
        this.linkedSheets = []
    }
}
;
let Cd = _a;
Cd.BATCH_SIZE = 1e3;
const NM = ["jpg", "png", "jpeg", "avif", "webp"];
function N1(e, t, i) {
    const s = {};
    if (e.forEach(n=>{
        s[n] = t
    }
    ),
    Object.keys(t.textures).forEach(n=>{
        s[n] = t.textures[n]
    }
    ),
    !i) {
        const n = Xe.dirname(e[0]);
        t.linkedSheets.forEach((r,o)=>{
            const a = N1([`${n}/${t.data.meta.related_multi_packs[o]}`], r, !0);
            Object.assign(s, a)
        }
        )
    }
    return s
}
const FM = {
    extension: lt.Asset,
    cache: {
        test: e=>e instanceof Cd,
        getCacheableAssets: (e,t)=>N1(e, t, !1)
    },
    resolver: {
        test: e=>{
            const i = e.split("?")[0].split(".")
              , s = i.pop()
              , n = i.pop();
            return s === "json" && NM.includes(n)
        }
        ,
        parse: e=>{
            const t = e.split(".");
            return {
                resolution: parseFloat(ft.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
                format: t[t.length - 2],
                src: e
            }
        }
    },
    loader: {
        extension: {
            type: lt.LoadParser,
            priority: Us.Normal
        },
        async testParse(e, t) {
            return Xe.extname(t.src).toLowerCase() === ".json" && !!e.frames
        },
        async parse(e, t, i) {
            let s = Xe.dirname(t.src);
            s && s.lastIndexOf("/") !== s.length - 1 && (s += "/");
            let n = s + e.meta.image;
            n = xd(n, t.src);
            const o = (await i.load([n]))[n]
              , a = new Cd(o.baseTexture,e,t.src);
            await a.parse();
            const l = e?.meta?.related_multi_packs;
            if (Array.isArray(l)) {
                const c = [];
                for (const u of l) {
                    if (typeof u != "string")
                        continue;
                    let d = s + u;
                    t.data?.ignoreMultiPack || (d = xd(d, t.src),
                    c.push(i.load({
                        src: d,
                        data: {
                            ignoreMultiPack: !0
                        }
                    })))
                }
                const h = await Promise.all(c);
                a.linkedSheets = h,
                h.forEach(u=>{
                    u.linkedSheets = [a].concat(a.linkedSheets.filter(d=>d !== u))
                }
                )
            }
            return a
        },
        unload(e) {
            e.destroy(!0)
        }
    }
};
vt.add(FM);
class Rc {
    constructor() {
        this.info = [],
        this.common = [],
        this.page = [],
        this.char = [],
        this.kerning = [],
        this.distanceField = []
    }
}
class ec {
    static test(t) {
        return typeof t == "string" && t.startsWith("info face=")
    }
    static parse(t) {
        const i = t.match(/^[a-z]+\s+.+$/gm)
          , s = {
            info: [],
            common: [],
            page: [],
            char: [],
            chars: [],
            kerning: [],
            kernings: [],
            distanceField: []
        };
        for (const r in i) {
            const o = i[r].match(/^[a-z]+/gm)[0]
              , a = i[r].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm)
              , l = {};
            for (const c in a) {
                const h = a[c].split("=")
                  , u = h[0]
                  , d = h[1].replace(/"/gm, "")
                  , f = parseFloat(d)
                  , p = isNaN(f) ? d : f;
                l[u] = p
            }
            s[o].push(l)
        }
        const n = new Rc;
        return s.info.forEach(r=>n.info.push({
            face: r.face,
            size: parseInt(r.size, 10)
        })),
        s.common.forEach(r=>n.common.push({
            lineHeight: parseInt(r.lineHeight, 10)
        })),
        s.page.forEach(r=>n.page.push({
            id: parseInt(r.id, 10),
            file: r.file
        })),
        s.char.forEach(r=>n.char.push({
            id: parseInt(r.id, 10),
            page: parseInt(r.page, 10),
            x: parseInt(r.x, 10),
            y: parseInt(r.y, 10),
            width: parseInt(r.width, 10),
            height: parseInt(r.height, 10),
            xoffset: parseInt(r.xoffset, 10),
            yoffset: parseInt(r.yoffset, 10),
            xadvance: parseInt(r.xadvance, 10)
        })),
        s.kerning.forEach(r=>n.kerning.push({
            first: parseInt(r.first, 10),
            second: parseInt(r.second, 10),
            amount: parseInt(r.amount, 10)
        })),
        s.distanceField.forEach(r=>n.distanceField.push({
            distanceRange: parseInt(r.distanceRange, 10),
            fieldType: r.fieldType
        })),
        n
    }
}
class Ad {
    static test(t) {
        const i = t;
        return "getElementsByTagName"in i && i.getElementsByTagName("page").length && i.getElementsByTagName("info")[0].getAttribute("face") !== null
    }
    static parse(t) {
        const i = new Rc
          , s = t.getElementsByTagName("info")
          , n = t.getElementsByTagName("common")
          , r = t.getElementsByTagName("page")
          , o = t.getElementsByTagName("char")
          , a = t.getElementsByTagName("kerning")
          , l = t.getElementsByTagName("distanceField");
        for (let c = 0; c < s.length; c++)
            i.info.push({
                face: s[c].getAttribute("face"),
                size: parseInt(s[c].getAttribute("size"), 10)
            });
        for (let c = 0; c < n.length; c++)
            i.common.push({
                lineHeight: parseInt(n[c].getAttribute("lineHeight"), 10)
            });
        for (let c = 0; c < r.length; c++)
            i.page.push({
                id: parseInt(r[c].getAttribute("id"), 10) || 0,
                file: r[c].getAttribute("file")
            });
        for (let c = 0; c < o.length; c++) {
            const h = o[c];
            i.char.push({
                id: parseInt(h.getAttribute("id"), 10),
                page: parseInt(h.getAttribute("page"), 10) || 0,
                x: parseInt(h.getAttribute("x"), 10),
                y: parseInt(h.getAttribute("y"), 10),
                width: parseInt(h.getAttribute("width"), 10),
                height: parseInt(h.getAttribute("height"), 10),
                xoffset: parseInt(h.getAttribute("xoffset"), 10),
                yoffset: parseInt(h.getAttribute("yoffset"), 10),
                xadvance: parseInt(h.getAttribute("xadvance"), 10)
            })
        }
        for (let c = 0; c < a.length; c++)
            i.kerning.push({
                first: parseInt(a[c].getAttribute("first"), 10),
                second: parseInt(a[c].getAttribute("second"), 10),
                amount: parseInt(a[c].getAttribute("amount"), 10)
            });
        for (let c = 0; c < l.length; c++)
            i.distanceField.push({
                fieldType: l[c].getAttribute("fieldType"),
                distanceRange: parseInt(l[c].getAttribute("distanceRange"), 10)
            });
        return i
    }
}
class Id {
    static test(t) {
        return typeof t == "string" && t.includes("<font>") ? Ad.test(ft.ADAPTER.parseXML(t)) : !1
    }
    static parse(t) {
        return Ad.parse(ft.ADAPTER.parseXML(t))
    }
}
const pu = [ec, Ad, Id];
function BM(e) {
    for (let t = 0; t < pu.length; t++)
        if (pu[t].test(e))
            return pu[t];
    return null
}
function UM(e, t, i, s, n, r) {
    const o = i.fill;
    if (Array.isArray(o)) {
        if (o.length === 1)
            return o[0]
    } else
        return o;
    let a;
    const l = i.dropShadow ? i.dropShadowDistance : 0
      , c = i.padding || 0
      , h = e.width / s - l - c * 2
      , u = e.height / s - l - c * 2
      , d = o.slice()
      , f = i.fillGradientStops.slice();
    if (!f.length) {
        const p = d.length + 1;
        for (let m = 1; m < p; ++m)
            f.push(m / p)
    }
    if (d.unshift(o[0]),
    f.unshift(0),
    d.push(o[o.length - 1]),
    f.push(1),
    i.fillGradientType === _h.LINEAR_VERTICAL) {
        a = t.createLinearGradient(h / 2, c, h / 2, u + c);
        let p = 0;
        const g = (r.fontProperties.fontSize + i.strokeThickness) / u;
        for (let y = 0; y < n.length; y++) {
            const x = r.lineHeight * y;
            for (let v = 0; v < d.length; v++) {
                let _ = 0;
                typeof f[v] == "number" ? _ = f[v] : _ = v / d.length;
                const C = x / u + _ * g;
                let k = Math.max(p, C);
                k = Math.min(k, 1),
                a.addColorStop(k, d[v]),
                p = k
            }
        }
    } else {
        a = t.createLinearGradient(c, u / 2, h + c, u / 2);
        const p = d.length + 1;
        let m = 1;
        for (let g = 0; g < d.length; g++) {
            let y;
            typeof f[g] == "number" ? y = f[g] : y = m / p,
            a.addColorStop(y, d[g]),
            m++
        }
    }
    return a
}
function GM(e, t, i, s, n, r, o) {
    const a = i.text
      , l = i.fontProperties;
    t.translate(s, n),
    t.scale(r, r);
    const c = o.strokeThickness / 2
      , h = -(o.strokeThickness / 2);
    if (t.font = o.toFontString(),
    t.lineWidth = o.strokeThickness,
    t.textBaseline = o.textBaseline,
    t.lineJoin = o.lineJoin,
    t.miterLimit = o.miterLimit,
    t.fillStyle = UM(e, t, o, r, [a], i),
    t.strokeStyle = o.stroke,
    o.dropShadow) {
        const u = o.dropShadowColor
          , d = tn(typeof u == "number" ? u : lh(u))
          , f = o.dropShadowBlur * r
          , p = o.dropShadowDistance * r;
        t.shadowColor = `rgba(${d[0] * 255},${d[1] * 255},${d[2] * 255},${o.dropShadowAlpha})`,
        t.shadowBlur = f,
        t.shadowOffsetX = Math.cos(o.dropShadowAngle) * p,
        t.shadowOffsetY = Math.sin(o.dropShadowAngle) * p
    } else
        t.shadowColor = "black",
        t.shadowBlur = 0,
        t.shadowOffsetX = 0,
        t.shadowOffsetY = 0;
    o.stroke && o.strokeThickness && t.strokeText(a, c, h + i.lineHeight - l.descent),
    o.fill && t.fillText(a, c, h + i.lineHeight - l.descent),
    t.setTransform(1, 0, 0, 1, 0, 0),
    t.fillStyle = "rgba(0, 0, 0, 0)"
}
function ic(e) {
    return e.codePointAt ? e.codePointAt(0) : e.charCodeAt(0)
}
function F1(e) {
    return Array.from ? Array.from(e) : e.split("")
}
function HM(e) {
    typeof e == "string" && (e = [e]);
    const t = [];
    for (let i = 0, s = e.length; i < s; i++) {
        const n = e[i];
        if (Array.isArray(n)) {
            if (n.length !== 2)
                throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${n.length}.`);
            const r = n[0].charCodeAt(0)
              , o = n[1].charCodeAt(0);
            if (o < r)
                throw new Error("[BitmapFont]: Invalid character range.");
            for (let a = r, l = o; a <= l; a++)
                t.push(String.fromCharCode(a))
        } else
            t.push(...F1(n))
    }
    if (t.length === 0)
        throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return t
}
const Qi = class {
    constructor(e, t, i) {
        const [s] = e.info
          , [n] = e.common
          , [r] = e.page
          , [o] = e.distanceField
          , a = en(r.file)
          , l = {};
        this._ownsTextures = i,
        this.font = s.face,
        this.size = s.size,
        this.lineHeight = n.lineHeight / a,
        this.chars = {},
        this.pageTextures = l;
        for (let c = 0; c < e.page.length; c++) {
            const {id: h, file: u} = e.page[c];
            l[h] = t instanceof Array ? t[c] : t[u],
            o?.fieldType && o.fieldType !== "none" && (l[h].baseTexture.alphaMode = _s.NO_PREMULTIPLIED_ALPHA,
            l[h].baseTexture.mipmap = ds.OFF)
        }
        for (let c = 0; c < e.char.length; c++) {
            const {id: h, page: u} = e.char[c];
            let {x: d, y: f, width: p, height: m, xoffset: g, yoffset: y, xadvance: x} = e.char[c];
            d /= a,
            f /= a,
            p /= a,
            m /= a,
            g /= a,
            y /= a,
            x /= a;
            const v = new qt(d + l[u].frame.x / a,f + l[u].frame.y / a,p,m);
            this.chars[h] = {
                xOffset: g,
                yOffset: y,
                xAdvance: x,
                kerning: {},
                texture: new ht(l[u].baseTexture,v),
                page: u
            }
        }
        for (let c = 0; c < e.kerning.length; c++) {
            let {first: h, second: u, amount: d} = e.kerning[c];
            h /= a,
            u /= a,
            d /= a,
            this.chars[u] && (this.chars[u].kerning[h] = d)
        }
        this.distanceFieldRange = o?.distanceRange,
        this.distanceFieldType = o?.fieldType?.toLowerCase() ?? "none"
    }
    destroy() {
        for (const e in this.chars)
            this.chars[e].texture.destroy(),
            this.chars[e].texture = null;
        for (const e in this.pageTextures)
            this._ownsTextures && this.pageTextures[e].destroy(!0),
            this.pageTextures[e] = null;
        this.chars = null,
        this.pageTextures = null
    }
    static install(e, t, i) {
        let s;
        if (e instanceof Rc)
            s = e;
        else {
            const r = BM(e);
            if (!r)
                throw new Error("Unrecognized data format for font.");
            s = r.parse(e)
        }
        t instanceof ht && (t = [t]);
        const n = new Qi(s,t,i);
        return Qi.available[n.font] = n,
        n
    }
    static uninstall(e) {
        const t = Qi.available[e];
        if (!t)
            throw new Error(`No font found named '${e}'`);
        t.destroy(),
        delete Qi.available[e]
    }
    static from(e, t, i) {
        if (!e)
            throw new Error("[BitmapFont] Property `name` is required.");
        const {chars: s, padding: n, resolution: r, textureWidth: o, textureHeight: a, ...l} = Object.assign({}, Qi.defaultOptions, i)
          , c = HM(s)
          , h = t instanceof ki ? t : new ki(t)
          , u = o
          , d = new Rc;
        d.info[0] = {
            face: h.fontFamily,
            size: h.fontSize
        },
        d.common[0] = {
            lineHeight: h.fontSize
        };
        let f = 0, p = 0, m, g, y, x = 0;
        const v = [];
        for (let C = 0; C < c.length; C++) {
            m || (m = ft.ADAPTER.createCanvas(),
            m.width = o,
            m.height = a,
            g = m.getContext("2d"),
            y = new Ot(m,{
                resolution: r,
                ...l
            }),
            v.push(new ht(y)),
            d.page.push({
                id: v.length - 1,
                file: ""
            }));
            const k = c[C]
              , S = He.measureText(k, h, !1, m)
              , T = S.width
              , L = Math.ceil(S.height)
              , D = Math.ceil((h.fontStyle === "italic" ? 2 : 1) * T);
            if (p >= a - L * r) {
                if (p === 0)
                    throw new Error(`[BitmapFont] textureHeight ${a}px is too small (fontFamily: '${h.fontFamily}', fontSize: ${h.fontSize}px, char: '${k}')`);
                --C,
                m = null,
                g = null,
                y = null,
                p = 0,
                f = 0,
                x = 0;
                continue
            }
            if (x = Math.max(L + S.fontProperties.descent, x),
            D * r + f >= u) {
                if (f === 0)
                    throw new Error(`[BitmapFont] textureWidth ${o}px is too small (fontFamily: '${h.fontFamily}', fontSize: ${h.fontSize}px, char: '${k}')`);
                --C,
                p += x * r,
                p = Math.ceil(p),
                f = 0,
                x = 0;
                continue
            }
            GM(m, g, S, f, p, r, h);
            const O = ic(S.text);
            d.char.push({
                id: O,
                page: v.length - 1,
                x: f / r,
                y: p / r,
                width: D,
                height: L,
                xoffset: 0,
                yoffset: 0,
                xadvance: T - (h.dropShadow ? h.dropShadowDistance : 0) - (h.stroke ? h.strokeThickness : 0)
            }),
            f += (D + 2 * n) * r,
            f = Math.ceil(f)
        }
        for (let C = 0, k = c.length; C < k; C++) {
            const S = c[C];
            for (let T = 0; T < k; T++) {
                const L = c[T]
                  , D = g.measureText(S).width
                  , O = g.measureText(L).width
                  , P = g.measureText(S + L).width - (D + O);
                P && d.kerning.push({
                    first: ic(S),
                    second: ic(L),
                    amount: P
                })
            }
        }
        const _ = new Qi(d,v,!0);
        return Qi.available[e] !== void 0 && Qi.uninstall(e),
        Qi.available[e] = _,
        _
    }
}
;
let le = Qi;
le.ALPHA = [["a", "z"], ["A", "Z"], " "];
le.NUMERIC = [["0", "9"]];
le.ALPHANUMERIC = [["a", "z"], ["A", "Z"], ["0", "9"], " "];
le.ASCII = [[" ", "~"]];
le.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: Qi.ALPHANUMERIC
};
le.available = {};
var VM = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r
\r
}\r
`
  , zM = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
const Dg = []
  , Ng = []
  , Fg = []
  , B1 = class extends ae {
    constructor(e, t={}) {
        super(),
        this._tint = 16777215;
        const {align: i, tint: s, maxWidth: n, letterSpacing: r, fontName: o, fontSize: a} = Object.assign({}, B1.styleDefaults, t);
        if (!le.available[o])
            throw new Error(`Missing BitmapFont "${o}"`);
        this._activePagesMeshData = [],
        this._textWidth = 0,
        this._textHeight = 0,
        this._align = i,
        this._tint = s,
        this._font = void 0,
        this._fontName = o,
        this._fontSize = a,
        this.text = e,
        this._maxWidth = n,
        this._maxLineHeight = 0,
        this._letterSpacing = r,
        this._anchor = new wn(()=>{
            this.dirty = !0
        }
        ,this,0,0),
        this._roundPixels = ft.ROUND_PIXELS,
        this.dirty = !0,
        this._resolution = ft.RESOLUTION,
        this._autoResolution = !0,
        this._textureCache = {}
    }
    updateText() {
        const e = le.available[this._fontName]
          , t = this.fontSize
          , i = t / e.size
          , s = new Zt
          , n = []
          , r = []
          , o = []
          , a = this._text.replace(/(?:\r\n|\r)/g, `
`) || " "
          , l = F1(a)
          , c = this._maxWidth * e.size / t
          , h = e.distanceFieldType === "none" ? Dg : Ng;
        let u = null
          , d = 0
          , f = 0
          , p = 0
          , m = -1
          , g = 0
          , y = 0
          , x = 0
          , v = 0;
        for (let D = 0; D < l.length; D++) {
            const O = l[D]
              , K = ic(O);
            if (/(?:\s)/.test(O) && (m = D,
            g = d,
            v++),
            O === "\r" || O === `
`) {
                r.push(d),
                o.push(-1),
                f = Math.max(f, d),
                ++p,
                ++y,
                s.x = 0,
                s.y += e.lineHeight,
                u = null,
                v = 0;
                continue
            }
            const P = e.chars[K];
            if (!P)
                continue;
            u && P.kerning[u] && (s.x += P.kerning[u]);
            const N = Fg.pop() || {
                texture: ht.EMPTY,
                line: 0,
                charCode: 0,
                prevSpaces: 0,
                position: new Zt
            };
            N.texture = P.texture,
            N.line = p,
            N.charCode = K,
            N.position.x = Math.round(s.x + P.xOffset + this._letterSpacing / 2),
            N.position.y = Math.round(s.y + P.yOffset),
            N.prevSpaces = v,
            n.push(N),
            d = N.position.x + Math.max(P.xAdvance - P.xOffset, P.texture.orig.width),
            s.x += P.xAdvance + this._letterSpacing,
            x = Math.max(x, P.yOffset + P.texture.height),
            u = K,
            m !== -1 && c > 0 && s.x > c && (++y,
            wr(n, 1 + m - y, 1 + D - m),
            D = m,
            m = -1,
            r.push(g),
            o.push(n.length > 0 ? n[n.length - 1].prevSpaces : 0),
            f = Math.max(f, g),
            p++,
            s.x = 0,
            s.y += e.lineHeight,
            u = null,
            v = 0)
        }
        const _ = l[l.length - 1];
        _ !== "\r" && _ !== `
` && (/(?:\s)/.test(_) && (d = g),
        r.push(d),
        f = Math.max(f, d),
        o.push(-1));
        const C = [];
        for (let D = 0; D <= p; D++) {
            let O = 0;
            this._align === "right" ? O = f - r[D] : this._align === "center" ? O = (f - r[D]) / 2 : this._align === "justify" && (O = o[D] < 0 ? 0 : (f - r[D]) / o[D]),
            C.push(O)
        }
        const k = n.length
          , S = {}
          , T = []
          , L = this._activePagesMeshData;
        h.push(...L);
        for (let D = 0; D < k; D++) {
            const O = n[D].texture
              , K = O.baseTexture.uid;
            if (!S[K]) {
                let P = h.pop();
                if (!P) {
                    const W = new gh;
                    let V, Q;
                    e.distanceFieldType === "none" ? (V = new Do(ht.EMPTY),
                    Q = j.NORMAL) : (V = new Do(ht.EMPTY,{
                        program: os.from(zM, VM),
                        uniforms: {
                            uFWidth: 0
                        }
                    }),
                    Q = j.NORMAL_NPM);
                    const pt = new ii(W,V);
                    pt.blendMode = Q,
                    P = {
                        index: 0,
                        indexCount: 0,
                        vertexCount: 0,
                        uvsCount: 0,
                        total: 0,
                        mesh: pt,
                        vertices: null,
                        uvs: null,
                        indices: null
                    }
                }
                P.index = 0,
                P.indexCount = 0,
                P.vertexCount = 0,
                P.uvsCount = 0,
                P.total = 0;
                const {_textureCache: N} = this;
                N[K] = N[K] || new ht(O.baseTexture),
                P.mesh.texture = N[K],
                P.mesh.tint = this._tint,
                T.push(P),
                S[K] = P
            }
            S[K].total++
        }
        for (let D = 0; D < L.length; D++)
            T.includes(L[D]) || this.removeChild(L[D].mesh);
        for (let D = 0; D < T.length; D++)
            T[D].mesh.parent !== this && this.addChild(T[D].mesh);
        this._activePagesMeshData = T;
        for (const D in S) {
            const O = S[D]
              , K = O.total;
            if (!(O.indices?.length > 6 * K) || O.vertices.length < ii.BATCHABLE_SIZE * 2)
                O.vertices = new Float32Array(4 * 2 * K),
                O.uvs = new Float32Array(4 * 2 * K),
                O.indices = new Uint16Array(6 * K);
            else {
                const P = O.total
                  , N = O.vertices;
                for (let W = P * 4 * 2; W < N.length; W++)
                    N[W] = 0
            }
            O.mesh.size = 6 * K
        }
        for (let D = 0; D < k; D++) {
            const O = n[D];
            let K = O.position.x + C[O.line] * (this._align === "justify" ? O.prevSpaces : 1);
            this._roundPixels && (K = Math.round(K));
            const P = K * i
              , N = O.position.y * i
              , W = O.texture
              , V = S[W.baseTexture.uid]
              , Q = W.frame
              , pt = W._uvs
              , bt = V.index++;
            V.indices[bt * 6 + 0] = 0 + bt * 4,
            V.indices[bt * 6 + 1] = 1 + bt * 4,
            V.indices[bt * 6 + 2] = 2 + bt * 4,
            V.indices[bt * 6 + 3] = 0 + bt * 4,
            V.indices[bt * 6 + 4] = 2 + bt * 4,
            V.indices[bt * 6 + 5] = 3 + bt * 4,
            V.vertices[bt * 8 + 0] = P,
            V.vertices[bt * 8 + 1] = N,
            V.vertices[bt * 8 + 2] = P + Q.width * i,
            V.vertices[bt * 8 + 3] = N,
            V.vertices[bt * 8 + 4] = P + Q.width * i,
            V.vertices[bt * 8 + 5] = N + Q.height * i,
            V.vertices[bt * 8 + 6] = P,
            V.vertices[bt * 8 + 7] = N + Q.height * i,
            V.uvs[bt * 8 + 0] = pt.x0,
            V.uvs[bt * 8 + 1] = pt.y0,
            V.uvs[bt * 8 + 2] = pt.x1,
            V.uvs[bt * 8 + 3] = pt.y1,
            V.uvs[bt * 8 + 4] = pt.x2,
            V.uvs[bt * 8 + 5] = pt.y2,
            V.uvs[bt * 8 + 6] = pt.x3,
            V.uvs[bt * 8 + 7] = pt.y3
        }
        this._textWidth = f * i,
        this._textHeight = (s.y + e.lineHeight) * i;
        for (const D in S) {
            const O = S[D];
            if (this.anchor.x !== 0 || this.anchor.y !== 0) {
                let W = 0;
                const V = this._textWidth * this.anchor.x
                  , Q = this._textHeight * this.anchor.y;
                for (let pt = 0; pt < O.total; pt++)
                    O.vertices[W++] -= V,
                    O.vertices[W++] -= Q,
                    O.vertices[W++] -= V,
                    O.vertices[W++] -= Q,
                    O.vertices[W++] -= V,
                    O.vertices[W++] -= Q,
                    O.vertices[W++] -= V,
                    O.vertices[W++] -= Q
            }
            this._maxLineHeight = x * i;
            const K = O.mesh.geometry.getBuffer("aVertexPosition")
              , P = O.mesh.geometry.getBuffer("aTextureCoord")
              , N = O.mesh.geometry.getIndex();
            K.data = O.vertices,
            P.data = O.uvs,
            N.data = O.indices,
            K.update(),
            P.update(),
            N.update()
        }
        for (let D = 0; D < n.length; D++)
            Fg.push(n[D]);
        this._font = e,
        this.dirty = !1
    }
    updateTransform() {
        this.validate(),
        this.containerUpdateTransform()
    }
    _render(e) {
        this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution,
        this.dirty = !0);
        const {distanceFieldRange: t, distanceFieldType: i, size: s} = le.available[this._fontName];
        if (i !== "none") {
            const {a: n, b: r, c: o, d: a} = this.worldTransform
              , l = Math.sqrt(n * n + r * r)
              , c = Math.sqrt(o * o + a * a)
              , h = (Math.abs(l) + Math.abs(c)) / 2
              , u = this.fontSize / s
              , d = e._view.resolution;
            for (const f of this._activePagesMeshData)
                f.mesh.shader.uniforms.uFWidth = h * t * u * d
        }
        super._render(e)
    }
    getLocalBounds() {
        return this.validate(),
        super.getLocalBounds()
    }
    validate() {
        const e = le.available[this._fontName];
        if (!e)
            throw new Error(`Missing BitmapFont "${this._fontName}"`);
        this._font !== e && (this.dirty = !0),
        this.dirty && this.updateText()
    }
    get tint() {
        return this._tint
    }
    set tint(e) {
        if (this._tint !== e) {
            this._tint = e;
            for (let t = 0; t < this._activePagesMeshData.length; t++)
                this._activePagesMeshData[t].mesh.tint = e
        }
    }
    get align() {
        return this._align
    }
    set align(e) {
        this._align !== e && (this._align = e,
        this.dirty = !0)
    }
    get fontName() {
        return this._fontName
    }
    set fontName(e) {
        if (!le.available[e])
            throw new Error(`Missing BitmapFont "${e}"`);
        this._fontName !== e && (this._fontName = e,
        this.dirty = !0)
    }
    get fontSize() {
        return this._fontSize ?? le.available[this._fontName].size
    }
    set fontSize(e) {
        this._fontSize !== e && (this._fontSize = e,
        this.dirty = !0)
    }
    get anchor() {
        return this._anchor
    }
    set anchor(e) {
        typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
    }
    get text() {
        return this._text
    }
    set text(e) {
        e = String(e ?? ""),
        this._text !== e && (this._text = e,
        this.dirty = !0)
    }
    get maxWidth() {
        return this._maxWidth
    }
    set maxWidth(e) {
        this._maxWidth !== e && (this._maxWidth = e,
        this.dirty = !0)
    }
    get maxLineHeight() {
        return this.validate(),
        this._maxLineHeight
    }
    get textWidth() {
        return this.validate(),
        this._textWidth
    }
    get letterSpacing() {
        return this._letterSpacing
    }
    set letterSpacing(e) {
        this._letterSpacing !== e && (this._letterSpacing = e,
        this.dirty = !0)
    }
    get roundPixels() {
        return this._roundPixels
    }
    set roundPixels(e) {
        e !== this._roundPixels && (this._roundPixels = e,
        this.dirty = !0)
    }
    get textHeight() {
        return this.validate(),
        this._textHeight
    }
    get resolution() {
        return this._resolution
    }
    set resolution(e) {
        this._autoResolution = !1,
        this._resolution !== e && (this._resolution = e,
        this.dirty = !0)
    }
    destroy(e) {
        const {_textureCache: t} = this
          , s = le.available[this._fontName].distanceFieldType === "none" ? Dg : Ng;
        s.push(...this._activePagesMeshData);
        for (const n of this._activePagesMeshData)
            this.removeChild(n.mesh);
        this._activePagesMeshData = [],
        s.filter(n=>t[n.mesh.texture.baseTexture.uid]).forEach(n=>{
            n.mesh.texture = ht.EMPTY
        }
        );
        for (const n in t)
            t[n].destroy(),
            delete t[n];
        this._font = null,
        this._textureCache = null,
        super.destroy(e)
    }
}
;
let $e = B1;
$e.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
};
const $M = [".xml", ".fnt"]
  , jM = {
    extension: {
        type: lt.LoadParser,
        priority: Us.Normal
    },
    test(e) {
        return $M.includes(Xe.extname(e).toLowerCase())
    },
    async testParse(e) {
        return ec.test(e) || Id.test(e)
    },
    async parse(e, t, i) {
        const s = ec.test(e) ? ec.parse(e) : Id.parse(e)
          , {src: n} = t
          , {page: r} = s
          , o = [];
        for (let c = 0; c < r.length; ++c) {
            const h = r[c].file;
            let u = Xe.join(Xe.dirname(n), h);
            u = xd(u, n),
            o.push(u)
        }
        const a = await i.load(o)
          , l = o.map(c=>a[c]);
        return le.install(s, l, !0)
    },
    async load(e, t) {
        return (await ft.ADAPTER.fetch(e)).text()
    },
    unload(e) {
        e.destroy()
    }
};
vt.add(jM);
function vi(e, t, i) {
    return Math.max(Math.min((t - e) / i, 1), 0)
}
function Ze(e, t, i) {
    return e + (t - e) * i
}
function kc(e) {
    return e < 10 ? `0${e}` : e
}
const mu = ()=>{
    const e = new Date;
    return `${kc(e.getHours())}:${kc(e.getMinutes())}`
}
;
function lo(e) {
    if (!e)
        return "";
    const t = e.opUnits.get(0);
    return t ? `url(${t.skinImg.src})` : ""
}
function Ui(e, t, i) {
    return Math.abs(e - t) < i
}
function U1(e) {
    return e.includes("Key") ? e.substring(3, e.leading) : e.includes("Arrow") ? e.substring(5, e.leading) : e
}
function yo(e) {
    const {code: t} = e;
    let i = ""
      , s = "";
    return t.includes("Shift") ? s = "Shift" : t.includes("Control") ? s = "Ctrl" : t.includes("Alt") ? s = "Alt" : (s = U1(t),
    i = e.shiftKey ? "Shift+" : e.ctrlKey ? "Ctrl+" : e.altKey ? "Alt+" : ""),
    s = i + s,
    s
}
function Bg(e, t, i, s, n) {
    return [e - n, t + n, i - n, s + n]
}
function Ug(e, t) {
    let i, s = [], n, r;
    for (let o = 0, a = e.length; o < a; )
        i = (247.5 + o / 2 * 45) / 180 * Math.PI,
        n = e[o++] + t * Math.cos(i),
        r = e[o++] + t * Math.sin(i),
        s.push(n, r);
    return s
}
function Be(e) {
    return e ? parseInt(`0x${e}`) : void 0
}
function gu(e) {
    var t = e.toString(16).toUpperCase();
    return t.length == 1 && (t = "0" + t),
    t
}
function Qa(e) {
    var t = e >> 16 & 255
      , i = e >> 8 & 255
      , s = 255 & e;
    return "#" + gu(t) + gu(i) + gu(s)
}
function ar(e) {
    const t = Be(e[0]);
    return lr(t, e[1])
}
function lr(e, t) {
    return `rgba(${e >> 16}, ${e >> 8 & 255}, ${e & 255}, ${t})`
}
function Md(e, t) {
    return e.length != 0 ? "#" + e : Qa(t)
}
function cr(e) {
    return [e & 4095, (e & 61440) >> 12]
}
function WM(e) {
    return {
        all: e = e || new Map,
        on: function(t, i) {
            var s = e.get(t);
            s ? s.push(i) : e.set(t, [i])
        },
        off: function(t, i) {
            var s = e.get(t);
            s && (i ? s.splice(s.indexOf(i) >>> 0, 1) : e.set(t, []))
        },
        emit: function(t, i) {
            var s = e.get(t);
            s && s.slice().map(function(n) {
                n(i)
            }),
            (s = e.get("*")) && s.slice().map(function(n) {
                n(t, i)
            })
        }
    }
}
const A = WM()
  , Rd = {
    TagType: 1,
    ShowNick: 1,
    ShowMass: 1,
    ShowSkin: 1,
    ShowFood: 1,
    VirusType: 1,
    ShowCursorLine: 1,
    ShowEnemyHint: 1,
    ShowMassMarker: 1,
    ShowSplitOrderMarker: 1,
    ShowAutosplitAlert: 1,
    ShootingHintType: 2,
    AnimationDelay: 180,
    ExtraLatency: 0,
    CameraDelay: 350,
    ZoomSpeed: 1.2,
    EnableAppearance: 1,
    EnableDisappearance: 1,
    EnableAbsorption: 0,
    Quality: 375,
    Resolution: 1,
    Antialias: 1,
    Mipmap: 1,
    CaptureTime: 0,
    AutoSwitchTab: 1,
    StopFeedingAfterSwitchingTab: 1,
    PauseAfterOpeningMenu: 0,
    ShowMenuAfterDeath: 0,
    StableSpecCamera: 0,
    ShowMinimap: 1,
    ShowLeaderboard: 1,
    ShowTeamRankings: 1,
    ShowPerfStatus: 1,
    ShowGameStatus: 1,
    ShowChatRoom: 1,
    ShowReplayBar: 1,
    MinimapSize: 1,
    LeaderboardSize: 1,
    TeamRankingsSize: 1,
    PerfStatusSize: 1,
    GameStatusSize: 1,
    AutoHideChatRoom: 0,
    HideCode: 0,
    EnableChat: 1
}
  , G1 = {
    0: "None",
    1: "Signal",
    2: "None",
    3: "None",
    4: "None"
}
  , sc = {
    FeedOnce: "W",
    MacroFeed: "Q",
    Split1X: "Space",
    Split2X: "R",
    Split3X: "T",
    Split4X: "E",
    Pause: "S",
    TogglePause: "",
    Scatter: "V",
    SwitchTab: "Tab",
    AutoSwitchTab: "",
    Toggle4TabMode: "",
    Respawn: "N",
    ShowCursorLine: "",
    ShowEnemyHint: "",
    ShowMassMarker: "",
    ShowSplitOrderMarker: "",
    ShowAutosplitAlert: "",
    IncreaseMass: "M",
    DecreaseMass: "N",
    ClearSmallCells: "C",
    QuickCapture: "",
    ShowNick: "A",
    ShowMass: "D",
    ShowSkin: "X",
    ShowFood: "Z",
    ShowMinimap: "",
    ShowLeaderboard: "",
    ShowTeamRankings: "",
    ShowPerfStatus: "",
    ShowGameStatus: "",
    ShowChatRoom: "",
    ShowReplayBar: ""
}
  , nc = {
    EjectedCell: ["", .75],
    Food: ["", 1],
    Virus: ["00ff00", .9],
    RedVirus: ["ff6699", .9],
    Text: ["FFFFFF", 1, 22.5, 7],
    TextStroke: ["222222", .75, 22.5, 1],
    CellSelf: ["", .9],
    SkinSelf: ["FFFFFF", .9],
    SkinFillSelf: ["", 1],
    CellTeam: ["", .9],
    SkinTeam: ["FFFFFF", .9],
    SkinFillTeam: ["", 1],
    CellEnemy: ["", .9],
    SkinEnemy: ["FFFFFF", .9],
    SkinFillEnemy: ["", 1],
    CellAll: ["", .9],
    SkinAll: ["FFFFFF", .9],
    SkinFillAll: ["", 1],
    CursorLine: ["FFFFFF", 1, 1.5, 0],
    MassMarker: ["", 1, 3.5, 0],
    SplitOrderMarker: ["", 1, 12.5, 0],
    AutosplitAlert: ["", 1, 3.5, 0],
    DestinationPoint: ["00FF00", 1],
    Signal: ["3090FF", null],
    CoordsFont: ["FFFFFF", .2],
    CoordsGrid: ["FFFFFF", .5],
    Border: ["0095FF", 1],
    BorderGlow: ["0095FF", 1],
    BackgroundColor: ["121418", 1],
    BackgroundImage: ["FFFFFF", .6, ""],
    CoordsFontMinimap: ["FFFFFF", .375],
    CoordsGridMinimap: ["FFFFFF", .125],
    BgcMinimap: ["252525", .5],
    LocationLine: ["FFFFFF", .35],
    ViewMinimap: ["", .1],
    EntityMinimap: ["", .8],
    EntityInfoMinimap: ["", 1],
    BgcLeaderboard: ["252525", .5],
    BgcTeamRankings: ["252525", .5],
    BgcPerfPanel: ["252525", .5]
}
  , XM = ["osa.cwal.io:8888", "tyo.cwal.io:8888", "na.cwal.io:8888", "localhost:8888"]
  , YM = ["tyo.cwal.io:8888", "osa.cwal.io:8888", "na.cwal.io:8888"]
  , Pc = ["zh_CN", "zh", "ja", "en"]
  , KM = ["http://cwal.io/skins/ring.png", "http://cwal.io/skins/h.png", "http://cwal.io/skins/circles.png", "http://cwal.io/skins/w.png", "http://cwal.io/skins/wolf.png", "http://cwal.io/skins/dragon.png", "http://cwal.io/skins/magatama.png", "http://cwal.io/skins/ghost.png", "http://cwal.io/skins/bat.png", "http://cwal.io/skins/daemon.png"]
  , ZM = (()=>{
    const e = [];
    for (let t = 0; t < 20; t++) {
        const i = "Profile" + (t + 1)
          , s = KM[t] ?? "http://cwal.io/skins/ring.png";
        e.push([["", ""], [[i, s], [i, s], [i, s], [i, s]], ""])
    }
    return e
}
)()
  , qM = 1;
var H1 = {
    exports: {}
};
(function(e) {
    (function() {
        function t(w, R, z) {
            return w.call.apply(w.bind, arguments)
        }
        function i(w, R, z) {
            if (!w)
                throw Error();
            if (2 < arguments.length) {
                var G = Array.prototype.slice.call(arguments, 2);
                return function() {
                    var et = Array.prototype.slice.call(arguments);
                    return Array.prototype.unshift.apply(et, G),
                    w.apply(R, et)
                }
            }
            return function() {
                return w.apply(R, arguments)
            }
        }
        function s(w, R, z) {
            return s = Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? t : i,
            s.apply(null, arguments)
        }
        var n = Date.now || function() {
            return +new Date
        }
        ;
        function r(w, R) {
            this.a = w,
            this.o = R || w,
            this.c = this.o.document
        }
        var o = !!window.FontFace;
        function a(w, R, z, G) {
            if (R = w.c.createElement(R),
            z)
                for (var et in z)
                    z.hasOwnProperty(et) && (et == "style" ? R.style.cssText = z[et] : R.setAttribute(et, z[et]));
            return G && R.appendChild(w.c.createTextNode(G)),
            R
        }
        function l(w, R, z) {
            w = w.c.getElementsByTagName(R)[0],
            w || (w = document.documentElement),
            w.insertBefore(z, w.lastChild)
        }
        function c(w) {
            w.parentNode && w.parentNode.removeChild(w)
        }
        function h(w, R, z) {
            R = R || [],
            z = z || [];
            for (var G = w.className.split(/\s+/), et = 0; et < R.length; et += 1) {
                for (var _t = !1, Mt = 0; Mt < G.length; Mt += 1)
                    if (R[et] === G[Mt]) {
                        _t = !0;
                        break
                    }
                _t || G.push(R[et])
            }
            for (R = [],
            et = 0; et < G.length; et += 1) {
                for (_t = !1,
                Mt = 0; Mt < z.length; Mt += 1)
                    if (G[et] === z[Mt]) {
                        _t = !0;
                        break
                    }
                _t || R.push(G[et])
            }
            w.className = R.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "")
        }
        function u(w, R) {
            for (var z = w.className.split(/\s+/), G = 0, et = z.length; G < et; G++)
                if (z[G] == R)
                    return !0;
            return !1
        }
        function d(w) {
            return w.o.location.hostname || w.a.location.hostname
        }
        function f(w, R, z) {
            function G() {
                de && et && _t && (de(Mt),
                de = null)
            }
            R = a(w, "link", {
                rel: "stylesheet",
                href: R,
                media: "all"
            });
            var et = !1
              , _t = !0
              , Mt = null
              , de = z || null;
            o ? (R.onload = function() {
                et = !0,
                G()
            }
            ,
            R.onerror = function() {
                et = !0,
                Mt = Error("Stylesheet failed to load"),
                G()
            }
            ) : setTimeout(function() {
                et = !0,
                G()
            }, 0),
            l(w, "head", R)
        }
        function p(w, R, z, G) {
            var et = w.c.getElementsByTagName("head")[0];
            if (et) {
                var _t = a(w, "script", {
                    src: R
                })
                  , Mt = !1;
                return _t.onload = _t.onreadystatechange = function() {
                    Mt || this.readyState && this.readyState != "loaded" && this.readyState != "complete" || (Mt = !0,
                    z && z(null),
                    _t.onload = _t.onreadystatechange = null,
                    _t.parentNode.tagName == "HEAD" && et.removeChild(_t))
                }
                ,
                et.appendChild(_t),
                setTimeout(function() {
                    Mt || (Mt = !0,
                    z && z(Error("Script load timeout")))
                }, G || 5e3),
                _t
            }
            return null
        }
        function m() {
            this.a = 0,
            this.c = null
        }
        function g(w) {
            return w.a++,
            function() {
                w.a--,
                x(w)
            }
        }
        function y(w, R) {
            w.c = R,
            x(w)
        }
        function x(w) {
            w.a == 0 && w.c && (w.c(),
            w.c = null)
        }
        function v(w) {
            this.a = w || "-"
        }
        v.prototype.c = function(w) {
            for (var R = [], z = 0; z < arguments.length; z++)
                R.push(arguments[z].replace(/[\W_]+/g, "").toLowerCase());
            return R.join(this.a)
        }
        ;
        function _(w, R) {
            this.c = w,
            this.f = 4,
            this.a = "n";
            var z = (R || "n4").match(/^([nio])([1-9])$/i);
            z && (this.a = z[1],
            this.f = parseInt(z[2], 10))
        }
        function C(w) {
            return T(w) + " " + (w.f + "00") + " 300px " + k(w.c)
        }
        function k(w) {
            var R = [];
            w = w.split(/,\s*/);
            for (var z = 0; z < w.length; z++) {
                var G = w[z].replace(/['"]/g, "");
                G.indexOf(" ") != -1 || /^\d/.test(G) ? R.push("'" + G + "'") : R.push(G)
            }
            return R.join(",")
        }
        function S(w) {
            return w.a + w.f
        }
        function T(w) {
            var R = "normal";
            return w.a === "o" ? R = "oblique" : w.a === "i" && (R = "italic"),
            R
        }
        function L(w) {
            var R = 4
              , z = "n"
              , G = null;
            return w && ((G = w.match(/(normal|oblique|italic)/i)) && G[1] && (z = G[1].substr(0, 1).toLowerCase()),
            (G = w.match(/([1-9]00|normal|bold)/i)) && G[1] && (/bold/i.test(G[1]) ? R = 7 : /[1-9]00/.test(G[1]) && (R = parseInt(G[1].substr(0, 1), 10)))),
            z + R
        }
        function D(w, R) {
            this.c = w,
            this.f = w.o.document.documentElement,
            this.h = R,
            this.a = new v("-"),
            this.j = R.events !== !1,
            this.g = R.classes !== !1
        }
        function O(w) {
            w.g && h(w.f, [w.a.c("wf", "loading")]),
            P(w, "loading")
        }
        function K(w) {
            if (w.g) {
                var R = u(w.f, w.a.c("wf", "active"))
                  , z = []
                  , G = [w.a.c("wf", "loading")];
                R || z.push(w.a.c("wf", "inactive")),
                h(w.f, z, G)
            }
            P(w, "inactive")
        }
        function P(w, R, z) {
            w.j && w.h[R] && (z ? w.h[R](z.c, S(z)) : w.h[R]())
        }
        function N() {
            this.c = {}
        }
        function W(w, R, z) {
            var G = [], et;
            for (et in R)
                if (R.hasOwnProperty(et)) {
                    var _t = w.c[et];
                    _t && G.push(_t(R[et], z))
                }
            return G
        }
        function V(w, R) {
            this.c = w,
            this.f = R,
            this.a = a(this.c, "span", {
                "aria-hidden": "true"
            }, this.f)
        }
        function Q(w) {
            l(w.c, "body", w.a)
        }
        function pt(w) {
            return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + k(w.c) + ";" + ("font-style:" + T(w) + ";font-weight:" + (w.f + "00") + ";")
        }
        function bt(w, R, z, G, et, _t) {
            this.g = w,
            this.j = R,
            this.a = G,
            this.c = z,
            this.f = et || 3e3,
            this.h = _t || void 0
        }
        bt.prototype.start = function() {
            var w = this.c.o.document
              , R = this
              , z = n()
              , G = new Promise(function(Mt, de) {
                function _e() {
                    n() - z >= R.f ? de() : w.fonts.load(C(R.a), R.h).then(function(Le) {
                        1 <= Le.length ? Mt() : setTimeout(_e, 25)
                    }, function() {
                        de()
                    })
                }
                _e()
            }
            )
              , et = null
              , _t = new Promise(function(Mt, de) {
                et = setTimeout(de, R.f)
            }
            );
            Promise.race([_t, G]).then(function() {
                et && (clearTimeout(et),
                et = null),
                R.g(R.a)
            }, function() {
                R.j(R.a)
            })
        }
        ;
        function ct(w, R, z, G, et, _t, Mt) {
            this.v = w,
            this.B = R,
            this.c = z,
            this.a = G,
            this.s = Mt || "BESbswy",
            this.f = {},
            this.w = et || 3e3,
            this.u = _t || null,
            this.m = this.j = this.h = this.g = null,
            this.g = new V(this.c,this.s),
            this.h = new V(this.c,this.s),
            this.j = new V(this.c,this.s),
            this.m = new V(this.c,this.s),
            w = new _(this.a.c + ",serif",S(this.a)),
            w = pt(w),
            this.g.a.style.cssText = w,
            w = new _(this.a.c + ",sans-serif",S(this.a)),
            w = pt(w),
            this.h.a.style.cssText = w,
            w = new _("serif",S(this.a)),
            w = pt(w),
            this.j.a.style.cssText = w,
            w = new _("sans-serif",S(this.a)),
            w = pt(w),
            this.m.a.style.cssText = w,
            Q(this.g),
            Q(this.h),
            Q(this.j),
            Q(this.m)
        }
        var gt = {
            D: "serif",
            C: "sans-serif"
        }
          , xt = null;
        function It() {
            if (xt === null) {
                var w = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
                xt = !!w && (536 > parseInt(w[1], 10) || parseInt(w[1], 10) === 536 && 11 >= parseInt(w[2], 10))
            }
            return xt
        }
        ct.prototype.start = function() {
            this.f.serif = this.j.a.offsetWidth,
            this.f["sans-serif"] = this.m.a.offsetWidth,
            this.A = n(),
            J(this)
        }
        ;
        function St(w, R, z) {
            for (var G in gt)
                if (gt.hasOwnProperty(G) && R === w.f[gt[G]] && z === w.f[gt[G]])
                    return !0;
            return !1
        }
        function J(w) {
            var R = w.g.a.offsetWidth, z = w.h.a.offsetWidth, G;
            (G = R === w.f.serif && z === w.f["sans-serif"]) || (G = It() && St(w, R, z)),
            G ? n() - w.A >= w.w ? It() && St(w, R, z) && (w.u === null || w.u.hasOwnProperty(w.a.c)) ? Tt(w, w.v) : Tt(w, w.B) : wt(w) : Tt(w, w.v)
        }
        function wt(w) {
            setTimeout(s(function() {
                J(this)
            }, w), 50)
        }
        function Tt(w, R) {
            setTimeout(s(function() {
                c(this.g.a),
                c(this.h.a),
                c(this.j.a),
                c(this.m.a),
                R(this.a)
            }, w), 0)
        }
        function Bt(w, R, z) {
            this.c = w,
            this.a = R,
            this.f = 0,
            this.m = this.j = !1,
            this.s = z
        }
        var kt = null;
        Bt.prototype.g = function(w) {
            var R = this.a;
            R.g && h(R.f, [R.a.c("wf", w.c, S(w).toString(), "active")], [R.a.c("wf", w.c, S(w).toString(), "loading"), R.a.c("wf", w.c, S(w).toString(), "inactive")]),
            P(R, "fontactive", w),
            this.m = !0,
            re(this)
        }
        ,
        Bt.prototype.h = function(w) {
            var R = this.a;
            if (R.g) {
                var z = u(R.f, R.a.c("wf", w.c, S(w).toString(), "active"))
                  , G = []
                  , et = [R.a.c("wf", w.c, S(w).toString(), "loading")];
                z || G.push(R.a.c("wf", w.c, S(w).toString(), "inactive")),
                h(R.f, G, et)
            }
            P(R, "fontinactive", w),
            re(this)
        }
        ;
        function re(w) {
            --w.f == 0 && w.j && (w.m ? (w = w.a,
            w.g && h(w.f, [w.a.c("wf", "active")], [w.a.c("wf", "loading"), w.a.c("wf", "inactive")]),
            P(w, "active")) : K(w.a))
        }
        function Xt(w) {
            this.j = w,
            this.a = new N,
            this.h = 0,
            this.f = this.g = !0
        }
        Xt.prototype.load = function(w) {
            this.c = new r(this.j,w.context || this.j),
            this.g = w.events !== !1,
            this.f = w.classes !== !1,
            E(this, new D(this.c,w), w)
        }
        ;
        function ce(w, R, z, G, et) {
            var _t = --w.h == 0;
            (w.f || w.g) && setTimeout(function() {
                var Mt = et || null
                  , de = G || null || {};
                if (z.length === 0 && _t)
                    K(R.a);
                else {
                    R.f += z.length,
                    _t && (R.j = _t);
                    var _e, Le = [];
                    for (_e = 0; _e < z.length; _e++) {
                        var Oe = z[_e]
                          , si = de[Oe.c]
                          , Yi = R.a
                          , Dr = Oe;
                        if (Yi.g && h(Yi.f, [Yi.a.c("wf", Dr.c, S(Dr).toString(), "loading")]),
                        P(Yi, "fontloading", Dr),
                        Yi = null,
                        kt === null)
                            if (window.FontFace) {
                                var Dr = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent)
                                  , tb = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                                kt = Dr ? 42 < parseInt(Dr[1], 10) : !tb
                            } else
                                kt = !1;
                        kt ? Yi = new bt(s(R.g, R),s(R.h, R),R.c,Oe,R.s,si) : Yi = new ct(s(R.g, R),s(R.h, R),R.c,Oe,R.s,Mt,si),
                        Le.push(Yi)
                    }
                    for (_e = 0; _e < Le.length; _e++)
                        Le[_e].start()
                }
            }, 0)
        }
        function E(w, R, z) {
            var et = []
              , G = z.timeout;
            O(R);
            var et = W(w.a, z, w.c)
              , _t = new Bt(w.c,R,G);
            for (w.h = et.length,
            R = 0,
            z = et.length; R < z; R++)
                et[R].load(function(Mt, de, _e) {
                    ce(w, _t, Mt, de, _e)
                })
        }
        function M(w, R) {
            this.c = w,
            this.a = R
        }
        M.prototype.load = function(w) {
            function R() {
                if (_t["__mti_fntLst" + G]) {
                    var Mt = _t["__mti_fntLst" + G](), de = [], _e;
                    if (Mt)
                        for (var Le = 0; Le < Mt.length; Le++) {
                            var Oe = Mt[Le].fontfamily;
                            Mt[Le].fontStyle != null && Mt[Le].fontWeight != null ? (_e = Mt[Le].fontStyle + Mt[Le].fontWeight,
                            de.push(new _(Oe,_e))) : de.push(new _(Oe))
                        }
                    w(de)
                } else
                    setTimeout(function() {
                        R()
                    }, 50)
            }
            var z = this
              , G = z.a.projectId
              , et = z.a.version;
            if (G) {
                var _t = z.c.o;
                p(this.c, (z.a.api || "https://fast.fonts.net/jsapi") + "/" + G + ".js" + (et ? "?v=" + et : ""), function(Mt) {
                    Mt ? w([]) : (_t["__MonotypeConfiguration__" + G] = function() {
                        return z.a
                    }
                    ,
                    R())
                }).id = "__MonotypeAPIScript__" + G
            } else
                w([])
        }
        ;
        function F(w, R) {
            this.c = w,
            this.a = R
        }
        F.prototype.load = function(w) {
            var R, z, G = this.a.urls || [], et = this.a.families || [], _t = this.a.testStrings || {}, Mt = new m;
            for (R = 0,
            z = G.length; R < z; R++)
                f(this.c, G[R], g(Mt));
            var de = [];
            for (R = 0,
            z = et.length; R < z; R++)
                if (G = et[R].split(":"),
                G[1])
                    for (var _e = G[1].split(","), Le = 0; Le < _e.length; Le += 1)
                        de.push(new _(G[0],_e[Le]));
                else
                    de.push(new _(G[0]));
            y(Mt, function() {
                w(de, _t)
            })
        }
        ;
        function $(w, R) {
            w ? this.c = w : this.c = Y,
            this.a = [],
            this.f = [],
            this.g = R || ""
        }
        var Y = "https://fonts.googleapis.com/css";
        function rt(w, R) {
            for (var z = R.length, G = 0; G < z; G++) {
                var et = R[G].split(":");
                et.length == 3 && w.f.push(et.pop());
                var _t = "";
                et.length == 2 && et[1] != "" && (_t = ":"),
                w.a.push(et.join(_t))
            }
        }
        function dt(w) {
            if (w.a.length == 0)
                throw Error("No fonts to load!");
            if (w.c.indexOf("kit=") != -1)
                return w.c;
            for (var R = w.a.length, z = [], G = 0; G < R; G++)
                z.push(w.a[G].replace(/ /g, "+"));
            return R = w.c + "?family=" + z.join("%7C"),
            0 < w.f.length && (R += "&subset=" + w.f.join(",")),
            0 < w.g.length && (R += "&text=" + encodeURIComponent(w.g)),
            R
        }
        function tt(w) {
            this.f = w,
            this.a = [],
            this.c = {}
        }
        var it = {
            latin: "BESbswy",
            "latin-ext": "\xE7\xF6\xFC\u011F\u015F",
            cyrillic: "\u0439\u044F\u0416",
            greek: "\u03B1\u03B2\u03A3",
            khmer: "\u1780\u1781\u1782",
            Hanuman: "\u1780\u1781\u1782"
        }
          , Z = {
            thin: "1",
            extralight: "2",
            "extra-light": "2",
            ultralight: "2",
            "ultra-light": "2",
            light: "3",
            regular: "4",
            book: "4",
            medium: "5",
            "semi-bold": "6",
            semibold: "6",
            "demi-bold": "6",
            demibold: "6",
            bold: "7",
            "extra-bold": "8",
            extrabold: "8",
            "ultra-bold": "8",
            ultrabold: "8",
            black: "9",
            heavy: "9",
            l: "3",
            r: "4",
            b: "7"
        }
          , Ct = {
            i: "i",
            italic: "i",
            n: "n",
            normal: "n"
        }
          , yt = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;
        function At(w) {
            for (var R = w.f.length, z = 0; z < R; z++) {
                var G = w.f[z].split(":")
                  , et = G[0].replace(/\+/g, " ")
                  , _t = ["n4"];
                if (2 <= G.length) {
                    var Mt, de = G[1];
                    if (Mt = [],
                    de)
                        for (var de = de.split(","), _e = de.length, Le = 0; Le < _e; Le++) {
                            var Oe;
                            if (Oe = de[Le],
                            Oe.match(/^[\w-]+$/)) {
                                var si = yt.exec(Oe.toLowerCase());
                                if (si == null)
                                    Oe = "";
                                else {
                                    if (Oe = si[2],
                                    Oe = Oe == null || Oe == "" ? "n" : Ct[Oe],
                                    si = si[1],
                                    si == null || si == "")
                                        si = "4";
                                    else
                                        var Yi = Z[si]
                                          , si = Yi || (isNaN(si) ? "4" : si.substr(0, 1));
                                    Oe = [Oe, si].join("")
                                }
                            } else
                                Oe = "";
                            Oe && Mt.push(Oe)
                        }
                    0 < Mt.length && (_t = Mt),
                    G.length == 3 && (G = G[2],
                    Mt = [],
                    G = G ? G.split(",") : Mt,
                    0 < G.length && (G = it[G[0]]) && (w.c[et] = G))
                }
                for (w.c[et] || (G = it[et]) && (w.c[et] = G),
                G = 0; G < _t.length; G += 1)
                    w.a.push(new _(et,_t[G]))
            }
        }
        function Pt(w, R) {
            this.c = w,
            this.a = R
        }
        var Kt = {
            Arimo: !0,
            Cousine: !0,
            Tinos: !0
        };
        Pt.prototype.load = function(w) {
            var R = new m
              , z = this.c
              , G = new $(this.a.api,this.a.text)
              , et = this.a.families;
            rt(G, et);
            var _t = new tt(et);
            At(_t),
            f(z, dt(G), g(R)),
            y(R, function() {
                w(_t.a, _t.c, Kt)
            })
        }
        ;
        function me(w, R) {
            this.c = w,
            this.a = R
        }
        me.prototype.load = function(w) {
            var R = this.a.id
              , z = this.c.o;
            R ? p(this.c, (this.a.api || "https://use.typekit.net") + "/" + R + ".js", function(G) {
                if (G)
                    w([]);
                else if (z.Typekit && z.Typekit.config && z.Typekit.config.fn) {
                    G = z.Typekit.config.fn;
                    for (var et = [], _t = 0; _t < G.length; _t += 2)
                        for (var Mt = G[_t], de = G[_t + 1], _e = 0; _e < de.length; _e++)
                            et.push(new _(Mt,de[_e]));
                    try {
                        z.Typekit.load({
                            events: !1,
                            classes: !1,
                            async: !0
                        })
                    } catch {}
                    w(et)
                }
            }, 2e3) : w([])
        }
        ;
        function ge(w, R) {
            this.c = w,
            this.f = R,
            this.a = []
        }
        ge.prototype.load = function(w) {
            var R = this.f.id
              , z = this.c.o
              , G = this;
            R ? (z.__webfontfontdeckmodule__ || (z.__webfontfontdeckmodule__ = {}),
            z.__webfontfontdeckmodule__[R] = function(et, _t) {
                for (var Mt = 0, de = _t.fonts.length; Mt < de; ++Mt) {
                    var _e = _t.fonts[Mt];
                    G.a.push(new _(_e.name,L("font-weight:" + _e.weight + ";font-style:" + _e.style)))
                }
                w(G.a)
            }
            ,
            p(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + d(this.c) + "/" + R + ".js", function(et) {
                et && w([])
            })) : w([])
        }
        ;
        var oe = new Xt(window);
        oe.a.c.custom = function(w, R) {
            return new F(R,w)
        }
        ,
        oe.a.c.fontdeck = function(w, R) {
            return new ge(R,w)
        }
        ,
        oe.a.c.monotype = function(w, R) {
            return new M(R,w)
        }
        ,
        oe.a.c.typekit = function(w, R) {
            return new me(R,w)
        }
        ,
        oe.a.c.google = function(w, R) {
            return new Pt(R,w)
        }
        ;
        var ui = {
            load: s(oe.load, oe)
        };
        e.exports ? e.exports = ui : (window.WebFont = ui,
        window.WebFontConfig && oe.load(window.WebFontConfig))
    }
    )()
}
)(H1);
var JM = H1.exports;
console.log("[Client info] Cwal-230209A");
const Gg = navigator.language
  , QM = "1.7.0";
localStorage.getItem("settings_version");
const V1 = e=>{
    const t = {
        ...e
    };
    return Object.keys(t).forEach(i=>t[i] = Symbol()),
    t
}
;
let H, tl, bi, B, xn, qf, Jf, Qf, tp, Vs;
function yh(e, t) {
    const i = {
        ...t
    }
      , s = JSON.parse(localStorage.getItem(e));
    return s && Object.keys(i).forEach(n=>{
        i[n] = s[n] ?? i[n]
    }
    ),
    i
}
function z1(e, t) {
    return JSON.parse(localStorage.getItem(e)) ?? [...t]
}
function ep(e, t) {
    return JSON.parse(localStorage.getItem(e)) ?? t
}
H = _i(yh("gconfig", Rd));
tl = yh("mouse_map", G1);
bi = yh("key_map", sc);
B = yh("theme_data", nc);
xn = z1("blocked_users", []);
Jf = z1("profile_data", ZM);
Qf = ep("profile_index", 0);
tp = ep("server", 0);
qf = ep("unit_num", qM);
{
    const e = localStorage.getItem("locale");
    e ? Vs = JSON.parse(e) : (Vs = Pc.indexOf(Gg.replace("-", "_")),
    Vs === -1 && (Vs = Pc.indexOf(Gg.substring(0, 2)),
    Vs === -1 && (Vs = 3)))
}
localStorage.clear();
localStorage.setItem("gconfig", JSON.stringify(H));
localStorage.setItem("mouse_map", JSON.stringify(tl));
localStorage.setItem("key_map", JSON.stringify(bi));
localStorage.setItem("theme_data", JSON.stringify(B));
localStorage.setItem("blocked_users", JSON.stringify(xn));
localStorage.setItem("profile_data", JSON.stringify(Jf));
localStorage.setItem("profile_index", Qf);
localStorage.setItem("server", tp);
localStorage.setItem("locale", Vs);
localStorage.setItem("unit_num", qf);
localStorage.setItem("settings_version", QM);
const Ut = V1(H)
  , Ht = V1(B)
  , tR = Pc[Vs]
  , Gt = {
    packetCount: 0,
    mouseX: 0,
    mouseY: 0,
    svrMouseX: 0,
    svrMouseY: 0,
    syncStamp: performance.now(),
    lastSync: performance.now(),
    fps: 60,
    load: [],
    statistics: [],
    eventReaction: !1,
    renderer: null,
    subRenderer: null
};
function Er() {
    return parseInt(H.AnimationDelay) - 1
}
function eR() {
    return H.CameraDelay
}
const $1 = parseInt(H.Quality);
function Lc() {
    return (B.Text[2] + 2) / 100 * $1
}
function Oc() {
    return B.TextStroke[2] / 1e3 * $1 * 1.1
}
const us = "Sawarabi Mincho, Shippori Mincho, Kiwi Maru, IBM Plex Sans KR, Do Hyeon, Open Sans, Noto Sans, Noto Sans JP, Titillium Web, Noto Sans TC, Noto Sans SC, Noto Sans KR"
  , iR = "\u2039\u203A\xAB\xBB><\u25CA\u25B0\u25B1\u25C6\u25C7\u25CB\u25CE\u25CC\u25CD\u25CF\u25A0\u25A1\u25A2\u25A4\u25A5\u25A6\u25A7\u25A8\u25A9\u201C\u201D\u2018\u2019"
  , sR = "\u3001_\u2013\u2014"
  , nR = "+-\u25C8\u25A3\u25C9\u25AA\u25AB\u25AC\u25AD\u25AE\u25AF"
  , rR = "=*\u2189\u215F\xBD\u2153\u2155\xBC\u2159\u2150\u215B\u2151\u2152\u2154\xBE\u2156\u2157\u2158\u215A\u215C\u215D\u215E\u2105\xD7\u035C"
  , oR = ".\u2026\xB7'\"\u2018\u2019,\u201E[]{}/|\\1234567890a\xE1\xE0\u0103\xE2\xE5\u01FB\xE4\xE3\u0105\u0101\xE6\u01FDbc\u0107\u0109\u010D\u010B\xE7d\u010F\u0111\xF0e\xE9\xE8\u0115\xEA\u011B\xEB\u0117\u0119\u0113f\u0192g\u011F\u011D\u0121\u0123h\u0125\u0127i\xED\xEC\u012D\xEE\xEF\u0129\u012F\u012B\u0131j\u0135k\u0137l\u013A\u013E\u013C\u0142mn\u0144\u0148\xF1\u0146\u014Bo\xF3\xF2\u014F\xF4\xF6\u0151\xF5\xF8\u01FF\u014D\u0153pqr\u0155\u0159\u0157s\u015B\u015D\u0161\u015F\u0219\xDFt\u0165\u0163\u021B\u0167u\xFA\xF9\u016D\xFB\u016F\xFC\u0171\u0169\u0173\u016Bvw\u1E83\u1E81\u0175\u1E85xy\xFD\u1EF3\u0177\xFF\u1EF9z\u017A\u017E\u017C\xFEA\xC1\xC0\u0102\xC2\xC5\u01FA\xC4\xC3\u0104\u0100\xC6\u01FCBC\u0106\u0108\u010C\u010A\xC7D\u010E\u0110\xD0E\xC9\xC8\u0114\xCA\u011A\xCB\u0116\u0118\u0112FG\u011E\u011C\u0120\u0122H\u0124\u0126I\xCD\xCC\u012C\xCE\xCF\u0128\u0130\u012E\u012AJ\u0134K\u0136L\u0139\u013D\u013B\u0141MN\u0143\u0147\xD1\u0145\u014AO\xD3\xD2\u014E\xD4\xD6\u0150\xD5\xD8\u01FE\u014C\u0152PQR\u0154\u0158\u0156S\u015A\u015C\u0160\u015E\u0218T\u0164\u0162\u021A\u0166U\xDA\xD9\u016C\xDB\u016E\xDC\u0170\u0168\u0172\u016AVW\u1E82\u1E80\u0174\u1E84XY\xDD\u1EF2\u0176\u0178\u1EF8Z\u0179\u017D\u017B\xDE`\xB4^\xAF\xA8\xB8\xB0\xA9\xAE+\xB1\xF7\xD7<=>\xAC|\xA6~\xA4\xA2$\xA3\xA5!\xA1?\xBF@#&";
JM.load({
    custom: {
        families: ["Sawarabi Mincho", "Shippori Mincho", "Kiwi Maru", "IBM Plex Sans KR", "Do Hyeon", "Open Sans", "Noto Sans", "Noto Sans JP"],
        urls: ["https://fonts.googleapis.com/css2?family=Sawarabi+Mincho&text=" + iR, "https://fonts.googleapis.com/css2?family=Shippori+Mincho&text=\u300E\u300F\u300C\u300D", "https://fonts.googleapis.com/css2?family=Kiwi+Maru&text=:;\uFF1A\uFF1B\uFF0C\u3002\u201A", "https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR&text=" + sR, "https://fonts.googleapis.com/css2?family=Do+Hyeon&text=" + nR, "https://fonts.googleapis.com/css2?family=Open+Sans&text=\u20AA", "https://fonts.googleapis.com/css2?family=Noto+Sans&text=%", "https://fonts.googleapis.com/css2?family=Noto+Sans+JP&text=" + rR, "https://fonts.googleapis.com/css2?family=Titillium+Web&text=" + oR + ":wght@400..700"]
    },
    google: {
        families: ["Barlow Semi Condensed:200", "Noto Sans TC", "Noto Sans SC", "Noto Sans KR"]
    },
    active() {
        setTimeout(()=>{
            A.emit("initFonts"),
            setTimeout(()=>{
                A.emit("initFonts"),
                setTimeout(()=>{
                    A.emit("refreshNickText")
                }
                , 4e3)
            }
            , 800)
        }
        , 200),
        A.emit("startClient")
    }
});
class $t {
    constructor(t, i, s) {
        I(this, "_func");
        I(this, "_interval");
        I(this, "_intervalFunc");
        I(this, "_endFunc");
        I(this, "executed", !1);
        this._func = t,
        this._intervalFunc = i,
        this._endFunc = s
    }
    execute(t) {
        return this._func(t),
        this._intervalFunc && !this.executed && (this._interval = setInterval(this._intervalFunc, 15)),
        this.executed = !0,
        this
    }
    end() {
        this.executed = !1,
        this._intervalFunc && clearInterval(this._interval),
        this._endFunc && this._endFunc()
    }
}
class aR {
    constructor(t, i, s) {
        this.view = t,
        this._o = i || 0,
        this._e = s
    }
    readUint8() {
        return this.view.getUint8(this._o++, this._e)
    }
    readInt8() {
        return this.view.getInt8(this._o++, this._e)
    }
    readUint16() {
        return this.view.getUint16((this._o += 2) - 2, this._e)
    }
    readInt16() {
        return this.view.getInt16((this._o += 2) - 2, this._e)
    }
    readUint24() {
        const t = this.readUint16();
        return this.readUint8() << 16 | t
    }
    readUint32() {
        return this.view.getUint32((this._o += 4) - 4, this._e)
    }
    readInt32() {
        return this.view.getInt32((this._o += 4) - 4, this._e)
    }
    readFloat32() {
        return this.view.getFloat32((this._o += 4) - 4, this._e)
    }
    readFloat64() {
        return this.view.getFloat64((this._o += 8) - 8, this._e)
    }
    readStringUTF8() {
        let t = "", i;
        for (; (i = this.readUint8()) !== 0; )
            t += String.fromCharCode(i);
        return decodeURIComponent(escape(t))
    }
}
class lR {
    constructor(t) {
        this.__buf = new DataView(new ArrayBuffer(8)),
        this._b = [],
        this._e = t
    }
    writeUint8(t) {
        return t >= 0 && t < 256 && this._b.push(t),
        this
    }
    writeInt8(t) {
        return t >= -128 && t < 128 && this._b.push(t),
        this
    }
    writeUint16(t) {
        return this.__buf.setUint16(0, t, this._e),
        this._move(2),
        this
    }
    writeInt16(t) {
        return this.__buf.setInt16(0, t, this._e),
        this._move(2),
        this
    }
    writeUint32(t) {
        return this.__buf.setUint32(0, t, this._e),
        this._move(4),
        this
    }
    writeUint64(t) {
        let i = t / 4294967296 >> 0
          , s = t - i * 2 ** 32;
        return this.writeUint32(i),
        this.writeUint32(s),
        this
    }
    writeInt32(t) {
        return this.__buf.setInt32(0, t, this._e),
        this._move(4),
        this
    }
    writeFloat32(t) {
        return this.__buf.setFloat32(0, t, this._e),
        this._move(4),
        this
    }
    writeFloat64(t) {
        return this.__buf.setFloat64(0, t, this._e),
        this._move(8),
        this
    }
    writeStringUTF8(t) {
        return this._b.push(...new TextEncoder("utf-8").encode(t)),
        this._b.push(0),
        this
    }
    _move(t) {
        for (var i = 0; i < t; i++)
            this._b.push(this.__buf.getUint8(i))
    }
}
class wi {
    constructor(t, i) {
        I(this, "capacity");
        I(this, "pool");
        I(this, "Type");
        this.Type = t,
        this.pool = new Array(i),
        this.capacity = i;
        for (let s = 0; s < i; s++)
            this.pool[s] = new t
    }
    expand(t) {
        for (let i = 0; i < t; i++)
            this.pool.push(new Type)
    }
    allocate() {
        return this.pool.length <= 0 ? new this.Type : this.pool.pop()
    }
    release(t) {
        this.pool.length <= this.capacity * 1.125 && this.pool.push(t)
    }
}
const We = parseInt(H.Quality)
  , on = Math.max(parseInt(H.Resolution), 1)
  , rc = .01
  , cR = Hi.LINEAR;
He._experimentalLetterSpacingSupported = !0;
He.experimentalLetterSpacing = !0;
Ot.defaultOptions.scaleMode = cR;
Ot.defaultOptions.mipmap = H.Mipmap * 2;
A.on(Ut.Mipmap, ()=>{
    Ot.defaultOptions.mipmap = H.Mipmap * 2,
    Object.values(mi).forEach(e=>{
        e.mipmap = H.Mipmap * 2
    }
    ),
    A.emit(Ht.Text)
}
);
const bh = 16
  , As = new wi(hi,bh)
  , kd = new wi(ae,bh)
  , j1 = new wi(ke,bh)
  , W1 = new wi(ys,bh)
  , ie = new Map
  , mt = We * on
  , el = (e,t,i)=>{
    const s = document.createElement("canvas")
      , n = s.getContext("2d");
    s.width = mt * 2,
    s.height = mt * 2,
    n.fillStyle = "#ffffff",
    n.beginPath(),
    t ? (n.arc(mt, mt, mt, 0, Math.PI * 2, !1),
    n.arc(mt, mt, mt * t, 0, Math.PI * 2, !0),
    n.fill()) : (n.arc(mt, mt, mt, 0, Math.PI * 2, !1),
    n.fill()),
    i && (n.beginPath(),
    n.arc(mt, mt, mt * ((1 - t) / 2 + t), 0, Math.PI * 2),
    n.globalAlpha = i,
    n.fill());
    const r = ht.from(s, {
        resolution: on
    })
      , o = ie.get(e);
    o ? (o.baseTexture = r.baseTexture,
    r.destroy()) : ie.set(e, r)
}
;
el("BASE");
el("ROUND_VIRUS", .865, .2);
const X1 = (e,t,i,s)=>{
    const n = document.createElement("canvas")
      , r = n.getContext("2d")
      , o = mt * .0625;
    n.width = (mt + o) * 2,
    n.height = (mt + o) * 2,
    r.fillStyle = "#ffffff",
    r.strokeStyle = "#ffffff",
    r.lineWidth = mt * i,
    r.lineJoin = "round";
    const a = mt + o
      , l = 360 / t / 180 * Math.PI
      , c = l / 2
      , h = mt * (1 - i / 2) + o
      , u = mt * (1 - i / 2) - o;
    for (let p = 0; p <= t; p++)
        r.lineTo(Math.cos(p * l) * h + a, -Math.sin(p * l) * h + a),
        r.lineTo(Math.cos(p * l + c) * u + a, -Math.sin(p * l + c) * u + a);
    r.closePath(),
    r.stroke(),
    r.globalAlpha = s,
    r.fill();
    const d = ht.from(n, {
        resolution: on
    })
      , f = ie.get(e);
    f ? (f.baseTexture = d.baseTexture,
    d.destroy()) : ie.set(e, d)
}
;
X1("VIRUS", 25, .08, .2);
X1("CVIRUS", 30, .0625, .2);
const hR = (e,t,i,s,n)=>{
    const r = document.createElement("canvas")
      , o = r.getContext("2d");
    r.width = mt * 2,
    r.height = mt * 2,
    o.fillStyle = "#ffffff",
    o.strokeStyle = "#ffffff",
    o.lineWidth = mt * i,
    o.lineJoin = "round";
    const a = 360 / t / 180 * Math.PI
      , l = mt * (1 - i / 2);
    for (let u = 0; u <= t; u++)
        o.lineTo(Math.cos(u * a) * l + mt, -Math.sin(u * a) * l + mt);
    o.closePath(),
    o.stroke(),
    o.globalAlpha = s,
    o.fill();
    const c = ht.from(r, {
        resolution: on
    })
      , h = ie.get(e);
    h ? (h.baseTexture = c.baseTexture,
    c.destroy()) : ie.set(e, c)
}
;
hR("BLASTER_SPORE", 8, .2, .2);
const Y1 = ()=>{
    const e = 1 - B.MassMarker[2] / 100;
    el("MASS_MARKER", e)
}
  , K1 = ()=>{
    const e = 1 - B.SplitOrderMarker[2] / 100;
    el("SPLIT_ORDER_MARKER", e)
}
  , Z1 = ()=>{
    const e = 1 - B.AutosplitAlert[2] / 100;
    el("AUTOSPLIT_ALERT1", e)
}
  , q1 = ()=>{
    const e = document.createElement("canvas")
      , t = e.getContext("2d");
    e.width = mt * 2,
    e.height = mt * 2,
    t.fillStyle = "#ffffff";
    let s = B.AutosplitAlert[2] / 100 * .618;
    t.beginPath(),
    t.arc(mt, mt, mt, 0, Math.PI * 2, !1),
    t.arc(mt, mt, mt * (1 - s), 0, Math.PI * 2, !0),
    t.fill(),
    s *= .618,
    t.beginPath(),
    t.arc(mt, mt, mt * (1 - s * 2.275), 0, Math.PI * 2, !1),
    t.arc(mt, mt, mt * (1 - s * 3.275), 0, Math.PI * 2, !0),
    t.fill();
    const n = ht.from(e, {
        resolution: on
    })
      , r = "AUTOSPLIT_ALERT2"
      , o = ie.get(r);
    o ? (o.baseTexture = n.baseTexture,
    n.destroy()) : ie.set(r, n)
}
  , uR = ()=>{
    const e = document.createElement("canvas")
      , t = e.getContext("2d");
    e.width = mt * 2,
    e.height = mt * 2,
    t.lineJoin = "round",
    t.fillStyle = "#000000",
    t.globalAlpha = .3,
    t.beginPath(),
    t.arc(mt, mt, mt, 0, Math.PI * 2, !1),
    t.fill(),
    t.globalAlpha = .8,
    t.fillStyle = "#ffffff",
    t.beginPath(),
    t.arc(mt, mt, mt * .935, 0, Math.PI * 2, !1),
    t.arc(mt, mt, mt * .8, 0, Math.PI * 2, !0),
    t.fill(),
    t.strokeStyle = "#ffffff",
    t.lineWidth = mt * .1;
    const i = (.707 - .14) * mt;
    t.beginPath(),
    t.moveTo(mt + i, mt - i),
    t.lineTo(mt - i, mt + i),
    t.stroke();
    const s = ht.from(e, {
        resolution: on
    })
      , n = "ENEMY_HINT"
      , r = ie.get(n);
    r ? (r.baseTexture = s.baseTexture,
    s.destroy()) : ie.set(n, s)
}
  , dR = ()=>{
    const e = document.createElement("canvas")
      , t = e.getContext("2d");
    e.width = mt * 2,
    e.height = mt * 2;
    const i = t.createRadialGradient(mt, mt, mt * .75, mt, mt, mt);
    i.addColorStop(0, "transparent"),
    i.addColorStop(1, "white"),
    t.fillStyle = i,
    t.beginPath(),
    t.arc(mt, mt, mt, 0, Math.PI * 2, !1),
    t.fill();
    const s = ht.from(e, {
        resolution: on
    })
      , n = "WAVE"
      , r = ie.get(n);
    r ? (r.baseTexture = s.baseTexture,
    s.destroy()) : ie.set(n, s)
}
  , fR = ()=>{
    const e = document.createElement("canvas")
      , t = e.getContext("2d")
      , i = mt / 4
      , s = i * .5
      , n = i * .2;
    e.width = i,
    e.height = i,
    t.fillStyle = "#ffffff",
    t.moveTo(n, 0),
    t.lineTo(0, n),
    t.lineTo(s, s),
    t.closePath(),
    t.moveTo(i - n, 0),
    t.lineTo(i, n),
    t.lineTo(s, s),
    t.closePath(),
    t.moveTo(i - n, i),
    t.lineTo(i, i - n),
    t.lineTo(s, s),
    t.closePath(),
    t.moveTo(n, i),
    t.lineTo(0, i - n),
    t.lineTo(s, s),
    t.closePath(),
    t.fill();
    const r = ht.from(e, {
        resolution: on
    })
      , o = "MOVE_POINT"
      , a = ie.get(o);
    a ? (a.baseTexture = r.baseTexture,
    r.destroy()) : ie.set(o, r)
}
;
uR();
Y1();
K1();
Z1();
q1();
dR();
fR();
A.on(Ht.MassMarker, Y1);
A.on(Ht.SplitOrderMarker, K1);
A.on(Ht.AutosplitAlert, ()=>{
    Z1(),
    q1()
}
);
const J1 = [14483642, 16711680, 16737792, 16776960, 65535, 2003199, 2088735, 32e3, 204]
  , Hg = new ki({
    fontFamily: "Barlow Semi Condensed",
    fontWeight: "200",
    fill: 16777215,
    fontSize: 400
});
class pR extends ae {
    constructor() {
        super();
        I(this, "canvas", document.createElement("canvas"));
        I(this, "background", new hi);
        I(this, "mask", new ke);
        I(this, "border", new ke);
        I(this, "borderGlow", new hi);
        I(this, "borderGlowMask", new ke);
        I(this, "innerWidth", 0);
        I(this, "innerHeight", 0);
        I(this, "edge", new ke);
        I(this, "coords", new ke);
        I(this, "coordsText", new ae)
    }
    get coordsFontTint() {
        return parseInt(`0x${B.CoordsFont[0]}`)
    }
    get coordsFontAlpha() {
        return B.CoordsFont[1]
    }
    get coordsGridTint() {
        return parseInt(`0x${B.CoordsGrid[0]}`)
    }
    get coordsGridAlpha() {
        return B.CoordsGrid[1]
    }
    get borderTint() {
        return parseInt(`0x${B.Border[0]}`)
    }
    get borderAlpha() {
        return B.Border[1]
    }
    get borderGlowTint() {
        return parseInt(`0x${B.BorderGlow[0]}`)
    }
    get borderGlowAlpha() {
        return B.BorderGlow[1]
    }
    get backgroundTint() {
        return parseInt(`0x${B.BackgroundImage[0]}`)
    }
    get backgroundAlpha() {
        return B.BackgroundImage[1]
    }
    get url() {
        return B.BackgroundImage[2]
    }
    init() {
        this.background.mask = this.mask,
        this.coords.mask = this.mask,
        this.coordsText.mask = this.mask,
        this.borderGlow.mask = this.borderGlowMask,
        this.coords.blendMode = j.NONE,
        this.edge.blendMode = j.NONE,
        this.borderGlow.texture = ht.from(this.canvas, {
            mipmap: ds.ON
        }),
        this.borderGlow.blendMode = j.LIGHTEN;
        let i;
        for (let s = 0; s < 25; s++)
            i = new ys("",Hg),
            i.scale.set(4),
            this.coordsText.addChild(i)
    }
    deploy() {
        this.deployBackgroundStyle(),
        this.deployBorderStyle(),
        this.deployCoordsStyle()
    }
    deployBackgroundStyle() {
        this.background.tint = this.backgroundTint,
        this.background.alpha = this.backgroundAlpha
    }
    deployBorderStyle() {
        this.border.tint = this.borderTint,
        this.border.alpha = this.borderAlpha,
        this.borderGlow.tint = this.borderGlowTint,
        this.borderGlow.alpha = this.borderGlowAlpha
    }
    deployCoordsStyle() {
        const i = this.coordsGridTint
          , s = this.coordsGridAlpha;
        this.edge.tint = i,
        this.edge.alpha = s,
        this.coords.tint = i,
        this.coords.alpha = s,
        this.coordsText.tint = this.coordsFontTint,
        this.coordsText.alpha = this.coordsFontAlpha
    }
    assembly() {
        this.addChild(this.background, this.mask, this.borderGlowMask, this.coords, this.coordsText, this.edge, this.borderGlow, this.border)
    }
    setup() {
        return this.init(),
        this.deploy(),
        this.assembly(),
        this
    }
    drawRectBorderGlow(i, s, n, r) {
        const [a,l,c,h] = Bg(i, s, n, r, 37.5)
          , u = 3250
          , d = l - a
          , f = h - c;
        this.innerWidth = d,
        this.innerHeight = f;
        const p = u / d
          , m = f / d * u / d
          , g = this.canvas
          , y = g.getContext("2d")
          , x = 325 * p + 5
          , v = 50 * p >> 0;
        g.width = u + x * 2,
        g.height = f / d * u + x * 2,
        y.lineWidth = v,
        y.strokeStyle = "#ffffff",
        y.globalAlpha = 1,
        y.shadowBlur = 0,
        y.shadowColor = "#ffffff",
        y.beginPath();
        const _ = (a - i) * p + x + v
          , C = (c - n) * m + x + v
          , k = u
          , S = u * f / d;
        y.rect(_, C, k, S),
        y.save(),
        y.clip(),
        y.globalAlpha = .75,
        y.shadowBlur = x,
        y.stroke(),
        y.restore(),
        y.globalAlpha = 1,
        y.shadowBlur = x * .625,
        y.stroke(),
        y.globalAlpha = .75,
        y.stroke(),
        y.shadowBlur = x * .5,
        y.stroke(),
        this.borderGlow.texture.update();
        const T = 37.5 * p
          , L = 37.5 * m;
        this.borderGlow.position.set(a - (x + v + 1 - T) / p, c - (x + v + 1 - L) / p),
        this.borderGlow.scale.set(1 / p);
        const [D,O,K,P] = Bg(i, s, n, r, 75);
        this.borderGlowMask.beginFill(16777215, 1).drawRect(i, n, s - i, r - n).endFill().lineStyle({
            width: 500,
            color: 16777215,
            alignment: 1,
            alpha: 1
        }).drawRect(D, K, O - D, P - K)
    }
    drawOctaBorderGlow(i) {
        const n = Ug(i, 37.5)
          , r = 3250
          , [o,a,l,c] = [n[14], n[1], n[6], n[9]]
          , h = l - o
          , u = c - a;
        this.innerWidth = h,
        this.innerHeight = u;
        const d = r / h
          , f = u / h * r / h
          , p = this.canvas
          , m = p.getContext("2d")
          , g = 325 * d + 5
          , y = 50 * d >> 0;
        p.width = r + g * 2 + y,
        p.height = u / h * r + g * 2 + y,
        m.lineWidth = y,
        m.strokeStyle = "#ffffff",
        m.globalAlpha = 1,
        m.shadowBlur = 0,
        m.shadowColor = "#ffffff";
        let x, v, _ = n.length;
        m.beginPath();
        for (let T = 0; T < _; )
            x = (n[T++] - (o + 37.5)) * d + g + y,
            v = (n[T++] - (a + 37.5)) * f + g + y,
            m.lineTo(x, v);
        m.closePath(),
        m.save(),
        m.clip(),
        m.globalAlpha = .75,
        m.shadowBlur = g,
        m.stroke(),
        m.restore(),
        m.globalAlpha = 1,
        m.shadowBlur = g * .625,
        m.stroke(),
        m.globalAlpha = .75,
        m.stroke(),
        m.shadowBlur = g * .5,
        m.stroke(),
        this.borderGlow.texture.update();
        const C = 37.5 * d
          , k = 37.5 * f;
        this.borderGlow.position.set(o - (g + y + 1 - C) / d, a - (g + y + 1 - k) / d),
        this.borderGlow.scale.set(1 / d);
        const S = Ug(i, 75);
        this.borderGlowMask.beginFill(16777215, 1).drawPolygon(i).endFill().lineStyle({
            width: 500,
            color: 16777215,
            alignment: 1,
            alpha: 1
        }).drawPolygon(S)
    }
    drawCoords(i, s, n, r, o) {
        const a = (n - i) / 5
          , l = (r - s) / 5
          , c = this.coords;
        c.lineStyle(o, 16777215, .5);
        var h, u;
        for (let g = 1; g < 5; g++)
            h = g * a + i,
            u = g * l + s,
            c.moveTo(h, s).lineTo(h, r).moveTo(i, u).lineTo(n, u);
        let d, f, p;
        Hg.fontSize = 155 * o / 10;
        const m = this.coordsText.children;
        for (let g = m.length - 1; g >= 0; g--)
            p = m[g],
            p.visible = !0,
            f = g % 5,
            d = g / 5 >> 0,
            p.text = String.fromCharCode(65 + d) + (f + 1),
            p.x = f * a + a / 2 - p.width / 2 + i,
            p.y = d * l + l / 2 - p.height / 2 + s
    }
    drawRectMap(i, s, n, r) {
        this.clear(),
        this.mask.beginFill(16777215).drawRect(i, n, s - i, r - n).endFill(),
        this.border.lineStyle({
            width: 75,
            color: 16777215,
            alignment: 1,
            alpha: 1
        }).drawRect(i, n, s - i, r - n).endFill(),
        this.drawRectBorderGlow(i, s, n, r);
        const [o,a,l,c] = [i, n, s, r]
          , h = (l - o + c - a) / 14142 * 10;
        this.edge.lineStyle({
            width: h,
            color: 16777215,
            alignment: .5,
            alpha: .5
        }).drawRect(i, n, s - i, r - n).endFill(),
        this.drawCoords(o, a, l, c, h),
        this.background.position.set(o, a)
    }
    drawOctagonMap(i) {
        this.clear(),
        this.mask.beginFill(16777215).drawPolygon(i).endFill(),
        this.border.lineStyle({
            width: 75,
            color: 16777215,
            alignment: 1,
            alpha: 1
        }).drawPolygon(i).endFill(),
        this.drawOctaBorderGlow(i);
        const [s,n,r,o] = [i[14], i[1], i[6], i[9]]
          , a = r - s
          , l = o - n
          , c = (a + l) / 14142 * 10;
        this.edge.lineStyle({
            width: c,
            color: 16777215,
            alignment: .5,
            alpha: .5
        }).drawPolygon(i).endFill(),
        this.drawCoords(s, n, r, o, c),
        this.background.position.set(s, n)
    }
    async drawBackground() {
        const {url: i} = this;
        this._url = i,
        i ? this.background.texture = await mR(i, this.innerWidth, this.innerHeight).catch(s=>null) : this.background.texture = null
    }
    clear() {
        this.mask.clear(),
        this.border.clear(),
        this.borderGlowMask.clear(),
        this.coords.clear();
        const i = this.coordsText.children;
        for (let s = i.length - 1; s >= 0; s--)
            i[s].visible = !1;
        this.edge.clear(),
        this.canvas.width = 0,
        this.canvas.height = 0,
        this.borderGlow.texture.update()
    }
    reset() {
        this.clear()
    }
}
async function mR(e, t, i) {
    const s = new Image;
    s.crossOrigin = "Anonymous",
    s.src = e;
    let n = null;
    if (!(await s.decode().catch(r=>r)instanceof Error)) {
        const r = Math.min(t, i)
          , o = Math.min(s.width, s.height)
          , a = r / o;
        s.width *= a,
        s.height *= a,
        n = ht.from(s)
    }
    return n
}
var ue = (e,t)=>{
    const i = e.__vccOpts || e;
    for (const [s,n] of t)
        i[s] = n;
    return i
}
;
const gR = {
    props: {
        max: String,
        val: Number
    },
    setup(e, {emit: t}) {
        const i = ut(null)
          , s = ut(null)
          , n = ut(null)
          , r = Ft(()=>o(e.max));
        function o(u) {
            const d = u % 25
              , f = (u - d) / 25 % 60;
            return (u - d - f * 25) / 60 + ":" + kc(f) + "." + kc(d)
        }
        function a(u) {
            const [d,f] = u.split(":")
              , [p,m] = f.split(".");
            return d * 60 * 25 + p * 25 + m * 1
        }
        function l(u) {
            let d = (u - 0) / (e.max - 0);
            isNaN(d) && (d = 0);
            const f = `${d * 92.5}%`;
            i.value.style.width = f,
            n.value.value = o(u)
        }
        function c() {
            if (/^\d{1,2}:\d\d\.\d\d$/.test(n.value.value)) {
                let d = a(n.value.value);
                d = d < 0 ? 0 : d > e.max ? e.max : d,
                h(d)
            } else
                h(s.value.value)
        }
        function h(u) {
            n.value.value = o(u),
            t("changeVal", Number(u))
        }
        return Aa(()=>e.val, (u,d)=>l(u)),
        Ve(()=>{
            l(e.val)
        }
        ),
        Pr(()=>{
            l(e.val)
        }
        ),
        {
            selection: i,
            slider: s,
            valEl: n,
            duration: r,
            checkStyle: l,
            checkVal: c,
            change: h
        }
    }
}
  , vR = {
    class: "slider-row"
}
  , _R = {
    class: "slider-name"
}
  , yR = {
    class: "slider-input"
}
  , bR = ["value"]
  , xR = {
    class: "slider-box"
}
  , wR = {
    ref: "selection",
    class: "slider-selection"
}
  , TR = {
    class: "slider-track"
}
  , ER = ["max", "value"];
function SR(e, t, i, s, n, r) {
    return st(),
    nt("div", vR, [b("label", _R, Dt(" / " + s.duration), 1), b("div", yR, [b("input", {
        ref: "valEl",
        type: "text",
        class: "rounded-0 form-control",
        tabindex: "-1",
        value: "0:00.00",
        onBlur: t[0] || (t[0] = (...o)=>s.checkVal && s.checkVal(...o))
    }, null, 40, bR)]), b("div", xR, [b("div", wR, null, 512), b("div", TR, [b("input", {
        ref: "slider",
        class: "slider",
        type: "range",
        min: 0,
        max: i.max,
        step: 1,
        value: i.val,
        onInput: t[1] || (t[1] = o=>s.change(o.target.value))
    }, null, 40, ER)])])])
}
var CR = ue(gR, [["render", SR], ["__scopeId", "data-v-bf5f766c"]]);
let AR = 0;
class xh {
    constructor() {
        I(this, "id");
        I(this, "ox");
        I(this, "oy");
        I(this, "or");
        I(this, "nx");
        I(this, "ny");
        I(this, "nr");
        I(this, "massValue");
        I(this, "finalAlpha");
        I(this, "lastSync");
        I(this, "floatTime");
        I(this, "uSig");
        I(this, "state");
        I(this, "__v_skip", !0);
        I(this, "baseLayer", new hi)
    }
    get displayObject() {
        return this.baseLayer
    }
    get x() {
        return this.displayObject.x
    }
    get y() {
        return this.displayObject.y
    }
    get r() {
        return this.displayObject.scale.x * We
    }
    get globalScale() {
        return this.r * ba.scale.x
    }
    get baseLayerTint() {
        return 16777215
    }
    get baseLayerAlpha() {
        return 1
    }
    get textVisibility() {
        return this.globalScale > 35
    }
    get moved() {
        return Ui(this.ox, this.nx, rc) && Ui(this.oy, this.ny, rc)
    }
    get resized() {
        return Ui(this.or, this.nr, rc)
    }
    get dead() {
        return Ui(0, .9 * Er(), performance.now() - this.floatTime)
    }
    get transparencyStatus() {
        return Ui(this.displayObject.alpha, this.finalAlpha, .05)
    }
    setPosition(t, i) {
        this.displayObject.position.set(t, i)
    }
    setSize(t) {
        this.displayObject.zIndex = t >> 0,
        this.displayObject.scale.set(t / We)
    }
    setAlpha(t) {
        this.displayObject.alpha = t
    }
    updateText() {}
    sync() {
        this.ox = this.x,
        this.oy = this.y,
        this.or = this.r
    }
    preUpdate(t, i, s) {
        s && (this.nr = s ** .5 * 10),
        this.nx = t ?? this.nx,
        this.ny = i ?? this.ny,
        this.massValue = s ?? this.massValue
    }
    preDeath(t) {
        this.floatTime = t,
        this.update_linear(vi(Gt.syncStamp, t, Er() * 1.08)),
        this.sync()
    }
    preDisappear(t) {
        this.floatTime = t,
        this.finalAlpha = 0
    }
    preAppear(t) {
        this.floatTime = t,
        this.setAlpha(0)
    }
    fixPosition() {
        const t = this.moved;
        return t && (this.ox = this.nx,
        this.oy = this.ny,
        this.setPosition(this.nx, this.ny)),
        t
    }
    fixSize() {
        const t = this.resized;
        return t && (this.or = this.nr,
        this.setSize(this.nr)),
        t
    }
    fixUpdate() {
        const t = this.fixPosition()
          , i = this.fixSize();
        return t && i
    }
    fixDeath() {
        const t = this.dead;
        return t && this.release(),
        t
    }
    fixDisappear() {
        const t = this.transparencyStatus;
        return t && this.release(),
        t
    }
    fixAppear() {
        const t = this.transparencyStatus;
        return t && this.setAlpha(this.finalAlpha),
        t
    }
    move(t, i, s, n, r) {
        this.setPosition(Ze(t, s, r), Ze(i, n, r))
    }
    resize(t, i, s) {
        this.setSize(Ze(t, i, s))
    }
    update(t, i, s, n, r, o, a) {
        return this.moved || this.move(t, i, n, r, a),
        this.resized || this.resize(s, o, a),
        this.fixUpdate()
    }
    update_linear(t) {
        return this.update(this.ox, this.oy, this.or, this.nx, this.ny, this.nr, t)
    }
    update_gradually(t) {
        return this.update(this.x, this.y, this.r, this.nx, this.ny, this.nr, t)
    }
    death(t) {
        return this.update(this.ox, this.oy, this.or, this.nx, this.ny, this.nr, vi(this.floatTime, t, Er() * 1.08) ** 2),
        this.fixDeath()
    }
    disappear(t) {
        return this.setAlpha(Ze(this.displayObject.alpha, this.finalAlpha, vi(this.floatTime, t, 400))),
        this.fixDisappear()
    }
    appear(t) {
        return this.setAlpha(Ze(this.displayObject.alpha, this.finalAlpha, vi(this.floatTime, t, 400))),
        this.fixAppear()
    }
    init(t, i, s, n, r) {
        return this.id = i,
        this._init(t, s, n, r),
        this.displayObject.interactive = !1,
        ti.state || (this.uSig = AR++),
        this
    }
    _init(t, i, s, n) {
        const r = n ** .5 * 10;
        this.massValue = n,
        this.ox = this.nx = i,
        this.oy = this.ny = s,
        this.or = this.nr = r,
        this.lastSync = t,
        this.setPosition(this.ox, this.oy),
        this.setSize(this.or)
    }
    deploy() {
        return this.deployBaseLayerStyle(),
        this
    }
    deployBaseLayerStyle() {
        this.baseLayer.tint = this.baseLayerTint,
        this.finalAlpha = this.baseLayerAlpha,
        this.setAlpha(this.baseLayerAlpha)
    }
    assembly() {}
    release() {}
}
class ip extends xh {
    constructor() {
        super(...arguments);
        I(this, "box", new ae);
        I(this, "mass", new $e("",{
            fontName: "ENTITY_TEXT"
        }))
    }
    get displayObject() {
        return this.box
    }
    get massVisibility() {
        return this.textVisibility
    }
    get massTint() {
        return 16777215
    }
    get massAlpha() {
        return 1
    }
    setSize(i) {
        super.setSize(i),
        this.updateMass(i),
        this.checkTextScale()
    }
    updateText() {
        this.mass.updateText()
    }
    fixSize() {
        const i = this.resized;
        return i && (this.or = this.nr,
        this.setSize(this.nr),
        this.mass.text = this.massValue >> 0),
        i
    }
    updateMass(i) {
        this.mass.text = (this.massValue + i ** 2 / 100) / 2 >> 0
    }
    init(i, s, n, r, o) {
        return super.init(i, s, n, r, o),
        this.mass.position.set(0),
        this.mass.anchor.set(.5),
        this.mass.letterSpacing = 4,
        this.fixSize(this.r),
        this
    }
    checkTextScale() {
        this.deployMassVisibility()
    }
    deploy() {
        return super.deploy(),
        this.deployMassStyle(),
        this.deployMassVisibility(),
        this
    }
    deployMassVisibility() {
        this.mass.visible = this.massVisibility
    }
    deployMassStyle() {
        this.mass.tint = this.massTint,
        this.mass.alpha = this.massAlpha
    }
    assembly() {
        this.box.addChild(this.baseLayer, this.mass)
    }
}
class sp extends ip {
    constructor(i=!1) {
        super();
        I(this, "massLevel", -1);
        I(this, "asaColor", -1);
        I(this, "assistance", kd.allocate());
        I(this, "tag", As.allocate());
        I(this, "nick", As.allocate());
        I(this, "color");
        I(this, "player");
        I(this, "opUnit");
        I(this, "MassMarker", As.allocate());
        I(this, "AutosplitAlert", As.allocate());
        I(this, "EnemyHint", As.allocate());
        this.box.on("mousedown", s=>this.onDown(s)),
        this.box.on("pointerdown", s=>this.onDown(s)),
        this.baseLayer.texture = ie.get("BASE"),
        this.baseLayer.position.set(0),
        this.baseLayer.scale.set(1),
        this.baseLayer.anchor.set(.5),
        this.tag.position.set(0),
        this.tag.scale.set(1),
        this.tag.anchor.set(.5),
        this.nick.position.set(0),
        this.nick.scale.set(1),
        this.nick.anchor.set(.5),
        this.mass.position.set(0, We * .45),
        this.assistance.position.set(-We),
        this.assistance.scale.set(1),
        this.MassMarker.texture = ie.get("MASS_MARKER"),
        this.EnemyHint.texture = ie.get("ENEMY_HINT"),
        this.AutosplitAlert.texture = ie.get("AUTOSPLIT_ALERT1"),
        i || this.assembly()
    }
    get type() {
        return this.state == 1 ? 110 : 111
    }
    get inSelfTeam() {
        return U.team == this.player.team
    }
    get skinVisibility() {
        return H.ShowSkin && this.skinAlpha
    }
    get nickVisibility() {
        return this.textVisibility && H.ShowNick
    }
    get massVisibility() {
        return this.textVisibility && H.ShowMass
    }
    get entityTint() {
        return this.inSelfTeam ? Be(B.CellTeam[0]) ?? this.color : Be(B.CellEnemy[0]) ?? this.color
    }
    get entityAlpha() {
        return this.inSelfTeam ? B.CellTeam[1] : B.CellEnemy[1]
    }
    get skinTint() {
        return this.inSelfTeam ? Be(B.SkinTeam[0]) : Be(B.SkinEnemy[0])
    }
    get skinAlpha() {
        return this.inSelfTeam ? B.SkinTeam[1] : B.SkinEnemy[1]
    }
    get MassMarkerAlpha() {
        return B.MassMarker[1]
    }
    get MassMarkerSize() {
        return B.MassMarker[2]
    }
    get AutosplitAlertAlpha() {
        return B.AutosplitAlert[1]
    }
    get AutosplitAlertSize() {
        return B.AutosplitAlert[2]
    }
    get EnemyHintVisibility() {
        return U.state % 2 && H.ShowEnemyHint && !this.opUnit.isBot && !this.inSelfTeam
    }
    get interactive() {
        return U.state >= 2
    }
    set interactive(i) {
        this.box.interactive = i
    }
    get viewport() {
        const i = this.nr * 1.125 + 256
          , s = this.nr * 1.125 + 154;
        return {
            x: this.nx - i,
            y: this.ny - s,
            w: i,
            h: s,
            color: U.state === 2 ? 16777215 : this.color
        }
    }
    setNick() {
        const i = this.player.team.tagText;
        this.tag.texture = i ? i.texture : null,
        this.nick.texture = this.opUnit.nickText.texture
    }
    preDeath(i) {
        super.preDeath(i),
        this.unbindOpUnit()
    }
    preDisappear(i) {
        super.preDisappear(i),
        this.unbindOpUnit()
    }
    resize(i, s, n) {
        super.resize(i, s, n)
    }
    syncUpdate() {
        this.updateMassLevel()
    }
    frameUpdate() {
        this.updateAutosplitAlert(),
        this.drawAssistance(),
        this.EnemyHint.visible = this.EnemyHintVisibility,
        this.EnemyHint.tint = this.player.team.color
    }
    updateMassLevel() {
        if (!U.largest) {
            this.massLevel != -1 && (this.massLevel = -1,
            this.assistance.needUpdate = !0);
            return
        }
        let s = this.massValue
          , n = U.largest.massValue
          , r = 4 * n * 1.3
          , o = 2 * n * 1.3
          , a = n * 1.3
          , l = n / 1.3
          , c = n / 2 * 1.3
          , h = n / 2 / 1.3
          , u = n / 4 / 1.3
          , d = n / 8 * 1.3
          , f = n / 8 / 1.3
          , p = s > r ? 0 : s > o ? 1 : s > a ? 2 : s > l ? 3 : s > c ? 4 : s > h ? 5 : s > u ? 6 : s > d ? 7 : s > f ? 8 : -1;
        this.massLevel != p && (this.massLevel = p,
        this.assistance.needUpdate = !0)
    }
    updateAutosplitAlert() {
        if (this.massValue < 17188.5) {
            this.asaColor != -1 && (this.asaColor = -1,
            this.assistance.needUpdate = !0);
            return
        }
        let i = Gt.lastFrame / (16 * 25) * .5 % 1 * 2;
        i > 1 && (i = 2 - i);
        let s = i * (.33 - 0) + 0;
        this.asaColor = 16777215 & function(n, r, o, a) {
            let l = (1 - r) * o
              , c = o - l
              , h = 6 * n
              , u = 0
              , d = 0
              , f = 0;
            return h < 1 ? (u = o,
            d = h * c + l,
            f = l) : h < 2 ? (u = (2 - h) * c + l,
            d = o,
            f = l) : h < 3 ? (u = l,
            d = o,
            f = (h - 2) * c + l) : h < 4 ? (u = l,
            d = (4 - h) * c + l,
            f = o) : h < 5 ? (u = (h - 4) * c + l,
            d = l,
            f = o) : (u = o,
            d = l,
            f = (6 - h) * c + l),
            255 * a >> 0 << 24 | 255 * u >> 0 << 16 | 255 * d >> 0 << 8 | 255 * f >> 0
        }(s, 1, 1, 1),
        this.assistance.needUpdate = !0
    }
    drawAssistance() {
        if (!this.assistance.needUpdate)
            return;
        const i = this.MassMarker
          , s = this.AutosplitAlert;
        i.visible = !1,
        s.visible = !1,
        this.assistance.needUpdate = !1;
        let n, r;
        if (H.ShowAutosplitAlert && this.asaColor != -1) {
            n = this.asaColor,
            r = this.AutosplitAlertAlpha,
            s.visible = !0,
            s.tint = n,
            s.alpha = r,
            this.massValue < 2e4 ? s.texture = ie.get("AUTOSPLIT_ALERT1") : s.texture = ie.get("AUTOSPLIT_ALERT2");
            return
        }
        H.ShowMassMarker && this.massLevel != -1 && (n = J1[this.massLevel],
        r = this.MassMarkerAlpha,
        i.visible = !0,
        i.tint = n,
        i.alpha = r)
    }
    onDown(i) {
        if (!(i.button != 0 && i.button != 2) && i.button == 2 && this.opUnit.isHuman) {
            const s = this.x - zt.mouseX
              , n = this.y - zt.mouseY;
            if (s ** 2 + n ** 2 <= this.r ** 2) {
                const o = this.player.id;
                i.stopImmediatePropagation(),
                Gt.eventReaction = !0,
                A.emit("selectSpectate", o)
            }
        }
    }
    init(i, s, n, r, o, a, l, c) {
        return super.init(i, s, n, r, o),
        this.color = a,
        this.player = l,
        this.opUnit = c,
        this.assistance.needUpdate = !0,
        this.bindOpUnit(),
        this
    }
    bindOpUnit() {
        this.opUnit.bindPlayerCell(this)
    }
    unbindOpUnit() {
        this.opUnit.unbindPlayerCell(this)
    }
    checkTextScale() {
        this.deployNickVisibility(),
        this.deployMassVisibility()
    }
    deploy() {
        return super.deploy(),
        this.box.interactive = this.interactive,
        this.deployEntityTexture(),
        this.deployTextStyle(),
        this.deployNickVisibility(),
        this.deployMassVisibility(),
        this.drawAssistance(),
        this
    }
    deployEntityTexture() {
        this.opUnit.hasSkin && this.skinVisibility ? (this.baseLayer.texture = this.opUnit.skinTexture,
        this.deploySkinStyle()) : (this.baseLayer.texture = ie.get("BASE"),
        this.deployEntityStyle())
    }
    deployNickVisibility() {
        !this.opUnit || (this.tag.visible = this.player.team.tagText && this.nickVisibility && H.TagType == 2,
        this.nick.visible = this.opUnit.nickText.text && this.nickVisibility,
        this.mass.position.set(0, this.nick.visible ? We * .45 : 0),
        this.nick.position.set(0, this.tag.visible ? We * .05 : 0))
    }
    deployEntityStyle() {
        this.baseLayer.tint = this.entityTint,
        this.baseLayer.alpha = this.entityAlpha
    }
    deploySkinStyle() {
        this.baseLayer.tint = this.skinTint,
        this.baseLayer.alpha = this.skinAlpha
    }
    deployTextStyle() {
        const i = this.tag;
        this.mass.fontName = `${this.player.team.uSig}`,
        this.mass.tint = 16777215,
        i.position.set(0, -We * .0125 - this.mass.textHeight * .72)
    }
    assembly() {
        this.assistance.addChild(this.EnemyHint, this.MassMarker, this.AutosplitAlert),
        this.box.addChild(this.baseLayer, this.assistance, this.tag, this.nick, this.mass)
    }
    copySpecific() {
        return [this.color, this.player.uSig, this.opUnit.id]
    }
    release() {
        this.tag.texture = ht.EMPTY,
        this.nick.texture = ht.EMPTY,
        this.mass.fontName = "0",
        this.baseLayer.texture = ie.get("BASE"),
        this.assistance.needUpdate = !0,
        this.massLevel = -1,
        this.MassMarker.visible = !1,
        this.AutosplitAlert.visible = !1,
        this.unbindOpUnit(),
        up.release(this)
    }
}
class Q1 {
    constructor(t, i, s, n) {
        I(this, "id");
        I(this, "owner");
        I(this, "_nick");
        I(this, "nickText", Ws(new ys));
        I(this, "skinUrl");
        I(this, "skinImg");
        I(this, "skinTexture");
        I(this, "canvas", Ws(document.createElement("canvas")));
        I(this, "pcells", Ws(new Set));
        this.id = t,
        this.owner = i,
        this.nick = s,
        this.skin = n,
        this.skinTexture = Ws(ht.from(this.canvas))
    }
    get isBot() {
        return this.id == 15
    }
    get isHuman() {
        return this.id != 15
    }
    get inSelfTeam() {
        return U.teamPlayers.size && U.team == this.owner.team
    }
    get nick() { 
        //console.log(this)
        return this.owner._bfp ? this._nick+" ["+this.owner._bfp.substr(0,4)+"]" : this._nick 
    } 
    set nick(t) {
        this._nick !== t && (this._nick = t,
        this.updateText(),
        this.pcells.forEach(i=>i.setNick()))
    }
    get tag() {
        return this.owner.isBot ? "" : this.owner.tag
    }
    get tagNick() {
        return this.tag + this.nick
    }
    get skin() {
        return this.skinUrl
    }
    set skin(t) {
        (this.skinUrl !== t || !this.skinImg) && (this.skinUrl = t,
        this.loadSkin())
    }
    get cellCount() {
        return this.pcells.size
    }
    get color() {
        return this._color
    }
    set color(t) {
        this._color != t && (this._color = t,
        this.skinImg && this.updateSkin())
    }
    get teamColor() {
        return Qa(this.owner.team.color)
    }
    get skinFillColor() {
        return this.inSelfTeam ? Md(B.SkinFillTeam[0], this.color) : Md(B.SkinFillEnemy[0], this.color)
    }
    get skinFillAlpha() {
        return this.inSelfTeam ? B.SkinFillTeam[1] : B.SkinFillEnemy[1]
    }
    updateText() {
        const t = dr.clone();
        B.Text[3] & 4 ? t.fill = lr(this.owner.teamColor, B.Text[1]) : t.fill = ar(B.Text),
        B.TextStroke[3] & 4 ? t.stroke = lr(this.owner.teamColor, B.TextStroke[1]) : t.stroke = ar(B.TextStroke),
        t.fontSize = Lc(),
        t.strokeThickness = Oc(),
        this.nickText.style = t,
        this.nickText.text = H.TagType == 1 ? this.tagNick : this.nick,
        this.nickText.updateText()
    }
    loadSkin() {
        if (this.isBot && !this.skinUrl)
            return;
        this.skinImg = null;
        const t = new Image;
        t.crossOrigin = "Anonymous",
        t.src = this.skinUrl ? this.skinUrl : location.href + "skins/noskin5.png",
        this.skinImg = t,
        t.onload = ()=>{
            this.skinImg == t && this.updateSkin()
        }
        ,
        t.onerror = ()=>{
            t.src != location.href + "skins/error.png" && (t.src = location.href + "skins/error.png")
        }
    }
    updateSkin() {
        !this.pcells.size || !this.skinImg || (this.owner.isHuman || this.skinUrl ? this.drawSkin() && (this.hasSkin = !0) : this.hasSkin = !1,
        this.pcells.forEach(t=>t.deployEntityTexture()))
    }
    drawSkin() {
        const t = this.skinImg
          , i = this.skinFillColor
          , s = this.skinFillAlpha
          , n = We * on
          , r = Math.min(t.width, t.height);
        if (!r)
            return !1;
        const o = this.canvas;
        o.width = o.height = n * 2;
        const a = o.getContext("2d");
        return a.lineJoin = "round",
        a.globalAlpha = s,
        a.beginPath(),
        a.arc(n, n, n, 0, Math.PI * 2),
        a.clip(),
        a.fillStyle = i,
        a.fill(),
        a.globalAlpha = 1,
        a.drawImage(t, 0, 0, r, r, 0, 0, n * 2, n * 2),
        this.skinTexture.update(),
        !0
    }
    bindPlayerCell(t) {
        const i = this.cellCount == 0;
        this.pcells.add(t),
        t.setNick(),
        i && (this.color = t.color)
    }
    unbindPlayerCell(t) {
        this.pcells.delete(t)
    }
    updateInfo(t, i) {
        this.nick = t,
        this.skin = i
    }
    deployNickStyle() {
        this.pcells.forEach(t=>{
            t.deployNickStyle()
        }
        )
    }
    clearPlayerCells() {
        this.pcells.clear()
    }
    calcViewRange() {
        let t = 0
          , i = 0
          , s = 0
          , n = 0;
        this.pcells.forEach(l=>{
            const c = l.massValue;
            t += l.nx * c,
            i += l.ny * c,
            s += c,
            n += l.nr
        }
        ),
        t /= s,
        i /= s;
        const r = Math.min(64 / n, 1) ** .4
          , o = 1200 / r
          , a = 768 / r;
        return [t, i, o, a]
    }
}
let IR = 0;
class np {
    constructor(t) {
        I(this, "id");
        I(this, "uSig");
        I(this, "_bfp");
        I(this, "_team");
        I(this, "block", !1);
        I(this, "enableChat", !1);
        I(this, "activity", 0);
        I(this, "latency", 0);
        I(this, "msg", []);
        I(this, "opUnits", new Map);
        this.id = t,
        this.uSig = ++IR
    }
    get bfp() {
        return this._bfp
    }
    set bfp(t) {
        xn.indexOf(t) >= 0 && (this.block = !0),
        this._bfp = t
    }
    get tag() {
        return this.team ? this.team.name : ""
    }
    get nick() {
        return this.opUnits.values().next().value.nick
    }
    get tagNick() {
        return this.tag + this.nick
    }
    get skin() {
        return this.opUnits.values().next().value.skin
    }
    get team() {
        return this._team
    }
    set team(t) {
        this._team && this._team.quitPlayer(this),
        this._team = Ws(t),
        this.opUnits.forEach(i=>i.deployNickStyle())
    }
    get cellCount() {
        let t = 0;
        return this.opUnits.forEach(i=>t += i.cellCount),
        t
    }
    get teamPlayers() {
        return this._team ? this.team.players : []
    }
    get teamColor() {
        return this._team ? this._team.color : 16777215
    }
    get isTeammate() {
        return this.team && this.team.id == U.team.id
    }
    get isBot() {
        return this.opUnits.get(15)
    }
    get isHuman() {
        return !this.isBot
    }
    get isSelf() {
        return this.id == U.id
    }
    get totalMass() {
        let t = 0;
        return this.opUnits.forEach(i=>{
            i.pcells.forEach(s=>{
                t += s.massValue
            }
            )
        }
        ),
        t
    }
    createOpUnit(t, i, s) {
        const n = new Q1(t,this,i,s);
        return this.opUnits.set(t, n),
        n
    }
    joinOpUnit(t, i, s) {
        this.opUnits.has(t) ? this.opUnits.get(t).updateInfo(i, s) : this.createOpUnit(t, i, s)
    }
    clearPlayerCells() {
        this.opUnits.forEach(t=>t.clearPlayerCells())
    }
    leaveTeam() {
        const t = this.team;
        t && t.quitPlayer(this)
    }
    destroy() {
        setTimeout(()=>{
            this.opUnits.forEach(t=>{
                t._texture && t._texture.destroy(!0),
                t.nickText.removeFromParent(),
                t.nickText.destroy({
                    texture: !0,
                    baseTexture: !0
                })
            }
            )
        }
        , 1e3)
    }
}
const Vg = ut(H.ShowReplayBar)
  , qn = []
  , ya = _i(qn)
  , mn = ut(!0)
  , Di = ut(0)
  , Ts = ut(0)
  , Jn = ut(null)
  , no = ut(1);
let un = null
  , Hr = []
  , Ul = null
  , Gl = 0
  , Pd = []
  , na = new Map
  , Vr = new Map;
A.on("recordTempCell", e=>Pd.push(e));
const Ie = class {
    static tick() {
        if (!Ie.state)
            return;
        !mn.value && un && (Ts.value < un.length - 1 ? (Ts.value += 1,
        Ie.decodeFrame()) : mn.value = !0),
        Ul && (Gt.mouseX = zt.toScreenX(Ul.mouseX),
        Gt.mouseY = zt.toScreenY(Ul.mouseY));
        const t = performance.now()
          , i = 40 / no.value;
        Gl += i;
        let s = 0;
        Gl + i < t ? Gl = t - i : s = Gl + i - t,
        setTimeout(Ie.tick, s)
    }
    static decodeFrame() {
        const t = un[Ts.value];
        if (t)
            Ul = t;
        else
            return;
        zt.currMapData != t.map && (A.emit("clearMap"),
        zt.drawMap(t.map)),
        t.teams.forEach(([n,r,o])=>{
            Vr.has(n) || Vr.set(n, new py(n,r,o))
        }
        ),
        t.players.forEach(([n,r,o])=>{
            let a = n == 0 ? U : na.get(n);
            if (a) {
                o.forEach(([c,h,u])=>{
                    a.joinOpUnit(c, h, u)
                }
                );
                const l = Vr.get(r);
                a.team.uSig != l.uSig && l.joinPlayer([a])
            } else {
                const l = new np(n);
                o.forEach(([c,h,u])=>{
                    l.joinOpUnit(c, h, u)
                }
                ),
                Vr.get(r).joinPlayer([l]),
                na.set(n, l)
            }
        }
        );
        const i = performance.now()
          , s = vi(Gt.syncStamp, i, Er());
        t.data.forEach(([n,r,o,a,l,c,h])=>{
            let u;
            (u = ze.get(r)) ? c == 2 ? (u.preDeath(i),
            u.preUpdate(o, a, l ** .5 * 10),
            _n.add(u),
            gn.delete(u),
            ze.delete(r)) : Me.preUpdate({
                coef: s,
                time: i,
                id: r,
                x: o,
                y: a,
                mass: l
            }) : c != 2 && Ie.replayCreate({
                time: i,
                type: n,
                id: r,
                x: o,
                y: a,
                mass: l,
                specific: h,
                state: c
            })
        }
        ),
        Cn.preUpdate(t.viewX, t.viewY, i),
        U.toggleOpUnit(t.opUnitIndex),
        zt.miniMap.drawViewport(),
        Gt.syncStamp = i,
        Me.sync(i)
    }
    static replayCreate({time: t, type: i, id: s, x: n, y: r, mass: o, specific: a, state: l}) {
        let c;
        const h = a ? a[0] : null;
        switch (i) {
        case 110:
        case 111:
            if (a[1] == 0) {
                const u = U
                  , d = u.opUnits.get(a[2]);
                c = dp.allocate().init(t, s, n, r, o, h, u, d).deploy()
            } else {
                const u = na.get(a[1])
                  , d = u.opUnits.get(a[2]);
                c = up.allocate().init(t, s, n, r, o, h, u, d).deploy()
            }
            Ce.add(c),
            is.addChild(c.displayObject);
            break;
        case 120:
        case 121:
            c = lp.allocate().init(t, s, n, r, o, h).deploy(),
            Ia.add(c),
            Bd.addChild(c.displayObject);
            break;
        case 131:
            c = ap.allocate().init(t, s, n, r, o, h).deploy(),
            Ma.add(c),
            Fd.addChild(c.displayObject);
            break;
        case 141:
            c = cp.allocate().init(t, s, n, r, o).deploy(),
            Tn.add(c),
            is.addChild(c.displayObject);
            break;
        case 142:
            c = hp.allocate().init(t, s, n, r, o).deploy(),
            ur.add(c),
            is.addChild(c.displayObject);
            break
        }
        ze.set(s, c),
        l != 1 && H.EnableAppearance && (c.preAppear(t),
        Qn.add(c))
    }
    static replayOrPause() {
        !qn.length || (mn.value ^= 1,
        !mn.value && un && Ts.value == un.length - 1 && (Ts.value = 0),
        Ie.state || Ie.enterRecordMode())
    }
    static loadRecord() {
        Hr = [],
        un = qn[Di.value],
        mn.value = !0,
        Ts.value = 0,
        A.emit("refreshGame"),
        Ie.decodeFrame()
    }
    static startRecording() {
        Ie.state || (Jn.value = [])
    }
    static endRecording() {
        ya.push(Jn.value),
        Jn.value = null
    }
    static updateRecording() {
        if (Jn.value || H.CaptureTime) {
            let t = {
                map: zt.currMapData,
                opUnitIndex: U.opUnitQueue.currIndex,
                viewX: Cn.realCameraX,
                viewY: Cn.realCameraY,
                mouseX: Gt.svrMouseX,
                mouseY: Gt.svrMouseY,
                data: [],
                players: [],
                teams: []
            };
            const i = s=>{
                const n = [s.type, s.uSig, s.nx, s.ny, s.massValue, s.state];
                s.copySpecific && n.push(s.copySpecific()),
                t.data.push(n)
            }
            ;
            ze.forEach(i),
            _n.forEach(i),
            Pd.forEach(i),
            Vt.forEach(s=>{
                if (!s.team)
                    return;
                const n = [s.uSig, s.team.uSig, []];
                s.opUnits.forEach(r=>{
                    n[2].push([r.id, r.nick, r.skin])
                }
                ),
                t.players.push(n)
            }
            ),
            Ms.forEach(s=>{
                const n = [s.uSig, s.name, s.color];
                t.teams.push(n)
            }
            ),
            Hr.push(t),
            Jn.value && Jn.value.push(t),
            Hr.length > H.CaptureTime * 1e3 / 40 && Hr.shift()
        }
        Pd.length = 0
    }
    static storeQuickCapture() {
        Hr.length && ya.push([...Hr])
    }
    static speedUp() {
        no.value >= 2 || (no.value += .25)
    }
    static slowDown() {
        no.value <= .25 || (no.value -= .25)
    }
    static setProcess(t) {
        Ie.state && Ie.decodeFrame(),
        Ts.value = t
    }
    static enterRecordMode() {
        at.PAUSE = !0,
        Ie.state = 1,
        Ie.loadRecord(),
        mn.value = !1,
        Ie.tick(),
        at.writer.writeUint8(10).writeUint8(1),
        at.send()
    }
    static quitReplayMode() {
        Ie.state == 1 && (U.state = 0,
        mn.value = !0,
        Ie.state = 2,
        un = null,
        Ts.value = 0,
        Vt.forEach(t=>t.opUnits.forEach(i=>{
            i.loadSkin()
        }
        )),
        A.emit("refreshGame"),
        at.writer.writeUint8(10).writeUint8(0),
        at.send(),
        na.forEach(t=>t.destroy()),
        na.clear(),
        Vr.forEach(t=>t.destroy()),
        Vr.clear())
    }
    static destroyRecord() {
        if (ya.splice(Di.value, 1),
        Ts.value = 0,
        ya.length == 0 && Ie.state) {
            Ie.quitReplayMode();
            return
        }
        Di.value = Math.min(Di.value, Math.max(qn.length - 1, 0)),
        un = qn[Di.value]
    }
    static nextRecord() {
        Di.value++,
        Di.value >= qn.length && (Di.value = 0),
        Ie.state && Ie.loadRecord()
    }
    static prevRecord() {
        Di.value--,
        Di.value < 0 && (Di.value = qn.length - 1),
        Ie.state && Ie.loadRecord()
    }
}
;
let ti = Ie;
I(ti, "state", 0);
A.on("quickCapture", ti.storeQuickCapture());
const MR = {
    name: "replay-bar",
    components: {
        "process-slider": CR
    },
    setup() {
        return A.on(Ut.ShowReplayBar, ()=>Vg.value = H.ShowReplayBar),
        Ve(()=>{
            document.getElementById("replay-bar").addEventListener("click", ()=>{
                A.emit("focusGameCanvas")
            }
            )
        }
        ),
        {
            showReplayBar: Vg,
            pause: mn,
            records: ya,
            currIndex: Di,
            currProcess: Ts,
            currRecord: Jn,
            speed: no,
            Recorder: ti
        }
    }
}
  , Xi = e=>(gs("data-v-2ba0e0aa"),
e = e(),
vs(),
e)
  , RR = {
    id: "replay-bar"
}
  , kR = Xi(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    fill: "var(--main-theme-color)",
    transform: "translate(4,3)"
}, [b("path", {
    d: "M434.897971 962.214818c-2.485611 0-4.357238-0.661056-5.599532-1.871627-8.714476-2.52552-11.821233-7.463995-9.335622-14.935154l57.877175-341.637937L225.804792 603.7701c-6.220678 0-10.577916-2.492774-13.071713-7.471159-3.727904-4.938476-3.106758-10.538007 1.871627-16.799618L602.920756 71.702042c4.978385-7.471159 10.577916-8.674567 16.799618-3.736091 6.220678 1.242294 9.335622 6.260587 9.335622 14.935154l-57.877175 341.646124L793.34269 424.547229c6.220678 0 10.577916 2.52552 13.071713 7.463995 1.242294 4.978385 1.242294 10.577916 0 16.806781L447.969685 956.615287C444.233594 960.343191 439.876356 962.214818 434.897971 962.214818z"
})], -1))
  , PR = [kR]
  , LR = Xi(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    fill: "var(--main-theme-color)",
    transform: "translate(6,3)"
}, [b("path", {
    d: "M647.725 840.897s93.091 0 93.091-93.091V282.353c0-93.091-93.091-93.091-93.091-93.091H93.091S0 189.262 0 282.353v465.453c0 93.091 93.091 93.091 93.091 93.091h554.634z m147.316-469.782V660.72l228.956 180.177V189.263L795.041 371.115z"
})], -1))
  , OR = [LR]
  , DR = Xi(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "18.5",
    height: "18.5",
    fill: "var(--main-theme-color)",
    transform: "translate(6.5,3)"
}, [b("path", {
    d: "M128 128m53.333333 0l661.333334 0q53.333333 0 53.333333 53.333333l0 661.333334q0 53.333333-53.333333 53.333333l-661.333334 0q-53.333333 0-53.333333-53.333333l0-661.333334q0-53.333333 53.333333-53.333333Z"
})], -1))
  , NR = [DR]
  , FR = {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "17",
    height: "17",
    fill: "var(--main-theme-color)",
    transform: "translate(8,2.75)"
}
  , BR = Xi(()=>b("path", {
    d: "M92.59163 7.124244v175.409681l588.077547 329.465052-460.111316 245.981852V402.176952l-127.966231-71.344766v686.04357l838.81674-504.876779z"
}, null, -1))
  , UR = [BR]
  , GR = {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "15",
    height: "15",
    fill: "var(--main-theme-color)",
    transform: "translate(8.5,2.5)"
}
  , HR = Xi(()=>b("path", {
    d: "M128 0h253.155556v1024H128V0z m512 0h256v1024h-256V0z"
}, null, -1))
  , VR = [HR]
  , zR = Xi(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    fill: "var(--main-theme-color)",
    transform: "translate(3,-5.5)"
}, [b("path", {
    d: "M704 304.2v415.6c0 37.4-30.7 64.1-64.1 64.1-10.8 0-22-2.8-32.4-9l-352-207.8c-41.9-24.8-41.9-85.5 0-110.2l351.9-207.8c10.5-6.2 21.6-9 32.4-9 33.5 0 64.2 26.7 64.2 64.1z"
})], -1))
  , $R = [zR]
  , jR = Xi(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    fill: "var(--main-theme-color)",
    transform: "translate(0.5,-5)"
}, [b("path", {
    d: "M768.5 567.1l-352 207.8c-10.4 6.2-21.6 9-32.4 9-33.4 0-64.1-26.7-64.1-64.1V304.2c0-37.4 30.7-64.1 64.1-64.1 10.8 0 22 2.8 32.4 9l351.9 207.8c42 24.8 42 85.4 0.1 110.2z"
})], -1))
  , WR = [jR]
  , XR = Xi(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "12",
    height: "12",
    fill: "var(--main-theme-color)",
    transform: "translate(6,-5)"
}, [b("path", {
    d: "M426.666667 426.666667H85.546667A85.418667 85.418667 0 0 0 0 512c0 47.445333 38.314667 85.333333 85.546667 85.333333H426.666667v341.12c0 47.274667 38.186667 85.546667 85.333333 85.546667 47.445333 0 85.333333-38.314667 85.333333-85.546667V597.333333h341.12A85.418667 85.418667 0 0 0 1024 512c0-47.445333-38.314667-85.333333-85.546667-85.333333H597.333333V85.546667A85.418667 85.418667 0 0 0 512 0c-47.445333 0-85.333333 38.314667-85.333333 85.546667V426.666667z"
})], -1))
  , YR = [XR]
  , KR = Xi(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "14",
    height: "14",
    fill: "var(--main-theme-color)",
    transform: "translate(5,-5)"
}, [b("path", {
    d: "M587.229378 437.990403 580.722174 437.990403 76.975139 437.990403 76.975139 581.918419 580.722174 581.918419 587.229378 581.918419 940.542216 581.918419 940.542216 437.990403Z"
})], -1))
  , ZR = [KR]
  , qR = {
    id: "speed"
}
  , JR = Xi(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "18",
    height: "18",
    fill: "var(--main-theme-color)",
    transform: "translate(7.5,3)"
}, [b("path", {
    d: "M930.248779 51.421136c-17.382902-8.393157-38.056758-6.107091-53.191456 5.929036l-522.479679 415.249469c-12.010545 9.54847-19.016099 24.054859-19.016099 39.402405 0 15.347546 7.005554 29.853935 19.016099 39.402405l522.479679 415.249469c9.081843 7.219425 20.154016 10.929934 31.323403 10.929934 7.43432 0 14.917758-1.645476 21.86703-5.000897 17.400299-8.399297 28.460192-26.01449 28.460192-45.331441L958.707948 96.752578C958.708971 77.435627 947.649078 59.820434 930.248779 51.421136zM858.042247 822.953078 466.790332 512.002047l391.251915-310.951031L858.042247 822.953078zM178.540326 117.206422 178.540326 916.731928c0 31.274284-25.350364 56.624648-56.624648 56.624648-31.275307 0-56.624648-25.350364-56.624648-56.624648L65.291029 117.206422c0-31.273261 25.350364-56.624648 56.624648-56.624648C153.189961 60.581774 178.540326 85.933161 178.540326 117.206422z"
})], -1))
  , QR = [JR]
  , tk = Xi(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "18",
    height: "18",
    fill: "var(--main-theme-color)",
    transform: "translate(6,3)"
}, [b("path", {
    d: "M683.816181 471.854675 147.889235 50.679239c-15.374152-12.084223-36.276205-14.32117-53.862745-5.776563C76.451206 53.446259 65.290005 71.276347 65.290005 90.819448l0 842.364173c0 19.543102 11.161201 37.373189 28.735461 45.916772 7.091512 3.447519 14.719236 5.135974 22.310122 5.135974 11.236925 0 22.378683-3.707438 31.552623-10.912537l535.926946-421.188738c12.31549-9.67843 19.506263-24.478508 19.506263-40.140209C703.32142 496.328066 696.130647 481.533105 683.816181 471.854675zM167.395498 828.131007l0-632.259968 402.25041 316.123844L167.395498 828.131007zM958.708971 111.565958l0 810.942533c0 31.720446-25.712615 57.434084-57.434084 57.434084-31.721469 0-57.434084-25.713638-57.434084-57.434084L843.840804 111.565958c0-31.721469 25.712615-57.434084 57.434084-57.434084C932.996356 54.131875 958.708971 79.844489 958.708971 111.565958z"
})], -1))
  , ek = [tk]
  , ik = {
    id: "number"
}
  , sk = Xi(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "23",
    height: "23",
    fill: "var(--main-theme-color)",
    transform: "translate(4,2.5)"
}, [b("path", {
    d: "M847.743 223.953H640.639c-3.132-68.921-60.177-124.029-129.858-124.029s-126.726 55.108-129.858 124.029H173.256c-17.673 0-32 14.327-32 32s14.327 32 32 32h674.487c17.673 0 32-14.327 32-32s-14.327-32-32-32z m-336.962-60.03c34.379 0 62.689 26.426 65.718 60.029H445.064c3.029-33.603 31.338-60.029 65.717-60.029zM767.743 351.79c-17.673 0-32 14.327-32 32v478.173H288.256V383.79c0-17.673-14.327-32-32-32s-32 14.327-32 32v510.173c0 17.673 14.327 32 32 32h511.487c17.673 0 32-14.327 32-32V383.79c0-17.673-14.327-32-32-32z"
}), b("path", {
    d: "M449.306 732.802V448.208c0-17.673-14.327-32-32-32s-32 14.327-32 32v284.593c0 17.673 14.327 32 32 32s32-14.326 32-31.999zM640.84 732.802V448.208c0-17.673-14.327-32-32-32s-32 14.327-32 32v284.593c0 17.673 14.327 32 32 32s32-14.326 32-31.999z"
})], -1))
  , nk = [sk];
function rk(e, t, i, s, n, r) {
    const o = se("process-slider");
    return ee((st(),
    nt("div", RR, [b("div", {
        id: "quick-capture",
        class: "replay-bar-btn",
        onClick: t[0] || (t[0] = (...a)=>s.Recorder.storeQuickCapture && s.Recorder.storeQuickCapture(...a))
    }, PR), b("div", {
        id: "record",
        class: "replay-bar-btn",
        style: jt({
            backgroundColor: s.currRecord ? "rgba(64, 64, 64, 0.6)" : null
        }),
        onClick: t[1] || (t[1] = a=>s.currRecord ? s.Recorder.endRecording() : s.Recorder.startRecording())
    }, OR, 4), b("div", {
        id: "stop",
        class: "replay-bar-btn",
        onClick: t[2] || (t[2] = (...a)=>s.Recorder.quitReplayMode && s.Recorder.quitReplayMode(...a))
    }, NR), b("div", {
        id: "play",
        class: "replay-bar-btn",
        onClick: t[3] || (t[3] = (...a)=>s.Recorder.replayOrPause && s.Recorder.replayOrPause(...a))
    }, [ee((st(),
    nt("svg", FR, UR, 512)), [[ye, s.pause]]), ee((st(),
    nt("svg", GR, VR, 512)), [[ye, !s.pause]])]), X(o, {
        id: "process",
        max: `${s.records[s.currIndex] ? s.records[s.currIndex].length - 1 : 0}`,
        step: "1",
        val: s.currProcess,
        onChangeVal: s.Recorder.setProcess
    }, null, 8, ["max", "val", "onChangeVal"]), b("div", {
        id: "prev-frame",
        class: "replay-bar-btn-tiny",
        onClick: t[4] || (t[4] = a=>s.Recorder.setProcess(--s.currProcess))
    }, $R), b("div", {
        id: "next-frame",
        class: "replay-bar-btn-tiny",
        onClick: t[5] || (t[5] = a=>s.Recorder.setProcess(++s.currProcess))
    }, WR), b("div", {
        id: "speed-up",
        class: "replay-bar-btn-tiny",
        onClick: t[6] || (t[6] = (...a)=>s.Recorder.speedUp && s.Recorder.speedUp(...a))
    }, YR), b("div", {
        id: "slow-down",
        class: "replay-bar-btn-tiny",
        onClick: t[7] || (t[7] = (...a)=>s.Recorder.slowDown && s.Recorder.slowDown(...a))
    }, ZR), b("div", qR, Dt("x" + s.speed.toFixed(2)), 1), b("div", {
        id: "prev-record",
        class: "replay-bar-btn",
        onClick: t[8] || (t[8] = (...a)=>s.Recorder.prevRecord && s.Recorder.prevRecord(...a))
    }, QR), b("div", {
        id: "next-record",
        class: "replay-bar-btn",
        onClick: t[9] || (t[9] = (...a)=>s.Recorder.nextRecord && s.Recorder.nextRecord(...a))
    }, ek), b("div", ik, Dt(s.records.length ? s.currIndex + 1 + "/" + s.records.length : "0/0"), 1), b("div", {
        id: "delete",
        class: "replay-bar-btn",
        onClick: t[10] || (t[10] = (...a)=>s.Recorder.destroyRecord && s.Recorder.destroyRecord(...a))
    }, nk)], 512)), [[ye, s.showReplayBar]])
}
var rp = ue(MR, [["render", rk], ["__scopeId", "data-v-2ba0e0aa"]]);
class ok extends ae {
    constructor() {
        super();
        I(this, "initialized", !1);
        I(this, "ox");
        I(this, "oy");
        I(this, "nx");
        I(this, "ny");
        I(this, "gameMap", new pR().setup());
        I(this, "fcellContainer", new Ed(10240,{
            tint: !0
        }));
        I(this, "ecellContainer", new Ed(10240,{
            tint: !0
        }));
        I(this, "entityContainer", new ae);
        I(this, "realCameraX", 0);
        I(this, "realCameraY", 0);
        this.ox = this.nx = this.x,
        this.oy = this.ny = this.y
    }
    get fcellContainerVisibility() {
        return H.ShowFood
    }
    get currCameraPos() {
        return [-this.position.x, -this.position.y]
    }
    get realCameraPos() {
        return U.state === 2 ? [this.realCameraX, this.realCameraY] : [-this.nx, -this.ny]
    }
    computeOctagonPos(i) {
        return -i * 2.4142135623731 / 2
    }
    drawRectMap(i, s, n, r) {
        if (this.gameMap.drawRectMap(i, s, n, r),
        !this.initialized) {
            let o = (i + s) / 2
              , a = (n + r) / 2;
            this.setCamera(o, a),
            this.initialized = !0
        }
    }
    drawOctagonMap(i) {
        const s = i[4] - i[12]
          , n = i[9] - i[1];
        let r = s / 2
          , o = n / 2;
        this.position.set(-r, -o),
        this.gameMap.drawOctagonMap(i),
        this.initialized || (this.setCamera(r, o),
        this.initialized = !0)
    }
    preUpdate(i, s, n) {
        this.update_linear(n),
        this.ox = this.x,
        this.oy = this.y;
        const r = U.pause && this.realCameraX == i && this.realCameraY == s;
        this.realCameraX = i,
        this.realCameraY = s;
        let o, a;
        if (U.state === 1 && !ti.state)
            [o,a] = U.calcViewCenter();
        else if (U.state >= 2 && !r && Je.jumping != 2 && !ti.state) {
            let l = zt.mouseX
              , c = zt.mouseY
              , h = this.realCameraX
              , u = this.realCameraY
              , d = ((l - h) ** 2 + (c - u) ** 2) ** .5
              , f = 1;
            U.specMode != 1 && (f = 0,
            U.specTarget && U.specTarget.cellCount == 0 && (f = 1));
            let p = Math.min(1920 / d, f, H.StableSpecCamera ^ 1) ** .5;
            o = h + (l - h) * p,
            a = u + (c - u) * p
        } else
            o = this.realCameraX,
            a = this.realCameraY;
        !isNaN(o) && !isNaN(a) && (this.nx = -o,
        this.ny = -a)
    }
    setCamera(i, s) {
        this.ox = -i,
        this.oy = -s,
        this.position.set(-i, -s),
        this.nx = -i,
        this.ny = -s
    }
    update(i, s, n, r, o) {
        this.position.set(Ze(i, n, o), Ze(s, r, o)),
        this.entityContainer.sortChildren()
    }
    update_linear(i) {
        this.update(this.ox, this.oy, this.nx, this.ny, vi(Gt.syncStamp, i, eR()))
    }
    init() {}
    deploy() {
        this.deployFoodCellContainerVisibility()
    }
    deployFoodCellContainerVisibility() {
        this.fcellContainer.visible = this.fcellContainerVisibility
    }
    assembly() {
        this.addChild(this.gameMap, this.fcellContainer, this.ecellContainer, this.entityContainer)
    }
    setup() {
        return this.init(),
        this.deploy(),
        this.assembly(),
        this
    }
    reset() {
        this.initialized = !1,
        this.entityContainer.removeChildren(),
        this.fcellContainer.removeChildren(),
        this.ecellContainer.removeChildren()
    }
}
class ak extends ae {
    constructor() {
        super();
        I(this, "mainContainer", new ok().setup());
        this.interactive = !0,
        this.on("pointerdown", i=>{
            i.button == 0 && U.state >= 2 && (i.stopImmediatePropagation(),
            Gt.eventReaction = !0,
            A.emit("selectSpectate", 0))
        }
        )
    }
    init() {
        this.scale.set(.15)
    }
    assembly() {
        this.addChild(this.mainContainer)
    }
    setup() {
        return this.init(),
        this.assembly(),
        this
    }
    reset() {
        this.mainContainer.reset()
    }
}
const dn = 240
  , lk = 5
  , ck = 5
  , hr = rc
  , hk = new ki({
    fontFamily: "Barlow Semi Condensed",
    fontWeight: "200",
    fill: 16777215,
    fontSize: 22
})
  , uk = new ki({
    fontFamily: us,
    fontWeight: "500",
    fill: 16777215,
    fontSize: 12.5
});
class dk {
    constructor(t, i, s, n, r, o) {
        I(this, "displayObject", kd.allocate());
        I(this, "sprite", As.allocate());
        I(this, "exist", !0);
        I(this, "id");
        I(this, "nx");
        I(this, "ny");
        I(this, "nw");
        I(this, "nh");
        I(this, "color");
        this.id = t,
        this.nx = i,
        this.ny = s,
        this.nw = n,
        this.nh = r,
        this.color = o ?? 16777215
    }
    get x() {
        return this.displayObject.x
    }
    get y() {
        return this.displayObject.y
    }
    get w() {
        return this.displayObject.scale.x
    }
    get h() {
        return this.displayObject.scale.y
    }
    get width() {
        return this.w * this.sprite.width
    }
    get height() {
        return this.h * this.sprite.height
    }
    get spriteTint() {
        return Be(B.ViewMinimap[0]) ?? this.color
    }
    get spriteAlpha() {
        return B.ViewMinimap[1]
    }
    get moved() {
        return Ui(this.x, this.nx, hr) && Ui(this.y, this.ny, hr)
    }
    get resized() {
        return Ui(this.w, this.nw, hr) && Ui(this.h, this.nh, hr)
    }
    get inControl() {
        return U.state === 2 || -this.id === U.currentOpUnit?.id
    }
    setPosition(t, i) {
        this.displayObject.position.set(t, i)
    }
    setSize(t, i) {
        this.displayObject.zIndex = t * i >> 0,
        this.displayObject.scale.set(t, i)
    }
    preUpdate(t, i, s, n, r) {
        this.exist = !0,
        this.nx = t,
        this.ny = i,
        this.nw = s,
        this.nh = n,
        this.color = r ?? this.color,
        this.deploySpriteStyle()
    }
    fixPosition() {
        this.moved && this.setPosition(this.nx, this.ny)
    }
    fixSize() {
        this.resized && this.setSize(this.nw, this.nh)
    }
    move(t) {
        this.setPosition(Ze(this.x, this.nx, t), Ze(this.y, this.ny, t)),
        this.fixPosition()
    }
    resize(t) {
        this.setSize(Ze(this.w, this.nw, t), Ze(this.h, this.nh, t)),
        this.fixSize()
    }
    update(t) {
        this.move(t),
        this.resize(t)
    }
    init() {
        this.setPosition(this.nx, this.ny),
        this.setSize(this.nw, this.nh),
        this.sprite.texture = ht.WHITE,
        this.sprite.anchor.set(.5),
        this.sprite.position.set(0),
        this.sprite.scale.set(1 / 13)
    }
    deploy() {
        this.deploySpriteStyle()
    }
    deploySpriteStyle() {
        this.sprite.tint = this.spriteTint,
        this.sprite.alpha = this.spriteAlpha
    }
    assembly() {
        this.displayObject.addChild(this.sprite)
    }
    setup() {
        return this.init(),
        this.deploy(),
        this.assembly(),
        this
    }
    release() {
        this.displayObject.zIndex = 0,
        this.displayObject.removeChildren(),
        this.sprite.texture = null,
        this.sprite.tint = 16777215,
        this.sprite.alpha = 1,
        this.sprite.zIndex = 0,
        kd.release(this.displayObject),
        As.release(this.sprite)
    }
}
class fk {
    constructor() {
        I(this, "sprite", As.allocate());
        I(this, "nick", new ys("",uk.clone()));
        I(this, "exist", !0);
        I(this, "nx");
        I(this, "ny");
        I(this, "nr");
        I(this, "player");
        I(this, "opUnit")
    }
    init(t, i, s, n, r) {
        return this.nx = t,
        this.ny = i,
        this.nr = s,
        this.player = n,
        this.opUnit = r,
        this.setPosition(this.nx, this.ny),
        this.setSize(this.nr),
        this.sprite.anchor.set(.5),
        this.setNick(),
        this.nick.anchor.set(.5),
        this
    }
    get x() {
        return this.sprite.x
    }
    get y() {
        return this.sprite.y
    }
    get r() {
        return this.sprite.scale.x * We
    }
    get moved() {
        return Ui(this.x, this.nx, hr) && Ui(this.y, this.ny, hr)
    }
    get resized() {
        return Ui(this.r, this.nr, hr)
    }
    get spriteTint() {
        return Be(B.EntityMinimap[0]) ?? this.player.teamColor
    }
    get spriteAlpha() {
        return B.EntityMinimap[1]
    }
    get nickColor() {
        return Qa(this.player.teamColor)
    }
    get nickAlpha() {
        return B.EntityInfoMinimap[1]
    }
    setPosition(t, i) {
        this.sprite.position.set(t, i),
        this.nick.position.set(t, i - this.r - 8)
    }
    setSize(t) {
        this.sprite.zIndex = t >> 0,
        this.sprite.scale.set(t / We),
        this.nick.zIndex = t >> 0
    }
    setNick() {
        this.player.isBot || (this.nick.text = this.opUnit.tagNick)
    }
    updateText() {}
    preUpdate(t, i, s) {
        this.exist = !0,
        this.nx = t,
        this.ny = i,
        this.nr = s
    }
    fixPosition() {
        this.moved && this.setPosition(this.nx, this.ny)
    }
    fixSize() {
        this.resized && this.setSize(this.nr)
    }
    move(t) {
        this.setPosition(Ze(this.x, this.nx, t), Ze(this.y, this.ny, t)),
        this.fixPosition()
    }
    resize(t) {
        this.setSize(Ze(this.r, this.nr, t)),
        this.fixSize()
    }
    update(t) {
        this.setNick(),
        this.move(t),
        this.resize(t)
    }
    deploy() {
        return this.deploySpriteStyle(),
        this.deployNickStyle(),
        this
    }
    deploySpriteStyle() {
        this.player.team == U.team ? (this.sprite.texture = ie.get("BASE"),
        this.sprite.alpha = this.spriteAlpha) : this.player.isBot ? (this.sprite.texture = ie.get("BASE"),
        this.sprite.alpha = .75 * this.spriteAlpha) : (this.sprite.texture = ie.get("BASE"),
        this.sprite.alpha = .75 * this.spriteAlpha),
        this.sprite.tint = this.spriteTint
    }
    deployNickStyle() {
        this.nick.style.fill = this.nickColor,
        this.nick.alpha = this.nickAlpha
    }
    setup() {
        return this.deploy(),
        this
    }
    release() {
        this.exist = !0,
        this.nick.text = "",
        Ld.release(this)
    }
    recycle() {
        As.release(this.sprite),
        W1.release(this.text)
    }
}
const Ld = new wi(fk,128);
class pk extends ae {
    constructor() {
        super();
        I(this, "graphics", new ke);
        I(this, "mask", new ke);
        I(this, "borderMask", new ke);
        I(this, "viewportContainer", new ae);
        I(this, "locationLine", new ke);
        I(this, "spriteContainer", new ae);
        I(this, "textContainer", new ae);
        I(this, "entityList", new Map);
        I(this, "viewportList", new Map);
        I(this, "updateStamp", performance.now());
        I(this, "zoom");
        I(this, "pointerIn");
        I(this, "jumping", 0);
        I(this, "coords", new ke);
        I(this, "coordsText", new ae);
        I(this, "offsetX", 0);
        I(this, "offsetY", 0);
        this.interactive = !0,
        this.on("pointerdown", i=>this.onDown(i)),
        this.on("pointerenter", ()=>this.pointerIn = !0),
        this.on("pointerleave", ()=>{
            this.pointerIn = this.jumping = 0
        }
        )
    }
    get visibility() {
        return H.ShowMinimap
    }
    get size() {
        return H.MinimapSize
    }
    get coordsFontTint() {
        return parseInt(`0x${B.CoordsFontMinimap[0]}`)
    }
    get coordsFontAlpha() {
        return B.CoordsFontMinimap[1]
    }
    get coordsGridTint() {
        return parseInt(`0x${B.CoordsGridMinimap[0]}`)
    }
    get coordsGridAlpha() {
        return B.CoordsGridMinimap[1]
    }
    get graphicsTint() {
        return Be(B.BgcMinimap[0])
    }
    get graphicsAlpha() {
        return B.BgcMinimap[1]
    }
    get locationLineTint() {
        return Be(B.LocationLine[0])
    }
    get locationLineAlpha() {
        return B.LocationLine[1]
    }
    onDown(i) {
        i.preventDefault(),
        i.stopImmediatePropagation();
        let s = (i.clientX - this.position.x) * this.zoom + this.offsetX >> 0
          , n = (i.clientY - this.position.y) * this.zoom + this.offsetY >> 0;
        U.state == 1 ? U.tp && (at.writer.writeUint8(25).writeStringUTF8(`/tp ${s} ${n}`),
        at.send()) : (this.pointerIn = !0,
        this.jumping == 0 && (this.jumping = 1),
        A.emit("moveCameraTo", {
            x: s,
            y: n
        }))
    }
    positioning() {
        this.position.set(innerWidth - this.width - lk, innerHeight - this.height - ck)
    }
    resize() {
        this.scale.set(this.size),
        this.positioning()
    }
    drawRectMap(i, s, n, r) {
        this.offsetX = i,
        this.offsetY = n,
        this.zoom = (s - i) / dn;
        const o = dn
          , a = dn * (r - n) / (s - i);
        this.clear(),
        this.borderMask.beginFill(16777215).drawRect(0, 0, o, a).endFill(),
        this.mask.beginFill(16777215).drawRect(0, 0, o, a).endFill(),
        this.graphics.beginFill(16777215).drawRect(0, 0, o, a).endFill();
        const l = (o + a) / 14142 * 20;
        this.drawCoords(0, 0, o, a, l)
    }
    drawOctagonMap(i) {
        this.offsetX = i[14],
        this.offsetY = i[1];
        let s = i[6] - i[14]
          , n = i[9] - i[1];
        this.zoom = s / dn;
        const r = [];
        for (let u = 0; u < i.length; )
            r[u] = (i[u++] - this.offsetX) / s * dn,
            r[u] = (i[u++] - this.offsetY) / s * dn;
        const [o,a,l,c] = [r[14], r[1], r[6], r[9]];
        s = l - o,
        n = c - a,
        this.clear(),
        this.borderMask.beginFill(16777215).drawRect(0, 0, dn, dn * n / s).endFill(),
        this.mask.beginFill(16777215).drawPolygon(r).endFill(),
        this.graphics.beginFill(16777215).drawPolygon(r).endFill();
        const h = (s + n) / 14142 * 20;
        this.drawCoords(o, a, l, c, h)
    }
    drawCoords(i, s, n, r, o) {
        const a = (n - i) / 5
          , l = (r - s) / 5
          , c = this.coords;
        c.lineStyle(o, 16777215);
        var h, u;
        for (let g = 1; g < 5; g++)
            h = g * a,
            u = g * l,
            c.moveTo(h, 0).lineTo(h, r).moveTo(0, u).lineTo(n, u);
        let d, f, p;
        const m = this.coordsText.children;
        for (let g = m.length - 1; g >= 0; g--)
            p = m[g],
            p.visible = !0,
            f = g % 5,
            d = g / 5 >> 0,
            p.text = String.fromCharCode(65 + d) + (f + 1),
            p.x = f * a + a / 2 - p.width / 2 + i,
            p.y = d * l + l / 2 - p.height / 2 + s
    }
    drawEntity(i) {
        i.forEach(([s,n,r,o,a])=>{
            if (r = (r - this.offsetX) / this.zoom,
            o = (o - this.offsetY) / this.zoom,
            a /= this.zoom / 8,
            this.entityList.has(s)) {
                const l = this.entityList.get(s);
                let c = l[n];
                if (c)
                    c.preUpdate(r, o, a);
                else {
                    const h = Pi.getPlayer(s)
                      , u = h.opUnits.get(n);
                    c = Ld.allocate().init(r, o, a, h, u).setup(),
                    this.spriteContainer.addChild(c.sprite),
                    this.textContainer.addChild(c.nick),
                    l[n] = c
                }
            } else {
                const l = Pi.getPlayer(s)
                  , c = l.opUnits.get(n)
                  , h = Ld.allocate().init(r, o, a, l, c).setup();
                this.spriteContainer.addChild(h.sprite),
                this.textContainer.addChild(h.nick);
                const u = [];
                u[n] = h,
                this.entityList.set(s, u)
            }
        }
        ),
        this.detectEntity()
    }
    calcViewportData() {
        const i = [];
        if (U.state !== 1) {
            const [n,r] = Cn.realCameraPos
              , o = 1 + U.state / 2 * 2.236
              , [a,l] = [1200 * o, 768 * o];
            i.push([0, n, r, a, l, 16777215])
        } else
            U.opUnits.forEach(s=>{
                if (s.pcells.size != 0) {
                    const [n,r,o,a] = s.calcViewRange();
                    i.push([s.id, n, r, o, a, 16777215])
                }
            }
            );
        return i
    }
    drawViewport() {
        this.calcViewportData().forEach(([s,n,r,o,a,l])=>{
            if (n /= this.zoom,
            r /= this.zoom,
            o /= this.zoom / 2,
            a /= this.zoom / 2,
            this.viewportList.has(s))
                this.viewportList.get(s).preUpdate(n, r, o, a, l);
            else {
                const c = new dk(s,n,r,o,a,l).setup();
                this.viewportContainer.addChild(c.displayObject),
                this.viewportList.set(s, c)
            }
        }
        ),
        this.detectViewport()
    }
    drawLocationLine() {
        let[i,s] = Cn.currCameraPos;
        i = (i - this.offsetX) / this.zoom,
        s = (s - this.offsetY) / this.zoom,
        this.locationLine.clear().lineStyle(1, 16777215).moveTo(0, s).lineTo(this.graphics.width, s).closePath().moveTo(i, 0).lineTo(i, this.graphics.height).closePath()
    }
    detectEntity() {
        this.entityList.forEach(i=>{
            let s = i.length;
            for (; s--; ) {
                const n = i[s];
                n && (n.exist ? n.exist = !1 : (n.release(),
                i.splice(s, 1, Array.EMPTY),
                this.spriteContainer.removeChild(n.sprite),
                this.textContainer.removeChild(n.nick)))
            }
        }
        )
    }
    detectViewport() {
        this.viewportList.forEach(i=>{
            i.exist ? i.exist = !1 : (i.release(),
            this.viewportContainer.removeChild(i.displayObject),
            this.viewportList.delete(i.id))
        }
        )
    }
    update(i) {
        const s = vi(this.updateStamp, i, 400);
        this.entityList.forEach(n=>n.forEach(r=>{
            r && r.update(s)
        }
        )),
        this.viewportList.forEach(n=>n.update(s)),
        this.updateStamp = performance.now(),
        this.drawLocationLine()
    }
    init() {
        this.viewportContainer.mask = this.mask,
        this.viewportContainer.position.set(0),
        this.locationLine.mask = this.mask,
        this.spriteContainer.mask = this.mask,
        this.spriteContainer.position.set(0),
        this.textContainer.mask = this.borderMask,
        this.textContainer.position.set(0),
        this.coords.mask = this.mask,
        this.coordsText.mask = this.mask;
        let i;
        for (let s = 0; s < 25; s++)
            i = new ys("",hk),
            this.coordsText.addChild(i)
    }
    deploy() {
        this.resize(),
        this.deployCoordsStyle(),
        this.deployVisibility(),
        this.deployGraphicsStyle(),
        this.deployLocationLineStyle()
    }
    deployCoordsStyle() {
        this.coords.tint = this.coordsGridTint,
        this.coords.alpha = this.coordsGridAlpha,
        this.coordsText.tint = this.coordsFontTint,
        this.coordsText.alpha = this.coordsFontAlpha
    }
    deployVisibility() {
        this.visible = this.visibility
    }
    deployGraphicsStyle() {
        this.graphics.tint = this.graphicsTint,
        this.graphics.alpha = this.graphicsAlpha
    }
    deployLocationLineStyle() {
        this.locationLine.tint = this.locationLineTint,
        this.locationLine.alpha = this.locationLineAlpha
    }
    assembly() {
        this.addChild(this.graphics, this.mask, this.borderMask, this.coords, this.coordsText, this.viewportContainer, this.locationLine, this.spriteContainer, this.textContainer)
    }
    setup() {
        return this.init(),
        this.deploy(),
        this.assembly(),
        this
    }
    clear() {
        this.mask.clear(),
        this.graphics.clear(),
        this.locationLine.clear(),
        this.coords.clear();
        const i = this.coords.children;
        for (let s = i.length - 1; s >= 0; s--)
            i[s].visible = !1
    }
    reset() {
        this.clear(),
        this.viewportContainer.removeChildren(),
        this.spriteContainer.removeChildren(),
        this.textContainer.removeChildren(),
        this.entityList.clear(),
        this.viewportList.clear()
    }
}
const vu = 200
  , mk = -3
  , Od = 5
  , ty = 8
  , oc = 12.5
  , ey = ()=>{
    le.from("LEADERBOARD_TITLE", {
        fontFamily: us,
        fontWeight: "500",
        fill: 3182847,
        fontSize: oc * 1.5 >> 0
    }, {
        chars: "LEADRBO",
        resolution: 2,
        textureWidth: 256,
        textureHeight: 256,
        mipmap: 0
    }),
    le.from("LEADERBOARD_MASS", {
        fontFamily: us,
        fontWeight: "300",
        fill: 16777215,
        fontSize: oc
    }, {
        chars: [...le.NUMERIC, ".k[]"],
        resolution: 2,
        textureWidth: 256,
        textureHeight: 256,
        mipmap: 0
    }),
    le.from("LEADERBOARD_RANK", {
        fontFamily: us,
        fontWeight: "300",
        fill: 16777215,
        fontSize: oc
    }, {
        chars: [...le.NUMERIC, "."],
        resolution: 2,
        textureWidth: 256,
        textureHeight: 256,
        mipmap: 0
    })
}
;
ey();
A.on("initFonts", ey);
const gk = new ki({
    fontFamily: us,
    fontWeight: "500",
    fill: 16252927,
    fontSize: oc
});
class vk {
    constructor() {
        I(this, "displayObject", j1.allocate());
        I(this, "mass", new $e("",{
            fontName: "LEADERBOARD_MASS"
        }));
        I(this, "rank", new $e("",{
            fontName: "LEADERBOARD_RANK"
        }));
        I(this, "nick", W1.allocate());
        I(this, "_massText");
        I(this, "nickText");
        this.assembly()
    }
    get color() {
        return Vt.get(this.id).teamColor
    }
    get graphicsTint() {
        return Be(B.BgcLeaderboard[0])
    }
    get graphicsAlpha() {
        return B.BgcLeaderboard[1]
    }
    get height() {
        return this.nick.height
    }
    get rankText() {
        return `${this.index + 1}`
    }
    set massText(t) {
        this._massText = `[${t >= 1e3 ? (t / 1e3).toFixed(1) + "k" : t >> 0}]`
    }
    get massText() {
        return this._massText
    }
    get interactive() {
        return U.state >= 2
    }
    set interactive(t) {
        this.displayObject.interactive = t
    }
    setTop(t) {
        this.displayObject.position.set(0, (this.height + ty) * this.index + t + Od * 2)
    }
    onDown(t) {
        t.preventDefault(),
        t.stopImmediatePropagation(),
        this.displayObject.alpha = .5,
        A.emit("selectSpectate", this.id),
        setTimeout(()=>this.displayObject.alpha = 1, 120)
    }
    init(t, i, s, n) {
        return this.id = t,
        this.index = i,
        this.nickText = s,
        this.massText = n,
        this.setup(),
        this
    }
    draw() {
        this.displayObject.interactive = this.interactive,
        this.displayObject.roundPixels = !0,
        this.displayObject.on("pointerdown", i=>this.onDown(i));
        let t = this.index === 9 ? 7.5 : 2;
        for (this.rank.text = this.rankText,
        this.rank.roundPixels = !0,
        this.rank.position.set(182.5 - t, 0),
        this.mass.text = this.massText,
        this.mass.roundPixels = !0,
        this.mass.position.set(172.5 - this.mass.textWidth, 0),
        this.nick.text = this.nickText,
        this.nick.roundPixels = !0,
        this.nick.style = gk.clone(); this.nick.width > 250; ) {
            const i = this.nick.text
              , s = i.length - 1;
            this.nick.text = i.substr(0, s)
        }
        this.nick.position.set(165 - this.nick.width - this.mass.textWidth, -.5)
    }
    setup() {
        return this.draw(),
        this.deployColorStyle(),
        this
    }
    deployColorStyle() {
        this.nick.style.fill = this.color,
        this.mass.tint = this.color,
        this.rank.tint = this.color,
        this.displayObject.clear().beginFill(this.graphicsTint, this.graphicsAlpha).drawRect(160 - this.nick.width - this.mass.textWidth, -2, this.nick.width + this.mass.textWidth + 32.5, this.height + 3)
    }
    assembly() {
        this.displayObject.addChild(this.mass, this.rank, this.nick)
    }
    release() {
        this.displayObject.clear(),
        this.displayObject.removeFromParent(),
        iy.release(this)
    }
}
const iy = new wi(vk,10);
class _k extends ae {
    constructor() {
        super();
        I(this, "graphics", new ke);
        I(this, "container", new ae);
        I(this, "title", new $e("LEADERBOARD",{
            fontName: "LEADERBOARD_TITLE"
        }));
        I(this, "nodeList", new Set)
    }
    get visibility() {
        return H.ShowLeaderboard
    }
    get size() {
        return H.LeaderboardSize
    }
    get graphicsTint() {
        return Be(B.BgcLeaderboard[0])
    }
    get graphicsAlpha() {
        return B.BgcLeaderboard[1]
    }
    positioning() {
        this.position.set(innerWidth - vu * this.size - mk, 0)
    }
    resize() {
        this.scale.set(this.size),
        this.positioning()
    }
    detectText(i) {
        i.forEach(s=>{
            const [n,r] = s;
            let o;
            n ? (Pi.getPlayer(n) || console.log(n, Vt.size),
            o = Pi.getPlayer(n).opUnits.get(r).tagNick) : o = "Bot",
            s[1] = o
        }
        )
    }
    draw(i) {
        this.clear(),
        this.detectText(i);
        let s = 0;
        i.forEach(([n,r,o],a)=>{
            const l = iy.allocate().init(n, a, r, o);
            l.setTop(this.title.height),
            this.container.addChild(l.displayObject),
            this.nodeList.add(l),
            s += l.height + ty
        }
        ),
        this.graphics.beginFill(16777215, 1).drawRect(0, 0, vu, s + this.title.height + Od * 2.5).endFill()
    }
    init() {
        this.title.roundPixels = !1,
        this.title.alpha = .85,
        this.title.position.set((vu - this.title.width) / 2 + 32, Od)
    }
    deploy() {
        this.resize(),
        this.deployVisibility(),
        this.deployGraphicsStyle()
    }
    deployVisibility() {
        this.visible = this.visibility
    }
    deployGraphicsStyle() {
        this.graphics.tint = this.graphicsTint,
        this.graphics.alpha = this.graphicsAlpha,
        this.nodeList.forEach(i=>{
            i.deployColorStyle()
        }
        )
    }
    assembly() {
        this.addChild(this.container, this.title)
    }
    setup() {
        return this.init(),
        this.deploy(),
        this.assembly(),
        this
    }
    clear() {
        this.nodeList.forEach(i=>i.release()),
        this.nodeList.clear(),
        this.graphics.clear()
    }
    reset() {
        this.clear()
    }
}
const _u = 160
  , yk = -3
  , bk = 12
  , Dd = 4
  , Nd = 2
  , sy = 7.5
  , ac = 13
  , ny = ()=>{
    le.from("TEAMRANKINGS_TITLE", {
        fontFamily: us,
        fontWeight: "500",
        fill: 3182847,
        fontSize: ac * 1.4 >> 0
    }, {
        chars: "TEAM RNKIGS",
        resolution: 2,
        textureWidth: 256,
        textureHeight: 256,
        mipmap: 0
    }),
    le.from("TEAMRANKINGS_RANK", {
        fontFamily: us,
        fontWeight: "300",
        fill: 16777215,
        fontSize: ac
    }, {
        chars: [...le.NUMERIC, "."],
        resolution: 2,
        textureWidth: 256,
        textureHeight: 256,
        mipmap: 0
    }),
    le.from("TEAMRANKINGS_PERCENTAGE", {
        fontFamily: us,
        fontWeight: "300",
        fill: 16777215,
        fontSize: ac
    }, {
        chars: [...le.NUMERIC, ".%[]"],
        resolution: 2,
        textureWidth: 256,
        textureHeight: 256,
        mipmap: 0
    })
}
;
ny();
A.on("initFonts", ny);
const xk = new ki({
    fontFamily: us,
    fontWeight: "500",
    fill: 16252927,
    fontSize: ac
});
class wk {
    constructor() {
        I(this, "displayObject", j1.allocate());
        I(this, "rank", new $e("",{
            fontName: "TEAMRANKINGS_RANK"
        }));
        I(this, "name", new ys("",xk.clone()));
        I(this, "percentage", new $e("",{
            fontName: "TEAMRANKINGS_PERCENTAGE"
        }));
        I(this, "id");
        I(this, "index");
        I(this, "nameText");
        I(this, "percentageValue");
        I(this, "color");
        this.assembly()
    }
    init(t, i, s, n, r) {
        return this.id = t,
        this.index = i,
        this.nameText = s,
        this.percentageValue = n,
        this.color = r,
        this.setup(),
        this
    }
    get graphicsTint() {
        return Be(B.BgcTeamRankings[0])
    }
    get graphicsAlpha() {
        return B.BgcTeamRankings[1]
    }
    get height() {
        return this.name.height
    }
    get rankText() {
        return `${this.index + 1}`
    }
    get percentageText() {
        return `[${this.percentageValue.toFixed(1)}%]`
    }
    setTop(t) {
        this.displayObject.position.set(0, t + (this.height + Nd + sy) * this.index + Nd + Dd * 2)
    }
    draw() {
        this.displayObject.scale.set(1),
        this.displayObject.roundPixels = !0;
        let t = this.index === 9 ? 7.5 : 2;
        this.rank.text = this.rankText,
        this.rank.roundPixels = !0,
        this.rank.position.set(142 - t, 0),
        this.percentage.text = this.percentageText,
        this.percentage.roundPixels = !0,
        this.percentage.position.set(132.5 - this.percentage.width, 0),
        this.name.text = this.nameText,
        this.name.roundPixels = !0,
        this.name.position.set(125 - this.name.width - this.percentage.width, -1)
    }
    deploy() {
        this.deployColorStyle()
    }
    deployColorStyle() {
        this.name.style.fill = this.color,
        this.percentage.tint = this.color,
        this.rank.tint = this.color,
        this.displayObject.clear().beginFill(this.graphicsTint, this.graphicsAlpha).drawRect(120 - this.name.width - this.percentage.width, -3, this.name.width + this.percentage.width + 32.5, this.height + 4.5)
    }
    assembly() {
        this.displayObject.addChild(this.rank, this.name, this.percentage)
    }
    setup() {
        return this.draw(),
        this.deploy(),
        this
    }
    release() {
        this.displayObject.clear(),
        this.displayObject.removeFromParent(),
        ry.release(this)
    }
}
const ry = new wi(wk,8);
class Tk extends ae {
    constructor() {
        super();
        I(this, "graphics", new ke);
        I(this, "container", new ae);
        I(this, "title", new $e("TEAM RANKINGS",{
            fontName: "TEAMRANKINGS_TITLE"
        }));
        I(this, "nodeList", new Set)
    }
    get visibility() {
        return H.ShowTeamRankings && this.nodeList.size
    }
    get size() {
        return H.TeamRankingsSize
    }
    get graphicsTint() {
        return Be(B.BgcTeamRankings[0])
    }
    get graphicsAlpha() {
        return B.BgcTeamRankings[1]
    }
    positioning(i) {
        this.position.set(innerWidth - _u * this.size - yk, i + bk)
    }
    resize() {
        this.scale.set(this.size)
    }
    detectText(i) {
        i.forEach(s=>{
            const {name: n, color: r} = Pi.getTeam(s[0]);
            s.push(n, r)
        }
        )
    }
    draw(i) {
        this.deployVisibility(),
        this.clear(),
        this.detectText(i);
        let s = 0;
        i.forEach(([n,r,o,a],l)=>{
            const c = ry.allocate().init(n, l, o, r / 10, a);
            c.setTop(this.title.height),
            this.container.addChild(c.displayObject),
            this.nodeList.add(c),
            s += c.height + Nd + sy
        }
        ),
        this.graphics.beginFill(16777215, 1).drawRect(0, 0, _u, s + this.title.height + Dd * 2.5).endFill()
    }
    init() {
        this.title.roundPixels = !0,
        this.title.alpha = .85,
        this.title.position.set((_u - this.title.width) / 2 + 7, Dd)
    }
    deploy() {
        this.resize(),
        this.deployVisibility(),
        this.deployGraphicsStyle()
    }
    deployVisibility() {
        this.visible = this.visibility
    }
    deployGraphicsStyle() {
        this.graphics.tint = this.graphicsTint,
        this.graphics.alpha = this.graphicsAlpha,
        this.nodeList.forEach(i=>{
            i.deployColorStyle()
        }
        )
    }
    assembly() {
        this.addChild(this.container, this.title)
    }
    setup() {
        return this.init(),
        this.deploy(),
        this.assembly(),
        this
    }
    clear() {
        this.nodeList.forEach(i=>i.release()),
        this.nodeList.clear(),
        this.graphics.clear()
    }
    reset() {
        this.clear(),
        this.visible = !1
    }
}
const zg = 240
  , Ek = 5
  , Sk = 8
  , zr = 12
  , zn = 6
  , oy = ()=>{
    le.from("PERFORMANCE_TEXT", {
        fontFamily: us,
        fontWeight: "600",
        fill: 3182847,
        fontSize: 12.5
    }, {
        chars: [...le.NUMERIC, "RDRPINGFSETYms: .+MAaXVOL%"],
        resolution: 2,
        textureWidth: 256,
        textureHeight: 256,
        mipmap: 0
    })
}
;
oy();
A.on("initFonts", oy);
class Ck extends ae {
    constructor() {
        super();
        I(this, "graphics", new ke);
        I(this, "FPS", new $e("",{
            fontName: "PERFORMANCE_TEXT"
        }));
        I(this, "PING", new $e("",{
            fontName: "PERFORMANCE_TEXT"
        }));
        I(this, "RENDER", new $e("",{
            fontName: "PERFORMANCE_TEXT"
        }));
        I(this, "ENTITY", new $e("",{
            fontName: "PERFORMANCE_TEXT"
        }));
        I(this, "AVGLOAD", new $e("",{
            fontName: "PERFORMANCE_TEXT"
        }));
        I(this, "MAXLOAD", new $e("",{
            fontName: "PERFORMANCE_TEXT"
        }));
        I(this, "_ping", !1);
        I(this, "_pingTime");
        I(this, "_pongTime");
        I(this, "_pingTimeout");
        I(this, "lastUpdate", 0);
        this.updatePerf()
    }
    get lineHeight() {
        return this.PING.height
    }
    get visibility() {
        return H.ShowPerfStatus
    }
    get size() {
        return H.PerfStatusSize
    }
    get graphicsTint() {
        return Be(B.BgcPerfPanel[0])
    }
    get graphicsAlpha() {
        return B.BgcPerfPanel[1]
    }
    positioning(i) {
        this.position.set(innerWidth - zg * this.size - Ek >> 0, i - this.height - Sk)
    }
    resize() {
        this.scale.set(this.size)
    }
    init() {
        this.FPS.roundPixels = !0,
        this.FPS.alpha = .85,
        this.FPS.position.set(zr, zn),
        this.PING.roundPixels = !0,
        this.PING.alpha = .85,
        this.PING.position.set(zr + 115, zn),
        this.RENDER.roundPixels = !0,
        this.RENDER.alpha = .85,
        this.RENDER.position.set(zr, this.lineHeight + zn * 2),
        this.ENTITY.roundPixels = !0,
        this.ENTITY.alpha = .85,
        this.ENTITY.position.set(zr + 115, this.lineHeight + zn * 2),
        this.AVGLOAD.roundPixels = !0,
        this.AVGLOAD.alpha = .85,
        this.AVGLOAD.position.set(zr, this.lineHeight * 2 + zn * 3),
        this.MAXLOAD.roundPixels = !0,
        this.MAXLOAD.alpha = .85,
        this.MAXLOAD.position.set(zr + 115, this.lineHeight * 2 + zn * 3),
        this.graphics.roundPixels = !0,
        this.graphics.beginFill(16777215).drawRect(0, 0, zg, this.lineHeight * 3 + zn * 4).endFill()
    }
    deploy() {
        this.resize(),
        this.deployVisibility(),
        this.deployGraphicsStyle()
    }
    deployVisibility() {
        this.visible = this.visibility
    }
    deployGraphicsStyle() {
        this.graphics.tint = this.graphicsTint,
        this.graphics.alpha = this.graphicsAlpha
    }
    assembly() {
        this.addChild(this.graphics, this.FPS, this.PING, this.RENDER, this.ENTITY, this.AVGLOAD, this.MAXLOAD)
    }
    setup() {
        return this.init(),
        this.deploy(),
        this.assembly(),
        this
    }
    ping() {
        this._ping || (at.send(),
        this._pingTime = performance.now(),
        this._ping = !0)
    }
    pong() {
        this._pongTime = performance.now(),
        H.ExtraLatency > 0 ? this.PING.text = `PING: ${this._pongTime - this._pingTime >> 0}+${H.ExtraLatency} ms` : this.PING.text = `PING: ${this._pongTime - this._pingTime >> 0} ms`,
        this._ping = !1,
        this._pingTimeout = setTimeout(()=>this.ping(), 1e3)
    }
    updatePerf(i) {
        if (i - this.lastUpdate < 1e3)
            return;
        const s = Gt.statistics;
        if (!s.length)
            return;
        let n = 0;
        s.forEach(l=>n += l);
        const r = (s.length / (i - this.lastUpdate) * 1e3).toFixed(1);
        Gt.fps = Number(r),
        n /= r,
        s.length = 0,
        n = (n * 100 >> 0) / 100,
        this.FPS.text = `FPS: ${r}`,
        this.RENDER.text = `RENDER: ${n}ms`,
        this.ENTITY.text = `ENTITY: ${Me.getVisibleEntitySize()}`;
        const o = Gt.load;
        let a = 0;
        n = 0,
        o.forEach(l=>{
            n += l,
            l > a && (a = l)
        }
        ),
        n /= o.length * 10,
        n = (n / 40 * 100).toFixed(1),
        a /= 10,
        a = (a / 40 * 100).toFixed(1),
        o.length = 0,
        this.AVGLOAD.text = `SVR LOAD: ${n}%`,
        this.MAXLOAD.text = `MAX LOAD: ${a}%`,
        this.lastUpdate = i
    }
    reset() {
        clearInterval(this._pingTimeout),
        this._ping = !1
    }
}
const $g = 24
  , ra = 12
  , Hl = .5
  , ay = ()=>{
    le.from("CWAL_GAME_STATUS_TEXT", {
        fontFamily: "Titillium Web",
        fontWeight: "500",
        fill: 3182847,
        fontSize: 16,
        stroke: 3182847,
        strokeThickness: .5
    }, {
        chars: [...le.NUMERIC, "MascoreSTE/:. k"],
        resolution: 2,
        textureWidth: 128,
        textureHeight: 128
    })
}
;
ay();
A.on("initFonts", ay);
class Ak extends ae {
    constructor() {
        super();
        I(this, "graphics", new ke);
        I(this, "MASS", new $e("Mass: 0",{
            fontName: "CWAL_GAME_STATUS_TEXT"
        }));
        I(this, "SCORE", new $e("Score: 0",{
            fontName: "CWAL_GAME_STATUS_TEXT"
        }));
        I(this, "STE", new $e("STE: 0",{
            fontName: "CWAL_GAME_STATUS_TEXT"
        }));
        I(this, "DIV", new $e("0/16",{
            fontName: "CWAL_GAME_STATUS_TEXT"
        }))
    }
    get visibility() {
        return H.ShowGameStatus
    }
    get size() {
        return H.GameStatusSize
    }
    get graphicsTint() {
        return 3815994
    }
    get graphicsAlpha() {
        return .25
    }
    positioning() {
        let i = ra;
        this.SCORE.roundPixels = !0,
        this.SCORE.alpha = .85,
        this.SCORE.position.set(i, Hl),
        i += ra + this.SCORE.width,
        this.MASS.roundPixels = !0,
        this.MASS.alpha = .85,
        this.MASS.position.set(i, Hl),
        i += ra + this.MASS.width,
        this.STE.roundPixels = !0,
        this.STE.alpha = .85,
        this.STE.position.set(i, Hl),
        i += ra + this.STE.width,
        this.DIV.roundPixels = !0,
        this.DIV.alpha = .85,
        this.DIV.position.set(i, Hl);
        const s = i + ra + this.DIV.width;
        this.graphics.width = s,
        this.graphics.roundPixels = !0,
        this.position.set(innerWidth / 2 - s / 2 * this.size >> 0, innerHeight - $g * this.size)
    }
    resize() {
        this.scale.set(this.size)
    }
    init() {
        this.graphics.beginFill(16777215).drawRect(0, 0, 320, $g).endFill()
    }
    deploy() {
        this.resize(),
        this.deployVisibility(),
        this.deployGraphicsStyle()
    }
    deployVisibility() {
        this.visible = this.visibility
    }
    deployGraphicsStyle() {
        this.graphics.tint = this.graphicsTint,
        this.graphics.alpha = this.graphicsAlpha
    }
    assembly() {
        this.addChild(this.graphics, this.SCORE, this.MASS, this.STE, this.DIV)
    }
    setup() {
        return this.init(),
        this.deploy(),
        this.assembly(),
        this
    }
    updateStatus() {
        let i = U.score ? U.score : 0
          , s = U.totalMass ? U.totalMass : 0;
        i > 1e3 && (i = ((i / 100 >> 0) / 10).toFixed(1) + "k"),
        s > 1e3 && (s = ((s / 100 >> 0) / 10).toFixed(1) + "k");
        let n = 0;
        U.largest && (n = U.largest.massValue / 1.31 >> 0,
        n > 1e3 && (n = ((n / 100 >> 0) / 10).toFixed(1) + "k"));
        let r = 0
          , o = U.currentOpUnit;
        o && (r = o.pcells.size),
        this.SCORE.text = `Score: ${i}`,
        this.MASS.text = `Mass: ${s}`,
        this.STE.text = `STE: ${n}`,
        this.DIV.text = `${r}/16`,
        this.positioning()
    }
    reset() {
        this.SCORE.text = "Score: 0",
        this.MASS.text = "Mass: 0",
        this.STE.text = "STE: 0",
        this.DIV.text = "0/16",
        this.positioning()
    }
}
class Ik extends ae {
    constructor() {
        super();
        I(this, "bottomContainer", new ak().setup());
        I(this, "miniMap", new pk().setup());
        I(this, "leaderboard", new _k().setup());
        I(this, "teamRankings", new Tk().setup());
        I(this, "performancePanel", new Ck().setup());
        I(this, "gameStatus", new Ak().setup());
        I(this, "currMapData");
        I(this, "currLBData");
        I(this, "currTRData")
    }
    get mouseX() {
        return -this.bottomContainer.mainContainer.x + Gt.mouseX / this.bottomContainer.scale.x - this.bottomContainer.x / this.bottomContainer.scale.x
    }
    get mouseY() {
        return -this.bottomContainer.mainContainer.y + Gt.mouseY / this.bottomContainer.scale.y - this.bottomContainer.y / this.bottomContainer.scale.y
    }
    get centerX() {
        return -this.bottomContainer.mainContainer.x + innerWidth / 2 / this.bottomContainer.scale.x - this.bottomContainer.x / this.bottomContainer.scale.x
    }
    get centerY() {
        return -this.bottomContainer.mainContainer.y + innerHeight / 2 / this.bottomContainer.scale.y - this.bottomContainer.y / this.bottomContainer.scale.y
    }
    toScreenX(i) {
        return (i + this.bottomContainer.x / this.bottomContainer.scale.x + this.bottomContainer.mainContainer.x) * this.bottomContainer.scale.x
    }
    toScreenY(i) {
        return (i + this.bottomContainer.y / this.bottomContainer.scale.y + this.bottomContainer.mainContainer.y) * this.bottomContainer.scale.y
    }
    resize(i, s) {
        this.bottomContainer.position.set(i, s),
        this.positioningComponents()
    }
    positioningComponents() {
        this.miniMap.positioning(),
        this.leaderboard.positioning(),
        this.teamRankings.positioning(this.leaderboard.height),
        this.performancePanel.positioning(this.miniMap.position.y),
        this.gameStatus.positioning()
    }
    drawLeaderboard(i) {
        this.currLBData = i,
        this.leaderboard.draw(i)
    }
    drawTeamRankings(i) {
        this.currTRData = i,
        this.teamRankings.draw(i),
        this.positioningComponents()
    }
    drawMap(i) {
        switch (this.currMapData = i,
        i.type) {
        case "Rect":
            const {borderLeft: s, borderRight: n, borderTop: r, borderBottom: o} = i;
            this.bottomContainer.mainContainer.drawRectMap(s, n, r, o),
            this.miniMap.drawRectMap(s, n, r, o),
            A.emit(Ht.BackgroundImage);
            break;
        case "Octa":
            this.bottomContainer.mainContainer.drawOctagonMap(i),
            this.miniMap.drawOctagonMap(i),
            A.emit(Ht.BackgroundImage);
            break
        }
        this.positioningComponents()
    }
    init() {
        this.positioningComponents()
    }
    assembly() {
        this.addChild(this.miniMap, this.leaderboard, this.teamRankings, this.performancePanel, this.gameStatus)
    }
    setup() {
        return this.init(),
        this.assembly(),
        this
    }
    reset() {
        this.bottomContainer.reset(),
        this.leaderboard.reset(),
        this.teamRankings.reset(),
        this.gameStatus.reset()
    }
}
const zt = new Ik().setup()
  , {bottomContainer: ba, bottomContainer: {mainContainer: Cn, mainContainer: {gameMap: Nn, fcellContainer: Fd, ecellContainer: Bd, entityContainer: is}}, miniMap: Je, leaderboard: Wo, teamRankings: op, performancePanel: Ar, gameStatus: ly} = zt;
A.on(Ut.ShowMinimap, ()=>Je.deployVisibility());
A.on(Ut.ShowLeaderboard, ()=>Wo.deployVisibility());
A.on(Ut.ShowTeamRankings, ()=>op.deployVisibility());
A.on(Ut.ShowPerfStatus, ()=>Ar.deployVisibility());
A.on(Ut.ShowGameStatus, ()=>ly.deployVisibility());
A.on(Ut.MinimapSize, ()=>{
    Je.resize(),
    zt.positioningComponents()
}
);
A.on(Ut.LeaderboardSize, ()=>{
    Wo.resize(),
    zt.positioningComponents()
}
);
A.on(Ut.TeamRankingsSize, ()=>{
    op.resize(),
    zt.positioningComponents()
}
);
A.on(Ut.PerfStatusSize, ()=>{
    Ar.resize(),
    zt.positioningComponents()
}
);
A.on(Ut.GameStatusSize, ()=>{
    ly.resize(),
    zt.positioningComponents()
}
);
A.on(Ht.CoordsFont, ()=>Nn.deployCoordsStyle());
A.on(Ht.CoordsGrid, ()=>Nn.deployCoordsStyle());
A.on(Ht.Border, ()=>{
    B.BorderGlow[0] = B.Border[0],
    B.BorderGlow[1] = (B.Border[1] ** .5 * 100 >> 0) / 100,
    Nn.deployBorderStyle()
}
);
A.on(Ht.BorderGlow, ()=>Nn.deployBorderStyle());
document.body.style.backgroundColor = "#" + B.BackgroundColor[0];
A.on(Ht.BackgroundColor, ()=>document.body.style.backgroundColor = "#" + B.BackgroundColor[0]);
A.on(Ht.BackgroundImage, ()=>{
    Nn.deployBackgroundStyle(),
    Nn.drawBackground()
}
);
A.on(Ht.CoordsFontMinimap, ()=>Je.deployCoordsStyle());
A.on(Ht.CoordsGridMinimap, ()=>Je.deployCoordsStyle());
A.on(Ht.BgcMinimap, ()=>Je.deployGraphicsStyle());
A.on(Ht.LocationLine, ()=>Je.deployLocationLineStyle());
A.on(Ht.ViewMinimap, ()=>Je.viewportList.forEach(e=>e.deploySpriteStyle()));
A.on(Ht.EntityMinimap, ()=>Je.entityList.forEach(e=>e.forEach(t=>{
    t && t.deploySpriteStyle()
}
)));
A.on(Ht.EntityInfoMinimap, ()=>{
    Je.entityList.forEach(e=>e.forEach(t=>{
        t && t.deployNickStyle()
    }
    ))
}
);
A.on(Ht.BgcLeaderboard, ()=>Wo.deployGraphicsStyle());
A.on(Ht.BgcTeamRankings, ()=>op.deployGraphicsStyle());
A.on(Ht.BgcPerfPanel, ()=>Ar.deployGraphicsStyle());
let jg = performance.now();
A.on("sendMousePos", e=>{
    U.state != 1 && Je.pointerIn && Je.jumping || e - jg > 15 && (Gt.svrMouseX = zt.mouseX,
    Gt.svrMouseY = zt.mouseY,
    at.writer.writeUint8(0).writeFloat32(zt.mouseX).writeFloat32(zt.mouseY),
    at.send(),
    jg = e)
}
);
A.on("play", ()=>Wo.nodeList.forEach(e=>e.interactive = !1));
A.on("spectate", ()=>Wo.nodeList.forEach(e=>e.interactive = !0));
A.on("death", ()=>Wo.nodeList.forEach(e=>e.interactive = !0));
const Mk = ()=>{
    Me.reset(),
    Ms.forEach(e=>e.destroy()),
    Ms.clear(),
    Vt.forEach(e=>e.id != U.id && e.destroy()),
    Vt.clear(),
    U.reset(),
    zt.reset(),
    Je.reset(),
    Nn.reset(),
    Ar.reset(),
    A.emit("sendProfile"),
    A.emit("sendNotice"),
    setTimeout(()=>Ar.ping(), 400)
}
;
A.on("initGame", Mk);
A.on("clearMap", ()=>{
    Je.reset(),
    Nn.reset()
}
);
A.on("refreshGame", ()=>{
    Me.reset(),
    zt.reset()
}
);
A.on("changeServer", e=>{
    at.PAUSE = !0,
    at.close(1e3),
    setTimeout(()=>{
        at.connect(e)
    }
    , 40)
}
);
class Rk extends sp {
    constructor() {
        super(!0);
        I(this, "cursorLine", new ke);
        I(this, "SplitOrderMarker", As.allocate());
        I(this, "_SplitOrderMarkerTint", 38655);
        this.cursorLine.zIndex = -1,
        this.cursorLine.position.set(0),
        this.cursorLine.scale.set(1),
        this.SplitOrderMarker.texture = ie.get("SPLIT_ORDER_MARKER"),
        this.assembly()
    }
    get inControl() {
        return this.player.currentOpUnit === this.opUnit
    }
    get nickVisibility() {
        return this.textVisibility && H.ShowNick
    }
    get cursorLineVisibility() {
        return this.inControl && H.ShowCursorLine
    }
    get SplitOrderMarkerVisibility() {
        return this.inControl && H.ShowSplitOrderMarker
    }
    get entityTint() {
        return Be(B.CellSelf[0]) ?? this.color
    }
    get entityAlpha() {
        return B.CellSelf[1]
    }
    get skinTint() {
        return Be(B.SkinSelf[0])
    }
    get skinAlpha() {
        return B.SkinSelf[1]
    }
    get cursorLineTint() {
        return Be(B.CursorLine[0])
    }
    get cursorLineAlpha() {
        return B.CursorLine[1]
    }
    get cursorLineSize() {
        return Number(B.CursorLine[2])
    }
    set SplitOrderMarkerWeight(i) {
        this._SplitOrderMarkerTint = 255 * (1 - i) << 16 | 55 * i ** 2 << 8 | 150 + 105 * i
    }
    get SplitOrderMarkerTint() {
        return Be(B.SplitOrderMarker[0]) ?? this._SplitOrderMarkerTint
    }
    get SplitOrderMarkerAlpha() {
        return B.SplitOrderMarker[1]
    }
    get SplitOrderMarkerSize() {
        return B.SplitOrderMarker[2]
    }
    preDeath(i) {
        super.preDeath(i),
        this.player.detectDeath(this.opUnit)
    }
    preDisappear(i) {
        super.preDisappear(i),
        this.player.detectDeath(this.opUnit)
    }
    drawCursorLine() {
        if (this.cursorLine.clear(),
        this.deployCursorLineVisibility(),
        this.cursorLineVisibility) {
            const {x: i, y: s} = this.baseLayer.getGlobalPosition();
            this.cursorLine.lineStyle(this.cursorLineSize, this.cursorLineTint, this.cursorLineAlpha).moveTo(i, s).lineTo(Gt.mouseX, Gt.mouseY).closePath()
        }
    }
    updateMassLevel() {
        this.inControl ? this.massLevel != -1 && (this.massLevel = -1,
        this.assistance.needUpdate = !0) : super.updateMassLevel()
    }
    drawAssistance() {
        if (!this.assistance.needUpdate)
            return;
        const i = this.SplitOrderMarker
          , s = this.MassMarker
          , n = this.AutosplitAlert;
        i.visible = !1,
        s.visible = !1,
        n.visible = !1,
        this.assistance.needUpdate = !1;
        let r, o;
        if (this.SplitOrderMarkerVisibility && (r = this.SplitOrderMarkerTint,
        o = this.SplitOrderMarkerAlpha,
        i.visible = !0,
        i.tint = r,
        i.alpha = o),
        H.ShowAutosplitAlert && this.asaColor != -1) {
            r = this.asaColor,
            o = this.AutosplitAlertAlpha,
            n.visible = !0,
            n.tint = r,
            n.alpha = o,
            this.massValue < 2e4 ? n.texture = ie.get("AUTOSPLIT_ALERT1") : n.texture = ie.get("AUTOSPLIT_ALERT2");
            return
        }
        !this.SplitOrderMarkerVisibility && H.ShowMassMarker && this.massLevel != -1 && (r = J1[this.massLevel],
        o = this.MassMarkerAlpha,
        s.visible = !0,
        s.tint = r,
        s.alpha = o)
    }
    update(i, s, n, r, o, a, l) {
        const c = super.update(i, s, n, r, o, a, l);
        return this.drawCursorLine(),
        (n ** 2 / 100 >= 42 && a ** 2 / 100 < 42 || a ** 2 / 100 >= 42 && n ** 2 / 100 < 42) && (U.needUpdate = !0),
        c
    }
    init(i, s, n, r, o, a, l, c) {
        return super.init(i, s, n, r, o, a, l, c),
        zt.addChild(this.cursorLine),
        this
    }
    deploy() {
        return super.deploy(),
        this.deployCursorLineVisibility(),
        this.drawAssistance(),
        this
    }
    deployCursorLineVisibility() {
        this.cursorLine.visible = this.cursorLineVisibility
    }
    assembly() {
        this.assistance.addChild(this.SplitOrderMarker, this.MassMarker, this.AutosplitAlert),
        this.box.addChild(this.baseLayer, this.assistance, this.tag, this.nick, this.mass)
    }
    release() {
        this.assistance.needUpdate = !0,
        this.massLevel = -1,
        this.SplitOrderMarker.visible = !1,
        this.MassMarker.visible = !1,
        this.AutosplitAlert.visible = !1,
        this.unbindOpUnit(),
        this.cursorLine.clear(),
        this.cursorLine.removeFromParent(),
        dp.release(this)
    }
}
class cy extends xh {
    constructor() {
        super();
        I(this, "color");
        this.baseLayer.anchor.set(.5),
        this.baseLayer.texture = ie.get("BASE"),
        this.assembly()
    }
    get type() {
        return this.state == 1 ? 120 : 121
    }
    get baseLayerTint() {
        return parseInt(`0x${B.EjectedCell[0]}`) || this.color
    }
    get baseLayerAlpha() {
        return B.EjectedCell[1]
    }
    init(i, s, n, r, o, a) {
        return super.init(i, s, n, r, o),
        this.color = a,
        this
    }
    copySpecific() {
        return [this.color]
    }
    release() {
        lp.release(this)
    }
}
class hy extends xh {
    constructor() {
        super();
        I(this, "color");
        this.baseLayer.anchor.set(.5),
        this.baseLayer.texture = ie.get("BLASTER_SPORE"),
        this.assembly()
    }
    get type() {
        return 131
    }
    get baseLayerTint() {
        return parseInt(`0x${B.Food[0]}`) || this.color
    }
    get baseLayerAlpha() {
        return B.Food[1]
    }
    init(i, s, n, r, o, a) {
        return super.init(i, s, n, r, o),
        this.color = a,
        this
    }
    copySpecific() {
        return [this.color]
    }
    release() {
        ap.release(this)
    }
}
class uy extends ip {
    constructor() {
        super();
        I(this, "shootingHint", new hi);
        this.baseLayer.anchor.set(.5),
        this.shootingHint.texture = ie.get("BASE"),
        this.shootingHint.position.set(0),
        this.shootingHint.scale.set(1),
        this.shootingHint.anchor.set(.5),
        this.assembly()
    }
    get type() {
        return 141
    }
    get baseLayerTint() {
        return parseInt(`0x${B.Virus[0]}`)
    }
    get baseLayerAlpha() {
        return B.Virus[1]
    }
    get massVisibility() {
        return this.textVisibility && H.ShowMass && H.ShootingHintType != 2
    }
    get textVisibility() {
        return H.ShootingHintType ? this.globalScale > 12 : this.globalScale > 25 && H.ShootingHintType < 2
    }
    deploy() {
        return super.deploy(),
        this.deployVirusStyle(),
        this
    }
    deployVirusStyle() {
        const i = H.VirusType ? "ROUND_VIRUS" : "VIRUS";
        this.baseLayer.texture = ie.get(i)
    }
    deploybaseLayerStyle() {
        this.baseLayer.tint = this.baseLayerTint,
        this.shootingHint.tint = 16777215,
        this.finalAlpha = this.baseLayerAlpha,
        this.setAlpha(this.baseLayerAlpha)
    }
    fixSize() {
        const i = this.resized;
        return i && (this.or = this.nr,
        this.setSize(this.nr),
        H.ShootingHintType == 0 && (this.mass.text = this.massValue >> 0)),
        i
    }
    updateMass(i) {
        let s = 16
          , n = 212;
        at.WORLD.includes("Caffe") && (n = 180);
        let r = (n - 100) / s;
        if (H.ShootingHintType == 2) {
            this.mass.visible = !1,
            this.shootingHint.visible = !0;
            const o = i ** 2 / 100
              , a = (n - o) / s
              , l = Math.max(r - a, 0) / r;
            this.shootingHint.scale.set(l)
        } else if (H.ShootingHintType == 1) {
            if (this.mass.visible = !0,
            this.shootingHint.visible = !1,
            this.massValue < 100)
                return;
            this.mass.text = (n - this.massValue) / s >> 0,
            this.mass.scale.set(4),
            this.mass.y = -We * .15
        } else
            this.mass.visible = !0,
            this.shootingHint.visible = !1,
            this.mass.text = (this.nr ** 2 + i ** 2) / 200 >> 0,
            this.mass.scale.set(2),
            this.mass.y = -We * .05
    }
    assembly() {
        this.box.addChild(this.baseLayer, this.mass, this.shootingHint)
    }
    release() {
        cp.release(this)
    }
}
class dy extends ip {
    constructor() {
        super(),
        this.baseLayer.anchor.set(.5),
        this.assembly()
    }
    get baseLayerTint() {
        return parseInt(`0x${B.RedVirus[0]}`)
    }
    get baseLayerAlpha() {
        return B.RedVirus[1]
    }
    get massVisibility() {
        return this.textVisibility && H.ShowMass
    }
    get textVisibility() {
        return this.globalScale > 25
    }
    get type() {
        return 142
    }
    deploy() {
        return super.deploy(),
        this.deployVirusStyle(),
        this
    }
    deployVirusStyle() {
        const t = H.VirusType ? "ROUND_VIRUS" : "CVIRUS";
        this.baseLayer.texture = ie.get(t)
    }
    updateMass(t) {
        this.mass.text = (this.nr ** 2 + t ** 2) / 200 >> 0,
        this.mass.scale.set(2),
        this.mass.y = -We * .05
    }
    release() {
        hp.release(this)
    }
}
class kk extends xh {
    constructor() {
        super();
        I(this, "color");
        this.baseLayer.anchor.set(.5),
        this.baseLayer.texture = ie.get("WAVE"),
        this.assembly()
    }
    get type() {
        return 9
    }
    init(i, s, n, r) {
        return super.init(i, 0, s, n, 64),
        this.color = r,
        this
    }
    copySpecific() {
        return [this.color]
    }
    disappear(i) {
        return this.setAlpha(Ze(this.displayObject.alpha, this.finalAlpha, vi(this.floatTime, i, 1200))),
        this.fixDisappear()
    }
    setSize(i) {
        this.displayObject.zIndex = (i >> 0) + 1e11,
        this.displayObject.scale.set(i / We)
    }
    get baseLayerTint() {
        return this.color
    }
    release() {
        this.finalAlpha = 1,
        fy.release(this)
    }
}
const Ce = new Set
  , Ia = new Set
  , Ma = new Set
  , Tn = new Set
  , ur = new Set
  , oa = new Set
  , ze = new Map
  , gn = new Set
  , _n = new Set
  , Qn = new Set
  , $r = new Set
  , dr = new ki({
    fontFamily: us,
    fontWeight: "600",
    fill: 16777215,
    fontSize: .225 * We,
    lineJoin: "round",
    letterSpacing: 4
});
function wh() {
    Ce.forEach(t=>t.deployTextStyle()),
    dr.fontSize = Lc(),
    dr.stroke = ar(B.TextStroke),
    dr.strokeThickness = Oc();
    const e = We / 400;
    le.from("ENTITY_TEXT", dr, {
        chars: [...le.NUMERIC, ".Kk"],
        textureWidth: 256 * e,
        textureHeight: 276 * e,
        mipmap: H.Mipmap * 2
    })
}
wh();
A.on("initFonts", ()=>{
    Vt.forEach(e=>e.opUnits.forEach(t=>t.updateText())),
    Ms.forEach(e=>e.updateText()),
    wh()
}
);
A.on("refreshNickText", ()=>{
    Vt.forEach(e=>e.opUnits.forEach(t=>t.updateText()))
}
);
const ap = new wi(hy,512)
  , lp = new wi(cy,512)
  , cp = new wi(uy,32)
  , hp = new wi(dy,32)
  , up = new wi(sp,2048)
  , dp = new wi(Rk,512)
  , fy = new wi(kk,16);
class Me {
    static getEntity(t) {
        return ze.get(t)
    }
    static getVisibleEntitySize() {
        return Ce.size + Ia.size + Tn.size + ur.size + (H.ShowFood ? Ma.size : 0)
    }
    static getViewport(t) {
        return ze.get(t).viewport
    }
    static deploy() {
        Ce.forEach(t=>{
            t.deployNickVisibility(),
            t.deployMassVisibility()
        }
        ),
        Tn.forEach(t=>t.deployMassVisibility()),
        ur.forEach(t=>t.deployMassVisibility())
    }
    static create({time: t, type: i, id: s, x: n, y: r, mass: o, color: a, pid: l, cid: c}) {
        let h;
        switch (i) {
        case 9:
            h = fy.allocate().init(t, n, r, a).deploy(),
            is.addChild(h.displayObject);
            break;
        case 110:
        case 111:
            const u = Pi.getPlayer(l)
              , d = u.opUnits.get(c);
            u === U ? h = dp.allocate().init(t, s, n, r, o, a, u, d).deploy() : h = up.allocate().init(t, s, n, r, o, a, u, d).deploy(),
            Ce.add(h),
            is.addChild(h.displayObject);
            break;
        case 120:
        case 121:
            h = lp.allocate().init(t, s, n, r, o, a).deploy(),
            Ia.add(h),
            Bd.addChild(h.displayObject);
            break;
        case 131:
            h = ap.allocate().init(t, s, n, r, o, a).deploy(),
            Ma.add(h),
            Fd.addChild(h.displayObject);
            break;
        case 141:
            h = cp.allocate().init(t, s, n, r, o).deploy(),
            Tn.add(h),
            is.addChild(h.displayObject);
            break;
        case 142:
            h = hp.allocate().init(t, s, n, r, o).deploy(),
            ur.add(h),
            is.addChild(h.displayObject);
            break
        }
        if (s)
            ze.set(s, h);
        else {
            oa.add(h);
            return
        }
        i % 10 != 0 && i < 140 ? (h.state = 0,
        H.EnableAppearance && (h.preAppear(t),
        Qn.add(h))) : h.state = 1
    }
    static preUpdate({coef: t, time: i, id: s, x: n, y: r, mass: o}) {
        const a = ze.get(s);
        a.update_linear(t),
        a.sync(),
        a.lastSync = i,
        a.preUpdate(n, r, o),
        gn.add(a)
    }
    static sync(t) {
        U.update(),
        ti.state ? ze.forEach(s=>{
            s.lastSync < Gt.syncStamp && Me.remove(t, s.id),
            s.syncUpdate && s.syncUpdate()
        }
        ) : (gn.forEach(s=>{
            let n;
            s.lastSync < Gt.syncStamp && (n = vi(s.lastSync, Gt.syncStamp, Er()),
            s.update_linear(n),
            s.sync(),
            s.lastSync = Gt.syncStamp)
        }
        ),
        Ce.forEach(s=>s.syncUpdate()));
        const i = vi(0, 40, 200);
        oa.forEach(s=>{
            s.update_linear(i),
            s.sync(),
            s.nr = s.or * 1.25 + Math.min(s.or / 2.25, 196),
            s.finalAlpha && s.nr > 1250 && s.preDisappear(Gt.syncStamp)
        }
        )
    }
    static update_base(t) {
        _n.forEach(i=>{
            i.death(t) && (_n.delete(i),
            this.release(i))
        }
        ),
        $r.forEach(i=>{
            i.disappear(t) && ($r.delete(i),
            this.release(i))
        }
        ),
        Qn.forEach(i=>{
            i.appear(t) && Qn.delete(i)
        }
        )
    }
    static update_linear(t) {
        this.update_base(t);
        const i = vi(Gt.syncStamp, t, 200);
        oa.forEach(n=>{
            n.update_linear(i),
            n.finalAlpha == 0 && n.disappear(t) && (n.displayObject.removeFromParent(),
            oa.delete(n))
        }
        );
        const s = vi(Gt.syncStamp, t, Er());
        gn.forEach(n=>{
            n.update_linear(s) && gn.delete(n)
        }
        ),
        ti.state ? ze.forEach(n=>{
            n.frameUpdate && n.frameUpdate()
        }
        ) : Ce.forEach(n=>n.frameUpdate())
    }
    static eat(t, i, s) {
        const n = ze.get(i);
        if (n.preDeath(t),
        n.state = 2,
        H.EnableAbsorption && ze.has(s)) {
            const {nx: r, ny: o, nr: a} = ze.get(s)
              , l = Math.max(n.nr / a - .375, 0) * 8 + 1;
            n.preUpdate(r, o, n.nr / l),
            _n.add(n)
        } else
            A.emit("recordTempCell", n),
            n.release(),
            this.release(n);
        ze.delete(i),
        gn.delete(n),
        Qn.delete(n),
        $r.delete(n)
    }
    static remove(t, i) {
        const s = ze.get(i);
        s.preDisappear(t),
        H.EnableDisappearance ? $r.add(s) : (s.release(),
        this.release(s)),
        ze.delete(i),
        gn.delete(s),
        _n.delete(s),
        Qn.delete(s)
    }
    static release(t) {
        t instanceof sp ? (Ce.delete(t),
        is.removeChild(t.displayObject)) : t instanceof cy ? (Ia.delete(t),
        Bd.removeChild(t.displayObject)) : t instanceof hy ? (Ma.delete(t),
        Fd.removeChild(t.displayObject)) : t instanceof uy ? (Tn.delete(t),
        is.removeChild(t.displayObject)) : t instanceof dy && (ur.delete(t),
        is.removeChild(t.displayObject))
    }
    static reset() {
        _n.forEach(t=>{
            t.release()
        }
        ),
        $r.forEach(t=>{
            t.release()
        }
        ),
        ze.forEach(t=>{
            t.release()
        }
        ),
        oa.forEach(t=>{
            t.release()
        }
        ),
        Ce.clear(),
        gn.clear(),
        _n.clear(),
        Qn.clear(),
        $r.clear(),
        ze.clear()
    }
}
A.on(Ut.TagType, ()=>{
    Vt.forEach(e=>e.opUnits.forEach(t=>t.updateText())),
    Ce.forEach(e=>e.deployNickVisibility())
}
);
A.on(Ut.ShowNick, ()=>Ce.forEach(e=>e.deployNickVisibility()));
A.on(Ut.ShowMass, ()=>Ce.forEach(e=>e.deployMassVisibility()));
A.on(Ut.ShowSkin, ()=>Ce.forEach(e=>e.deployEntityTexture()));
A.on(Ut.ShowFood, ()=>Cn.deployFoodCellContainerVisibility());
A.on(Ut.VirusType, ()=>{
    Tn.forEach(e=>e.deployVirusStyle()),
    ur.forEach(e=>e.deployVirusStyle())
}
);
A.on(Ut.ShowCursorLine, ()=>U.opUnitQueue.current.pcells.forEach(e=>e.deployCursorLineVisibility()));
A.on(Ut.ShowMassMarker, ()=>{
    Ce.forEach(e=>{
        e.assistance.needUpdate = !0,
        e.drawAssistance()
    }
    )
}
);
A.on(Ut.ShowSplitOrderMarker, ()=>{
    U.opUnits.forEach(e=>e.deploySplitOrderMarkerStyle())
}
);
A.on(Ut.ShootingHintType, ()=>{
    Tn.forEach(e=>e.updateMass(e.r))
}
);
A.on(Ht.EjectedCell, ()=>Ia.forEach(e=>e.deployBaseLayerStyle()));
A.on(Ht.Food, ()=>Ma.forEach(e=>e.deployBaseLayerStyle()));
A.on(Ht.Virus, ()=>Tn.forEach(e=>e.deployBaseLayerStyle()));
A.on(Ht.RedVirus, ()=>ur.forEach(e=>e.deployBaseLayerStyle()));
A.on(Ht.Text, ()=>{
    Vt.forEach(e=>e.opUnits.forEach(t=>t.updateText())),
    Ms.forEach(e=>e.updateText()),
    wh()
}
);
A.on(Ht.TextStroke, ()=>{
    Vt.forEach(e=>e.opUnits.forEach(t=>t.updateText())),
    Ms.forEach(e=>e.updateText()),
    wh()
}
);
A.on(Ht.CellSelf, ()=>{
    U.opUnits.forEach(e=>e.pcells.forEach(t=>t.deployEntityTexture()))
}
);
A.on(Ht.SkinSelf, ()=>{
    U.opUnits.forEach(e=>e.pcells.forEach(t=>t.deployEntityTexture()))
}
);
A.on(Ht.SkinFillSelf, ()=>{
    U.opUnits.forEach(e=>e.updateSkin())
}
);
A.on(Ht.CellTeam, ()=>Ce.forEach(e=>e.deployEntityTexture()));
A.on(Ht.SkinTeam, ()=>Ce.forEach(e=>e.deployEntityTexture()));
A.on(Ht.SkinFillTeam, ()=>{
    Vt.forEach(e=>{
        e.opUnits.forEach(t=>t.updateSkin())
    }
    )
}
);
A.on(Ht.CellEnemy, ()=>Ce.forEach(e=>e.deployEntityTexture()));
A.on(Ht.SkinEnemy, ()=>Ce.forEach(e=>e.deployEntityTexture()));
A.on(Ht.SkinFillEnemy, ()=>{
    Vt.forEach(e=>{
        e.opUnits.forEach(t=>t.updateSkin())
    }
    )
}
);
A.on(Ht.CellAll, ()=>{
    B.CellSelf = B.CellTeam = B.CellEnemy = B.CellAll,
    Ce.forEach(e=>e.deployEntityTexture())
}
);
A.on(Ht.SkinAll, ()=>{
    B.SkinSelf = B.SkinTeam = B.SkinEnemy = B.SkinAll,
    Ce.forEach(e=>e.deployEntityTexture())
}
);
A.on(Ht.SkinFillAll, ()=>{
    B.SkinFillSelf = B.SkinFillTeam = B.SkinFillEnemy = B.SkinFillAll,
    Vt.forEach(e=>{
        e.opUnits.forEach(t=>t.updateSkin())
    }
    )
}
);
A.on(Ht.MassMarker, ()=>{
    Ce.forEach(e=>{
        e.assistance.needUpdate = !0,
        e.drawAssistance()
    }
    )
}
);
A.on(Ht.SplitOrderMarker, ()=>{
    U.opUnits.forEach(e=>e.deploySplitOrderMarkerStyle())
}
);
A.on("play", ()=>Ce.forEach(e=>e.interactive = !1));
A.on("spectate", ()=>Ce.forEach(e=>e.interactive = !0));
A.on("death", ()=>Ce.forEach(e=>e.interactive = !0));
let Pk = 0;
class py {
    constructor(t, i, s) {
        I(this, "id");
        I(this, "uSig");
        I(this, "name");
        I(this, "color");
        I(this, "tagText");
        I(this, "players", new Set);
        this.id = t,
        this.uSig = Pk++,
        this.name = i,
        this.color = s,
        this.updateText()
    }
    joinPlayer(t) {
        t.forEach(i=>{
            i.leaveTeam(),
            i.team = this,
            this.players.add(i),
            i.opUnits.forEach(s=>{
                s.updateText()
            }
            )
        }
        )
    }
    quitPlayer(t) {
        this.players.delete(t)
    }
    updateText() {
        this.updateTag(),
        this.updateBitmapFont()
    }
    updateTag() {
        if (!this.name || this.id == 0)
            return;
        this.tagText || (this.tagText = new ys);
        const t = dr.clone();
        B.Text[3] & 4 ? t.fill = lr(this.color, B.Text[1]) : t.fill = ar(B.Text),
        B.TextStroke[3] & 4 ? t.stroke = lr(this.color, B.TextStroke[1]) : t.stroke = ar(B.TextStroke),
        t.fontSize = Lc() * .72,
        t.strokeThickness = Oc() * .786,
        this.tagText.style = t,
        this.tagText.text = this.name,
        this.tagText.updateText()
    }
    updateBitmapFont() {
        const t = dr.clone();
        B.Text[3] & 4 ? t.fill = lr(this.color, B.Text[1]) : t.fill = ar(B.Text),
        B.TextStroke[3] & 4 ? t.stroke = lr(this.color, B.TextStroke[1]) : t.stroke = ar(B.TextStroke),
        t.fontSize = Lc(),
        t.strokeThickness = Oc();
        const i = We / 400;
        le.from(`${this.uSig}`, t, {
            chars: [...le.NUMERIC, ".Kk"],
            textureWidth: 256 * i,
            textureHeight: 276 * i,
            mipmap: H.Mipmap * 2
        })
    }
    destroy() {
        setTimeout(()=>{
            this.tagText && (this.tagText.removeFromParent(),
            this.tagText.destroy({
                texture: !0,
                baseTexture: !0
            })),
            le.available[this.uSig].destroy()
        }
        , 1e3)
    }
}
class Lk {
    constructor() {
        I(this, "store", []);
        I(this, "currIndex", 0);
        I(this, "targetIndex", 0)
    }
    get size() {
        return this.store.length
    }
    get first() {
        return this.store[0]
    }
    get last() {
        return this.store[this.size - 1]
    }
    get current() {
        return this.store[this.currIndex]
    }
    get target() {
        return this.store[this.targetIndex]
    }
    get nextToggleIndex() {
        let t = this.targetIndex;
        return t += 1,
        t >= this.size && (t = 0),
        this.targetIndex = t,
        t
    }
    push(t) {
        this.store.push(t)
    }
    remove(t) {
        const i = this.store.indexOf(t);
        this.store.slice(i, 1)
    }
    advance() {
        this.currIndex += 1,
        this.currIndex >= this.size && (this.currIndex = 0)
    }
    moveTo(t) {
        this.currIndex = t
    }
    clear() {
        this.targetIndex = 0,
        this.currIndex = 0,
        this.store.length = 0
    }
}
Ot.prototype.getDrawableSource = function() {
    const t = this.resource;
    return t ? t.bitmap || t.source : null
}
;
$f.prototype._canvasRenderTarget = null;
ht.prototype.patternCache = null;
ht.prototype.tintCache = null;
function Wg(e) {
    const t = ft.ADAPTER.createCanvas(6, 1)
      , i = t.getContext("2d");
    return i.fillStyle = e,
    i.fillRect(0, 0, 6, 1),
    t
}
function my() {
    if (typeof document > "u")
        return !1;
    const e = Wg("#ff00ff")
      , t = Wg("#ffff00")
      , s = ft.ADAPTER.createCanvas(6, 1).getContext("2d");
    s.globalCompositeOperation = "multiply",
    s.drawImage(e, 0, 0),
    s.drawImage(t, 2, 0);
    const n = s.getImageData(2, 0, 1, 1);
    if (!n)
        return !1;
    const r = n.data;
    return r[0] === 255 && r[1] === 0 && r[2] === 0
}
function Ok(e=[]) {
    return my() ? (e[j.NORMAL] = "source-over",
    e[j.ADD] = "lighter",
    e[j.MULTIPLY] = "multiply",
    e[j.SCREEN] = "screen",
    e[j.OVERLAY] = "overlay",
    e[j.DARKEN] = "darken",
    e[j.LIGHTEN] = "lighten",
    e[j.COLOR_DODGE] = "color-dodge",
    e[j.COLOR_BURN] = "color-burn",
    e[j.HARD_LIGHT] = "hard-light",
    e[j.SOFT_LIGHT] = "soft-light",
    e[j.DIFFERENCE] = "difference",
    e[j.EXCLUSION] = "exclusion",
    e[j.HUE] = "hue",
    e[j.SATURATION] = "saturation",
    e[j.COLOR] = "color",
    e[j.LUMINOSITY] = "luminosity") : (e[j.NORMAL] = "source-over",
    e[j.ADD] = "lighter",
    e[j.MULTIPLY] = "source-over",
    e[j.SCREEN] = "source-over",
    e[j.OVERLAY] = "source-over",
    e[j.DARKEN] = "source-over",
    e[j.LIGHTEN] = "source-over",
    e[j.COLOR_DODGE] = "source-over",
    e[j.COLOR_BURN] = "source-over",
    e[j.HARD_LIGHT] = "source-over",
    e[j.SOFT_LIGHT] = "source-over",
    e[j.DIFFERENCE] = "source-over",
    e[j.EXCLUSION] = "source-over",
    e[j.HUE] = "source-over",
    e[j.SATURATION] = "source-over",
    e[j.COLOR] = "source-over",
    e[j.LUMINOSITY] = "source-over"),
    e[j.NORMAL_NPM] = e[j.NORMAL],
    e[j.ADD_NPM] = e[j.ADD],
    e[j.SCREEN_NPM] = e[j.SCREEN],
    e[j.SRC_IN] = "source-in",
    e[j.SRC_OUT] = "source-out",
    e[j.SRC_ATOP] = "source-atop",
    e[j.DST_OVER] = "destination-over",
    e[j.DST_IN] = "destination-in",
    e[j.DST_OUT] = "destination-out",
    e[j.DST_ATOP] = "destination-atop",
    e[j.XOR] = "xor",
    e[j.SUBTRACT] = "source-over",
    e
}
const Dk = new pe;
class gy {
    constructor(t) {
        this.activeResolution = 1,
        this.smoothProperty = "imageSmoothingEnabled",
        this.blendModes = Ok(),
        this._activeBlendMode = null,
        this._projTransform = null,
        this._outerBlend = !1,
        this.renderer = t
    }
    init() {
        const t = this.renderer.background.alpha < 1;
        if (this.rootContext = this.renderer.view.getContext("2d", {
            alpha: t
        }),
        this.activeContext = this.rootContext,
        !this.rootContext.imageSmoothingEnabled) {
            const i = this.rootContext;
            i.webkitImageSmoothingEnabled ? this.smoothProperty = "webkitImageSmoothingEnabled" : i.mozImageSmoothingEnabled ? this.smoothProperty = "mozImageSmoothingEnabled" : i.oImageSmoothingEnabled ? this.smoothProperty = "oImageSmoothingEnabled" : i.msImageSmoothingEnabled && (this.smoothProperty = "msImageSmoothingEnabled")
        }
    }
    setContextTransform(t, i, s) {
        let n = t;
        const r = this._projTransform
          , o = this.activeResolution;
        s = s || o,
        r && (n = Dk,
        n.copyFrom(t),
        n.prepend(r)),
        i ? this.activeContext.setTransform(n.a * s, n.b * s, n.c * s, n.d * s, n.tx * o | 0, n.ty * o | 0) : this.activeContext.setTransform(n.a * s, n.b * s, n.c * s, n.d * s, n.tx * o, n.ty * o)
    }
    clear(t, i) {
        const {activeContext: s, renderer: n} = this;
        t = t ?? this.renderer.background.colorString,
        s.clearRect(0, 0, n.width, n.height),
        t && (s.globalAlpha = i ?? this.renderer.background.alpha,
        s.fillStyle = t,
        s.fillRect(0, 0, n.width, n.height),
        s.globalAlpha = 1)
    }
    setBlendMode(t, i) {
        const s = t === j.SRC_IN || t === j.SRC_OUT || t === j.DST_IN || t === j.DST_ATOP;
        !i && s && (t = j.NORMAL),
        this._activeBlendMode !== t && (this._activeBlendMode = t,
        this._outerBlend = s,
        this.activeContext.globalCompositeOperation = this.blendModes[t])
    }
    resize() {
        this.smoothProperty && (this.rootContext[this.smoothProperty] = Ot.defaultOptions.scaleMode === Hi.LINEAR)
    }
    invalidateBlendMode() {
        this._activeBlendMode = this.blendModes.indexOf(this.activeContext.globalCompositeOperation)
    }
    destroy() {
        this.renderer = null,
        this.rootContext = null,
        this.activeContext = null,
        this.smoothProperty = null
    }
}
gy.extension = {
    type: lt.CanvasRendererSystem,
    name: "canvasContext"
};
vt.add(gy);
class vy {
    constructor(t) {
        this._foundShapes = [],
        this.renderer = t
    }
    pushMask(t) {
        const i = this.renderer
          , s = t.maskObject || t;
        i.canvasContext.activeContext.save();
        const n = this._foundShapes;
        if (this.recursiveFindShapes(s, n),
        n.length > 0) {
            const r = i.canvasContext.activeContext;
            r.beginPath();
            for (let o = 0; o < n.length; o++) {
                const a = n[o]
                  , l = a.transform.worldTransform;
                this.renderer.canvasContext.setContextTransform(l),
                this.renderGraphicsShape(a)
            }
            n.length = 0,
            r.clip()
        }
    }
    recursiveFindShapes(t, i) {
        t.geometry && t.geometry.graphicsData && i.push(t);
        const {children: s} = t;
        if (s)
            for (let n = 0; n < s.length; n++)
                this.recursiveFindShapes(s[n], i)
    }
    renderGraphicsShape(t) {
        t.finishPoly();
        const i = this.renderer.canvasContext.activeContext
          , s = t.geometry.graphicsData
          , n = s.length;
        if (n !== 0)
            for (let r = 0; r < n; r++) {
                const o = s[r]
                  , a = o.shape;
                if (a.type === we.POLY) {
                    let l = a.points;
                    const c = o.holes;
                    let h, u, d, f;
                    i.moveTo(l[0], l[1]);
                    for (let p = 1; p < l.length / 2; p++)
                        i.lineTo(l[p * 2], l[p * 2 + 1]);
                    if (c.length > 0) {
                        h = 0,
                        d = l[0],
                        f = l[1];
                        for (let p = 2; p + 2 < l.length; p += 2)
                            h += (l[p] - d) * (l[p + 3] - f) - (l[p + 2] - d) * (l[p + 1] - f);
                        for (let p = 0; p < c.length; p++)
                            if (l = c[p].shape.points,
                            !!l) {
                                u = 0,
                                d = l[0],
                                f = l[1];
                                for (let m = 2; m + 2 < l.length; m += 2)
                                    u += (l[m] - d) * (l[m + 3] - f) - (l[m + 2] - d) * (l[m + 1] - f);
                                if (u * h < 0) {
                                    i.moveTo(l[0], l[1]);
                                    for (let m = 2; m < l.length; m += 2)
                                        i.lineTo(l[m], l[m + 1])
                                } else {
                                    i.moveTo(l[l.length - 2], l[l.length - 1]);
                                    for (let m = l.length - 4; m >= 0; m -= 2)
                                        i.lineTo(l[m], l[m + 1])
                                }
                                c[p].shape.closeStroke && i.closePath()
                            }
                    }
                    l[0] === l[l.length - 2] && l[1] === l[l.length - 1] && i.closePath()
                } else if (a.type === we.RECT)
                    i.rect(a.x, a.y, a.width, a.height),
                    i.closePath();
                else if (a.type === we.CIRC)
                    i.arc(a.x, a.y, a.radius, 0, 2 * Math.PI),
                    i.closePath();
                else if (a.type === we.ELIP) {
                    const l = a.width * 2
                      , c = a.height * 2
                      , h = a.x - l / 2
                      , u = a.y - c / 2
                      , d = .5522848
                      , f = l / 2 * d
                      , p = c / 2 * d
                      , m = h + l
                      , g = u + c
                      , y = h + l / 2
                      , x = u + c / 2;
                    i.moveTo(h, x),
                    i.bezierCurveTo(h, x - p, y - f, u, y, u),
                    i.bezierCurveTo(y + f, u, m, x - p, m, x),
                    i.bezierCurveTo(m, x + p, y + f, g, y, g),
                    i.bezierCurveTo(y - f, g, h, x + p, h, x),
                    i.closePath()
                } else if (a.type === we.RREC) {
                    const l = a.x
                      , c = a.y
                      , h = a.width
                      , u = a.height;
                    let d = a.radius;
                    const f = Math.min(h, u) / 2;
                    d = d > f ? f : d,
                    i.moveTo(l, c + d),
                    i.lineTo(l, c + u - d),
                    i.quadraticCurveTo(l, c + u, l + d, c + u),
                    i.lineTo(l + h - d, c + u),
                    i.quadraticCurveTo(l + h, c + u, l + h, c + u - d),
                    i.lineTo(l + h, c + d),
                    i.quadraticCurveTo(l + h, c, l + h - d, c),
                    i.lineTo(l + d, c),
                    i.quadraticCurveTo(l, c, l, c + d),
                    i.closePath()
                }
            }
    }
    popMask(t) {
        t.canvasContext.activeContext.restore(),
        t.canvasContext.invalidateBlendMode()
    }
    destroy() {}
}
vy.extension = {
    type: lt.CanvasRendererSystem,
    name: "mask"
};
vt.add(vy);
class _y {
    constructor(t) {
        this.renderer = t
    }
    render(t, i) {
        const s = this.renderer;
        if (!s.view)
            return;
        const n = s.canvasContext;
        let r, o, a, l;
        i && (r = i.renderTexture,
        o = i.clear,
        a = i.transform,
        l = i.skipUpdateTransform),
        this.renderingToScreen = !r,
        s.emit("prerender");
        const c = s.resolution;
        r ? (r = r.castToBaseTexture(),
        r._canvasRenderTarget || (r._canvasRenderTarget = new Po(r.width,r.height,r.resolution),
        r.resource = new v1(r._canvasRenderTarget.canvas),
        r.valid = !0),
        n.activeContext = r._canvasRenderTarget.context,
        s.canvasContext.activeResolution = r._canvasRenderTarget.resolution) : (n.activeContext = n.rootContext,
        n.activeResolution = c);
        const h = n.activeContext;
        if (n._projTransform = a || null,
        r || (this.lastObjectRendered = t),
        !l) {
            const d = t.enableTempParent();
            t.updateTransform(),
            t.disableTempParent(d)
        }
        if (h.save(),
        h.setTransform(1, 0, 0, 1, 0, 0),
        h.globalAlpha = 1,
        n._activeBlendMode = j.NORMAL,
        n._outerBlend = !1,
        h.globalCompositeOperation = n.blendModes[j.NORMAL],
        o ?? s.background.clearBeforeRender)
            if (this.renderingToScreen) {
                h.clearRect(0, 0, s.width, s.height);
                const d = s.background;
                d.alpha > 0 && (h.globalAlpha = d.alpha,
                h.fillStyle = d.colorString,
                h.fillRect(0, 0, s.width, s.height),
                h.globalAlpha = 1)
            } else {
                r = r,
                r._canvasRenderTarget.clear();
                const d = r.clearColor;
                d[3] > 0 && (h.globalAlpha = d[3] ?? 1,
                h.fillStyle = ah(Ff(d)),
                h.fillRect(0, 0, r.realWidth, r.realHeight),
                h.globalAlpha = 1)
            }
        const u = n.activeContext;
        n.activeContext = h,
        t.renderCanvas(s),
        n.activeContext = u,
        h.restore(),
        n.activeResolution = c,
        n._projTransform = null,
        s.emit("postrender")
    }
    destroy() {
        this.lastObjectRendered = null,
        this.render = null
    }
}
_y.extension = {
    type: lt.CanvasRendererSystem,
    name: "objectRenderer"
};
vt.add(_y);
const {deprecation: Qe} = l4
  , Ud = class extends o1 {
    constructor(e) {
        super(),
        this.rendererLogId = "Canvas",
        e = Object.assign({}, ft.RENDER_OPTIONS, e);
        const t = {
            runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
            systems: Ud.__systems,
            priority: ["textureGenerator", "background", "_view", "_plugin", "startup", "mask", "canvasContext", "objectRenderer"]
        };
        this.setup(t),
        "useContextAlpha"in e && (Qe("7.0.0", "options.useContextAlpha is deprecated, use options.backgroundAlpha instead"),
        e.backgroundAlpha = e.useContextAlpha === !1 ? 1 : e.backgroundAlpha);
        const i = {
            hello: e.hello,
            _plugin: Ud.__plugins,
            background: {
                alpha: e.backgroundAlpha,
                color: e.background ?? e.backgroundColor,
                clearBeforeRender: e.clearBeforeRender
            },
            _view: {
                height: e.height,
                width: e.width,
                autoDensity: e.autoDensity,
                resolution: e.resolution,
                view: e.view
            }
        };
        this.options = e,
        this.startup.run(i)
    }
    static test() {
        return !0
    }
    generateTexture(e, t) {
        return this.textureGenerator.generateTexture(e, t)
    }
    reset() {}
    render(e, t) {
        this.objectRenderer.render(e, t)
    }
    clear() {
        this.canvasContext.clear()
    }
    destroy(e) {
        this.runners.destroy.items.reverse(),
        this.emitWithCustomOptions(this.runners.destroy, {
            _view: e
        }),
        super.destroy()
    }
    get plugins() {
        return this._plugin.plugins
    }
    resize(e, t) {
        this._view.resizeView(e, t)
    }
    get width() {
        return this._view.element.width
    }
    get height() {
        return this._view.element.height
    }
    get resolution() {
        return this._view.resolution
    }
    set resolution(e) {
        this._view.resolution = e,
        this.runners.resolutionChange.emit(e)
    }
    get autoDensity() {
        return this._view.autoDensity
    }
    get view() {
        return this._view.element
    }
    get screen() {
        return this._view.screen
    }
    get lastObjectRendered() {
        return this.objectRenderer.lastObjectRendered
    }
    get renderingToScreen() {
        return this.objectRenderer.renderingToScreen
    }
    get clearBeforeRender() {
        return this.background.clearBeforeRender
    }
    get blendModes() {
        return Qe("7.0.0", "renderer.blendModes has been deprecated, please use renderer.canvasContext.blendModes instead"),
        this.canvasContext.blendModes
    }
    get maskManager() {
        return Qe("7.0.0", "renderer.maskManager has been deprecated, please use renderer.mask instead"),
        this.mask
    }
    get refresh() {
        return Qe("7.0.0", "renderer.refresh has been deprecated"),
        !0
    }
    get rootContext() {
        return Qe("7.0.0", "renderer.rootContext has been deprecated, please use renderer.canvasContext.rootContext instead"),
        this.canvasContext.rootContext
    }
    get context() {
        return Qe("7.0.0", "renderer.context has been deprecated, please use renderer.canvasContext.activeContext instead"),
        this.canvasContext.activeContext
    }
    get smoothProperty() {
        return Qe("7.0.0", "renderer.smoothProperty has been deprecated, please use renderer.canvasContext.smoothProperty instead"),
        this.canvasContext.smoothProperty
    }
    setBlendMode(e, t) {
        Qe("7.0.0", "renderer.setBlendMode has been deprecated, use renderer.canvasContext.setBlendMode instead"),
        this.canvasContext.setBlendMode(e, t)
    }
    invalidateBlendMode() {
        Qe("7.0.0", "renderer.invalidateBlendMode has been deprecated, use renderer.canvasContext.invalidateBlendMode instead"),
        this.canvasContext.invalidateBlendMode()
    }
    setContextTransform(e, t, i) {
        Qe("7.0.0", "renderer.setContextTransform has been deprecated, use renderer.canvasContext.setContextTransform instead"),
        this.canvasContext.setContextTransform(e, t, i)
    }
    get backgroundColor() {
        return Qe("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
        this.background.color
    }
    set backgroundColor(e) {
        Qe("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."),
        this.background.color = e
    }
    get backgroundAlpha() {
        return Qe("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
        this.background.color
    }
    set backgroundAlpha(e) {
        Qe("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."),
        this.background.alpha = e
    }
    get preserveDrawingBuffer() {
        return Qe("7.0.0", "renderer.preserveDrawingBuffer has been deprecated"),
        !1
    }
    get useContextAlpha() {
        return Qe("7.0.0", "renderer.useContextAlpha has been deprecated"),
        !1
    }
}
;
let Or = Ud;
Or.extension = {
    type: lt.Renderer,
    priority: 0
};
Or.__plugins = {};
Or.__systems = {};
vt.handleByMap(lt.CanvasRendererPlugin, Or.__plugins);
vt.handleByMap(lt.CanvasRendererSystem, Or.__systems);
vt.add(Or);
const Ge = {
    canvas: null,
    getTintedCanvas: (e,t)=>{
        const i = e.texture;
        t = Ge.roundColor(t);
        const s = `#${`00000${(t | 0).toString(16)}`.slice(-6)}`;
        i.tintCache = i.tintCache || {};
        const n = i.tintCache[s];
        let r;
        if (n) {
            if (n.tintId === i._updateID)
                return i.tintCache[s];
            r = i.tintCache[s]
        } else
            r = ft.ADAPTER.createCanvas();
        return Ge.tintMethod(i, t, r),
        r.tintId = i._updateID,
        i.tintCache[s] = r,
        r
    }
    ,
    getTintedPattern: (e,t)=>{
        t = Ge.roundColor(t);
        const i = `#${`00000${(t | 0).toString(16)}`.slice(-6)}`;
        e.patternCache = e.patternCache || {};
        let s = e.patternCache[i];
        return s?.tintId === e._updateID || (Ge.canvas || (Ge.canvas = ft.ADAPTER.createCanvas()),
        Ge.tintMethod(e, t, Ge.canvas),
        s = Ge.canvas.getContext("2d").createPattern(Ge.canvas, "repeat"),
        s.tintId = e._updateID,
        e.patternCache[i] = s),
        s
    }
    ,
    tintWithMultiply: (e,t,i)=>{
        const s = i.getContext("2d")
          , n = e._frame.clone()
          , r = e.baseTexture.resolution;
        n.x *= r,
        n.y *= r,
        n.width *= r,
        n.height *= r,
        i.width = Math.ceil(n.width),
        i.height = Math.ceil(n.height),
        s.save(),
        s.fillStyle = `#${`00000${(t | 0).toString(16)}`.slice(-6)}`,
        s.fillRect(0, 0, n.width, n.height),
        s.globalCompositeOperation = "multiply";
        const o = e.baseTexture.getDrawableSource();
        s.drawImage(o, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height),
        s.globalCompositeOperation = "destination-atop",
        s.drawImage(o, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height),
        s.restore()
    }
    ,
    tintWithOverlay: (e,t,i)=>{
        const s = i.getContext("2d")
          , n = e._frame.clone()
          , r = e.baseTexture.resolution;
        n.x *= r,
        n.y *= r,
        n.width *= r,
        n.height *= r,
        i.width = Math.ceil(n.width),
        i.height = Math.ceil(n.height),
        s.save(),
        s.globalCompositeOperation = "copy",
        s.fillStyle = `#${`00000${(t | 0).toString(16)}`.slice(-6)}`,
        s.fillRect(0, 0, n.width, n.height),
        s.globalCompositeOperation = "destination-atop",
        s.drawImage(e.baseTexture.getDrawableSource(), n.x, n.y, n.width, n.height, 0, 0, n.width, n.height),
        s.restore()
    }
    ,
    tintWithPerPixel: (e,t,i)=>{
        const s = i.getContext("2d")
          , n = e._frame.clone()
          , r = e.baseTexture.resolution;
        n.x *= r,
        n.y *= r,
        n.width *= r,
        n.height *= r,
        i.width = Math.ceil(n.width),
        i.height = Math.ceil(n.height),
        s.save(),
        s.globalCompositeOperation = "copy",
        s.drawImage(e.baseTexture.getDrawableSource(), n.x, n.y, n.width, n.height, 0, 0, n.width, n.height),
        s.restore();
        const o = tn(t)
          , a = o[0]
          , l = o[1]
          , c = o[2]
          , h = s.getImageData(0, 0, n.width, n.height)
          , u = h.data;
        for (let d = 0; d < u.length; d += 4)
            u[d + 0] *= a,
            u[d + 1] *= l,
            u[d + 2] *= c;
        s.putImageData(h, 0, 0)
    }
    ,
    roundColor: e=>{
        const t = Ge.cacheStepsPerColorChannel
          , i = tn(e);
        return i[0] = Math.min(255, i[0] / t * t),
        i[1] = Math.min(255, i[1] / t * t),
        i[2] = Math.min(255, i[2] / t * t),
        Ff(i)
    }
    ,
    cacheStepsPerColorChannel: 8,
    convertTintToImage: !1,
    canUseMultiply: my(),
    tintMethod: null
};
Ge.tintMethod = Ge.canUseMultiply ? Ge.tintWithMultiply : Ge.tintWithPerPixel;
const Vl = new pe
  , aa = new pe
  , ws = [new Zt, new Zt, new Zt, new Zt];
Zf.prototype._renderCanvas = function(t) {
    const i = this._texture;
    if (!i.baseTexture.valid)
        return;
    const s = t.canvasContext.activeContext
      , n = this.worldTransform
      , r = i.baseTexture
      , o = r.getDrawableSource()
      , a = r.resolution;
    if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint) {
        this._textureID = this._texture._updateID;
        const f = new Po(i._frame.width,i._frame.height,a);
        this.tint !== 16777215 ? (this._tintedCanvas = Ge.getTintedCanvas(this, this.tint),
        f.context.drawImage(this._tintedCanvas, 0, 0)) : f.context.drawImage(o, -i._frame.x * a, -i._frame.y * a),
        this._cachedTint = this.tint,
        this._canvasPattern = f.context.createPattern(f.canvas, "repeat")
    }
    s.globalAlpha = this.worldAlpha,
    t.canvasContext.setBlendMode(this.blendMode),
    this.tileTransform.updateLocalTransform();
    const l = this.tileTransform.localTransform
      , c = this._width
      , h = this._height;
    Vl.identity(),
    aa.copyFrom(l),
    this.uvRespectAnchor || aa.translate(-this.anchor.x * c, -this.anchor.y * h),
    aa.scale(this.tileScale.x / a, this.tileScale.y / a),
    Vl.prepend(aa),
    Vl.prepend(n),
    t.canvasContext.setContextTransform(Vl),
    s.fillStyle = this._canvasPattern;
    const u = this.anchor.x * -c
      , d = this.anchor.y * -h;
    ws[0].set(u, d),
    ws[1].set(u + c, d),
    ws[2].set(u + c, d + h),
    ws[3].set(u, d + h);
    for (let f = 0; f < 4; f++)
        aa.applyInverse(ws[f], ws[f]);
    s.beginPath(),
    s.moveTo(ws[0].x, ws[0].y);
    for (let f = 1; f < 4; f++)
        s.lineTo(ws[f].x, ws[f].y);
    s.closePath(),
    s.fill()
}
;
Ed.prototype.renderCanvas = function(t) {
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable)
        return;
    const i = t.canvasContext.activeContext
      , s = this.worldTransform;
    let n = !0
      , r = 0
      , o = 0
      , a = 0
      , l = 0;
    t.canvasContext.setBlendMode(this.blendMode),
    i.globalAlpha = this.worldAlpha,
    this.displayObjectUpdateTransform();
    for (let c = 0; c < this.children.length; ++c) {
        const h = this.children[c];
        if (!h.visible || !h._texture.valid)
            continue;
        const u = h._texture.frame;
        if (i.globalAlpha = this.worldAlpha * h.alpha,
        h.rotation % (Math.PI * 2) === 0)
            n && (t.canvasContext.setContextTransform(s, !1, 1),
            n = !1),
            r = h.anchor.x * (-u.width * h.scale.x) + h.position.x + .5,
            o = h.anchor.y * (-u.height * h.scale.y) + h.position.y + .5,
            a = u.width * h.scale.x,
            l = u.height * h.scale.y;
        else {
            n || (n = !0),
            h.displayObjectUpdateTransform();
            const p = h.worldTransform;
            t.canvasContext.setContextTransform(p, this.roundPixels, 1),
            r = h.anchor.x * -u.width + .5,
            o = h.anchor.y * -u.height + .5,
            a = u.width,
            l = u.height
        }
        const d = h._texture.baseTexture.resolution
          , f = t.canvasContext.activeResolution;
        i.drawImage(h._texture.baseTexture.getDrawableSource(), u.x * d, u.y * d, u.width * d, u.height * d, r * f, o * f, a * f, l * f)
    }
}
;
ae.prototype._renderCanvas = function(t) {}
;
ae.prototype.renderCanvas = function(t) {
    if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable)) {
        this._mask && t.mask.pushMask(this._mask),
        this._renderCanvas(t);
        for (let i = 0, s = this.children.length; i < s; ++i)
            this.children[i].renderCanvas(t);
        this._mask && t.mask.popMask(t)
    }
}
;
Ae.prototype.renderCanvas = function(t) {}
;
ys.prototype._renderCanvas = function(t) {
    this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution,
    this.dirty = !0),
    this.updateText(!0),
    hi.prototype._renderCanvas.call(this, t)
}
;
const Xg = new qt;
class yy {
    constructor(t) {
        this.renderer = t
    }
    async image(t, i, s) {
        const n = new Image;
        return n.src = await this.base64(t, i, s),
        n
    }
    async base64(t, i, s) {
        const n = this.canvas(t);
        if (n.toDataURL !== void 0)
            return n.toDataURL(i, s);
        if (n.convertToBlob !== void 0) {
            const r = await n.convertToBlob({
                type: i,
                quality: s
            });
            return await new Promise(o=>{
                const a = new FileReader;
                a.onload = ()=>o(a.result),
                a.readAsDataURL(r)
            }
            )
        }
        throw new Error("CanvasExtract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented")
    }
    canvas(t, i) {
        const s = this.renderer;
        let n, r, o;
        t && (t instanceof fs ? o = t : o = s.generateTexture(t)),
        o ? (n = o.baseTexture._canvasRenderTarget.context,
        r = o.baseTexture._canvasRenderTarget.resolution,
        i = i ?? o.frame) : (n = s.canvasContext.rootContext,
        r = s._view.resolution,
        i || (i = Xg,
        i.width = s.width,
        i.height = s.height));
        const a = Math.round(i.x * r)
          , l = Math.round(i.y * r)
          , c = Math.round(i.width * r)
          , h = Math.round(i.height * r)
          , u = new Po(c,h,1)
          , d = n.getImageData(a, l, c, h);
        return u.context.putImageData(d, 0, 0),
        u.canvas
    }
    pixels(t, i) {
        const s = this.renderer;
        let n, r, o;
        t && (t instanceof fs ? o = t : o = s.generateTexture(t)),
        o ? (n = o.baseTexture._canvasRenderTarget.context,
        r = o.baseTexture._canvasRenderTarget.resolution,
        i = i ?? o.frame) : (n = s.canvasContext.rootContext,
        r = s.resolution,
        i || (i = Xg,
        i.width = s.width,
        i.height = s.height));
        const a = Math.round(i.x * r)
          , l = Math.round(i.y * r)
          , c = Math.round(i.width * r)
          , h = Math.round(i.height * r);
        return n.getImageData(a, l, c, h).data
    }
    destroy() {
        this.renderer = null
    }
}
yy.extension = {
    name: "extract",
    type: lt.CanvasRendererSystem
};
vt.add(yy);
let yu;
const la = new pe;
ke.prototype.generateCanvasTexture = function(t, i=1) {
    const s = this.getLocalBounds()
      , n = fs.create({
        width: s.width,
        height: s.height,
        scaleMode: t,
        resolution: i
    });
    yu || (yu = new Or),
    this.transform.updateLocalTransform(),
    this.transform.localTransform.copyTo(la),
    la.invert(),
    la.tx -= s.x,
    la.ty -= s.y,
    yu.render(this, {
        renderTexture: n,
        clear: !0,
        transform: la
    });
    const r = ht.from(n.baseTexture._canvasRenderTarget.canvas, {
        scaleMode: t
    });
    return r.baseTexture.setResolution(i),
    r
}
;
ke.prototype.cachedGraphicsData = [];
ke.prototype._renderCanvas = function(t) {
    this.isMask !== !0 && (this.finishPoly(),
    t.plugins.graphics.render(this))
}
;
class za {
    static offsetPolygon(t, i) {
        const s = []
          , n = t.length;
        i = za.isPolygonClockwise(t) ? i : -1 * i;
        for (let r = 0; r < n; r += 2) {
            let o = r - 2;
            o < 0 && (o += n);
            const a = (r + 2) % n;
            let l = t[r] - t[o]
              , c = t[r + 1] - t[o + 1]
              , h = Math.sqrt(l * l + c * c);
            l /= h,
            c /= h,
            l *= i,
            c *= i;
            const u = -c
              , d = l
              , f = [t[o] + u, t[o + 1] + d]
              , p = [t[r] + u, t[r + 1] + d];
            let m = t[a] - t[r]
              , g = t[a + 1] - t[r + 1];
            h = Math.sqrt(m * m + g * g),
            m /= h,
            g /= h,
            m *= i,
            g *= i;
            const y = -g
              , x = m
              , v = [t[r] + y, t[r + 1] + x]
              , _ = [t[a] + y, t[a + 1] + x]
              , C = za.findIntersection(f[0], f[1], p[0], p[1], v[0], v[1], _[0], _[1]);
            C && s.push(...C)
        }
        return s
    }
    static findIntersection(t, i, s, n, r, o, a, l) {
        const c = (l - o) * (s - t) - (a - r) * (n - i)
          , h = (a - r) * (i - o) - (l - o) * (t - r)
          , u = (s - t) * (i - o) - (n - i) * (t - r);
        if (c === 0)
            return h === 0 && u === 0 ? [(t + s) / 2, (i + n) / 2] : null;
        const d = h / c;
        return [t + d * (s - t), i + d * (n - i)]
    }
    static isPolygonClockwise(t) {
        let i = 0;
        for (let s = 0, n = t.length - 2; s < t.length; n = s,
        s += 2)
            i += (t[s] - t[n]) * (t[s + 1] + t[n + 1]);
        return i > 0
    }
}
class by {
    constructor(t) {
        this._svgMatrix = null,
        this._tempMatrix = new pe,
        this.renderer = t
    }
    _calcCanvasStyle(t, i) {
        let s;
        return t.texture && t.texture.baseTexture !== ht.WHITE.baseTexture ? t.texture.valid ? (s = Ge.getTintedPattern(t.texture, i),
        this.setPatternTransform(s, t.matrix || pe.IDENTITY)) : s = "#808080" : s = `#${`00000${(i | 0).toString(16)}`.slice(-6)}`,
        s
    }
    render(t) {
        const i = this.renderer
          , s = i.canvasContext.activeContext
          , n = t.worldAlpha
          , r = t.transform.worldTransform;
        i.canvasContext.setContextTransform(r),
        i.canvasContext.setBlendMode(t.blendMode);
        const o = t.geometry.graphicsData;
        let a, l;
        const c = (t.tint >> 16 & 255) / 255
          , h = (t.tint >> 8 & 255) / 255
          , u = (t.tint & 255) / 255;
        for (let d = 0; d < o.length; d++) {
            const f = o[d]
              , p = f.shape
              , m = f.fillStyle
              , g = f.lineStyle
              , y = f.fillStyle.color | 0
              , x = f.lineStyle.color | 0;
            if (f.matrix && i.canvasContext.setContextTransform(r.copyTo(this._tempMatrix).append(f.matrix)),
            m.visible) {
                const v = ((y >> 16 & 255) / 255 * c * 255 << 16) + ((y >> 8 & 255) / 255 * h * 255 << 8) + (y & 255) / 255 * u * 255;
                a = this._calcCanvasStyle(m, v)
            }
            if (g.visible) {
                const v = ((x >> 16 & 255) / 255 * c * 255 << 16) + ((x >> 8 & 255) / 255 * h * 255 << 8) + (x & 255) / 255 * u * 255;
                l = this._calcCanvasStyle(g, v)
            }
            if (s.lineWidth = g.width,
            s.lineCap = g.cap,
            s.lineJoin = g.join,
            s.miterLimit = g.miterLimit,
            f.type === we.POLY) {
                s.beginPath();
                const v = p;
                let _ = v.points;
                const C = f.holes;
                let k, S, T, L, D;
                s.moveTo(_[0], _[1]);
                for (let O = 2; O < _.length; O += 2)
                    s.lineTo(_[O], _[O + 1]);
                if (v.closeStroke && s.closePath(),
                C.length > 0) {
                    D = [],
                    k = 0,
                    T = _[0],
                    L = _[1];
                    for (let O = 2; O + 2 < _.length; O += 2)
                        k += (_[O] - T) * (_[O + 3] - L) - (_[O + 2] - T) * (_[O + 1] - L);
                    for (let O = 0; O < C.length; O++)
                        if (_ = C[O].shape.points,
                        !!_) {
                            S = 0,
                            T = _[0],
                            L = _[1];
                            for (let K = 2; K + 2 < _.length; K += 2)
                                S += (_[K] - T) * (_[K + 3] - L) - (_[K + 2] - T) * (_[K + 1] - L);
                            if (S * k < 0) {
                                s.moveTo(_[0], _[1]);
                                for (let K = 2; K < _.length; K += 2)
                                    s.lineTo(_[K], _[K + 1])
                            } else {
                                s.moveTo(_[_.length - 2], _[_.length - 1]);
                                for (let K = _.length - 4; K >= 0; K -= 2)
                                    s.lineTo(_[K], _[K + 1])
                            }
                            C[O].shape.closeStroke && s.closePath(),
                            D[O] = S * k < 0
                        }
                }
                m.visible && (s.globalAlpha = m.alpha * n,
                s.fillStyle = a,
                s.fill()),
                g.visible && this.paintPolygonStroke(v, g, l, C, D, n, s)
            } else if (f.type === we.RECT) {
                const v = p;
                if (m.visible && (s.globalAlpha = m.alpha * n,
                s.fillStyle = a,
                s.fillRect(v.x, v.y, v.width, v.height)),
                g.visible) {
                    const _ = g.width * (.5 - (1 - g.alignment))
                      , C = v.width + 2 * _
                      , k = v.height + 2 * _;
                    s.globalAlpha = g.alpha * n,
                    s.strokeStyle = l,
                    s.strokeRect(v.x - _, v.y - _, C, k)
                }
            } else if (f.type === we.CIRC) {
                const v = p;
                if (s.beginPath(),
                s.arc(v.x, v.y, v.radius, 0, 2 * Math.PI),
                s.closePath(),
                m.visible && (s.globalAlpha = m.alpha * n,
                s.fillStyle = a,
                s.fill()),
                g.visible) {
                    if (g.alignment !== .5) {
                        const _ = g.width * (.5 - (1 - g.alignment));
                        s.beginPath(),
                        s.arc(v.x, v.y, v.radius + _, 0, 2 * Math.PI),
                        s.closePath()
                    }
                    s.globalAlpha = g.alpha * n,
                    s.strokeStyle = l,
                    s.stroke()
                }
            } else if (f.type === we.ELIP) {
                const v = p
                  , _ = g.alignment === 1;
                if (_ || this.paintEllipse(v, m, g, a, n, s),
                g.visible) {
                    if (g.alignment !== .5) {
                        const C = .5522848
                          , k = g.width * (.5 - (1 - g.alignment))
                          , S = (v.width + k) * 2
                          , T = (v.height + k) * 2
                          , L = v.x - S / 2
                          , D = v.y - T / 2
                          , O = S / 2 * C
                          , K = T / 2 * C
                          , P = L + S
                          , N = D + T
                          , W = L + S / 2
                          , V = D + T / 2;
                        s.beginPath(),
                        s.moveTo(L, V),
                        s.bezierCurveTo(L, V - K, W - O, D, W, D),
                        s.bezierCurveTo(W + O, D, P, V - K, P, V),
                        s.bezierCurveTo(P, V + K, W + O, N, W, N),
                        s.bezierCurveTo(W - O, N, L, V + K, L, V),
                        s.closePath()
                    }
                    s.globalAlpha = g.alpha * n,
                    s.strokeStyle = l,
                    s.stroke()
                }
                _ && this.paintEllipse(v, m, g, a, n, s)
            } else if (f.type === we.RREC) {
                const v = p
                  , _ = g.alignment === 1;
                if (_ || this.paintRoundedRectangle(v, m, g, a, n, s),
                g.visible) {
                    if (g.alignment !== .5) {
                        const C = v.width
                          , k = v.height
                          , S = g.width * (.5 - (1 - g.alignment))
                          , T = v.x - S
                          , L = v.y - S
                          , D = v.width + 2 * S
                          , O = v.height + 2 * S
                          , K = S * (g.alignment >= 1 ? Math.min(D / C, O / k) : Math.min(C / D, k / O));
                        let P = v.radius + K;
                        const N = Math.min(D, O) / 2;
                        P = P > N ? N : P,
                        s.beginPath(),
                        s.moveTo(T, L + P),
                        s.lineTo(T, L + O - P),
                        s.quadraticCurveTo(T, L + O, T + P, L + O),
                        s.lineTo(T + D - P, L + O),
                        s.quadraticCurveTo(T + D, L + O, T + D, L + O - P),
                        s.lineTo(T + D, L + P),
                        s.quadraticCurveTo(T + D, L, T + D - P, L),
                        s.lineTo(T + P, L),
                        s.quadraticCurveTo(T, L, T, L + P),
                        s.closePath()
                    }
                    s.globalAlpha = g.alpha * n,
                    s.strokeStyle = l,
                    s.stroke()
                }
                _ && this.paintRoundedRectangle(v, m, g, a, n, s)
            }
        }
    }
    paintPolygonStroke(t, i, s, n, r, o, a) {
        if (i.alignment !== .5) {
            const l = i.width * (.5 - (1 - i.alignment));
            let c = za.offsetPolygon(t.points, l), h;
            a.beginPath(),
            a.moveTo(c[0], c[1]);
            for (let u = 2; u < c.length; u += 2)
                a.lineTo(c[u], c[u + 1]);
            t.closeStroke && a.closePath();
            for (let u = 0; u < n.length; u++) {
                if (h = n[u].shape.points,
                c = za.offsetPolygon(h, l),
                r[u]) {
                    a.moveTo(c[0], c[1]);
                    for (let d = 2; d < c.length; d += 2)
                        a.lineTo(c[d], c[d + 1])
                } else {
                    a.moveTo(c[c.length - 2], c[c.length - 1]);
                    for (let d = c.length - 4; d >= 0; d -= 2)
                        a.lineTo(c[d], c[d + 1])
                }
                n[u].shape.closeStroke && a.closePath()
            }
        }
        a.globalAlpha = i.alpha * o,
        a.strokeStyle = s,
        a.stroke()
    }
    paintEllipse(t, i, s, n, r, o) {
        const a = t.width * 2
          , l = t.height * 2
          , c = t.x - a / 2
          , h = t.y - l / 2
          , u = .5522848
          , d = a / 2 * u
          , f = l / 2 * u
          , p = c + a
          , m = h + l
          , g = c + a / 2
          , y = h + l / 2;
        s.alignment === 0 && o.save(),
        o.beginPath(),
        o.moveTo(c, y),
        o.bezierCurveTo(c, y - f, g - d, h, g, h),
        o.bezierCurveTo(g + d, h, p, y - f, p, y),
        o.bezierCurveTo(p, y + f, g + d, m, g, m),
        o.bezierCurveTo(g - d, m, c, y + f, c, y),
        o.closePath(),
        s.alignment === 0 && o.clip(),
        i.visible && (o.globalAlpha = i.alpha * r,
        o.fillStyle = n,
        o.fill()),
        s.alignment === 0 && o.restore()
    }
    paintRoundedRectangle(t, i, s, n, r, o) {
        const a = t.x
          , l = t.y
          , c = t.width
          , h = t.height;
        let u = t.radius;
        const d = Math.min(c, h) / 2;
        u = u > d ? d : u,
        s.alignment === 0 && o.save(),
        o.beginPath(),
        o.moveTo(a, l + u),
        o.lineTo(a, l + h - u),
        o.quadraticCurveTo(a, l + h, a + u, l + h),
        o.lineTo(a + c - u, l + h),
        o.quadraticCurveTo(a + c, l + h, a + c, l + h - u),
        o.lineTo(a + c, l + u),
        o.quadraticCurveTo(a + c, l, a + c - u, l),
        o.lineTo(a + u, l),
        o.quadraticCurveTo(a, l, a, l + u),
        o.closePath(),
        s.alignment === 0 && o.clip(),
        i.visible && (o.globalAlpha = i.alpha * r,
        o.fillStyle = n,
        o.fill()),
        s.alignment === 0 && o.restore()
    }
    setPatternTransform(t, i) {
        if (this._svgMatrix !== !1) {
            if (!this._svgMatrix) {
                const s = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                if (s?.createSVGMatrix && (this._svgMatrix = s.createSVGMatrix()),
                !this._svgMatrix || !t.setTransform) {
                    this._svgMatrix = !1;
                    return
                }
            }
            this._svgMatrix.a = i.a,
            this._svgMatrix.b = i.b,
            this._svgMatrix.c = i.c,
            this._svgMatrix.d = i.d,
            this._svgMatrix.e = i.tx,
            this._svgMatrix.f = i.ty,
            t.setTransform(this._svgMatrix.inverse())
        }
    }
    destroy() {
        this.renderer = null,
        this._svgMatrix = null,
        this._tempMatrix = null
    }
}
by.extension = {
    name: "graphics",
    type: lt.CanvasRendererPlugin
};
vt.add(by);
Object.defineProperties(ft, {
    MESH_CANVAS_PADDING: {
        get() {
            return ii.defaultCanvasPadding
        },
        set(e) {
            Qt("7.1.0", "settings.MESH_CANVAS_PADDING is deprecated, use Mesh.defaultCanvasPadding"),
            ii.defaultCanvasPadding = e
        }
    }
});
Do.prototype._renderCanvas = function(t, i) {
    t.plugins.mesh.render(i)
}
;
vh.prototype._cachedTint = 16777215;
vh.prototype._tintedCanvas = null;
vh.prototype._canvasUvs = null;
vh.prototype._renderCanvas = function(t) {
    const i = t.canvasContext.activeContext
      , s = this.worldTransform
      , n = this.tint !== 16777215
      , r = this.texture;
    if (!r.valid)
        return;
    n && this._cachedTint !== this.tint && (this._cachedTint = this.tint,
    this._tintedCanvas = Ge.getTintedCanvas(this, this.tint));
    const o = n ? this._tintedCanvas : r.baseTexture.getDrawableSource();
    this._canvasUvs || (this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0]);
    const a = this.vertices
      , l = this._canvasUvs
      , c = n ? 0 : r.frame.x
      , h = n ? 0 : r.frame.y
      , u = c + r.frame.width
      , d = h + r.frame.height;
    l[0] = c,
    l[1] = c + this._leftWidth,
    l[2] = u - this._rightWidth,
    l[3] = u,
    l[4] = h,
    l[5] = h + this._topHeight,
    l[6] = d - this._bottomHeight,
    l[7] = d;
    for (let f = 0; f < 8; f++)
        l[f] *= r.baseTexture.resolution;
    i.globalAlpha = this.worldAlpha,
    t.canvasContext.setBlendMode(this.blendMode),
    t.canvasContext.setContextTransform(s, this.roundPixels);
    for (let f = 0; f < 3; f++)
        for (let p = 0; p < 3; p++) {
            const m = p * 2 + f * 8
              , g = Math.max(1, l[p + 1] - l[p])
              , y = Math.max(1, l[f + 5] - l[f + 4])
              , x = Math.max(1, a[m + 10] - a[m])
              , v = Math.max(1, a[m + 11] - a[m + 1]);
            i.drawImage(o, l[p], l[f + 4], g, y, a[m], a[m + 1], x, v)
        }
}
;
let Yg = !1;
ii.prototype._cachedTint = 16777215;
ii.prototype._tintedCanvas = null;
ii.prototype._cachedTexture = null;
ii.prototype._renderCanvas = function(t) {
    this.shader.uvMatrix && (this.shader.uvMatrix.update(),
    this.calculateUvs()),
    this.material._renderCanvas ? this.material._renderCanvas(t, this) : Yg || (Yg = !0,
    globalThis.console.warn("Mesh with custom shaders are not supported in CanvasRenderer."))
}
;
ii.prototype._canvasPadding = null;
ii.defaultCanvasPadding = 0;
Object.defineProperty(ii.prototype, "canvasPadding", {
    get() {
        return this._canvasPadding ?? ii.defaultCanvasPadding
    },
    set(e) {
        this._canvasPadding = e
    }
});
mM.prototype._renderCanvas = function(t) {
    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(),
    this.shader.update && this.shader.update(),
    this.calculateUvs(),
    this.material._renderCanvas(t, this)
}
;
gM.prototype._renderCanvas = function(t) {
    (this.autoUpdate || this.geometry._width !== this.shader.texture.height) && (this.geometry._width = this.shader.texture.height,
    this.geometry.update()),
    this.shader.update && this.shader.update(),
    this.calculateUvs(),
    this.material._renderCanvas(t, this)
}
;
class xy {
    constructor(t) {
        this.renderer = t
    }
    render(t) {
        const i = this.renderer
          , s = t.worldTransform;
        i.canvasContext.activeContext.globalAlpha = t.worldAlpha,
        i.canvasContext.setBlendMode(t.blendMode),
        i.canvasContext.setContextTransform(s, t.roundPixels),
        t.drawMode !== rs.TRIANGLES ? this._renderTriangleMesh(t) : this._renderTriangles(t)
    }
    _renderTriangleMesh(t) {
        const i = t.geometry.buffers[0].data.length;
        for (let s = 0; s < i - 2; s++) {
            const n = s * 2;
            this._renderDrawTriangle(t, n, n + 2, n + 4)
        }
    }
    _renderTriangles(t) {
        const i = t.geometry.getIndex().data
          , s = i.length;
        for (let n = 0; n < s; n += 3) {
            const r = i[n] * 2
              , o = i[n + 1] * 2
              , a = i[n + 2] * 2;
            this._renderDrawTriangle(t, r, o, a)
        }
    }
    _renderDrawTriangle(t, i, s, n) {
        const r = this.renderer.canvasContext.activeContext
          , o = t.geometry.buffers[0].data
          , {uvs: a, texture: l} = t;
        if (!l.valid)
            return;
        const c = t.tint !== 16777215
          , h = l.baseTexture
          , u = h.width
          , d = h.height;
        t._cachedTexture && t._cachedTexture.baseTexture !== h && (t._cachedTint = 16777215,
        t._cachedTexture?.destroy(),
        t._cachedTexture = null,
        t._tintedCanvas = null),
        c && t._cachedTint !== t.tint && (t._cachedTint = t.tint,
        t._cachedTexture = t._cachedTexture || new ht(h),
        t._tintedCanvas = Ge.getTintedCanvas({
            texture: t._cachedTexture
        }, t.tint));
        const f = c ? t._tintedCanvas : h.getDrawableSource()
          , p = a[i] * h.width
          , m = a[s] * h.width
          , g = a[n] * h.width
          , y = a[i + 1] * h.height
          , x = a[s + 1] * h.height
          , v = a[n + 1] * h.height;
        let _ = o[i]
          , C = o[s]
          , k = o[n]
          , S = o[i + 1]
          , T = o[s + 1]
          , L = o[n + 1];
        const D = t.canvasPadding / this.renderer.canvasContext.activeResolution;
        if (D > 0) {
            const {a: pt, b: bt, c: ct, d: gt} = t.worldTransform
              , xt = (_ + C + k) / 3
              , It = (S + T + L) / 3;
            let St = _ - xt
              , J = S - It
              , wt = pt * St + ct * J
              , Tt = bt * St + gt * J
              , Bt = Math.sqrt(wt * wt + Tt * Tt)
              , kt = 1 + D / Bt;
            _ = xt + St * kt,
            S = It + J * kt,
            St = C - xt,
            J = T - It,
            wt = pt * St + ct * J,
            Tt = bt * St + gt * J,
            Bt = Math.sqrt(wt * wt + Tt * Tt),
            kt = 1 + D / Bt,
            C = xt + St * kt,
            T = It + J * kt,
            St = k - xt,
            J = L - It,
            wt = pt * St + ct * J,
            Tt = bt * St + gt * J,
            Bt = Math.sqrt(wt * wt + Tt * Tt),
            kt = 1 + D / Bt,
            k = xt + St * kt,
            L = It + J * kt
        }
        r.save(),
        r.beginPath(),
        r.moveTo(_, S),
        r.lineTo(C, T),
        r.lineTo(k, L),
        r.closePath(),
        r.clip();
        const O = p * x + y * g + m * v - x * g - y * m - p * v
          , K = _ * x + y * k + C * v - x * k - y * C - _ * v
          , P = p * C + _ * g + m * k - C * g - _ * m - p * k
          , N = p * x * k + y * C * g + _ * m * v - _ * x * g - y * m * k - p * C * v
          , W = S * x + y * L + T * v - x * L - y * T - S * v
          , V = p * T + S * g + m * L - T * g - S * m - p * L
          , Q = p * x * L + y * T * g + S * m * v - S * x * g - y * m * L - p * T * v;
        r.transform(K / O, W / O, P / O, V / O, N / O, Q / O),
        r.drawImage(f, 0, 0, u * h.resolution, d * h.resolution, 0, 0, u, d),
        r.restore(),
        this.renderer.canvasContext.invalidateBlendMode()
    }
    renderMeshFlat(t) {
        const i = this.renderer.canvasContext.activeContext
          , s = t.geometry.getBuffer("aVertexPosition").data
          , n = s.length / 2;
        i.beginPath();
        for (let r = 1; r < n - 2; ++r) {
            const o = r * 2
              , a = s[o]
              , l = s[o + 1]
              , c = s[o + 2]
              , h = s[o + 3]
              , u = s[o + 4]
              , d = s[o + 5];
            i.moveTo(a, l),
            i.lineTo(c, h),
            i.lineTo(u, d)
        }
        i.fillStyle = "#FF0000",
        i.fill(),
        i.closePath()
    }
    destroy() {
        this.renderer = null
    }
}
xy.extension = {
    name: "mesh",
    type: lt.CanvasRendererPlugin
};
vt.add(xy);
const Kg = 16;
function Nk(e, t) {
    const i = e;
    if (t instanceof Ot) {
        const s = t.source
          , n = s.width === 0 ? i.canvas.width : Math.min(i.canvas.width, s.width)
          , r = s.height === 0 ? i.canvas.height : Math.min(i.canvas.height, s.height);
        return i.ctx.drawImage(s, 0, 0, n, r, 0, 0, i.canvas.width, i.canvas.height),
        !0
    }
    return !1
}
class wy extends Va {
    constructor(t) {
        super(t),
        this.uploadHookHelper = this,
        this.canvas = ft.ADAPTER.createCanvas(Kg, Kg),
        this.ctx = this.canvas.getContext("2d"),
        this.registerUploadHook(Nk)
    }
    destroy() {
        super.destroy(),
        this.ctx = null,
        this.canvas = null
    }
}
wy.extension = {
    name: "prepare",
    type: lt.CanvasRendererSystem
};
vt.add(wy);
hi.prototype._tintedCanvas = null;
hi.prototype._renderCanvas = function(t) {
    t.plugins.sprite.render(this)
}
;
const Zg = new pe;
class Ty {
    constructor(t) {
        this.renderer = t
    }
    render(t) {
        const i = t._texture
          , s = this.renderer
          , n = s.canvasContext.activeContext
          , r = s.canvasContext.activeResolution;
        if (!i.valid)
            return;
        const o = i._frame.width
          , a = i._frame.height;
        let l = i._frame.width
          , c = i._frame.height;
        i.trim && (l = i.trim.width,
        c = i.trim.height);
        let h = t.transform.worldTransform
          , u = 0
          , d = 0;
        const f = i.baseTexture.getDrawableSource();
        if (i.orig.width <= 0 || i.orig.height <= 0 || !i.valid || !f)
            return;
        s.canvasContext.setBlendMode(t.blendMode, !0),
        n.globalAlpha = t.worldAlpha;
        const p = i.baseTexture.scaleMode === Hi.LINEAR
          , m = s.canvasContext.smoothProperty;
        m && n[m] !== p && (n[m] = p),
        i.trim ? (u = i.trim.width / 2 + i.trim.x - t.anchor.x * i.orig.width,
        d = i.trim.height / 2 + i.trim.y - t.anchor.y * i.orig.height) : (u = (.5 - t.anchor.x) * i.orig.width,
        d = (.5 - t.anchor.y) * i.orig.height),
        i.rotate && (h.copyTo(Zg),
        h = Zg,
        Se.matrixAppendRotationInv(h, i.rotate, u, d),
        u = 0,
        d = 0),
        u -= l / 2,
        d -= c / 2,
        s.canvasContext.setContextTransform(h, t.roundPixels, 1),
        t.roundPixels && (u = u | 0,
        d = d | 0);
        const g = i.baseTexture.resolution
          , y = s.canvasContext._outerBlend;
        y && (n.save(),
        n.beginPath(),
        n.rect(u * r, d * r, l * r, c * r),
        n.clip()),
        t.tint !== 16777215 ? ((t._cachedTint !== t.tint || t._tintedCanvas.tintId !== t._texture._updateID) && (t._cachedTint = t.tint,
        t._tintedCanvas = Ge.getTintedCanvas(t, t.tint)),
        n.drawImage(t._tintedCanvas, 0, 0, Math.floor(o * g), Math.floor(a * g), Math.floor(u * r), Math.floor(d * r), Math.floor(l * r), Math.floor(c * r))) : n.drawImage(f, i._frame.x * g, i._frame.y * g, Math.floor(o * g), Math.floor(a * g), Math.floor(u * r), Math.floor(d * r), Math.floor(l * r), Math.floor(c * r)),
        y && n.restore(),
        s.canvasContext.setBlendMode(j.NORMAL)
    }
    destroy() {
        this.renderer = null
    }
}
Ty.extension = {
    name: "sprite",
    type: lt.CanvasRendererPlugin
};
vt.add(Ty);
class Fk extends Q1 {
    constructor(i, s, n, r) {
        super(i, s, n, r);
        I(this, "_pcellCapacity", 16);
        I(this, "pcellCache", Ws([]));
        I(this, "moveMode", 0);
        I(this, "DestinationPoint", Ws(new hi(ie.get("MOVE_POINT"))));
        this.DestinationPoint.anchor.set(.5),
        this.DestinationPoint.visible = !1,
        is.addChild(this.DestinationPoint)
    }
    get skinFillColor() {
        return Md(B.SkinFillSelf[0], this.color)
    }
    get skinFillAlpha() {
        return B.SkinFillSelf[1]
    }
    get DestinationPointColor() {
        return Be(B.DestinationPoint[0])
    }
    get DestinationPointAlpha() {
        return B.DestinationPoint[1]
    }
    bindPlayerCell(i) {
        this.pcellCache.push(i),
        U.state != 1 && (U.state = 1)
    }
    unbindPlayerCell(i) {
        super.unbindPlayerCell(i),
        U.needUpdate = !0
    }
    sortPlayerCell() {
        this.pcellCache.length && (this.pcellCache.sort((i,s)=>i.id - s.id),
        this.pcellCache.forEach(i=>{
            super.bindPlayerCell(i)
        }
        ),
        this.pcellCache.length = 0,
        U.needUpdate = !0)
    }
    drawCursorLine() {
        this.pcells.forEach(i=>{
            i.drawCursorLine()
        }
        )
    }
    computeSplitOrderMarker() {
        const i = this.cellCount
          , s = this._pcellCapacity - i;
        let n = 0
          , r = 0;
        this.pcells.forEach(o=>{
            let a = 0;
            n < s ? Number(o.massValue) >= 44 ? (a = 0,
            n++) : a = 1 : a = (r - n) * .618 / (i - s) + .382,
            o.SplitOrderMarkerWeight = a,
            r++
        }
        )
    }
    deploySplitOrderMarkerStyle() {
        this.computeSplitOrderMarker(),
        this.pcells.forEach(i=>{
            i.assistance.needUpdate = !0,
            i.drawAssistance()
        }
        )
    }
}
class Bk extends np {
    constructor() {
        super();
        I(this, "uSig", 0);
        I(this, "state", 0);
        I(this, "largest", null);
        I(this, "opUnitQueue", new Lk);
        I(this, "totalMass", 0);
        I(this, "score", 0);
        I(this, "tp", !1);
        I(this, "pause", !1);
        I(this, "specMode", 3);
        I(this, "specTarget", null);
        I(this, "needUpdate", !1);
        I(this, "toggleCheck", !1);
        I(this, "deathCheck", !1)
    }
    get currentOpUnit() {
        return this.opUnitQueue.current
    }
    get targetOpUnit() {
        return this.opUnitQueue.target
    }
    get nextOpUnit() {
        return this.opUnitQueue.next
    }
    get nextOpUnitIndex() {
        return this.opUnitQueue.nextToggleIndex
    }
    init(i) {
        this.id = i.id,
        this.team = i.team,
        i.opUnits.forEach(s=>this.joinOpUnit(s.id, s.nick, s.skin))
    }
    createOpUnit(i, s, n) {
        const r = new Fk(i,this,s,n);
        return this.opUnits.set(i, r),
        r
    }
    joinOpUnit(i, s, n) {
        const {opUnits: r, opUnitQueue: o} = this;
        r.size ? r.has(i) ? r.get(i).updateInfo(s, n) : o.push(this.createOpUnit(i, s, n)) : o.push(this.createOpUnit(i, s, n))
    }
    findLargestCell() {
        this.largest = null,
        !(!this.opUnitQueue.current || this.opUnitQueue.current.pcells.size == 0) && this.opUnitQueue.current.pcells.forEach(s=>{
            (this.largest == null || s.nr > this.largest.nr) && (this.largest = s)
        }
        )
    }
    calcViewCenter() {
        let i = 0
          , s = 0
          , n = 0;
        return this.opUnits.forEach(r=>{
            r.pcells.forEach(o=>{
                const a = o.massValue;
                i += o.nx * a,
                s += o.ny * a,
                n += a
            }
            )
        }
        ),
        this.score = Math.max(this.score, n),
        this.totalMass = n,
        [i /= n, s /= n]
    }
    clearPlayerCells() {
        this.opUnits.forEach(i=>i.clearPlayerCells()),
        this.opUnitQueue.store.forEach(i=>i.clearPlayerCells())
    }
    toggleOpUnit(i) {
        this.opUnitQueue.moveTo(i),
        this.opUnits.forEach(s=>{
            s.pcells.forEach(n=>{
                n.assistance.needUpdate = !0,
                n.drawAssistance()
            }
            )
        }
        ),
        U.toggleCheck = !0,
        U.needUpdate = !0
    }
    detectDeath(i) {
        this.cellCount ? H.AutoSwitchTab && !i.cellCount && this.currentOpUnit === i && A.emit("toggleOpUnit") : this.deathCheck = !0
    }
    die() {
        this.state = 3,
        this.totalMass = 0,
        this.toggleOpUnit(0),
        this.opUnitQueue.targetIndex = 0,
        this.specMode = 1,
        U.specTarget = null,
        A.emit("death")
    }
    setDestinationPoint(i, s) {
        const n = this.targetOpUnit;
        n.DestinationPoint.alpha = 0,
        n.DestinationPoint.position.set(i, s),
        n.moveMode = 1
    }
    drawCursorLine() {
        this.opUnits.forEach(i=>i.drawCursorLine())
    }
    update() {
        this.opUnits.forEach(s=>s.sortPlayerCell()),
        this.findLargestCell(),
        this.needUpdate && (this.opUnits.forEach(s=>s.deploySplitOrderMarkerStyle()),
        this.needUpdate = !1),
        this.toggleCheck && (H.AutoSwitchTab && this.state == 2 && !this.currentOpUnit.cellCount && A.emit("toggleOpUnit"),
        this.toggleCheck = !1),
        this.deathCheck && (this.cellCount || this.die(),
        this.deathCheck = !1);
        const i = vi(0, 40, 500);
        this.opUnits.forEach(s=>{
            if (s.DestinationPoint.visible = s.moveMode && s.cellCount > 0 && s == this.currentOpUnit,
            !s.DestinationPoint.visible)
                return;
            const n = s.DestinationPoint.alpha
              , r = s.DestinationPointAlpha;
            Math.abs(n - r) > .001 && (s.DestinationPoint.alpha = Ze(n, r, i)),
            s.DestinationPoint.tint = s.DestinationPointColor
        }
        )
    }
    reset() {
        this.state = 0,
        this.tp = !1,
        this.largest = null,
        this.activity = 0,
        this.opUnits.clear(),
        this.opUnitQueue.clear()
    }
}
const Ms = new Map
  , Vt = _i(new Map)
  , U = _i(new Bk);
class Pi {
    static getTeam(t) {
        return Ms.get(t)
    }
    static getPlayer(t) {
        return Vt.get(t)
    }
    static joinTeam(t, i, s, n=[]) {
        let r = Ms.get(t);
        r && r.destroy(),
        r = new py(t,i,s),
        r.joinPlayer(n.map(o=>Vt.get(o))),
        Ms.set(t, r)
    }
    static joinPlayer(t, i, s, n) {
        let r;
        return (r = Vt.get(t)) ? r.joinOpUnit(i, s, n) : (r = new np(t),
        Vt.set(t, r),
        r.createOpUnit(i, s, n)),
        r
    }
    static joinSelf(t) {
        const i = Vt.get(t);
        U.init(i),
        Vt.set(t, U)
    }
    static bindPlayerTeam(t, i) {
        Ms.get(i).joinPlayer([Vt.get(t)])
    }
    static disconnect(t) {
        const i = Vt.get(t);
        !i || (i.destroy(),
        Vt.delete(t))
    }
}
A.on("joinSelf", Pi.joinSelf);
var Gd = function() {
    return Gd = Object.assign || function(t) {
        for (var i, s = 1, n = arguments.length; s < n; s++) {
            i = arguments[s];
            for (var r in i)
                Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r])
        }
        return t
    }
    ,
    Gd.apply(this, arguments)
};
function an(e, t, i, s) {
    function n(r) {
        return r instanceof i ? r : new i(function(o) {
            o(r)
        }
        )
    }
    return new (i || (i = Promise))(function(r, o) {
        function a(h) {
            try {
                c(s.next(h))
            } catch (u) {
                o(u)
            }
        }
        function l(h) {
            try {
                c(s.throw(h))
            } catch (u) {
                o(u)
            }
        }
        function c(h) {
            h.done ? r(h.value) : n(h.value).then(a, l)
        }
        c((s = s.apply(e, t || [])).next())
    }
    )
}
function Fs(e, t) {
    var i = {
        label: 0,
        sent: function() {
            if (r[0] & 1)
                throw r[1];
            return r[1]
        },
        trys: [],
        ops: []
    }, s, n, r, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    },
    typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }
    ),
    o;
    function a(c) {
        return function(h) {
            return l([c, h])
        }
    }
    function l(c) {
        if (s)
            throw new TypeError("Generator is already executing.");
        for (; o && (o = 0,
        c[0] && (i = 0)),
        i; )
            try {
                if (s = 1,
                n && (r = c[0] & 2 ? n.return : c[0] ? n.throw || ((r = n.return) && r.call(n),
                0) : n.next) && !(r = r.call(n, c[1])).done)
                    return r;
                switch (n = 0,
                r && (c = [c[0] & 2, r.value]),
                c[0]) {
                case 0:
                case 1:
                    r = c;
                    break;
                case 4:
                    return i.label++,
                    {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    i.label++,
                    n = c[1],
                    c = [0];
                    continue;
                case 7:
                    c = i.ops.pop(),
                    i.trys.pop();
                    continue;
                default:
                    if (r = i.trys,
                    !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        i = 0;
                        continue
                    }
                    if (c[0] === 3 && (!r || c[1] > r[0] && c[1] < r[3])) {
                        i.label = c[1];
                        break
                    }
                    if (c[0] === 6 && i.label < r[1]) {
                        i.label = r[1],
                        r = c;
                        break
                    }
                    if (r && i.label < r[2]) {
                        i.label = r[2],
                        i.ops.push(c);
                        break
                    }
                    r[2] && i.ops.pop(),
                    i.trys.pop();
                    continue
                }
                c = t.call(e, i)
            } catch (h) {
                c = [6, h],
                n = 0
            } finally {
                s = r = 0
            }
        if (c[0] & 5)
            throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}
function Ey() {
    for (var e = 0, t = 0, i = arguments.length; t < i; t++)
        e += arguments[t].length;
    for (var s = Array(e), n = 0, t = 0; t < i; t++)
        for (var r = arguments[t], o = 0, a = r.length; o < a; o++,
        n++)
            s[n] = r[o];
    return s
}
var Sy = "3.3.6";
function No(e, t) {
    return new Promise(function(i) {
        return setTimeout(i, e, t)
    }
    )
}
function Uk(e, t) {
    t === void 0 && (t = 1 / 0);
    var i = window.requestIdleCallback;
    return i ? new Promise(function(s) {
        return i.call(window, function() {
            return s()
        }, {
            timeout: t
        })
    }
    ) : No(Math.min(e, t))
}
function Gk(e) {
    return e && typeof e.then == "function"
}
function qg(e, t) {
    try {
        var i = e();
        Gk(i) ? i.then(function(s) {
            return t(!0, s)
        }, function(s) {
            return t(!1, s)
        }) : t(!0, i)
    } catch (s) {
        t(!1, s)
    }
}
function Jg(e, t, i) {
    return i === void 0 && (i = 16),
    an(this, void 0, void 0, function() {
        var s, n, r;
        return Fs(this, function(o) {
            switch (o.label) {
            case 0:
                s = Date.now(),
                n = 0,
                o.label = 1;
            case 1:
                return n < e.length ? (t(e[n], n),
                r = Date.now(),
                r >= s + i ? (s = r,
                [4, No(0)]) : [3, 3]) : [3, 4];
            case 2:
                o.sent(),
                o.label = 3;
            case 3:
                return ++n,
                [3, 1];
            case 4:
                return [2]
            }
        })
    })
}
function fp(e) {
    e.then(void 0, function() {})
}
function fn(e, t) {
    e = [e[0] >>> 16, e[0] & 65535, e[1] >>> 16, e[1] & 65535],
    t = [t[0] >>> 16, t[0] & 65535, t[1] >>> 16, t[1] & 65535];
    var i = [0, 0, 0, 0];
    return i[3] += e[3] + t[3],
    i[2] += i[3] >>> 16,
    i[3] &= 65535,
    i[2] += e[2] + t[2],
    i[1] += i[2] >>> 16,
    i[2] &= 65535,
    i[1] += e[1] + t[1],
    i[0] += i[1] >>> 16,
    i[1] &= 65535,
    i[0] += e[0] + t[0],
    i[0] &= 65535,
    [i[0] << 16 | i[1], i[2] << 16 | i[3]]
}
function Fi(e, t) {
    e = [e[0] >>> 16, e[0] & 65535, e[1] >>> 16, e[1] & 65535],
    t = [t[0] >>> 16, t[0] & 65535, t[1] >>> 16, t[1] & 65535];
    var i = [0, 0, 0, 0];
    return i[3] += e[3] * t[3],
    i[2] += i[3] >>> 16,
    i[3] &= 65535,
    i[2] += e[2] * t[3],
    i[1] += i[2] >>> 16,
    i[2] &= 65535,
    i[2] += e[3] * t[2],
    i[1] += i[2] >>> 16,
    i[2] &= 65535,
    i[1] += e[1] * t[3],
    i[0] += i[1] >>> 16,
    i[1] &= 65535,
    i[1] += e[2] * t[2],
    i[0] += i[1] >>> 16,
    i[1] &= 65535,
    i[1] += e[3] * t[1],
    i[0] += i[1] >>> 16,
    i[1] &= 65535,
    i[0] += e[0] * t[3] + e[1] * t[2] + e[2] * t[1] + e[3] * t[0],
    i[0] &= 65535,
    [i[0] << 16 | i[1], i[2] << 16 | i[3]]
}
function jr(e, t) {
    return t %= 64,
    t === 32 ? [e[1], e[0]] : t < 32 ? [e[0] << t | e[1] >>> 32 - t, e[1] << t | e[0] >>> 32 - t] : (t -= 32,
    [e[1] << t | e[0] >>> 32 - t, e[0] << t | e[1] >>> 32 - t])
}
function Ti(e, t) {
    return t %= 64,
    t === 0 ? e : t < 32 ? [e[0] << t | e[1] >>> 32 - t, e[1] << t] : [e[1] << t - 32, 0]
}
function Ee(e, t) {
    return [e[0] ^ t[0], e[1] ^ t[1]]
}
function Qg(e) {
    return e = Ee(e, [0, e[0] >>> 1]),
    e = Fi(e, [4283543511, 3981806797]),
    e = Ee(e, [0, e[0] >>> 1]),
    e = Fi(e, [3301882366, 444984403]),
    e = Ee(e, [0, e[0] >>> 1]),
    e
}
function Hk(e, t) {
    e = e || "",
    t = t || 0;
    var i = e.length % 16, s = e.length - i, n = [0, t], r = [0, t], o = [0, 0], a = [0, 0], l = [2277735313, 289559509], c = [1291169091, 658871167], h;
    for (h = 0; h < s; h = h + 16)
        o = [e.charCodeAt(h + 4) & 255 | (e.charCodeAt(h + 5) & 255) << 8 | (e.charCodeAt(h + 6) & 255) << 16 | (e.charCodeAt(h + 7) & 255) << 24, e.charCodeAt(h) & 255 | (e.charCodeAt(h + 1) & 255) << 8 | (e.charCodeAt(h + 2) & 255) << 16 | (e.charCodeAt(h + 3) & 255) << 24],
        a = [e.charCodeAt(h + 12) & 255 | (e.charCodeAt(h + 13) & 255) << 8 | (e.charCodeAt(h + 14) & 255) << 16 | (e.charCodeAt(h + 15) & 255) << 24, e.charCodeAt(h + 8) & 255 | (e.charCodeAt(h + 9) & 255) << 8 | (e.charCodeAt(h + 10) & 255) << 16 | (e.charCodeAt(h + 11) & 255) << 24],
        o = Fi(o, l),
        o = jr(o, 31),
        o = Fi(o, c),
        n = Ee(n, o),
        n = jr(n, 27),
        n = fn(n, r),
        n = fn(Fi(n, [0, 5]), [0, 1390208809]),
        a = Fi(a, c),
        a = jr(a, 33),
        a = Fi(a, l),
        r = Ee(r, a),
        r = jr(r, 31),
        r = fn(r, n),
        r = fn(Fi(r, [0, 5]), [0, 944331445]);
    switch (o = [0, 0],
    a = [0, 0],
    i) {
    case 15:
        a = Ee(a, Ti([0, e.charCodeAt(h + 14)], 48));
    case 14:
        a = Ee(a, Ti([0, e.charCodeAt(h + 13)], 40));
    case 13:
        a = Ee(a, Ti([0, e.charCodeAt(h + 12)], 32));
    case 12:
        a = Ee(a, Ti([0, e.charCodeAt(h + 11)], 24));
    case 11:
        a = Ee(a, Ti([0, e.charCodeAt(h + 10)], 16));
    case 10:
        a = Ee(a, Ti([0, e.charCodeAt(h + 9)], 8));
    case 9:
        a = Ee(a, [0, e.charCodeAt(h + 8)]),
        a = Fi(a, c),
        a = jr(a, 33),
        a = Fi(a, l),
        r = Ee(r, a);
    case 8:
        o = Ee(o, Ti([0, e.charCodeAt(h + 7)], 56));
    case 7:
        o = Ee(o, Ti([0, e.charCodeAt(h + 6)], 48));
    case 6:
        o = Ee(o, Ti([0, e.charCodeAt(h + 5)], 40));
    case 5:
        o = Ee(o, Ti([0, e.charCodeAt(h + 4)], 32));
    case 4:
        o = Ee(o, Ti([0, e.charCodeAt(h + 3)], 24));
    case 3:
        o = Ee(o, Ti([0, e.charCodeAt(h + 2)], 16));
    case 2:
        o = Ee(o, Ti([0, e.charCodeAt(h + 1)], 8));
    case 1:
        o = Ee(o, [0, e.charCodeAt(h)]),
        o = Fi(o, l),
        o = jr(o, 31),
        o = Fi(o, c),
        n = Ee(n, o)
    }
    return n = Ee(n, [0, e.length]),
    r = Ee(r, [0, e.length]),
    n = fn(n, r),
    r = fn(r, n),
    n = Qg(n),
    r = Qg(r),
    n = fn(n, r),
    r = fn(r, n),
    ("00000000" + (n[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (n[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (r[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (r[1] >>> 0).toString(16)).slice(-8)
}
function Vk(e) {
    var t;
    return Gd({
        name: e.name,
        message: e.message,
        stack: (t = e.stack) === null || t === void 0 ? void 0 : t.split(`
`)
    }, e)
}
function zk(e, t) {
    for (var i = 0, s = e.length; i < s; ++i)
        if (e[i] === t)
            return !0;
    return !1
}
function $k(e, t) {
    return !zk(e, t)
}
function pp(e) {
    return parseInt(e)
}
function ts(e) {
    return parseFloat(e)
}
function zs(e, t) {
    return typeof e == "number" && isNaN(e) ? t : e
}
function bs(e) {
    return e.reduce(function(t, i) {
        return t + (i ? 1 : 0)
    }, 0)
}
function Cy(e, t) {
    if (t === void 0 && (t = 1),
    Math.abs(t) >= 1)
        return Math.round(e / t) * t;
    var i = 1 / t;
    return Math.round(e * i) / i
}
function jk(e) {
    for (var t, i, s = "Unexpected syntax '" + e + "'", n = /^\s*([a-z-]*)(.*)$/i.exec(e), r = n[1] || void 0, o = {}, a = /([.:#][\w-]+|\[.+?\])/gi, l = function(d, f) {
        o[d] = o[d] || [],
        o[d].push(f)
    }; ; ) {
        var c = a.exec(n[2]);
        if (!c)
            break;
        var h = c[0];
        switch (h[0]) {
        case ".":
            l("class", h.slice(1));
            break;
        case "#":
            l("id", h.slice(1));
            break;
        case "[":
            {
                var u = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(h);
                if (u)
                    l(u[1], (i = (t = u[4]) !== null && t !== void 0 ? t : u[5]) !== null && i !== void 0 ? i : "");
                else
                    throw new Error(s);
                break
            }
        default:
            throw new Error(s)
        }
    }
    return [r, o]
}
function t0(e) {
    return e && typeof e == "object" && "message"in e ? e : {
        message: e
    }
}
function Wk(e) {
    return typeof e != "function"
}
function Xk(e, t) {
    var i = new Promise(function(s) {
        var n = Date.now();
        qg(e.bind(null, t), function() {
            for (var r = [], o = 0; o < arguments.length; o++)
                r[o] = arguments[o];
            var a = Date.now() - n;
            if (!r[0])
                return s(function() {
                    return {
                        error: t0(r[1]),
                        duration: a
                    }
                });
            var l = r[1];
            if (Wk(l))
                return s(function() {
                    return {
                        value: l,
                        duration: a
                    }
                });
            s(function() {
                return new Promise(function(c) {
                    var h = Date.now();
                    qg(l, function() {
                        for (var u = [], d = 0; d < arguments.length; d++)
                            u[d] = arguments[d];
                        var f = a + Date.now() - h;
                        if (!u[0])
                            return c({
                                error: t0(u[1]),
                                duration: f
                            });
                        c({
                            value: u[1],
                            duration: f
                        })
                    })
                }
                )
            })
        })
    }
    );
    return fp(i),
    function() {
        return i.then(function(n) {
            return n()
        })
    }
}
function Yk(e, t, i) {
    var s = Object.keys(e).filter(function(r) {
        return $k(i, r)
    })
      , n = Array(s.length);
    return Jg(s, function(r, o) {
        n[o] = Xk(e[r], t)
    }),
    function() {
        return an(this, void 0, void 0, function() {
            var o, a, l, c, h, u, d;
            return Fs(this, function(f) {
                switch (f.label) {
                case 0:
                    for (o = {},
                    a = 0,
                    l = s; a < l.length; a++)
                        c = l[a],
                        o[c] = void 0;
                    h = Array(s.length),
                    u = function() {
                        var p;
                        return Fs(this, function(m) {
                            switch (m.label) {
                            case 0:
                                return p = !0,
                                [4, Jg(s, function(g, y) {
                                    if (!h[y])
                                        if (n[y]) {
                                            var x = n[y]().then(function(v) {
                                                return o[g] = v
                                            });
                                            fp(x),
                                            h[y] = x
                                        } else
                                            p = !1
                                })];
                            case 1:
                                return m.sent(),
                                p ? [2, "break"] : [4, No(1)];
                            case 2:
                                return m.sent(),
                                [2]
                            }
                        })
                    }
                    ,
                    f.label = 1;
                case 1:
                    return [5, u()];
                case 2:
                    if (d = f.sent(),
                    d === "break")
                        return [3, 4];
                    f.label = 3;
                case 3:
                    return [3, 1];
                case 4:
                    return [4, Promise.all(h)];
                case 5:
                    return f.sent(),
                    [2, o]
                }
            })
        })
    }
}
function Ay() {
    var e = window
      , t = navigator;
    return bs(["MSCSSMatrix"in e, "msSetImmediate"in e, "msIndexedDB"in e, "msMaxTouchPoints"in t, "msPointerEnabled"in t]) >= 4
}
function Kk() {
    var e = window
      , t = navigator;
    return bs(["msWriteProfilerMark"in e, "MSStream"in e, "msLaunchUri"in t, "msSaveBlob"in t]) >= 3 && !Ay()
}
function mp() {
    var e = window
      , t = navigator;
    return bs(["webkitPersistentStorage"in t, "webkitTemporaryStorage"in t, t.vendor.indexOf("Google") === 0, "webkitResolveLocalFileSystemURL"in e, "BatteryManager"in e, "webkitMediaStream"in e, "webkitSpeechGrammar"in e]) >= 5
}
function il() {
    var e = window
      , t = navigator;
    return bs(["ApplePayError"in e, "CSSPrimitiveValue"in e, "Counter"in e, t.vendor.indexOf("Apple") === 0, "getStorageUpdates"in t, "WebKitMediaKeys"in e]) >= 4
}
function gp() {
    var e = window;
    return bs(["safari"in e, !("DeviceMotionEvent"in e), !("ongestureend"in e), !("standalone"in navigator)]) >= 3
}
function Zk() {
    var e, t, i = window;
    return bs(["buildID"in navigator, "MozAppearance"in ((t = (e = document.documentElement) === null || e === void 0 ? void 0 : e.style) !== null && t !== void 0 ? t : {}), "onmozfullscreenchange"in i, "mozInnerScreenX"in i, "CSSMozDocumentRule"in i, "CanvasCaptureMediaStream"in i]) >= 4
}
function qk() {
    var e = window;
    return bs([!("MediaSettingsRange"in e), "RTCEncodedAudioFrame"in e, "" + e.Intl == "[object Intl]", "" + e.Reflect == "[object Reflect]"]) >= 3
}
function Jk() {
    var e = window;
    return bs(["DOMRectList"in e, "RTCPeerConnectionIceEvent"in e, "SVGGeometryElement"in e, "ontransitioncancel"in e]) >= 3
}
function Qk() {
    if (navigator.platform === "iPad")
        return !0;
    var e = screen
      , t = e.width / e.height;
    return bs(["MediaSource"in window, !!Element.prototype.webkitRequestFullscreen, t > .65 && t < 1.53]) >= 2
}
function tP() {
    var e = document;
    return e.fullscreenElement || e.msFullscreenElement || e.mozFullScreenElement || e.webkitFullscreenElement || null
}
function eP() {
    var e = document;
    return (e.exitFullscreen || e.msExitFullscreen || e.mozCancelFullScreen || e.webkitExitFullscreen).call(e)
}
function Iy() {
    var e = mp()
      , t = Zk();
    if (!e && !t)
        return !1;
    var i = window;
    return bs(["onorientationchange"in i, "orientation"in i, e && !("SharedWorker"in i), t && /android/i.test(navigator.appVersion)]) >= 2
}
function iP() {
    var e = window
      , t = e.OfflineAudioContext || e.webkitOfflineAudioContext;
    if (!t)
        return -2;
    if (sP())
        return -1;
    var i = 4500
      , s = 5e3
      , n = new t(1,s,44100)
      , r = n.createOscillator();
    r.type = "triangle",
    r.frequency.value = 1e4;
    var o = n.createDynamicsCompressor();
    o.threshold.value = -50,
    o.knee.value = 40,
    o.ratio.value = 12,
    o.attack.value = 0,
    o.release.value = .25,
    r.connect(o),
    o.connect(n.destination),
    r.start(0);
    var a = nP(n)
      , l = a[0]
      , c = a[1]
      , h = l.then(function(u) {
        return rP(u.getChannelData(0).subarray(i))
    }, function(u) {
        if (u.name === "timeout" || u.name === "suspended")
            return -3;
        throw u
    });
    return fp(h),
    function() {
        return c(),
        h
    }
}
function sP() {
    return il() && !gp() && !Jk()
}
function nP(e) {
    var t = 3
      , i = 500
      , s = 500
      , n = 5e3
      , r = function() {}
      , o = new Promise(function(a, l) {
        var c = !1
          , h = 0
          , u = 0;
        e.oncomplete = function(p) {
            return a(p.renderedBuffer)
        }
        ;
        var d = function() {
            setTimeout(function() {
                return l(e0("timeout"))
            }, Math.min(s, u + n - Date.now()))
        }
          , f = function() {
            try {
                switch (e.startRendering(),
                e.state) {
                case "running":
                    u = Date.now(),
                    c && d();
                    break;
                case "suspended":
                    document.hidden || h++,
                    c && h >= t ? l(e0("suspended")) : setTimeout(f, i);
                    break
                }
            } catch (p) {
                l(p)
            }
        };
        f(),
        r = function() {
            c || (c = !0,
            u > 0 && d())
        }
    }
    );
    return [o, r]
}
function rP(e) {
    for (var t = 0, i = 0; i < e.length; ++i)
        t += Math.abs(e[i]);
    return t
}
function e0(e) {
    var t = new Error(e);
    return t.name = e,
    t
}
function My(e, t, i) {
    var s, n, r;
    return i === void 0 && (i = 50),
    an(this, void 0, void 0, function() {
        var o, a;
        return Fs(this, function(l) {
            switch (l.label) {
            case 0:
                o = document,
                l.label = 1;
            case 1:
                return o.body ? [3, 3] : [4, No(i)];
            case 2:
                return l.sent(),
                [3, 1];
            case 3:
                a = o.createElement("iframe"),
                l.label = 4;
            case 4:
                return l.trys.push([4, , 10, 11]),
                [4, new Promise(function(c, h) {
                    var u = !1
                      , d = function() {
                        u = !0,
                        c()
                    }
                      , f = function(g) {
                        u = !0,
                        h(g)
                    };
                    a.onload = d,
                    a.onerror = f;
                    var p = a.style;
                    p.setProperty("display", "block", "important"),
                    p.position = "absolute",
                    p.top = "0",
                    p.left = "0",
                    p.visibility = "hidden",
                    t && "srcdoc"in a ? a.srcdoc = t : a.src = "about:blank",
                    o.body.appendChild(a);
                    var m = function() {
                        var g, y;
                        u || (((y = (g = a.contentWindow) === null || g === void 0 ? void 0 : g.document) === null || y === void 0 ? void 0 : y.readyState) === "complete" ? d() : setTimeout(m, 10))
                    };
                    m()
                }
                )];
            case 5:
                l.sent(),
                l.label = 6;
            case 6:
                return !((n = (s = a.contentWindow) === null || s === void 0 ? void 0 : s.document) === null || n === void 0) && n.body ? [3, 8] : [4, No(i)];
            case 7:
                return l.sent(),
                [3, 6];
            case 8:
                return [4, e(a, a.contentWindow)];
            case 9:
                return [2, l.sent()];
            case 10:
                return (r = a.parentNode) === null || r === void 0 || r.removeChild(a),
                [7];
            case 11:
                return [2]
            }
        })
    })
}
function oP(e) {
    for (var t = jk(e), i = t[0], s = t[1], n = document.createElement(i ?? "div"), r = 0, o = Object.keys(s); r < o.length; r++) {
        var a = o[r]
          , l = s[a].join(" ");
        a === "style" ? aP(n.style, l) : n.setAttribute(a, l)
    }
    return n
}
function aP(e, t) {
    for (var i = 0, s = t.split(";"); i < s.length; i++) {
        var n = s[i]
          , r = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(n);
        if (r) {
            var o = r[1]
              , a = r[2]
              , l = r[4];
            e.setProperty(o, a, l || "")
        }
    }
}
var lP = "mmMwWLliI0O&1"
  , cP = "48px"
  , Wr = ["monospace", "sans-serif", "serif"]
  , i0 = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];
function hP() {
    return My(function(e, t) {
        var i = t.document
          , s = i.body;
        s.style.fontSize = cP;
        var n = i.createElement("div")
          , r = {}
          , o = {}
          , a = function(m) {
            var g = i.createElement("span")
              , y = g.style;
            return y.position = "absolute",
            y.top = "0",
            y.left = "0",
            y.fontFamily = m,
            g.textContent = lP,
            n.appendChild(g),
            g
        }
          , l = function(m, g) {
            return a("'" + m + "'," + g)
        }
          , c = function() {
            return Wr.map(a)
        }
          , h = function() {
            for (var m = {}, g = function(_) {
                m[_] = Wr.map(function(C) {
                    return l(_, C)
                })
            }, y = 0, x = i0; y < x.length; y++) {
                var v = x[y];
                g(v)
            }
            return m
        }
          , u = function(m) {
            return Wr.some(function(g, y) {
                return m[y].offsetWidth !== r[g] || m[y].offsetHeight !== o[g]
            })
        }
          , d = c()
          , f = h();
        s.appendChild(n);
        for (var p = 0; p < Wr.length; p++)
            r[Wr[p]] = d[p].offsetWidth,
            o[Wr[p]] = d[p].offsetHeight;
        return i0.filter(function(m) {
            return u(f[m])
        })
    })
}
function uP() {
    var e = navigator.plugins;
    if (!!e) {
        for (var t = [], i = 0; i < e.length; ++i) {
            var s = e[i];
            if (!!s) {
                for (var n = [], r = 0; r < s.length; ++r) {
                    var o = s[r];
                    n.push({
                        type: o.type,
                        suffixes: o.suffixes
                    })
                }
                t.push({
                    name: s.name,
                    description: s.description,
                    mimeTypes: n
                })
            }
        }
        return t
    }
}
function dP() {
    var e = !1, t, i, s = fP(), n = s[0], r = s[1];
    if (!pP(n, r))
        t = i = "";
    else {
        e = mP(r),
        gP(n, r);
        var o = bu(n)
          , a = bu(n);
        o !== a ? t = i = "unstable" : (i = o,
        vP(n, r),
        t = bu(n))
    }
    return {
        winding: e,
        geometry: t,
        text: i
    }
}
function fP() {
    var e = document.createElement("canvas");
    return e.width = 1,
    e.height = 1,
    [e, e.getContext("2d")]
}
function pP(e, t) {
    return !!(t && e.toDataURL)
}
function mP(e) {
    return e.rect(0, 0, 10, 10),
    e.rect(2, 2, 6, 6),
    !e.isPointInPath(5, 5, "evenodd")
}
function gP(e, t) {
    e.width = 240,
    e.height = 60,
    t.textBaseline = "alphabetic",
    t.fillStyle = "#f60",
    t.fillRect(100, 1, 62, 20),
    t.fillStyle = "#069",
    t.font = '11pt "Times New Roman"';
    var i = "Cwm fjordbank gly " + String.fromCharCode(55357, 56835);
    t.fillText(i, 2, 15),
    t.fillStyle = "rgba(102, 204, 0, 0.2)",
    t.font = "18pt Arial",
    t.fillText(i, 4, 45)
}
function vP(e, t) {
    e.width = 122,
    e.height = 110,
    t.globalCompositeOperation = "multiply";
    for (var i = 0, s = [["#f2f", 40, 40], ["#2ff", 80, 40], ["#ff2", 60, 80]]; i < s.length; i++) {
        var n = s[i]
          , r = n[0]
          , o = n[1]
          , a = n[2];
        t.fillStyle = r,
        t.beginPath(),
        t.arc(o, a, 40, 0, Math.PI * 2, !0),
        t.closePath(),
        t.fill()
    }
    t.fillStyle = "#f9c",
    t.arc(60, 60, 60, 0, Math.PI * 2, !0),
    t.arc(60, 60, 20, 0, Math.PI * 2, !0),
    t.fill("evenodd")
}
function bu(e) {
    return e.toDataURL()
}
function _P() {
    var e = navigator, t = 0, i;
    e.maxTouchPoints !== void 0 ? t = pp(e.maxTouchPoints) : e.msMaxTouchPoints !== void 0 && (t = e.msMaxTouchPoints);
    try {
        document.createEvent("TouchEvent"),
        i = !0
    } catch {
        i = !1
    }
    var s = "ontouchstart"in window;
    return {
        maxTouchPoints: t,
        touchEvent: i,
        touchStart: s
    }
}
function yP() {
    return navigator.oscpu
}
function bP() {
    var e = navigator
      , t = []
      , i = e.language || e.userLanguage || e.browserLanguage || e.systemLanguage;
    if (i !== void 0 && t.push([i]),
    Array.isArray(e.languages))
        mp() && qk() || t.push(e.languages);
    else if (typeof e.languages == "string") {
        var s = e.languages;
        s && t.push(s.split(","))
    }
    return t
}
function xP() {
    return window.screen.colorDepth
}
function wP() {
    return zs(ts(navigator.deviceMemory), void 0)
}
function TP() {
    var e = screen
      , t = function(s) {
        return zs(pp(s), null)
    }
      , i = [t(e.width), t(e.height)];
    return i.sort().reverse(),
    i
}
var EP = 2500, SP = 10, lc, xu;
function CP() {
    if (xu === void 0) {
        var e = function() {
            var t = Hd();
            Vd(t) ? xu = setTimeout(e, EP) : (lc = t,
            xu = void 0)
        };
        e()
    }
}
function AP() {
    var e = this;
    return CP(),
    function() {
        return an(e, void 0, void 0, function() {
            var t;
            return Fs(this, function(i) {
                switch (i.label) {
                case 0:
                    return t = Hd(),
                    Vd(t) ? lc ? [2, Ey(lc)] : tP() ? [4, eP()] : [3, 2] : [3, 2];
                case 1:
                    i.sent(),
                    t = Hd(),
                    i.label = 2;
                case 2:
                    return Vd(t) || (lc = t),
                    [2, t]
                }
            })
        })
    }
}
function IP() {
    var e = this
      , t = AP();
    return function() {
        return an(e, void 0, void 0, function() {
            var i, s;
            return Fs(this, function(n) {
                switch (n.label) {
                case 0:
                    return [4, t()];
                case 1:
                    return i = n.sent(),
                    s = function(r) {
                        return r === null ? null : Cy(r, SP)
                    }
                    ,
                    [2, [s(i[0]), s(i[1]), s(i[2]), s(i[3])]]
                }
            })
        })
    }
}
function Hd() {
    var e = screen;
    return [zs(ts(e.availTop), null), zs(ts(e.width) - ts(e.availWidth) - zs(ts(e.availLeft), 0), null), zs(ts(e.height) - ts(e.availHeight) - zs(ts(e.availTop), 0), null), zs(ts(e.availLeft), null)]
}
function Vd(e) {
    for (var t = 0; t < 4; ++t)
        if (e[t])
            return !1;
    return !0
}
function MP() {
    return zs(pp(navigator.hardwareConcurrency), void 0)
}
function RP() {
    var e, t = (e = window.Intl) === null || e === void 0 ? void 0 : e.DateTimeFormat;
    if (t) {
        var i = new t().resolvedOptions().timeZone;
        if (i)
            return i
    }
    var s = -kP();
    return "UTC" + (s >= 0 ? "+" : "") + Math.abs(s)
}
function kP() {
    var e = new Date().getFullYear();
    return Math.max(ts(new Date(e,0,1).getTimezoneOffset()), ts(new Date(e,6,1).getTimezoneOffset()))
}
function PP() {
    try {
        return !!window.sessionStorage
    } catch {
        return !0
    }
}
function LP() {
    try {
        return !!window.localStorage
    } catch {
        return !0
    }
}
function OP() {
    if (!(Ay() || Kk()))
        try {
            return !!window.indexedDB
        } catch {
            return !0
        }
}
function DP() {
    return !!window.openDatabase
}
function NP() {
    return navigator.cpuClass
}
function FP() {
    var e = navigator.platform;
    return e === "MacIntel" && il() && !gp() ? Qk() ? "iPad" : "iPhone" : e
}
function BP() {
    return navigator.vendor || ""
}
function UP() {
    for (var e = [], t = 0, i = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; t < i.length; t++) {
        var s = i[t]
          , n = window[s];
        n && typeof n == "object" && e.push(s)
    }
    return e.sort()
}
function GP() {
    var e = document;
    try {
        e.cookie = "cookietest=1; SameSite=Strict;";
        var t = e.cookie.indexOf("cookietest=") !== -1;
        return e.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT",
        t
    } catch {
        return !1
    }
}
function HP() {
    var e = atob;
    return {
        abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", e("YVt0aXRsZT0iN25hZ2EgcG9rZXIiIGld"), '[title="ALIENBOLA" i]'],
        abpvn: ["#quangcaomb", e("Lmlvc0Fkc2lvc0Fkcy1sYXlvdXQ="), ".quangcao", e("W2hyZWZePSJodHRwczovL3I4OC52bi8iXQ=="), e("W2hyZWZePSJodHRwczovL3piZXQudm4vIl0=")],
        adBlockFinland: [".mainostila", e("LnNwb25zb3JpdA=="), ".ylamainos", e("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), e("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
        adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", e("I2FkMl9pbmxpbmU=")],
        adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", e("LmhlYWRlci1ibG9ja2VkLWFk"), e("I2FkX2Jsb2NrZXI=")],
        adGuardAnnoyances: ['amp-embed[type="zen"]', ".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil"],
        adGuardBase: [".BetterJsPopOverlay", e("I2FkXzMwMFgyNTA="), e("I2Jhbm5lcmZsb2F0MjI="), e("I2FkLWJhbm5lcg=="), e("I2NhbXBhaWduLWJhbm5lcg==")],
        adGuardChinese: [e("LlppX2FkX2FfSA=="), e("YVtocmVmKj0iL29kMDA1LmNvbSJd"), e("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), ".qq_nr_lad", "#widget-quan"],
        adGuardFrench: [e("I2Jsb2NrLXZpZXdzLWFkcy1zaWRlYmFyLWJsb2NrLWJsb2Nr"), "#pavePub", e("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv"],
        adGuardGerman: [e("LmJhbm5lcml0ZW13ZXJidW5nX2hlYWRfMQ=="), e("LmJveHN0YXJ0d2VyYnVuZw=="), e("LndlcmJ1bmcz"), e("YVtocmVmXj0iaHR0cDovL3d3dy5laXMuZGUvaW5kZXgucGh0bWw/cmVmaWQ9Il0="), e("YVtocmVmXj0iaHR0cHM6Ly93d3cudGlwaWNvLmNvbS8/YWZmaWxpYXRlSWQ9Il0=")],
        adGuardJapanese: ["#kauli_yad_1", e("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), e("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), e("LmFkZ29vZ2xl"), e("LmFkX3JlZ3VsYXIz")],
        adGuardMobile: [e("YW1wLWF1dG8tYWRz"), e("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", e("I2FkX2ludmlld19hcmVh")],
        adGuardRussian: [e("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), e("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', e("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), e("I2FkX3NxdWFyZQ==")],
        adGuardSocial: [e("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), e("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
        adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", e("W2hyZWZePSJodHRwOi8vYWRzLmdsaXNwYS5jb20vIl0=")],
        adGuardTrackingProtection: ["#qoo-counter", e("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), e("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), e("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
        adGuardTurkish: ["#backkapat", e("I3Jla2xhbWk="), e("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), e("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), e("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
        bulgarian: [e("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers", e("I25ld0Fk")],
        easyList: [e("I0FEX0NPTlRST0xfMjg="), e("LnNlY29uZC1wb3N0LWFkcy13cmFwcGVy"), ".universalboxADVBOX03", e("LmFkdmVydGlzZW1lbnQtNzI4eDkw"), e("LnNxdWFyZV9hZHM=")],
        easyListChina: [e("YVtocmVmKj0iLndlbnNpeHVldGFuZy5jb20vIl0="), e("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), e("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box"],
        easyListCookie: ["#AdaCompliance.app-notice", ".text-center.rgpd", ".panel--cookie", ".js-cookies-andromeda", ".elxtr-consent"],
        easyListCzechSlovak: ["#onlajny-stickers", e("I3Jla2xhbW5pLWJveA=="), e("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", e("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
        easyListDutch: [e("I2FkdmVydGVudGll"), e("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", e("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
        easyListGermany: [e("I0FkX1dpbjJkYXk="), e("I3dlcmJ1bmdzYm94MzAw"), e("YVtocmVmXj0iaHR0cDovL3d3dy5yb3RsaWNodGthcnRlaS5jb20vP3NjPSJd"), e("I3dlcmJ1bmdfd2lkZXNreXNjcmFwZXJfc2NyZWVu"), e("YVtocmVmXj0iaHR0cDovL2xhbmRpbmcucGFya3BsYXR6a2FydGVpLmNvbS8/YWc9Il0=")],
        easyListItaly: [e("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", e("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), e("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), e("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
        easyListLithuania: [e("LnJla2xhbW9zX3RhcnBhcw=="), e("LnJla2xhbW9zX251b3JvZG9z"), e("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), e("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), e("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
        estonian: [e("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
        fanboyAnnoyances: ["#feedback-tab", "#taboola-below-article", ".feedburnerFeedBlock", ".widget-feedburner-counter", '[title="Subscribe to our blog"]'],
        fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
        fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
        fanboySocial: [".td-tags-and-social-wrapper-box", ".twitterContainer", ".youtube-social", 'a[title^="Like us on Facebook"]', 'img[alt^="Share on Digg"]'],
        frellwitSwedish: [e("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), e("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", e("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
        greekAdBlock: [e("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), e("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), e("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
        hungarian: ["#cemp_doboz", ".optimonk-iframe-container", e("LmFkX19tYWlu"), e("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
        iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", ".cookie-msg-info-container", "#cookies-policy-sticky"],
        icelandicAbp: [e("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
        latvian: [e("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), e("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
        listKr: [e("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), e("I2xpdmVyZUFkV3JhcHBlcg=="), e("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), e("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
        listeAr: [e("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", e("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), e("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), e("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
        listeFr: [e("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), e("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), e("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
        officialPolish: ["#ceneo-placeholder-ceneo-12", e("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), e("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), e("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), e("ZGl2I3NrYXBpZWNfYWQ=")],
        ro: [e("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), 'a[href^="/magazin/"]', e("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), e("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), e("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd")],
        ruAd: [e("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), e("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), e("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
        thaiAds: ["a[href*=macau-uta-popup]", e("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), e("LmFkczMwMHM="), ".bumq", ".img-kosana"],
        webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", e("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
    }
}
function VP(e) {
    var t = (e === void 0 ? {} : e).debug;
    return an(this, void 0, void 0, function() {
        var i, s, n, r, o, a;
        return Fs(this, function(l) {
            switch (l.label) {
            case 0:
                return zP() ? (i = HP(),
                s = Object.keys(i),
                n = (a = []).concat.apply(a, s.map(function(c) {
                    return i[c]
                })),
                [4, $P(n)]) : [2, void 0];
            case 1:
                return r = l.sent(),
                t && jP(i, r),
                o = s.filter(function(c) {
                    var h = i[c]
                      , u = bs(h.map(function(d) {
                        return r[d]
                    }));
                    return u > h.length * .6
                }),
                o.sort(),
                [2, o]
            }
        })
    })
}
function zP() {
    return il() || Iy()
}
function $P(e) {
    var t;
    return an(this, void 0, void 0, function() {
        var i, s, n, r, l, o, a, l;
        return Fs(this, function(c) {
            switch (c.label) {
            case 0:
                for (i = document,
                s = i.createElement("div"),
                n = new Array(e.length),
                r = {},
                s0(s),
                l = 0; l < e.length; ++l)
                    o = oP(e[l]),
                    a = i.createElement("div"),
                    s0(a),
                    a.appendChild(o),
                    s.appendChild(a),
                    n[l] = o;
                c.label = 1;
            case 1:
                return i.body ? [3, 3] : [4, No(50)];
            case 2:
                return c.sent(),
                [3, 1];
            case 3:
                i.body.appendChild(s);
                try {
                    for (l = 0; l < e.length; ++l)
                        n[l].offsetParent || (r[e[l]] = !0)
                } finally {
                    (t = s.parentNode) === null || t === void 0 || t.removeChild(s)
                }
                return [2, r]
            }
        })
    })
}
function s0(e) {
    e.style.setProperty("display", "block", "important")
}
function jP(e, t) {
    for (var i = "DOM blockers debug:\n```", s = 0, n = Object.keys(e); s < n.length; s++) {
        var r = n[s];
        i += `
` + r + ":";
        for (var o = 0, a = e[r]; o < a.length; o++) {
            var l = a[o];
            i += `
  ` + (t[l] ? "\u{1F6AB}" : "\u27A1\uFE0F") + " " + l
        }
    }
    console.log(i + "\n```")
}
function WP() {
    for (var e = 0, t = ["rec2020", "p3", "srgb"]; e < t.length; e++) {
        var i = t[e];
        if (matchMedia("(color-gamut: " + i + ")").matches)
            return i
    }
}
function XP() {
    if (n0("inverted"))
        return !0;
    if (n0("none"))
        return !1
}
function n0(e) {
    return matchMedia("(inverted-colors: " + e + ")").matches
}
function YP() {
    if (r0("active"))
        return !0;
    if (r0("none"))
        return !1
}
function r0(e) {
    return matchMedia("(forced-colors: " + e + ")").matches
}
var KP = 100;
function ZP() {
    if (!!matchMedia("(min-monochrome: 0)").matches) {
        for (var e = 0; e <= KP; ++e)
            if (matchMedia("(max-monochrome: " + e + ")").matches)
                return e;
        throw new Error("Too high value")
    }
}
function qP() {
    if (Xr("no-preference"))
        return 0;
    if (Xr("high") || Xr("more"))
        return 1;
    if (Xr("low") || Xr("less"))
        return -1;
    if (Xr("forced"))
        return 10
}
function Xr(e) {
    return matchMedia("(prefers-contrast: " + e + ")").matches
}
function JP() {
    if (o0("reduce"))
        return !0;
    if (o0("no-preference"))
        return !1
}
function o0(e) {
    return matchMedia("(prefers-reduced-motion: " + e + ")").matches
}
function QP() {
    if (a0("high"))
        return !0;
    if (a0("standard"))
        return !1
}
function a0(e) {
    return matchMedia("(dynamic-range: " + e + ")").matches
}
var ve = Math
  , ni = function() {
    return 0
};
function t8() {
    var e = ve.acos || ni
      , t = ve.acosh || ni
      , i = ve.asin || ni
      , s = ve.asinh || ni
      , n = ve.atanh || ni
      , r = ve.atan || ni
      , o = ve.sin || ni
      , a = ve.sinh || ni
      , l = ve.cos || ni
      , c = ve.cosh || ni
      , h = ve.tan || ni
      , u = ve.tanh || ni
      , d = ve.exp || ni
      , f = ve.expm1 || ni
      , p = ve.log1p || ni
      , m = function(T) {
        return ve.pow(ve.PI, T)
    }
      , g = function(T) {
        return ve.log(T + ve.sqrt(T * T - 1))
    }
      , y = function(T) {
        return ve.log(T + ve.sqrt(T * T + 1))
    }
      , x = function(T) {
        return ve.log((1 + T) / (1 - T)) / 2
    }
      , v = function(T) {
        return ve.exp(T) - 1 / ve.exp(T) / 2
    }
      , _ = function(T) {
        return (ve.exp(T) + 1 / ve.exp(T)) / 2
    }
      , C = function(T) {
        return ve.exp(T) - 1
    }
      , k = function(T) {
        return (ve.exp(2 * T) - 1) / (ve.exp(2 * T) + 1)
    }
      , S = function(T) {
        return ve.log(1 + T)
    };
    return {
        acos: e(.12312423423423424),
        acosh: t(1e308),
        acoshPf: g(1e154),
        asin: i(.12312423423423424),
        asinh: s(1),
        asinhPf: y(1),
        atanh: n(.5),
        atanhPf: x(.5),
        atan: r(.5),
        sin: o(-1e300),
        sinh: a(1),
        sinhPf: v(1),
        cos: l(10.000000000123),
        cosh: c(1),
        coshPf: _(1),
        tan: h(-1e300),
        tanh: u(1),
        tanhPf: k(1),
        exp: d(1),
        expm1: f(1),
        expm1Pf: C(1),
        log1p: p(10),
        log1pPf: S(10),
        powPI: m(-100)
    }
}
var e8 = "mmMwWLliI0fiflO&1"
  , wu = {
    default: [],
    apple: [{
        font: "-apple-system-body"
    }],
    serif: [{
        fontFamily: "serif"
    }],
    sans: [{
        fontFamily: "sans-serif"
    }],
    mono: [{
        fontFamily: "monospace"
    }],
    min: [{
        fontSize: "1px"
    }],
    system: [{
        fontFamily: "system-ui"
    }]
};
function i8() {
    return s8(function(e, t) {
        for (var i = {}, s = {}, n = 0, r = Object.keys(wu); n < r.length; n++) {
            var o = r[n]
              , a = wu[o]
              , l = a[0]
              , c = l === void 0 ? {} : l
              , h = a[1]
              , u = h === void 0 ? e8 : h
              , d = e.createElement("span");
            d.textContent = u,
            d.style.whiteSpace = "nowrap";
            for (var f = 0, p = Object.keys(c); f < p.length; f++) {
                var m = p[f]
                  , g = c[m];
                g !== void 0 && (d.style[m] = g)
            }
            i[o] = d,
            t.appendChild(e.createElement("br")),
            t.appendChild(d)
        }
        for (var y = 0, x = Object.keys(wu); y < x.length; y++) {
            var o = x[y];
            s[o] = i[o].getBoundingClientRect().width
        }
        return s
    })
}
function s8(e, t) {
    return t === void 0 && (t = 4e3),
    My(function(i, s) {
        var n = s.document
          , r = n.body
          , o = r.style;
        o.width = t + "px",
        o.webkitTextSizeAdjust = o.textSizeAdjust = "none",
        mp() ? r.style.zoom = "" + 1 / s.devicePixelRatio : il() && (r.style.zoom = "reset");
        var a = n.createElement("div");
        return a.textContent = Ey(Array(t / 20 << 0)).map(function() {
            return "word"
        }).join(" "),
        r.appendChild(a),
        e(n, r)
    }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}
var n8 = {
    fonts: hP,
    domBlockers: VP,
    fontPreferences: i8,
    audio: iP,
    screenFrame: IP,
    osCpu: yP,
    languages: bP,
    colorDepth: xP,
    deviceMemory: wP,
    screenResolution: TP,
    hardwareConcurrency: MP,
    timezone: RP,
    sessionStorage: PP,
    localStorage: LP,
    indexedDB: OP,
    openDatabase: DP,
    cpuClass: NP,
    platform: FP,
    plugins: uP,
    canvas: dP,
    touchSupport: _P,
    vendor: BP,
    vendorFlavors: UP,
    cookiesEnabled: GP,
    colorGamut: WP,
    invertedColors: XP,
    forcedColors: YP,
    monochrome: ZP,
    contrast: qP,
    reducedMotion: JP,
    hdr: QP,
    math: t8
};
function r8(e) {
    return Yk(n8, e, [])
}
var o8 = "$ if upgrade to Pro: https://fpjs.dev/pro";
function a8(e) {
    var t = l8(e)
      , i = c8(t);
    return {
        score: t,
        comment: o8.replace(/\$/g, "" + i)
    }
}
function l8(e) {
    if (Iy())
        return .4;
    if (il())
        return gp() ? .5 : .3;
    var t = e.platform.value || "";
    return /^Win/.test(t) ? .6 : /^Mac/.test(t) ? .5 : .7
}
function c8(e) {
    return Cy(.99 + .01 * e, 1e-4)
}
function h8(e) {
    for (var t = "", i = 0, s = Object.keys(e).sort(); i < s.length; i++) {
        var n = s[i]
          , r = e[n]
          , o = r.error ? "error" : JSON.stringify(r.value);
        t += (t ? "|" : "") + n.replace(/([:|\\])/g, "\\$1") + ":" + o
    }
    return t
}
function u8(e) {
    return JSON.stringify(e, function(t, i) {
        return i instanceof Error ? Vk(i) : i
    }, 2)
}
function d8(e) {
    return Hk(h8(e))
}
function f8(e) {
    var t, i = a8(e);
    return {
        get visitorId() {
            return t === void 0 && (t = d8(this.components)),
            t
        },
        set visitorId(s) {
            t = s
        },
        confidence: i,
        components: e,
        version: Sy
    }
}
function p8(e) {
    return e === void 0 && (e = 50),
    Uk(e, e * 2)
}
function m8(e, t) {
    var i = Date.now();
    return {
        get: function(s) {
            return an(this, void 0, void 0, function() {
                var n, r, o;
                return Fs(this, function(a) {
                    switch (a.label) {
                    case 0:
                        return n = Date.now(),
                        [4, e()];
                    case 1:
                        return r = a.sent(),
                        o = f8(r),
                        (t || s?.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: " + o.version + `
userAgent: ` + navigator.userAgent + `
timeBetweenLoadAndGet: ` + (n - i) + `
visitorId: ` + o.visitorId + `
components: ` + u8(r) + "\n```"),
                        [2, o]
                    }
                })
            })
        }
    }
}
function g8() {
    if (!(window.__fpjs_d_m || Math.random() >= .001))
        try {
            var e = new XMLHttpRequest;
            e.open("get", "https://m1.openfpcdn.io/fingerprintjs/v" + Sy + "/npm-monitoring", !0),
            e.send()
        } catch (t) {
            console.error(t)
        }
}
function v8(e) {
    var t = e === void 0 ? {} : e
      , i = t.delayFallback
      , s = t.debug
      , n = t.monitoring
      , r = n === void 0 ? !0 : n;
    return an(this, void 0, void 0, function() {
        var o;
        return Fs(this, function(a) {
            switch (a.label) {
            case 0:
                return r && g8(),
                [4, p8(i)];
            case 1:
                return a.sent(),
                o = r8({
                    debug: s
                }),
                [2, m8(o, s)]
            }
        })
    })
}
let ne = {
    writer: new lR(!1)
}, Bi;
v8().then(e=>e.get()).then(e=>{
    ne.bfp = e.visitorId
}
);
ne.isValid = ()=>Bi && Bi.readyState == WebSocket.OPEN;
ne.connect = e=>{
    if (!ne.bfp) {
        setTimeout(()=>ne.connect(e), 40);
        return
    }
    const t = e[0];
    console.log(`[${t}] connecting...`);
    let i;
    window.location.protocol == "https:" ? i = "wss://" : i = "ws://",
    Bi = new WebSocket(i + `${e[1]}`),
    Bi.binaryType = "arraybuffer",
    Bi.onopen = ()=>_8(t),
    Bi.onclose = ()=>y8(t),
    Bi.onerror = ()=>void 0,
    Bi.onmessage = s=>F8(s)
}
;
ne.WORLD = null;
ne.SELF_ID = null;
ne.SERVER_CODE = null;
ne.PAUSE = null;
ne.INFO = null;
ne.close = (e,t)=>{
    Bi && Bi.close(e, t)
}
;
ne.send = e=>{
    if (ne.isValid())
        if (e)
            for (let t = 0; t < e; t++)
                Bi.send(new Uint8Array(ne.writer._b));
        else
            Bi.send(new Uint8Array(ne.writer._b));
    ne.writer._b = []
}
;
function _8(e) {
    ne.writer.writeStringUTF8(ne.bfp),
    ne.send(),
    console.log(`[${e}] connected.`)
}
function y8(e) {
    console.log(`[${e}] closed.`)
}
function b8(e) {
    const t = e.readUint8();
    U.toggleOpUnit(t)
}
function x8(e) {
    const t = e.readUint8();
    U.specMode = t,
    Je.jumping == 1 && (Je.jumping = 2)
}
function w8(e) {
    const [t,i] = cr(e.readUint16())
      , s = e.readStringUTF8()
      , n = e.readStringUTF8()
      , r = Pi.joinPlayer(t, i, s, n);
    e.readUint8() && (r.bfp = e.readStringUTF8(),
    r.enableChat = e.readUint8() == 1,
    r.notice = e.readStringUTF8()),
    A.emit("waitListUpdate")
}
function T8(e) {
    if (ne.PAUSE)
        return;
    ti.updateRecording();
    const t = e.readUint16();
    Gt.load.push(t);
    const i = performance.now()
      , s = vi(Gt.syncStamp, i, Er());
    function n() {
        const _ = e.readUint16();
        for (let C = 0; C < _; C++) {
            const k = e.readUint32()
              , S = e.readFloat32()
              , T = e.readFloat32()
              , L = e.readUint24();
            Me.preUpdate({
                coef: s,
                time: i,
                id: k,
                x: S,
                y: T,
                mass: L
            })
        }
    }
    function r() {
        const _ = e.readUint16();
        for (let C = 0; C < _; C++) {
            const k = e.readUint32()
              , S = e.readFloat32()
              , T = e.readFloat32();
            Me.preUpdate({
                coef: s,
                time: i,
                id: k,
                x: S,
                y: T
            })
        }
    }
    function o() {
        const _ = e.readUint16();
        for (let C = 0; C < _; C++) {
            const k = e.readUint32()
              , S = e.readUint24();
            Me.preUpdate({
                coef: s,
                time: i,
                id: k,
                mass: S
            })
        }
    }
    function a() {
        const _ = e.readUint16();
        for (let C = 0; C < _; C++) {
            const k = e.readUint32()
              , S = e.readUint32();
            Me.eat(i, k, S)
        }
    }
    function l() {
        const _ = e.readUint16();
        for (let C = 0; C < _; C++) {
            const k = e.readUint32();
            Me.remove(i, k)
        }
    }
    function c(_) {
        const C = e.readUint32()
          , k = e.readFloat32()
          , S = e.readFloat32()
          , T = e.readUint24()
          , L = e.readUint8() << 16 | e.readUint8() << 8 | e.readUint8()
          , [D,O] = cr(e.readUint16());
        Me.create({
            time: i,
            type: _,
            id: C,
            x: k,
            y: S,
            mass: T,
            color: L,
            pid: D,
            cid: O
        })
    }
    function h(_) {
        const C = e.readUint32()
          , k = e.readFloat32()
          , S = e.readFloat32()
          , T = e.readUint24()
          , L = e.readUint8() << 16 | e.readUint8() << 8 | e.readUint8()
          , [D,O] = cr(e.readUint16());
        Me.create({
            time: i,
            type: _,
            id: C,
            x: k,
            y: S,
            mass: T,
            color: L,
            pid: D,
            cid: O
        })
    }
    function u(_) {
        const C = e.readUint32()
          , k = e.readUint32()
          , S = e.readFloat32()
          , T = e.readUint24()
          , L = Me.getEntity(k)
          , [D,O,K,P,N,W,V] = [L.ox, L.oy, L.or, L.nx, L.ny, L.nr, L.color]
          , Q = D + K * Math.cos(S)
          , pt = O + K * Math.sin(S)
          , bt = P + W * Math.cos(S)
          , ct = N + W * Math.sin(S);
        Me.create({
            time: i,
            type: _,
            id: C,
            x: Q,
            y: pt,
            mass: T,
            color: V
        }),
        Me.preUpdate({
            coef: s,
            time: i,
            id: C,
            x: bt,
            y: ct,
            mass: T
        })
    }
    function d(_) {
        const C = e.readUint32()
          , k = e.readFloat32()
          , S = e.readFloat32()
          , T = e.readUint24()
          , L = e.readUint8() << 16 | e.readUint8() << 8 | e.readUint8();
        Me.create({
            time: i,
            type: _,
            id: C,
            x: k,
            y: S,
            mass: T,
            color: L
        })
    }
    function f(_) {
        const C = e.readUint32()
          , k = e.readFloat32()
          , S = e.readFloat32()
          , T = e.readUint24();
        Me.create({
            time: i,
            type: _,
            id: C,
            x: k,
            y: S,
            mass: T
        })
    }
    function p() {
        const _ = []
          , C = e.readUint16();
        for (let k = 0; k < C; k++) {
            const [S,T] = cr(e.readUint16())
              , L = e.readFloat32()
              , D = e.readFloat32()
              , O = e.readUint16();
            _.push([S, T, L, D, O])
        }
        zt.miniMap.drawEntity(_)
    }
    function m() {
        const _ = []
          , C = e.readUint8();
        for (let T = 0; T < C; T++) {
            const [L,D] = cr(e.readUint16())
              , O = e.readFloat32();
            _.push([L, D, O])
        }
        zt.drawLeaderboard(_);
        const k = []
          , S = e.readUint8();
        for (let T = 0; T < S; T++) {
            const L = e.readUint8()
              , D = e.readUint16();
            k.push([L, D])
        }
        zt.drawTeamRankings(k)
    }
    function g() {
        let _ = e.readUint16(), C;
        for (; _ > 0; _--) {
            const k = e.readUint16()
              , S = e.readUint16();
            C = Vt.get(k),
            C && (C.latency = S)
        }
        for (_ = e.readUint8(); _ > 0; _--) {
            const k = e.readUint16()
              , S = k >> 12
              , T = k & 4095;
            A.emit("updateRoomStatus", {
                index: S,
                players: T
            })
        }
    }
    function y() {
        Gt.lastSync = Gt.syncStamp,
        Gt.syncStamp = i,
        Me.sync(),
        zt.miniMap.drawViewport(),
        zt.gameStatus.updateStatus(),
        A.emit("updateVueComp")
    }
    let x = e.readFloat32()
      , v = e.readFloat32();
    for (Cn.preUpdate(x, v, i); ; ) {
        const _ = e.readUint8();
        switch (_) {
        case 110:
            c(_);
            break;
        case 111:
            h(_);
            break;
        case 120:
            u(_);
            break;
        case 121:
        case 131:
            d(_);
            break;
        case 141:
        case 142:
            f(_);
            break;
        case 100:
            p();
            break;
        case 108:
            m();
            break;
        case 244:
            g();
            break
        }
        if (_ <= 31) {
            _ & 1 && n(),
            _ & 2 && r(),
            _ & 4 && o(),
            _ & 8 && a(),
            _ & 16 && l(),
            y();
            break
        }
    }
}
function E8(e) {
    ne.SELF_ID = e.readUint16(),
    ne.SERVER_CODE = e.readStringUTF8();
    const t = e.readStringUTF8();
    Ry(),
    console.log("[Server info]", t, "written in Rust");
    let i = e.readUint8();
    const s = [];
    for (; i > 0; i--) {
        const n = e.readStringUTF8()
          , r = e.readUint8()
          , o = e.readUint8();
        s.push([n, r, o])
    }
    ne.WORLD = s[0][0],
    A.emit("setRooms", s),
    A.emit("sendProfile")
}
function S8(e) {
    ti.state == 2 ? ti.state = 0 : A.emit("initGame"),
    ne.PAUSE = !1;
    let t;
    const i = e.readStringUTF8();
    switch (i) {
    case "Rect":
        {
            t = {
                borderLeft: e.readFloat32(),
                borderRight: e.readFloat32(),
                borderTop: e.readFloat32(),
                borderBottom: e.readFloat32()
            };
            break
        }
    case "Octa":
        {
            t = [];
            for (var s = 0; s < 8; s++) {
                const l = e.readFloat32()
                  , c = e.readFloat32();
                t.push(l, c)
            }
            break
        }
    }
    t.type = i,
    zt.drawMap(t);
    const n = e.readUint16();
    for (let l = 0; l < n; l++) {
        const [c,h] = cr(e.readUint16())
          , u = e.readStringUTF8()
          , d = e.readStringUTF8()
          , f = Pi.joinPlayer(c, h, u, d);
        e.readUint8() && (f.bfp = e.readStringUTF8(),
        f.ping = e.readUint16(),
        f.activity = e.readUint8(),
        f.enableChat = e.readUint8() == 1,
        f.notice = e.readStringUTF8())
    }
    const r = e.readUint16();
    for (let l = 0; l < r; l++) {
        const c = e.readUint8()
          , h = e.readStringUTF8()
          , u = e.readUint8() << 16 | e.readUint8() << 8 | e.readUint8()
          , d = e.readUint16()
          , f = [];
        for (let p = 0; p < d; p++) {
            const m = e.readUint16();
            f.push(m)
        }
        Pi.joinTeam(c, h, u, f)
    }
    let o = [];
    const a = e.readUint8();
    for (let l = 0; l < a; l++) {
        const [c,h] = cr(e.readUint16())
          , u = e.readFloat32();
        o.push([c, h, u])
    }
    zt.drawLeaderboard(o),
    ne.SANDBOX = e.readUint8(),
    ne.DYNAMIC_COLLISION = e.readUint8(),
    ne.MAX_OU = e.readUint8(),
    A.emit("joinSelf", ne.SELF_ID),
    ne.INFO = e.readStringUTF8(),
    A.emit("updateChatState"),
    A.emit("updateWorldInfo"),
    A.emit("receiveChatMsg", {
        type: 4,
        id: 0,
        msg: `ANNOUNCEMENT: 
` + ne.INFO
    })
}
function C8(e) {
    let t;
    const i = e.readStringUTF8();
    switch (i) {
    case "Rect":
        {
            t = {
                borderLeft: e.readFloat32(),
                borderRight: e.readFloat32(),
                borderTop: e.readFloat32(),
                borderBottom: e.readFloat32()
            };
            break
        }
    case "Octa":
        {
            t = [];
            for (var s = 0; s < 8; s++) {
                const n = e.readFloat32()
                  , r = e.readFloat32();
                t.push(n, r)
            }
            break
        }
    }
    t.type = i,
    zt.drawMap(t)
}
function A8(e) {
    const t = e.readUint8()
      , i = e.readStringUTF8()
      , s = e.readUint8() << 16 | e.readUint8() << 8 | e.readUint8();
    Pi.joinTeam(t, i, s)
}
function I8(e) {
    const t = e.readUint16()
      , i = e.readUint8();
    Pi.bindPlayerTeam(t, i)
}
function M8(e) {
    const t = e.readUint16();
    Pi.disconnect(t),
    A.emit("waitListUpdate")
}
function Ry() {
    setTimeout(()=>{
        ne.writer.writeUint8(244),
        ne.send()
    }
    , H.ExtraLatency)
}
function R8(e) {
    const t = e.readUint16()
      , i = Vt.get(t);
    i.enableChat = !0,
    A.emit("waitListUpdate")
}
function k8(e) {
    const t = e.readUint16()
      , i = Vt.get(t);
    i.enableChat = !1,
    A.emit("waitListUpdate")
}
function P8(e) {
    const t = e.readFloat32()
      , i = e.readFloat32()
      , s = e.readUint32()
      , n = e.readUint16()
      , r = Vt.get(n);
    r.block || (A.emit("signalHint", [r, s]),
    Me.create({
        type: 9,
        x: t,
        y: i,
        color: s
    }))
}
function L8(e) {
    const t = e.readUint16();
    Vt.get(t).notice = e.readStringUTF8()
}
function O8(e) {
    const t = e.readUint8()
      , i = e.readUint16()
      , s = e.readStringUTF8();
    let n;
    t == 3 && (n = e.readUint16()),
    A.emit("receiveChatMsg", {
        type: t,
        id: i,
        msg: s,
        toId: n
    })
}
function D8(e) {
    const t = e.readUint16()
      , i = e.readUint8();
    Vt.get(t).activity = i
}
function N8() {
    ne.writer.writeUint8(26).writeUint8(H.EnableChat)
}
A.on("updateChatState", N8);
A.on("sendPlayerNotice", e=>{
    ne.writer.writeUint8(27).writeStringUTF8(e)
}
);
function F8({data: e}) {
    if (e.byteLength === 0) {
        Ar.pong();
        return
    }
    const t = new aR(new DataView(e),0,!1);
    switch (t.readUint8()) {
    case 3:
        setTimeout(()=>{
            b8(t)
        }
        , H.ExtraLatency);
        break;
    case 4:
        x8(t);
        break;
    case 9:
        P8(t);
        break;
    case 10:
        w8(t);
        break;
    case 11:
        setTimeout(()=>{
            T8(t)
        }
        , H.ExtraLatency);
        break;
    case 12:
        setTimeout(()=>{
            S8(t)
        }
        , H.ExtraLatency);
        break;
    case 13:
        C8(t);
        break;
    case 14:
        A8(t);
        break;
    case 15:
        setTimeout(()=>{
            I8(t)
        }
        , H.ExtraLatency);
        break;
    case 16:
        M8(t);
        break;
    case 20:
        R8(t);
        break;
    case 21:
        k8(t);
        break;
    case 22:
        E8(t);
        break;
    case 23:
        L8(t);
        break;
    case 24:
        O8(t);
        break;
    case 31:
        D8(t);
        break;
    case 244:
        Ry();
        break
    }
}
var at = ne;
let zd = null;
const be = {
    FeedNone: ()=>{
        U.state == 1 && (at.writer.writeUint8(1).writeUint8(0),
        at.send())
    }
    ,
    FeedOnce: ()=>{
        U.state == 1 && (at.writer.writeUint8(1).writeUint8(1),
        at.send())
    }
    ,
    MacroFeed: ()=>{
        U.state == 1 && (at.writer.writeUint8(1).writeUint8(2),
        at.send())
    }
    ,
    Split: (e=1)=>{
        U.state == 1 && (U.currentOpUnit.moveMode == 1 && Te.MoveChange.execute().end(),
        e === 4 && !Te.Pause.executed ? (at.writer.writeUint8(8).writeUint8(2).writeUint8(2).writeUint8(2).writeUint8(2),
        at.send()) : (at.writer.writeUint8(2).writeFloat32(zt.mouseX).writeFloat32(zt.mouseY),
        at.send(e)))
    }
    ,
    Pause: ()=>{
        U.pause = !0,
        at.writer.writeUint8(6).writeUint8(1),
        at.send()
    }
    ,
    Scatter: ()=>{
        U.state == 1 && (U.pause = !1,
        at.writer.writeUint8(6).writeUint8(3),
        at.send())
    }
    ,
    CancelPauseOrScatter: ()=>{
        U.pause = !1,
        at.writer.writeUint8(6).writeUint8(2),
        at.send()
    }
    ,
    GetMass: ()=>{
        U.state == 1 && (at.writer.writeUint8(51),
        at.send())
    }
    ,
    LoseMass: ()=>{
        U.state == 1 && (at.writer.writeUint8(52),
        at.send())
    }
    ,
    Clear: ()=>{
        U.state == 1 && (at.writer.writeUint8(53),
        at.send())
    }
    ,
    ToggleOpUnit: ()=>{
        Te.ClickMove.end(),
        Te.MoveChange.end(),
        Te.Shift.end();
        const e = U.nextOpUnitIndex;
        at.writer.writeUint8(3).writeUint8(e | H.StopFeedingAfterSwitchingTab << 4),
        at.send()
    }
    ,
    Signal: ()=>{
        at.writer.writeUint8(9).writeFloat32(zt.mouseX).writeFloat32(zt.mouseY).writeUint32(Be(B.Signal[0])),
        at.send()
    }
    ,
    ClickMove: ()=>{
        if (U.state == 1) {
            if (performance.now() - zd > 240) {
                Te.MoveChange.execute();
                return
            }
            U.pause = !1,
            U.setDestinationPoint(zt.mouseX, zt.mouseY),
            at.writer.writeUint8(6).writeUint8(0).writeFloat32(zt.mouseX).writeFloat32(zt.mouseY),
            at.send()
        }
    }
    ,
    MoveChange: ()=>{
        U.state == 1 && (U.pause = !1,
        U.targetOpUnit.moveMode = 0,
        at.writer.writeUint8(6).writeUint8(0),
        at.send())
    }
    ,
    Shift: ()=>{
        U.state == 1 && (U.pause = !1,
        at.writer.writeUint8(6).writeUint8(4),
        at.send())
    }
}
  , Te = {
    FeedOnce: new $t(be.FeedOnce),
    MacroFeed: new $t(()=>{
        be.MacroFeed()
    }
    ,null,()=>{
        be.FeedNone()
    }
    ),
    Split1X: new $t(be.Split),
    Split2X: new $t(()=>be.Split(2)),
    Split3X: new $t(()=>be.Split(3)),
    Split4X: new $t(()=>be.Split(4)),
    Pause: new $t(()=>{
        const e = Te.Scatter;
        e.executed && clearInterval(e._interval),
        be.Pause()
    }
    ,null,()=>{
        Te.Scatter.executed ? be.Scatter() : Te.TogglePause.executed || be.CancelPauseOrScatter()
    }
    ),
    TogglePause: new $t(()=>{
        if (Te.TogglePause.executed)
            return;
        const e = Te.Pause
          , t = Te.Scatter;
        U.pause && !e.executed ? t.executed ? be.Scatter() : be.CancelPauseOrScatter() : (t.executed && clearInterval(t._interval),
        be.Pause())
    }
    ,null,null),
    Scatter: new $t(()=>{
        Te.Pause.executed || be.Scatter()
    }
    ,null,()=>{
        Te.Pause.executed || be.CancelPauseOrScatter()
    }
    ),
    SwitchTab: new $t(be.ToggleOpUnit),
    AutoSwitchTab: new $t(()=>{
        H.AutoSwitchTab ^= 1,
        A.emit(Ut.AutoSwitchTab)
    }
    ),
    Toggle4TabMode: new $t(()=>{}
    ),
    Respawn: new $t(()=>{}
    ),
    ShowCursorLine: new $t(()=>{
        H.ShowCursorLine ^= 1,
        A.emit(Ut.ShowCursorLine)
    }
    ),
    ShowEnemyHint: new $t(()=>{
        H.ShowEnemyHint ^= 1,
        A.emit(Ut.ShowEnemyHint)
    }
    ),
    ShowMassMarker: new $t(()=>{
        H.ShowMassMarker ^= 1,
        A.emit(Ut.ShowMassMarker)
    }
    ),
    ShowSplitOrderMarker: new $t(()=>{
        H.ShowSplitOrderMarker ^= 1,
        A.emit(Ut.ShowSplitOrderMarker)
    }
    ),
    ShowAutosplitAlert: new $t(()=>{
        H.ShowAutosplitAlert ^= 1,
        A.emit(Ut.ShowAutosplitAlert)
    }
    ),
    IncreaseMass: new $t(be.GetMass,be.GetMass),
    DecreaseMass: new $t(be.LoseMass,be.LoseMass),
    ClearSmallCells: new $t(be.Clear),
    QuickCapture: new $t(()=>{
        A.emit("quickCapture")
    }
    ),
    ShowNick: new $t(()=>{
        H.ShowNick ^= 1,
        A.emit(Ut.ShowNick)
    }
    ),
    ShowMass: new $t(()=>{
        H.ShowMass ^= 1,
        A.emit(Ut.ShowMass)
    }
    ),
    ShowSkin: new $t(()=>{
        H.ShowSkin ^= 1,
        A.emit(Ut.ShowSkin)
    }
    ),
    ShowFood: new $t(()=>{
        H.ShowFood ^= 1,
        A.emit(Ut.ShowFood)
    }
    ),
    ShowMinimap: new $t(()=>{
        H.ShowMinimap ^= 1,
        A.emit(Ut.ShowMinimap)
    }
    ),
    ShowLeaderboard: new $t(()=>{
        H.ShowLeaderboard ^= 1,
        A.emit(Ut.ShowLeaderboard)
    }
    ),
    ShowTeamRankings: new $t(()=>{
        H.ShowTeamRankings ^= 1,
        A.emit(Ut.ShowTeamRankings)
    }
    ),
    ShowPerfStatus: new $t(()=>{
        H.ShowPerfStatus ^= 1,
        A.emit(Ut.ShowPerfStatus)
    }
    ),
    ShowGameStatus: new $t(()=>{
        H.ShowGameStatus ^= 1,
        A.emit(Ut.ShowGameStatus)
    }
    ),
    ShowChatRoom: new $t(()=>{
        H.ShowChatRoom ^= 1,
        A.emit(Ut.ShowChatRoom)
    }
    ),
    ShowReplayBar: new $t(()=>{
        H.ShowReplayBar ^= 1,
        A.emit(Ut.ShowReplayBar)
    }
    ),
    Signal: new $t(be.Signal),
    ClickMove: new $t(be.ClickMove,be.ClickMove,null),
    MoveChange: new $t(be.MoveChange),
    Shift: new $t(be.Shift)
}
  , $a = new $t(e=>{
    if (at.writer.writeUint8(4),
    U.specTarget = null,
    U.state || (U.state = 2),
    e == 0)
        U.specTarget = null,
        at.writer.writeUint16(0);
    else if (e) {
        if (U.specMode = 1,
        U.specTarget = Vt.get(e),
        U.specTarget.isBot) {
            U.specTarget = null,
            at.writer._b = [];
            return
        }
        at.writer.writeUint16(e)
    }
    at.send()
}
);
function B8(e) {
    if (e.repeat || !e.code)
        return;
    const {code: t} = e;
    (t === "Tab" || e.altKey) && e.preventDefault();
    const i = yo(e);
    if (U.state == 1) {
        if (rp.state)
            return;
        Object.entries(bi).forEach(([s,n])=>{
            i == n && Te[s].execute()
        }
        )
    } else
        U.state >= 2 && (i === "Q" ? A.emit("spectate", !0) : Object.entries(bi).forEach(([s,n])=>{
            i == n && Te[s].execute()
        }
        ))
}
function U8(e) {
    const t = yo(e);
    if (U.state == 1) {
        if (rp.state)
            return;
        Object.entries(bi).forEach(([i,s])=>{
            t == s && Te[i].end()
        }
        )
    } else
        U.state >= 2 && Object.entries(bi).forEach(([i,s])=>{
            t == s && Te[i].end()
        }
        )
}
function G8({button: e, timeStamp: t}) {
    const i = tl[e];
    if (U.state === 1 || i == "Signal") {
        if (i == "None")
            return;
        if (i == "ClickMove") {
            const s = t;
            Te.ClickMove.execute(),
            s - zd < 240 && Gt.gamemode == "Poineer" && Te.Shift.execute().end(),
            zd = s
        } else
            Te[i].execute()
    }
}
function H8({button: e}) {
    const t = tl[e];
    if (U.state === 1 || t == "Signal") {
        if (t == "None")
            return;
        t == "ClickMove" ? (Te.ClickMove.end(),
        Te.MoveChange.end(),
        Te.Shift.end()) : Te[t].end()
    }
}
function V8({button: e}) {}
function z8() {
    $a.end();
    for (let e = 0; e < bi.length - 1; e++)
        for (let t = 0; t < bi[e].length; t++)
            bi[e][t].executed && Te[e][t].end()
}
A.on("changeRoom", e=>{
    at.WORLD = e,
    at.writer.writeUint8(23).writeStringUTF8(e),
    at.send()
}
);
A.on("spectate", e=>{
    U.specMode != 2 && e ? $a.execute(0).end() : $a.execute().end()
}
);
A.on("selectSpectate", e=>{
    e == 0 ? $a.execute().end() : $a.execute(e).end()
}
);
A.on("moveCameraTo", ({x: e, y: t})=>{
    U.state >= 2 && (at.writer.writeUint8(4),
    at.writer.writeFloat32(e),
    at.writer.writeFloat32(t),
    at.send())
}
);
A.on("clearEvent", z8);
A.on("toggleOpUnit", be.ToggleOpUnit);
class $8 {
    constructor(t) {
        I(this, "renderer", ma({
            width: innerWidth,
            height: innerHeight,
            antialias: H.Antialias,
            resolution: H.Resolution,
            autoDensity: !0,
            backgroundAlpha: 0,
            hello: !0
        }));
        I(this, "subRenderer", ma({
            width: innerWidth,
            height: innerHeight,
            antialias: H.Antialias,
            resolution: H.Resolution,
            autoDensity: !0,
            backgroundAlpha: 0
        }));
        I(this, "antialias", H.Antialias);
        I(this, "ticker", Gt);
        I(this, "oScale");
        I(this, "nScale");
        I(this, "zoomInterval");
        const i = document.querySelector(t)
          , {main_canvas: s, sub_canvas: n, screen: r} = this;
        ba.position.set(r.width / 2, r.height / 2),
        A.on("focusGameCanvas", ()=>this.focus()),
        A.on(Ut.Resolution, ()=>{
            this.renderer.resolution = H.Resolution,
            this.subRenderer.resolution = H.Resolution,
            this.resize()
        }
        ),
        A.on(Ut.Antialias, ()=>{
            this.antialias != H.Antialias && (this.antialias = H.Antialias,
            o.removeChild(this.main_canvas),
            o.removeChild(this.sub_canvas),
            this.renderer.destroy(!0),
            this.subRenderer.destroy(!0),
            this.renderer = ma({
                width: innerWidth,
                height: innerHeight,
                antialias: H.Antialias,
                resolution: H.Resolution,
                autoDensity: !0,
                backgroundAlpha: 0
            }),
            this.subRenderer = ma({
                width: innerWidth,
                height: innerHeight,
                antialias: H.Antialias,
                resolution: H.Resolution,
                autoDensity: !0,
                backgroundAlpha: 0
            }),
            Gt.renderer = this.renderer,
            Gt.subRenderer = this.subRenderer,
            this.main_canvas.style.position = "absolute",
            this.sub_canvas.style.position = "absolute",
            o.appendChild(this.main_canvas),
            o.appendChild(this.sub_canvas))
        }
        ),
        window.onbeforeunload = ()=>this.destroy(),
        window.addEventListener("resize", ()=>this.resize()),
        document.addEventListener("mousemove", h=>this.mousemove(h));
        const o = document.createElement("div");
        this.view = o,
        o.id = "game_canvas",
        o.addEventListener("wheel", h=>this.zoom(h), {
            passive: !0
        }),
        o.addEventListener("keydown", B8),
        o.addEventListener("keyup", U8),
        o.addEventListener("mousedown", G8),
        o.addEventListener("mouseup", H8),
        o.addEventListener("dblclick", V8),
        o.tabIndex = -1,
        s.style.position = "absolute",
        n.style.position = "absolute",
        Gt.renderer = this.renderer,
        Gt.subRenderer = this.subRenderer,
        o.appendChild(s),
        o.appendChild(n),
        i.appendChild(o),
        this.renderer.hitArea = this.screen,
        this.subRenderer.hitArea = this.screen;
        const a = h=>{
            Gt.eventReaction = !1,
            s.dispatchEvent(new PointerEvent("pointerdown",{
                button: h.button,
                pointerType: h.pointerType,
                clientX: h.clientX,
                clientY: h.clientY,
                isPrimary: !0
            })),
            Gt.eventReaction || A.emit("selectSpectate", 0)
        }
        ;
        n.addEventListener("mousedown", a),
        n.addEventListener("touchstart", a),
        this.delta = 0;
        const l = ()=>{
            requestAnimationFrame(l),
            this.updateUIFrame()
        }
        ;
        l();
        const c = ()=>{
            requestAnimationFrame(c),
            this.updateMainFrame()
        }
        ;
        c()
    }
    get main_canvas() {
        return this.renderer.view
    }
    get screen() {
        return this.renderer.screen
    }
    get sub_canvas() {
        return this.subRenderer.view
    }
    get zoomed() {
        return Math.abs(this.oScale / this.nScale - 1) < 1e-5
    }
    updateMainFrame() {
        let t = performance.now();
        A.emit("sendMousePos", t);
        let i = performance.now()
          , s = 0
          , n = this.delta * s;
        Cn.update_linear(t + n),
        t = performance.now(),
        Me.update_linear(t + n),
        Gt.lastFrame = t,
        this.renderer.render(ba),
        this.delta = (this.delta + performance.now() - t) / 2,
        i = performance.now() - i,
        Gt.statistics.push(i)
    }
    updateUIFrame() {
        let t = performance.now();
        Je.update(t),
        Ar.updatePerf(t),
        this.subRenderer.render(zt),
        U.drawCursorLine()
    }
    focus() {
        this.view.focus()
    }
    resize() {
        this.renderer.resize(innerWidth, innerHeight),
        this.subRenderer.resize(innerWidth, innerHeight),
        zt.resize(this.screen.width / 2, this.screen.height / 2)
    }
    zoom({deltaY: t}) {
        cancelAnimationFrame(this.zoomInterval);
        const i = H.ZoomSpeed * 1.05;
        this.oScale = ba.scale.x,
        this.nScale || (this.nScale = this.oScale);
        const s = this.nScale * .618 + this.oScale * .382;
        this.nScale = t > 0 ? s / i : s * i,
        this.nScale = Math.max(Math.min(this.nScale, 1.35), .0075);
        let n = ()=>{
            if (this.zoomed)
                this.oScale = this.nScale;
            else {
                const r = 1 - .8875 ** (60 / Math.max(Gt.fps, 60));
                this.oScale = Ze(this.oScale, this.nScale, r),
                this.zoomInterval = requestAnimationFrame(n)
            }
            ba.scale.set(this.oScale),
            Me.deploy(),
            U.drawCursorLine()
        }
        ;
        this.zoomInterval = requestAnimationFrame(n)
    }
    mousemove({pageX: t, pageY: i}) {
        ti.state || (t || i) && (Gt.mouseX = t,
        Gt.mouseY = i)
    }
    destroy() {
        zt.destroy(),
        this.renderer.destroy(!0)
    }
}
const j8 = {
    play: "\u5F00\u59CB",
    spectate: "\u89C2\u6218",
    server: "\u670D\u52A1\u5668",
    settings: "\u8BBE\u7F6E",
    servers: ["EA-S", "EA", "NA", "\u672C\u5730"],
    servers2: ["EA", "EA-S", "NA"]
}
  , W8 = {
    play: "\u958B\u59CB",
    spectate: "\u89C0\u6230",
    server: "\u4F3A\u670D\u5668",
    settings: "\u8A2D\u7F6E",
    servers: ["EA-S", "EA", "NA", "\u672C\u5730"],
    servers2: ["EA", "EA-S", "NA"]
}
  , X8 = {
    play: "\u958B\u59CB",
    spectate: "\u89B3\u6226",
    server: "\u30B5\u30FC\u30D0\u30FC",
    settings: "\u8A2D\u5B9A",
    servers: ["EA-S", "EA", "NA", "\u958B\u767A\u8005\u306E\u307F"],
    servers2: ["EA", "EA-S", "NA"]
}
  , Y8 = {
    play: "PLAY",
    spectate: "SPECTATE",
    server: "SERVER",
    settings: "SETTINGS",
    servers: ["EA-S", "EA", "NA", "DEV-ONLY"],
    servers2: ["EA", "EA-S", "NA"]
};
var K8 = {
    zh_CN: j8,
    zh: W8,
    ja: X8,
    en: Y8
};
const Z8 = {
    name: "common-select",
    props: {
        class: String,
        selected: {
            type: Number,
            default: 0
        },
        options: {
            type: Array,
            default: []
        }
    },
    setup(e, {emit: t}) {
        const i = ut(null)
          , s = Ft(()=>e.options.length * -38.5 + "px")
          , n = Ft(()=>e.selected * -38.5 + "px")
          , r = ut("(0deg)");
        let o = !1;
        function a() {
            i.value.classList.contains("open") || i.value.classList.add("open"),
            i.value.style.cssText = "--t:" + s.value,
            r.value = "(180deg)"
        }
        function l() {
            o || (i.value.classList.remove("open"),
            i.value.style.cssText = "--t: 32.5px",
            r.value = "(0deg)",
            A.emit("focusGameCanvas"))
        }
        function c(h) {
            h !== e.selected && (t("change", h),
            o = !0,
            setTimeout(()=>{
                i.value.classList.remove("open"),
                o = !1,
                l()
            }
            , 240))
        }
        return Ve(()=>{
            i.value.classList.add(e.class),
            i.value.style.cssText = "--t: 32.5px"
        }
        ),
        {
            o: s,
            t: n,
            r,
            menu: i,
            open: a,
            close: l,
            change: c
        }
    }
}
  , q8 = e=>(gs("data-v-a7030bc6"),
e = e(),
vs(),
e)
  , J8 = q8(()=>b("path", {
    d: "M533.333333 465.066667L358.4 640 298.666667 580.266667l234.666666-234.666667 234.666667 234.666667-64 59.733333-170.666667-174.933333z"
}, null, -1))
  , Q8 = [J8]
  , tL = ["onClick"];
function eL(e, t, i, s, n, r) {
    return st(),
    nt("div", {
        class: "select-menu",
        ref: "menu",
        tabindex: "-1",
        onBlur: t[1] || (t[1] = (...o)=>s.close && s.close(...o))
    }, [b("div", {
        class: "select-button",
        style: jt({
            "--t": s.t
        }),
        onClick: t[0] || (t[0] = (...o)=>s.open && s.open(...o))
    }, [(st(),
    nt("svg", {
        class: "select-status",
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "25",
        height: "25",
        fill: "#707070",
        style: jt({
            transform: "rotateZ" + s.r
        })
    }, Q8, 4)), b("ul", null, [(st(!0),
    nt(Nt, null, Jt(i.options, (o,a)=>(st(),
    nt("li", {
        key: a
    }, Dt(o), 1))), 128))])], 4), b("ul", null, [(st(!0),
    nt(Nt, null, Jt(i.options, (o,a)=>(st(),
    nt("li", {
        key: a,
        onClick: l=>s.change(a)
    }, Dt(o), 9, tL))), 128))])], 544)
}
var iL = ue(Z8, [["render", eL], ["__scopeId", "data-v-a7030bc6"]]);
const sL = {
    name: "list",
    props: {
        class: String,
        selected: {
            type: Number,
            default: 0
        },
        options: {
            type: Array,
            default: []
        }
    },
    setup(e, {emit: t}) {
        const i = ut(null);
        A.on("updateRoomStatus", ({index: r, players: o})=>{
            e.options[r][1] = o
        }
        );
        function s(r) {
            r !== e.selected && t("change", r)
        }
        function n(r) {
            return r == e.selected ? "rgba(64, 64, 64, 0.75)" : "transparent"
        }
        return Ve(()=>{
            i.value.classList.add(e.class)
        }
        ),
        {
            change: s,
            checkColor: n,
            list: i
        }
    }
}
  , nL = {
    class: "room-list",
    ref: "list"
}
  , rL = {
    class: "list-inner"
}
  , oL = ["onClick"]
  , aL = {
    class: "room-name"
}
  , lL = {
    class: "room-players"
};
function cL(e, t, i, s, n, r) {
    return st(),
    nt("div", nL, [b("ul", rL, [(st(!0),
    nt(Nt, null, Jt(i.options, (o,a)=>(st(),
    nt("li", {
        key: a,
        style: jt({
            "background-color": s.checkColor(a)
        }),
        onClick: l=>s.change(a)
    }, [b("div", aL, Dt(o[0]), 1), b("div", lL, Dt(o[1] + "/" + o[2]), 1)], 12, oL))), 128))])], 512)
}
var hL = ue(sL, [["render", cL], ["__scopeId", "data-v-78404f50"]]);
const uL = {
    name: "multibox-avatar",
    setup(e, {emit: t}) {
        const i = ut(null);
        function s(o, a, l, c) {
            o.onmouseover = ()=>{
                o.isClick || o.classList.add(a)
            }
            ,
            o.onmouseout = ()=>{
                o.isClick || o.classList.remove(a)
            }
            ,
            o.onclick = h=>{
                t("change", o.value),
                Array.from(i.value.children).forEach(u=>{
                    c && u.classList.remove(c),
                    u.classList.remove(a),
                    u.classList.remove(l),
                    u.isClick = !1
                }
                ),
                o.isClick = !0,
                o.classList.add(l)
            }
        }
        function n(o, a, l=0) {
            for (i.value.removeAttribute("style"); i.value.hasChildNodes(); )
                i.value.removeChild(i.value.firstChild);
            switch (o) {
            case 1:
                {
                    i.value.style.backgroundImage = `url(${a[0][1]})`;
                    break
                }
            case 2:
                {
                    const c = document.createElement("div");
                    c.value = 0,
                    c.classList.add("slice"),
                    c.style.position = "static",
                    c.style.left = "0%",
                    c.style.transformOrigin = "50% 100%",
                    c.style.transform = "rotate(-45deg)";
                    const h = document.createElement("div");
                    h.classList.add("slice-content"),
                    h.style.position = "absolute",
                    h.style.left = "0%",
                    h.style.transform = "rotate(45deg)",
                    h.style.backgroundImage = `url(${a[0][1]})`,
                    c.appendChild(h);
                    const u = c.cloneNode();
                    u.value = 1,
                    u.style.transformOrigin = "50% 0%",
                    u.style.transform = "rotate(-45deg)";
                    const d = h.cloneNode();
                    d.style.right = "0%",
                    d.style.bottom = "0%",
                    d.style.backgroundImage = `url(${a[1][1]})`,
                    u.appendChild(d),
                    s(c, "slice-mouseover-1", "slice-click-1", "slice-click-2"),
                    s(u, "slice-mouseover-2", "slice-click-2", "slice-click-1"),
                    i.value.appendChild(c),
                    i.value.appendChild(u);
                    const f = Array.from(i.value.children)[l];
                    f.isClick = !0,
                    f.classList.add(`slice-click-${parseInt(l) + 1}`);
                    break
                }
            case 3:
                {
                    const c = document.createElement("div");
                    c.value = 0,
                    c.classList.add("slice"),
                    c.style.transform = "rotate(30deg) skew(-30deg)";
                    const h = document.createElement("div");
                    h.classList.add("slice-content"),
                    h.style.backgroundImage = `url(${a[0][1]})`,
                    h.style.transform = "rotate(0deg) skew(30deg)",
                    c.appendChild(h);
                    const u = c.cloneNode();
                    u.value = 1,
                    u.style.transform = "rotate(150deg) skew(-30deg)";
                    const d = h.cloneNode();
                    d.style.backgroundImage = `url(${a[1][1]})`,
                    d.style.transform = "skew(30deg) rotate(-150deg)",
                    u.appendChild(d);
                    const f = c.cloneNode();
                    f.value = 2,
                    f.style.transform = "rotate(-90deg) skew(-30deg)";
                    const p = h.cloneNode();
                    p.style.backgroundImage = `url(${a[2][1]})`,
                    p.style.transform = "skew(30deg) rotate(-240deg)",
                    f.appendChild(p),
                    s(c, "slice-mouseover", "slice-click"),
                    s(u, "slice-mouseover", "slice-click"),
                    s(f, "slice-mouseover", "slice-click"),
                    i.value.appendChild(c),
                    i.value.appendChild(u),
                    i.value.appendChild(f);
                    const m = Array.from(i.value.children)[l];
                    m.isClick = !0,
                    m.classList.add("slice-click");
                    break
                }
            case 4:
                {
                    const c = document.createElement("div");
                    c.value = 0,
                    c.classList.add("slice"),
                    c.style.transform = "rotate(45deg)";
                    const h = document.createElement("div");
                    h.classList.add("slice-content"),
                    h.style.backgroundImage = `url(${a[0][1]})`,
                    h.style.transform = "rotate(-45deg)",
                    c.appendChild(h),
                    c.onclick = this.sliceClick;
                    const u = c.cloneNode();
                    u.value = 1,
                    u.style.transform = "rotate(135deg)";
                    const d = h.cloneNode();
                    d.style.backgroundImage = `url(${a[1][1]})`,
                    d.style.transform = "rotate(-135deg)",
                    u.appendChild(d);
                    const f = c.cloneNode();
                    f.value = 2,
                    f.style.transform = "rotate(225deg)";
                    const p = h.cloneNode();
                    p.style.backgroundImage = `url(${a[2][1]})`,
                    p.style.transform = "rotate(-225deg)",
                    f.appendChild(p);
                    const m = c.cloneNode();
                    m.value = 3,
                    m.style.transform = "rotate(315deg)";
                    const g = h.cloneNode();
                    g.style.backgroundImage = `url(${a[3][1]})`,
                    g.style.transform = "rotate(-315deg)",
                    m.appendChild(g),
                    s(c, "slice-mouseover", "slice-click"),
                    s(u, "slice-mouseover", "slice-click"),
                    s(f, "slice-mouseover", "slice-click"),
                    s(m, "slice-mouseover", "slice-click"),
                    i.value.appendChild(c),
                    i.value.appendChild(u),
                    i.value.appendChild(f),
                    i.value.appendChild(m);
                    const y = Array.from(i.value.children)[l];
                    y.isClick = !0,
                    y.classList.add("slice-click");
                    break
                }
            }
        }
        function r(o, a) {
            i.value.hasChildNodes() ? Array.from(i.value.children)[o].firstChild.style.backgroundImage = `url(${a})` : i.value.style.backgroundImage = `url(${a})`
        }
        return {
            avatar: i,
            sliceChange: n,
            contentChange: r
        }
    }
}
  , dL = {
    id: "avatar"
}
  , fL = b("div", {
    id: "avatar-base"
}, null, -1)
  , pL = {
    id: "avatar-inner",
    ref: "avatar"
};
function mL(e, t, i, s, n, r) {
    return st(),
    nt("div", dL, [fL, b("div", pL, null, 512)])
}
var gL = ue(uL, [["render", mL]]);
const xa = ut(null)
  , es = _i(Jf)
  , Fo = ut(Qf)
  , tr = Ft(()=>es[Fo.value])
  , Ni = ut(qf)
  , fr = ut(0)
  , ir = Ft(()=>tr.value[1])
  , ca = Ft(()=>ir.value[fr.value]);
let ky = !0;
function Py(e) {
    ky = !0,
    Fo.value = e,
    fr.value = 0,
    xa.value.sliceChange(Ni.value, ir.value, fr.value),
    localStorage.setItem("profile_index", Fo.value)
}
function l0(e) {
    const t = Fo.value;
    let i = t + e === es.length ? 0 : t + e === -1 ? es.length - 1 : t + e;
    Py(i)
}
const vL = {
    name: "main-menu",
    components: {
        list: hL,
        "common-select": iL,
        "multibox-avatar": gL
    },
    props: {
        menuState: Boolean
    },
    setup(e, {emit: t}) {
        const i = Ft(()=>K8[yi("locale").value])
          , s = ut(0)
          , n = ut(tp)
          , r = ut(1)
          , o = ut(0)
          , a = _i([])
          , l = Ft(()=>(e.menuState || (r.value = 1),
        e.menuState))
          , c = Ft(()=>location.host.split(".")[0].includes("nano") ? i.value.servers2 : i.value.servers)
          , h = Ft(()=>location.host.split(".")[0].includes("nano") ? YM : XM)
          , u = Ft({
            get: ()=>tr.value[0][0],
            set: W=>tr.value[0][0] = W
        })
          , d = Ft({
            get: ()=>tr.value[0][1],
            set: W=>tr.value[0][1] = W
        })
          , f = Ft({
            get: ()=>ca.value[0],
            set: W=>ca.value[0] = W
        })
          , p = Ft({
            get: ()=>ca.value[1],
            set: W=>ca.value[1] = W
        });
        Ft(()=>({
            tag: u.value,
            code: d.value,
            nick: f.value,
            skin: p.value
        }));
        function m(W) {
            fr.value = W
        }
        function g(W) {
            Ni.value = Math.max(Math.min(Ni.value + W, 4), 1),
            Ni.value == 3 && (Ni.value += W),
            xa.value.sliceChange(Ni.value, ir.value, fr.value),
            localStorage.setItem("unit_num", Ni.value)
        }
        function y() {
            localStorage.setItem("profile_data", JSON.stringify(es))
        }
        function x() {
            xa.value.contentChange(fr.value, ca.value[1]),
            localStorage.setItem("profile_data", JSON.stringify(es))
        }
        function v() {
            r.value == 1 ? l0(1) : r.value == 2 && (s.value + 20 <= es.length ? s.value += 10 : s.value = 0)
        }
        function _() {
            r.value == 1 ? l0(-1) : r.value == 2 && (s.value - 10 >= 0 ? s.value -= 10 : s.value = es.length - 10)
        }
        function C(W) {
            r.value == W ? r.value = 1 : (r.value = W,
            A.emit("switchSettings", !1))
        }
        const k = ut(H.HideCode);
        function S() {
            k.value ^= 1,
            H.HideCode = k.value,
            localStorage.setItem("gconfig_data", JSON.stringify(H))
        }
        function T(W) {
            o.value = 0,
            a.length = 0,
            n.value = W,
            localStorage.setItem("server", W),
            A.emit("changeServer", [c.value[W], h.value[W]]),
            A.emit("clearChatMsg", 0)
        }
        function L(W) {
            o.value = W,
            A.emit("changeRoom", a[W][0]),
            A.emit("clearChatMsg", 1)
        }
        function D() {
            if (at.writer.writeUint8(7).writeStringUTF8(u.value).writeStringUTF8(d.value),
            Ni.value == 1) {
                const W = ir.value[0];
                for (let V = 0; V < 4; V++)
                    at.writer.writeUint8(V).writeStringUTF8(W[0]).writeStringUTF8(W[1])
            } else if (Ni.value == 2)
                for (let W = 0; W < 4; W++) {
                    const V = ir.value[W % 2];
                    at.writer.writeUint8(W).writeStringUTF8(V[0]).writeStringUTF8(V[1])
                }
            else
                ir.value.forEach((W,V)=>{
                    at.writer.writeUint8(V).writeStringUTF8(W[0]).writeStringUTF8(W[1])
                }
                );
            at.send(),
            ky && O(tr.value[2])
        }
        function O(W) {
            typeof W < "u" && (tr.value[2] = W),
            localStorage.setItem("profile_data", JSON.stringify(es)),
            at.writer.writeUint8(27).writeStringUTF8(W),
            at.send()
        }
        function K() {
            !at.isValid() || ti.state || (A.emit("sendProfile"),
            U.state !== 1 && (A.emit("play"),
            at.writer.writeUint8(5),
            at.send(),
            U.score = 0),
            localStorage.setItem("profile_data", JSON.stringify(es)),
            localStorage.setItem("profile_index", Fo.value),
            localStorage.setItem("unit_num", Ni.value),
            A.emit("menuHide"),
            A.emit("switchMenu", !1))
        }
        function P() {
            ti.state || (A.emit("sendProfile"),
            U.state !== 1 && (U.state = 2,
            A.emit("spectate")),
            A.emit("menuHide"),
            localStorage.setItem("profile_data", JSON.stringify(es)),
            localStorage.setItem("profile_index", Fo.value),
            localStorage.setItem("unit_num", Ni.value),
            A.emit("switchMenu", !1))
        }
        function N() {
            r.value = 1,
            A.emit("switchSettings")
        }
        return zv(()=>{
            at.connect([c.value[n.value], h.value[n.value]])
        }
        ),
        Ve(()=>{
            const W = ()=>{
                const V = document.activeElement.classList;
                !V.contains("menu-input") && !V.contains("select-menu") && A.emit("focusGameCanvas")
            }
            ;
            document.getElementById("menu").addEventListener("mouseleave", W),
            xa.value.sliceChange(Ni.value, ir.value, fr.value)
        }
        ),
        A.on("setRooms", W=>{
            a.length = 0,
            a.push(...W)
        }
        ),
        A.on("quickStart", ()=>{
            U.state != 1 ? K() : H.AutoSwitchTab || (console.trace(),
            A.emit("toggleOpUnit"))
        }
        ),
        A.on("sendProfile", D),
        A.on("sendNotice", O),
        {
            t: i,
            avatar: xa,
            showMenu: l,
            panelState: r,
            baseProfileListIndex: s,
            serverIndex: n,
            profileData: es,
            roomIndex: o,
            serverOpt: c,
            roomOpt: a,
            tag: u,
            code: d,
            nick: f,
            skin: p,
            avatarChange: m,
            multiboxChange: g,
            setProfileData: y,
            preLoadAvatar: x,
            turnTo: Py,
            pageUp: _,
            pageDown: v,
            setting: N,
            hideCode: k,
            hide: S,
            switchPanel: C,
            changeServer: T,
            changeRoom: L,
            play: K,
            spectate: P
        }
    }
}
  , _L = {
    id: "menu",
    action: "javascript:;"
}
  , yL = {
    id: "avatar-panel"
}
  , bL = ih('<div id="avatar-background"><div id="avatar-rect"></div><div id="avatar-tra"><div id="avatar-tra-border1"></div><div id="avatar-tra-border2"></div></div><div id="avatar-po"></div><div id="avatar-tri"></div></div>', 1)
  , xL = ih('<div id="pl-btn-tri"></div><div id="pl-btn-border1"></div><div id="pl-btn-border2"></div><svg id="profile-list-icon" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><image id="image0" width="200" height="200" x="0" y="0" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADIAgMAAADQNkYNAAAABGdBTUEAALGPC/xhBQAAACBjSFJN AAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAADFBMVEUwkP////8wkP/////v ZWcRAAAAAnRSTlMAAHaTzTgAAAABYktHRAH/Ai3eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJ TUUH5gwHEy0FGs40zgAAAGVJREFUaN7t1rENgDAMRUEvmX2YJ1MiOggJogkyyr3S0rVfjtppi6M6 KBBkaRKnriSaEARBEARBEARBspJeCILcSb9SEARZmLQlJ4/ThyAzybjU5M0NQRAEQRAEmUe++foQ 5CdkBxMfY5eXB6OaAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTEyLTA3VDE5OjQ1OjA0KzAwOjAw dsMd+wAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0xMi0wN1QxOTo0NTowNCswMDowMAeepUcAAAAo dEVYdGRhdGU6dGltZXN0YW1wADIwMjItMTItMDdUMTk6NDU6MDUrMDA6MDD2/I8sAAAAAElFTkSu QmCC"></image></svg>', 4)
  , wL = [xL]
  , TL = b("div", {
    id: "mac-btn-border1"
}, null, -1)
  , EL = ih('<div id="multibox-cut-btn"><div id="mc-btn-tri1"></div><div id="mc-btn-tri2"></div><svg id="multibox-cut-icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="var(--main-theme-color)" transform="translate(0,0.75)"><path d="M117.734106 458.213254 906.212134 458.213254C925.995765 458.213254 959.972 482.279754 959.972 511.97312 959.972 541.666486 925.995765 565.732986 906.212134 565.732986L117.734106 565.732986C97.950475 565.732986 63.97424 541.666486 63.97424 511.97312 63.97424 482.279754 97.950475 458.213254 117.734106 458.213254Z"></path></svg></div>', 1)
  , SL = b("div", {
    id: "ma-btn-tri1"
}, null, -1)
  , CL = b("div", {
    id: "ma-btn-tri2"
}, null, -1)
  , AL = b("svg", {
    id: "multibox-add-icon",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "16",
    height: "16",
    fill: "var(--main-theme-color)",
    transform: "translate(0,-1.5)"
}, [b("path", {
    d: "M911.244448 452.317713 563.184241 452.317713 563.184241 104.274902c0-27.465538-22.254863-49.720402-49.721425-49.720402-27.465538 0-49.719378 22.254863-49.719378 49.720402l0 348.043834L115.715977 452.318736c-27.465538 0-49.720402 22.254863-49.720402 49.721425 0 27.465538 22.254863 49.720402 49.720402 49.720402l348.028485 0 0 348.010065c0 27.467585 22.25384 49.722448 49.719378 49.722448 27.466562 0 49.721425-22.254863 49.721425-49.722448L563.185264 551.760562l348.060207 0c27.466562 0 49.720402-22.254863 49.720402-49.720402C960.96485 474.572576 938.71101 452.317713 911.244448 452.317713z"
})], -1)
  , IL = [SL, CL, AL]
  , ML = b("div", {
    id: "mouse-blocker1"
}, null, -1)
  , RL = b("div", {
    id: "mouse-blocker2"
}, null, -1)
  , kL = {
    class: "center-panel"
}
  , PL = b("div", {
    class: "center-panel-bg"
}, [b("div", {
    class: "center-panel-rect"
}), b("div", {
    class: "center-panel-tra1"
}), b("div", {
    class: "center-panel-tra2"
})], -1)
  , LL = b("div", {
    class: "center-panel-pup-bg"
}, null, -1)
  , OL = b("svg", {
    class: "center-panel-pup-icon",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "23",
    height: "23",
    fill: "var(--main-theme-color)"
}, [b("path", {
    d: "M512.00988746 141.21142578c10.45623779 0 19.24145531 3.50024414 26.37542748 10.71331811l259.5421145 259.55200196C805.03668189 418.58105492 808.63085938 427.33660865 808.63085938 437.84228516c0 10.60949731-3.53485132 19.46887183-10.56994606 26.46936011-7.02026391 7.00543237-15.88952661 10.60949731-26.50891137 10.60949731-10.44140625 0-19.22167969-3.60900903-26.35565185-10.71331811L549.09863305 267.79370094V845.7097168c0 10.19915748-3.62384057 18.94976782-10.89624071 26.16284179-7.23284888 7.31195068-15.97357177 10.91601563-26.2122798 10.91601563-10.23376465 0-18.959656-3.60900903-26.22216796-10.91601563-7.24273705-7.21307397-10.87646508-15.96862769-10.87646508-26.16284179V267.79370094l-196.10760522 196.41906761C271.65484619 471.31213355 262.87951684 474.92114258 252.41833496 474.92114258c-10.61938477 0-19.45898438-3.60900903-26.4990232-10.60949731C218.86444068 457.31115699 215.36914062 448.45178247 215.36914062 437.84228516c0-10.50567651 3.55462623-19.26123023 10.69354248-26.36553931l259.53717042-259.55200196C492.7288816 144.71166992 501.52398658 141.21142578 511.97033691 141.21142578h0.03955055z"
})], -1)
  , DL = [LL, OL]
  , NL = b("div", {
    class: "center-panel-pdown-bg"
}, null, -1)
  , FL = b("svg", {
    class: "center-panel-pdown-icon",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "23",
    height: "23",
    fill: "var(--main-theme-color)"
}, [b("path", {
    d: "M511.99011254 141.21142578c10.23376465 0 18.95471191 3.60900903 26.2122798 10.81713891 7.25262451 7.20812988 10.86657691 15.96862769 10.86657763 26.2666626v577.89129615l196.1619873-196.43884254c7.099365-7.00543237 15.90435815-10.61444068 26.34082031-10.61444139 10.61938477 0 19.43426538 3.50518822 26.51385474 10.51062059 7.04498291 7.10430908 10.54522705 15.96862769 10.54522706 26.57318092 0 10.40679908-3.54473877 19.16235352-10.69354248 26.37542748l-259.55694604 259.48278761C531.23156714 879.28833008 522.44635033 882.78857422 512.00988746 882.78857422c-10.45623779 0-19.24145531-3.50024414-26.3704834-10.71331811l-259.55200195-259.48278761C218.94848656 605.37939453 215.36914062 596.62384009 215.36914062 586.21704102c0-10.60949731 3.52496314-19.46887183 10.56994606-26.57318092C232.99395776 552.63842773 241.82861328 549.12829614 252.44799805 549.12829614c10.42163062 0 19.2167356 3.60900903 26.36553931 10.61444068l196.1125493 196.43884253V178.29522729c0-10.30297828 3.60900903-19.05853271 10.88635255-26.2666626C493.05517555 144.81549073 501.80084252 141.21142578 512.02966309 141.21142578h-0.03955055z"
})], -1)
  , BL = [NL, FL]
  , UL = {
    id: "profile-list-container"
}
  , GL = ["onClick"]
  , HL = b("div", {
    class: "profile-skin-base"
}, null, -1)
  , VL = {
    class: "profile-nick"
}
  , zL = {
    id: "profile-editor"
}
  , $L = b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    fill: "var(--main-theme-color)",
    transform: "translate(3.5,0.5)"
}, [b("path", {
    d: "M227.2 709.7l42.5-42.5c-11.1-8.7-21.9-17.8-32.5-27.1-50-44.5-87.5-89.3-105.9-113.1 18.5-23.8 55.8-68.6 105.9-113.1 64.9-57.6 165.2-126.2 274.7-126.2 39.5 0 77.7 8.9 113.5 23L671 265c-53.8-24.7-107.3-37-159.2-37-57.3 0-116.6 15.2-176.1 45.3-46.6 23.4-93.4 56-139.3 96.8C119.3 438.9 71.6 507 69.5 509.8c-7.1 10.3-7.1 24 0 34.2 2 2.8 49.6 71 127.1 139.8 10 8.8 20.2 17.5 30.6 25.9z m600-339.7c-18.2-16.2-37.2-31.6-56.8-46l97.1-97.2c12.4-12.5 12.4-32.6 0-45.1l2.7 2.7c-6-6-14-9.3-22.5-9.3-8.4 0-16.5 3.3-22.4 9.3L213.7 797.2c-12.4 12.5-12.4 32.6 0 45.1l-2.7-2.7c6 6 14.1 9.3 22.5 9.3s16.5-3.5 22.5-9.4l66-66.1c4.7 2.5 9.3 5 14 7.3 59.5 30 118.8 45.3 176.1 45.3s116.6-15.2 176.1-45.3c46.6-23.4 93.4-56 139.2-96.8 77.3-68.9 125-137 127.1-139.9 7.1-10.3 7.1-24 0-34.2-2.3-2.8-50-70.9-127.3-139.8z m-181 156.9c0 74.2-60.3 134.6-134.3 134.6-22.6 0-44.1-5.7-62.7-15.6L630.7 464c10.2 19.4 15.5 40.9 15.5 62.9z m140.4 113c-64.9 57.6-165.2 126.2-274.7 126.2-51.5 0-100.9-15.2-145.7-37.3l39.4-39.4c31.6 20.8 68.5 31.9 106.3 31.9 107 0 194-87.2 194-194.4 0-39.3-11.7-75.8-31.8-106.5l53.4-53.5c20.5 14.5 40.2 30.1 59.1 46.9 50 44.4 87.5 89.3 105.9 113.1-18.4 23.7-55.9 68.7-105.9 113zM511.9 392.4c9.9 0 19.6 1.1 28.9 3.1l47.3-47.3c-24.1-10.4-49.9-15.6-76.1-15.6-107 0-194 87.2-194 194.4 0 27.1 5.6 52.9 15.6 76.2l47.3-47.3c-2.1-9.5-3.1-19.2-3.1-28.9-0.2-74.3 60-134.6 134.1-134.6z"
})], -1)
  , jL = [$L]
  , WL = ["placeholder", "disabled"]
  , XL = {
    id: "world-panel"
}
  , YL = b("div", {
    id: "world-panel-bg"
}, [b("div", {
    id: "world-panel-rect"
}), b("div", {
    id: "world-panel-tra"
}), b("div", {
    id: "world-panel-po"
})], -1)
  , KL = b("div", {
    id: "menu-play-bg"
}, null, -1)
  , ZL = {
    class: "menu-big-text"
}
  , qL = b("div", {
    id: "menu-setting-bg"
}, null, -1)
  , JL = b("svg", {
    id: "setting-icon",
    width: "24",
    height: "24",
    viewBox: "0 0 16 16",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "var(--main-theme-color)"
}, [b("path", {
    "fill-rule": "evenodd",
    d: "M8.837 1.626c-.246-.835-1.428-.835-1.674 0l-.094.319A1.873 1.873 0 0 1 4.377 3.06l-.292-.16c-.764-.415-1.6.42-1.184 1.185l.159.292a1.873 1.873 0 0 1-1.115 2.692l-.319.094c-.835.246-.835 1.428 0 1.674l.319.094a1.873 1.873 0 0 1 1.115 2.693l-.16.291c-.415.764.42 1.6 1.185 1.184l.292-.159a1.873 1.873 0 0 1 2.692 1.116l.094.318c.246.835 1.428.835 1.674 0l.094-.319a1.873 1.873 0 0 1 2.693-1.115l.291.16c.764.415 1.6-.42 1.184-1.185l-.159-.291a1.873 1.873 0 0 1 1.116-2.693l.318-.094c.835-.246.835-1.428 0-1.674l-.319-.094a1.873 1.873 0 0 1-1.115-2.692l.16-.292c.415-.764-.42-1.6-1.185-1.184l-.291.159A1.873 1.873 0 0 1 8.93 1.945l-.094-.319zm-2.633-.283c.527-1.79 3.065-1.79 3.592 0l.094.319a.873.873 0 0 0 1.255.52l.292-.16c1.64-.892 3.434.901 2.54 2.541l-.159.292a.873.873 0 0 0 .52 1.255l.319.094c1.79.527 1.79 3.065 0 3.592l-.319.094a.873.873 0 0 0-.52 1.255l.16.292c.893 1.64-.902 3.434-2.541 2.54l-.292-.159a.873.873 0 0 0-1.255.52l-.094.319c-.527 1.79-3.065 1.79-3.592 0l-.094-.319a.873.873 0 0 0-1.255-.52l-.292.16c-1.64.893-3.433-.902-2.54-2.541l.159-.292a.873.873 0 0 0-.52-1.255l-.319-.094c-1.79-.527-1.79-3.065 0-3.592l.319-.094a.873.873 0 0 0 .52-1.255l-.16-.292c-.892-1.64.902-3.433 2.541-2.54l.292.159a.873.873 0 0 0 1.255-.52l.094-.319z"
}), b("path", {
    "fill-rule": "evenodd",
    d: "M8 5.754a2.246 2.246 0 1 0 0 4.492 2.246 2.246 0 0 0 0-4.492zM4.754 8a3.246 3.246 0 1 1 6.492 0 3.246 3.246 0 0 1-6.492 0z"
})], -1)
  , QL = [qL, JL]
  , tO = b("div", {
    id: "menu-spec-bg"
}, null, -1)
  , eO = {
    class: "menu-big-text"
};
function iO(e, t, i, s, n, r) {
    const o = se("multibox-avatar")
      , a = se("list")
      , l = se("common-select");
    return ee((st(),
    nt("div", _L, [b("div", yL, [bL, b("div", {
        id: "profile-list-btn",
        onClick: t[0] || (t[0] = c=>s.switchPanel(2))
    }, wL), TL, b("div", {
        id: "mac-btn-border2",
        onClick: t[1] || (t[1] = c=>s.multiboxChange(-1))
    }), EL, b("div", {
        id: "multibox-add-btn",
        onClick: t[2] || (t[2] = c=>s.multiboxChange(1))
    }, IL), ML, RL, X(o, {
        id: "avatar",
        ref: "avatar",
        onChange: s.avatarChange
    }, null, 8, ["onChange"])]), b("div", kL, [PL, b("div", {
        class: "center-panel-pup",
        onClick: t[3] || (t[3] = (...c)=>s.pageUp && s.pageUp(...c))
    }, DL), b("div", {
        class: "center-panel-pdown",
        onClick: t[4] || (t[4] = (...c)=>s.pageDown && s.pageDown(...c))
    }, BL), ee(b("div", UL, [(st(!0),
    nt(Nt, null, Jt(s.profileData.slice(0 + s.baseProfileListIndex, 10 + s.baseProfileListIndex), (c,h)=>(st(),
    nt("div", {
        class: "profile-unit",
        key: h,
        onClick: u=>s.turnTo(h + s.baseProfileListIndex)
    }, [HL, b("div", {
        class: "profile-skin",
        style: jt({
            "background-image": `url(${c[1][0][1]})`
        })
    }, null, 4), b("div", VL, [b("p", null, Dt(c[1][0][0] ? c[1][0][0] : " "), 1)])], 8, GL))), 128))], 512), [[ye, s.panelState == 2]]), ee(b("div", zL, [ee(b("input", {
        id: "menu-tag",
        class: "rounded-0 form-control menu-input",
        type: "text",
        placeholder: "Tag",
        maxlength: "16",
        size: "16",
        "onUpdate:modelValue": t[5] || (t[5] = c=>s.tag = c),
        onChange: t[6] || (t[6] = (...c)=>s.setProfileData && s.setProfileData(...c))
    }, null, 544), [[nr, s.tag]]), ee(b("input", {
        id: "menu-nick",
        class: "rounded-0 form-control menu-input",
        type: "text",
        placeholder: "Nick",
        maxlength: "16",
        size: "16",
        "onUpdate:modelValue": t[7] || (t[7] = c=>s.nick = c),
        onChange: t[8] || (t[8] = (...c)=>s.setProfileData && s.setProfileData(...c))
    }, null, 544), [[nr, s.nick]]), b("div", {
        id: "code-blocker",
        onClick: t[9] || (t[9] = (...c)=>s.hide && s.hide(...c))
    }, jL), ee(b("input", {
        id: "menu-code",
        class: "rounded-0 form-control menu-input",
        type: "text",
        placeholder: s.hideCode ? "" : "Code",
        maxlength: "16",
        size: "16",
        disabled: s.hideCode,
        "onUpdate:modelValue": t[10] || (t[10] = c=>s.code = c),
        onChange: t[11] || (t[11] = (...c)=>s.setProfileData && s.setProfileData(...c))
    }, null, 40, WL), [[nr, s.code]]), ee(b("input", {
        id: "menu-skin",
        class: "rounded-0 form-control menu-input",
        type: "text",
        placeholder: "Skin URL",
        maxlength: "128",
        "onUpdate:modelValue": t[12] || (t[12] = c=>s.skin = c),
        onChange: t[13] || (t[13] = (...c)=>s.preLoadAvatar && s.preLoadAvatar(...c))
    }, null, 544), [[nr, s.skin]])], 512), [[ye, s.panelState == 1]])]), b("div", XL, [YL, X(a, {
        id: "select-gamemode",
        selected: s.roomIndex,
        options: s.roomOpt,
        onChange: s.changeRoom
    }, null, 8, ["selected", "options", "onChange"]), X(l, {
        id: "menu-servers",
        selected: s.serverIndex,
        options: s.serverOpt,
        onChange: s.changeServer
    }, null, 8, ["selected", "options", "onChange"])]), b("div", {
        id: "menu-play",
        onClick: t[14] || (t[14] = (...c)=>s.play && s.play(...c))
    }, [KL, b("div", ZL, Dt(s.t.play), 1)]), b("div", {
        id: "menu-setting",
        onClick: t[15] || (t[15] = (...c)=>s.setting && s.setting(...c))
    }, QL), b("div", {
        id: "menu-spec",
        onClick: t[16] || (t[16] = (...c)=>s.spectate && s.spectate(...c))
    }, [tO, b("div", eO, Dt(s.t.spectate), 1)])], 512)), [[ye, s.showMenu]])
}
var sO = ue(vL, [["render", iO]]);
const nO = {
    content: [[["\u961F\u6807", "\u9690\u85CF", "\u666E\u901A", "\u53CC\u884C"], "\u540D\u5B57", "\u8D28\u91CF", "\u76AE\u80A4", "\u98DF\u7269", ["\u523A\u7403\u98CE\u683C", "\u5C16\u9510", "\u5706\u5F62"], "\u5149\u6807\u7EBF", "\u654C\u6211\u533A\u5206", "\u8D28\u91CF\u6307\u793A", "\u5206\u88C2\u987A\u5E8F\u6307\u793A", "\u81EA\u52A8\u5206\u88C2\u63D0\u793A", ["\u5C04\u523A\u63D0\u793A", "\u5173\u95ED", "\u6570\u5B57", "\u586B\u5145"]], [["\u52A8\u753B\u5EF6\u8FDF", "50", "275", "1"], ["\u7F51\u7EDC\u5EF6\u8FDF", "0", "80", "1"], ["\u89C6\u91CE\u5EF6\u8FDF", "100", "800", "5"], ["\u7F29\u653E\u901F\u5EA6", "1.05", "1.40", "0.01"], "\u663E\u73B0", "\u6D88\u5931", "\u541E\u566C"], [["\u753B\u9762\u8D28\u91CF", "50", "800", "5"], ["\u5206\u8FA8\u7387", "0.75", "2", "0.05"], "\u6297\u952F\u9F7F", "\u7EB9\u7406\u6620\u5C04"], [["\u5FEB\u901F\u5F55\u5236\u65F6\u957F", "0", "60", "5"], "\u53CC\u5F00\u81EA\u52A8\u5207\u6362", "\u53CC\u5F00\u5207\u6362\u65F6\u4E2D\u65AD\u5410\u7403", "\u663E\u793A\u83DC\u5355\u65F6\u505C\u6B62\u79FB\u52A8", "\u6B7B\u4EA1\u663E\u793A\u83DC\u5355", "\u7A33\u5B9A\u89C2\u6218\u955C\u5934"], ["\u5C0F\u5730\u56FE", "\u6392\u884C\u699C", "\u961F\u4F0D\u6392\u884C", "\u6027\u80FD\u72B6\u6001", "\u6E38\u620F\u72B6\u6001", "\u804A\u5929\u5BA4", "\u56DE\u653E\u9762\u677F", ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"], ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"], ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"], ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"], ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"], "\u81EA\u52A8\u9690\u85CF"]],
    display: {
        name: "\u663E\u793A",
        divide: {
            basic: "\u57FA\u7840",
            assistance: "\u8F85\u52A9",
            importance: "\u91CD\u8981",
            animation: "\u52A8\u753B"
        }
    },
    graphics: {
        name: "\u56FE\u50CF",
        divide: {
            basic: "\u57FA\u7840"
        }
    },
    HUD: {
        divide: {
            display: "\u663E\u793A",
            minimap: "\u5C0F\u5730\u56FE",
            leaderboard: "\u6392\u884C\u699C",
            teamRanking: "\u961F\u4F0D\u6392\u884C",
            performance: "\u6027\u80FD\u72B6\u6001",
            gamestatus: "\u6E38\u620F\u72B6\u6001",
            chatroom: "\u804A\u5929\u5BA4"
        }
    },
    gameplay: {
        name: "\u6E38\u620F",
        divide: {
            basic: "\u57FA\u790E",
            language: "\u8BED\u8A00"
        }
    }
}
  , rO = {
    content: [[["\u968A\u6A19", "\u96B1\u85CF", "\u666E\u901A", "\u96D9\u884C"], "\u540D\u5B57", "\u8CEA\u91CF", "\u76AE\u819A", "\u98DF\u7269", ["\u523A\u7403\u98A8\u683C", "\u5C16\u92B3", "\u5713\u5F62"], "\u5149\u6A19\u7DDA", "\u6575\u6211\u5340\u5206", "\u8CEA\u91CF\u6307\u793A", "\u5206\u88C2\u9806\u5E8F\u6307\u793A", "\u81EA\u52D5\u5206\u88C2\u63D0\u793A", ["\u5C04\u523A\u63D0\u793A", "\u95DC\u9589", "\u6578\u5B57", "\u586B\u5145"]], [["\u52D5\u756B\u5EF6\u9072", "50", "275", "1"], ["\u7DB2\u7D61\u5EF6\u9072", "0", "80", "1"], ["\u8996\u91CE\u5EF6\u9072", "100", "800", "5"], ["\u7E2E\u653E\u901F\u5EA6", "1.05", "1.40", "0.01"], "\u986F\u73FE", "\u6D88\u5931", "\u541E\u566C"], [["\u756B\u9762\u8CEA\u91CF", "50", "800", "5"], ["\u89E3\u6790\u5EA6", "0.75", "2", "0.05"], "\u6297\u92F8\u9F52", "\u7D0B\u7406\u6620\u5C04"], [["\u5FEB\u901F\u9304\u88FD\u6642\u9577", "0", "60", "5"], "\u96D9\u958B\u81EA\u52D5\u5207\u63DB", "\u96D9\u958B\u5207\u63DB\u6642\u4E2D\u65B7\u5410\u7403", "\u986F\u793A\u9078\u55AE\u6642\u505C\u6B62\u79FB\u52D5", "\u6B7B\u4EA1\u986F\u793A\u9078\u55AE", "\u7A69\u5B9A\u89C0\u6230\u93E1\u982D"], ["\u5C0F\u5730\u5716", "\u6392\u884C\u699C", "\u968A\u4F0D\u6392\u884C", "\u6027\u80FD\u72C0\u614B", "\u904A\u6232\u72C0\u614B", "\u804A\u5929\u5BA4", "\u56DE\u653E\u9762\u677F", ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"], ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"], ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"], ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"], ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"], "\u81EA\u52D5\u96B1\u85CF"]],
    display: {
        name: "\u986F\u793A",
        divide: {
            basic: "\u57FA\u790E",
            assistance: "\u8F14\u52A9",
            importance: "\u91CD\u8981",
            animation: "\u52D5\u756B"
        }
    },
    graphics: {
        name: "\u5716\u50CF",
        divide: {
            basic: "\u57FA\u790E"
        }
    },
    HUD: {
        divide: {
            display: "\u986F\u793A",
            minimap: "\u5C0F\u5730\u5716",
            leaderboard: "\u6392\u884C\u699C",
            teamRanking: "\u968A\u4F0D\u6392\u884C",
            performance: "\u6027\u80FD\u72C0\u614B",
            gamestatus: "\u904A\u6232\u72C0\u614B",
            chatroom: "\u804A\u5929\u5BA4"
        }
    },
    gameplay: {
        name: "\u904A\u6232",
        divide: {
            basic: "\u57FA\u790E",
            language: "\u8A9E\u8A00"
        }
    }
}
  , oO = {
    content: [[["\u30BF\u30B0", "\u96A0\u3059", "\u901A\u5E38", "\u4E8C\u884C"], "\u540D\u524D", "\u8CEA\u91CF", "\u30B9\u30AD\u30F3", "\u98DF\u7269", ["\u68D8\u306E\u69D8\u5F0F", "\u92ED\u3044", "\u5186\u5F62"], "\u30AB\u30FC\u30BD\u30EB\u7DDA", "\u6575\u5473\u65B9\u533A\u5225", "\u8CEA\u91CF\u30DE\u30FC\u30AB\u30FC", "\u5206\u88C2\u9806\u5E8F\u30DE\u30FC\u30AB\u30FC", "\u81EA\u7136\u5206\u88C2\u30A2\u30E9\u30FC\u30C8", ["\u68D8\u6253\u3061\u30D2\u30F3\u30C8", "\u7121\u3057", "\u6570", "\u6E80\u305F\u3059"]], [["\u88DC\u9593\u9045\u5EF6", "50", "275", "1"], ["\u8FFD\u52A0\u30EC\u30A4\u30C6\u30F3\u30B7", "0", "80", "1"], ["\u30AB\u30E1\u30E9\u9045\u5EF6", "100", "800", "5"], ["\u30BA\u30FC\u30E0\u901F\u5EA6", "1.05", "1.40", "0.01"], "\u51FA\u73FE", "\u6D88\u5931", "\u5438\u53CE"], [["\u753B\u8CEA", "50", "800", "5"], ["\u89E3\u50CF\u5EA6", "0.75", "2", "0.05"], "\u30A2\u30F3\u30C1\u30A8\u30A4\u30EA\u30A2\u30B9", "\u30DF\u30C3\u30D7\u30DE\u30C3\u30D7"], [["\u30AD\u30E3\u30D7\u30C1\u30E3\u6642\u9593", "0", "60", "5"], "\u30BF\u30D6\u81EA\u52D5\u5207\u66FF", "\u30BF\u30D6\u5207\u66FF\u5F8C\u990C\u767A\u5C04\u505C\u6B62", "\u30E1\u30CB\u30E5\u30FC\u8868\u793A\u5F8C\u505C\u6B62", "\u6B7B\u4EA1\u5F8C\u30E1\u30CB\u30E5\u30FC\u8868\u793A", "\u5B89\u5B9A\u5316\u89B3\u6226\u30AB\u30E1\u30E9"], ["\u30DF\u30CB\u30DE\u30C3\u30D7", "\u30EA\u30FC\u30C0\u30FC\u30DC\u30FC\u30C9", "\u30C1\u30FC\u30E0\u30E9\u30F3\u30AD\u30F3\u30B0", "\u6027\u80FD\u72B6\u614B", "\u30B2\u30FC\u30E0\u72B6\u614B", "\u30C1\u30E3\u30C3\u30C8\u30EB\u30FC\u30E0", "\u30EA\u30D7\u30EC\u30A4\u30D0\u30FC", ["\u30B5\u30A4\u30BA", "0.75", "1.25", "0.05"], ["\u30B5\u30A4\u30BA", "0.75", "1.25", "0.05"], ["\u30B5\u30A4\u30BA", "0.75", "1.25", "0.05"], ["\u30B5\u30A4\u30BA", "0.75", "1.25", "0.05"], ["\u30B5\u30A4\u30BA", "0.75", "1.25", "0.05"], "\u81EA\u52D5\u3067\u96A0\u3059"]],
    display: {
        name: "\u8868\u793A",
        divide: {
            basic: "\u57FA\u672C",
            assistance: "\u30A2\u30B7\u30B9\u30BF\u30F3\u30B9",
            importance: "\u91CD\u8981",
            animation: "\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3"
        }
    },
    graphics: {
        name: "\u30B0\u30E9\u30D5\u30A3\u30C3\u30AF",
        divide: {
            basic: "\u57FA\u672C"
        }
    },
    HUD: {
        divide: {
            display: "\u8868\u793A",
            minimap: "\u30DF\u30CB\u30DE\u30C3\u30D7",
            leaderboard: "\u30EA\u30FC\u30C0\u30FC\u30DC\u30FC\u30C9",
            teamRanking: "\u30C1\u30FC\u30E0\u30E9\u30F3\u30AD\u30F3\u30B0",
            performance: "\u30D1\u30D5\u30A9\u30FC\u30DE\u30F3\u30B9\u72B6\u614B",
            gamestatus: "\u30B2\u30FC\u30E0\u72B6\u614B",
            chatroom: "\u30C1\u30E3\u30C3\u30C8\u30EB\u30FC\u30E0"
        }
    },
    gameplay: {
        name: "\u30B2\u30FC\u30E0",
        divide: {
            basic: "\u57FA\u672C",
            language: "\u8A00\u8A9E"
        }
    }
}
  , aO = {
    content: [[["Tag", "Hide", "Normal", "Parallel"], "Nick", "Mass", "Skin", "Food", ["Virus Style", "Sharp", "Round"], "Cursor Line", "Enemy Hint", "Mass Marker", "Split Order Marker", "Autosplit Alert", ["Shooting Hint", "Off", "Num", "Fill"]], [["Animation Delay", "50", "275", "1"], ["Extra Latency", "0", "80", "1"], ["Camera Delay", "100", "800", "5"], ["Zoom Speed", "1.05", "1.40", "0.01"], "Appearance Animation", "Disappearance Animation", "Absorption Animation"], [["Quality", "50", "800", "5"], ["Resolution", "0.75", "2", "0.05"], "Antialias", "Mipmap"], [["Capture Time", "0", "60", "5"], "Auto Switch Tab", "Stop Feeding After Switching Tab", "Pause After Opening Menu", "Show Menu After Death", "Stable Spectating Camera"], ["Minimap", "Leaderboard", "Team Rankings", "Performance Status", "Game Status", "Chat Room", "Replay Bar", ["Size", "0.75", "1.25", "0.05"], ["Size", "0.75", "1.25", "0.05"], ["Size", "0.75", "1.25", "0.05"], ["Size", "0.75", "1.25", "0.05"], ["Size", "0.75", "1.25", "0.05"], "Auto Hide"]],
    display: {
        name: "DISPLAY",
        divide: {
            basic: "BASIC",
            assistance: "ASSISTANCE",
            importance: "IMPORTANCE",
            animation: "ANIMATION"
        }
    },
    graphics: {
        name: "GRAPHICS",
        divide: {
            basic: "BASIC"
        }
    },
    HUD: {
        divide: {
            display: "DISPLAY",
            minimap: "MINIMAP",
            leaderboard: "LEADERBOARD",
            teamRanking: "TEAM RANKING",
            performance: "PERFORMANCE STATUS",
            gamestatus: "GAME STATUS",
            chatroom: "CHAT ROOM"
        }
    },
    gameplay: {
        name: "GAMEPLAY",
        divide: {
            basic: "BASIC",
            mouse: "MOUSE",
            language: "LANGUAGE"
        }
    }
};
var lO = {
    zh_CN: nO,
    zh: rO,
    ja: oO,
    en: aO
};
const cO = {
    name: "common-select",
    props: {
        class: String,
        selected: {
            type: Number,
            default: 0
        },
        options: {
            type: Array,
            default: []
        }
    },
    setup(e, {emit: t}) {
        const i = ut(null)
          , s = Ft(()=>-1 + e.selected * -37.9625 + "px");
        function n() {
            i.value.classList.contains("open") || i.value.classList.add("open")
        }
        function r() {
            i.value.classList.remove("open")
        }
        function o(a) {
            a !== e.selected && (t("change", a),
            setTimeout(()=>i.value.classList.remove("open"), 350))
        }
        return Ve(()=>i.value.classList.add(e.class)),
        {
            t: s,
            menu: i,
            open: n,
            close: r,
            change: o
        }
    }
}
  , hO = e=>(gs("data-v-1bcab658"),
e = e(),
vs(),
e)
  , uO = {
    "data-menu": ""
}
  , dO = ["value", "selected"]
  , fO = {
    class: "select-button"
}
  , pO = hO(()=>b("em", null, null, -1))
  , mO = ["onClick"];
function gO(e, t, i, s, n, r) {
    return st(),
    nt("div", {
        class: "select-menu rounded-0",
        ref: "menu",
        tabindex: "-1",
        style: jt({
            "--t": s.t
        }),
        onClick: t[0] || (t[0] = (...o)=>s.open && s.open(...o)),
        onBlur: t[1] || (t[1] = (...o)=>s.close && s.close(...o))
    }, [b("select", uO, [(st(!0),
    nt(Nt, null, Jt(i.options, (o,a)=>(st(),
    nt("option", {
        key: a,
        value: a,
        selected: i.selected === a
    }, Dt(o), 9, dO))), 128))]), b("div", fO, [pO, b("ul", null, [(st(!0),
    nt(Nt, null, Jt(i.options, (o,a)=>(st(),
    nt("li", {
        key: a
    }, Dt(o), 1))), 128))])]), b("ul", null, [(st(!0),
    nt(Nt, null, Jt(i.options, (o,a)=>(st(),
    nt("li", {
        key: a,
        onClick: l=>s.change(a)
    }, Dt(o), 9, mO))), 128))])], 36)
}
var vp = ue(cO, [["render", gO], ["__scopeId", "data-v-1bcab658"]]);
const vO = {
    back: "\u8FD4\u56DE"
}
  , _O = {
    back: "\u8FD4\u56DE"
}
  , yO = {
    back: "\u623B\u308B"
}
  , bO = {
    back: "BACK"
};
var xO = {
    zh_CN: vO,
    zh: _O,
    ja: yO,
    en: bO
};
const wO = {
    name: "sub-nav",
    props: {
        tabs: Array
    },
    setup(e, {emit: t}) {
        const i = Ft(()=>xO[yi("locale").value]);
        function s() {
            A.emit("switchSettings")
        }
        function n(r, o) {
            r.forEach(a=>{
                document.getElementById(a.href).classList.remove("show", "active")
            }
            ),
            document.getElementById(r[o].href).classList.add("show", "active"),
            r[o].func && r[o].func()
        }
        return {
            t: i,
            back: s,
            click: n
        }
    }
}
  , TO = {
    class: "nav nav-tabs container-nav"
}
  , EO = ["onClick"];
function SO(e, t, i, s, n, r) {
    return st(),
    nt("nav", TO, [(st(!0),
    nt(Nt, null, Jt(i.tabs, (o,a)=>(st(),
    nt("a", {
        class: Ai(["nav-item nav-link", i.tabs[a].active ? "active" : ""]),
        "data-bs-toggle": "tab",
        key: a,
        onClick: l=>s.click(i.tabs, a)
    }, Dt(i.tabs[a].text), 11, EO))), 128)), b("a", {
        class: "nav-link nav-back",
        onClick: t[0] || (t[0] = (...o)=>s.back && s.back(...o))
    }, Dt(s.t.back), 1)])
}
var _p = ue(wO, [["render", SO], ["__scopeId", "data-v-2aadac40"]]);
const CO = {
    reset: "\u91CD\u7F6E",
    save: "\u4FDD\u5B58"
}
  , AO = {
    reset: "\u91CD\u7F6E",
    save: "\u4FDD\u5B58"
}
  , IO = {
    reset: "\u30EA\u30BB\u30C3\u30C8",
    save: "\u30BB\u30FC\u30D6"
}
  , MO = {
    reset: "RESET",
    save: "SAVE"
};
var RO = {
    zh_CN: CO,
    zh: AO,
    ja: IO,
    en: MO
};
const kO = {
    name: "button-group",
    props: {
        reset: {
            type: Boolean,
            default: !1
        },
        save: {
            type: Boolean,
            default: !1
        }
    },
    setup(e, {emit: t}) {
        const i = Ft(()=>RO[yi("locale").value]);
        function s() {
            t("onReset")
        }
        function n() {
            t("onSave")
        }
        return {
            t: i,
            resetFuc: s,
            saveFuc: n
        }
    }
}
  , PO = {
    class: "fixed-bottom btngroup"
};
function LO(e, t, i, s, n, r) {
    return st(),
    nt("div", PO, [ee(b("button", {
        class: "btn btn-dark",
        onClick: t[0] || (t[0] = (...o)=>s.resetFuc && s.resetFuc(...o))
    }, Dt(s.t.reset), 513), [[ye, i.reset]]), ee(b("button", {
        class: "btn btn-dark",
        onClick: t[1] || (t[1] = (...o)=>s.saveFuc && s.saveFuc(...o))
    }, Dt(s.t.save), 513), [[ye, i.save]])])
}
var yp = ue(kO, [["render", LO], ["__scopeId", "data-v-4b2abf57"]]);
const OO = {
    name: "deviding-line",
    props: {
        name: {
            type: String,
            default: " "
        }
    },
    setup(e) {
        const t = Ft(()=>{
            const s = encodeURIComponent(e.name).match(/%[89ABab]/g);
            return (e.name.length + (s ? s.length : 0)) * 2.8 + 8
        }
        )
          , i = Ft(()=>(100 - t.value) / 2);
        return {
            spanLen: t,
            hrLen: i
        }
    }
}
  , DO = {
    class: "divide"
};
function NO(e, t, i, s, n, r) {
    return st(),
    nt("div", DO, [b("hr", {
        style: jt({
            flex: s.hrLen
        })
    }, null, 4), b("span", {
        style: jt({
            flex: s.spanLen
        })
    }, Dt(i.name), 5), b("hr", {
        style: jt({
            flex: s.hrLen
        })
    }, null, 4)])
}
var bp = ue(OO, [["render", NO], ["__scopeId", "data-v-020771af"]]);
const FO = {
    name: "setting-switch",
    props: {
        name: String,
        val: Number
    },
    setup(e, {emit: t}) {
        const i = ut(null);
        function s() {
            t("changeVal", i.value.checked ? 1 : 0)
        }
        return {
            switchEl: i,
            change: s
        }
    }
}
  , BO = e=>(gs("data-v-5886baf5"),
e = e(),
vs(),
e)
  , UO = {
    class: "switch-row"
}
  , GO = {
    class: "switch-option"
}
  , HO = {
    class: "switch-box"
}
  , VO = {
    class: "switch-label"
}
  , zO = ["checked"]
  , $O = BO(()=>b("span", {
    class: "switch-slider"
}, null, -1));
function jO(e, t, i, s, n, r) {
    return st(),
    nt("div", UO, [b("div", GO, [b("span", null, Dt(i.name), 1)]), b("div", HO, [b("label", VO, [b("input", {
        type: "checkbox",
        ref: "switchEl",
        checked: i.val,
        onChange: t[0] || (t[0] = (...o)=>s.change && s.change(...o))
    }, null, 40, zO), $O])])])
}
var Ly = ue(FO, [["render", jO], ["__scopeId", "data-v-5886baf5"]]);
const WO = {
    name: "setting-radio",
    props: {
        id: String,
        name: String,
        checked: Number,
        options: Array
    },
    setup(e, {emit: t}) {
        function i(s) {
            t("changeVal", Number(s.target.value))
        }
        return {
            change: i
        }
    }
}
  , XO = {
    class: "radio-row"
}
  , YO = {
    class: "radio-name"
}
  , KO = ["id", "value", "checked"]
  , ZO = ["for"];
function qO(e, t, i, s, n, r) {
    return st(),
    nt("div", XO, [b("div", YO, Dt(i.name), 1), (st(!0),
    nt(Nt, null, Jt(i.options, (o,a)=>(st(),
    nt("div", {
        class: "radio-btn",
        key: a
    }, [b("input", {
        type: "radio",
        id: `radio-${i.id}-${a}`,
        value: a,
        checked: i.checked === a,
        onChange: t[0] || (t[0] = (...l)=>s.change && s.change(...l))
    }, null, 40, KO), b("label", {
        for: `radio-${i.id}-${a}`
    }, Dt(o), 9, ZO)]))), 128))])
}
var JO = ue(WO, [["render", qO], ["__scopeId", "data-v-90b973d0"]]);
const QO = {
    props: {
        name: String,
        min: String,
        max: String,
        step: String,
        val: Number
    },
    setup(e, {emit: t}) {
        const i = ut(null)
          , s = ut(null)
          , n = ut(null);
        function r(l) {
            const h = `${(l - e.min) / (e.max - e.min) * 90}%`;
            i.value.style.width = h
        }
        function o() {
            let l = Number(n.value.value);
            /^[0-9]\d*$/.test(l) ? (l = l < e.min ? e.min : l > e.max ? e.max : l,
            a(l)) : n.value.value = s.value.value
        }
        function a(l) {
            t("changeVal", Number(l))
        }
        return Aa(()=>e.val, (l,c)=>r(l)),
        Ve(()=>{
            r(e.val)
        }
        ),
        Pr(()=>{
            r(e.val)
        }
        ),
        {
            selection: i,
            slider: s,
            valEl: n,
            checkStyle: r,
            checkVal: o,
            change: a
        }
    }
}
  , tD = {
    class: "slider-row"
}
  , eD = {
    class: "slider-name"
}
  , iD = {
    class: "slider-input"
}
  , sD = ["value"]
  , nD = {
    class: "slider-box"
}
  , rD = {
    ref: "selection",
    class: "slider-selection"
}
  , oD = {
    class: "slider-track"
}
  , aD = ["min", "max", "step", "value"];
function lD(e, t, i, s, n, r) {
    return st(),
    nt("div", tD, [b("label", eD, Dt(i.name), 1), b("div", iD, [b("input", {
        ref: "valEl",
        type: "text",
        class: "rounded-0 form-control",
        tabindex: "-1",
        value: i.val,
        onBlur: t[0] || (t[0] = (...o)=>s.checkVal && s.checkVal(...o))
    }, null, 40, sD)]), b("div", nD, [b("div", rD, null, 512), b("div", oD, [b("input", {
        ref: "slider",
        class: "slider",
        type: "range",
        min: i.min,
        max: i.max,
        step: i.step,
        value: i.val,
        onInput: t[1] || (t[1] = o=>s.change(o.target.value))
    }, null, 40, aD)])])])
}
var Oy = ue(QO, [["render", lD], ["__scopeId", "data-v-be681c4e"]]);
const cD = {
    name: "gamesetting-pane",
    components: {
        "common-select": vp,
        "sub-nav": _p,
        "btn-group": yp,
        "dividing-line": bp,
        "setting-switch": Ly,
        "setting-radio": JO,
        "setting-slider": Oy
    },
    setup() {
        const e = ut(Vs)
          , t = yi("locale")
          , i = ["\u7B80\u4F53\u4E2D\u6587", "\u7E41\u9AD4\u4E2D\u6587", "\u65E5\u672C\u8A9E", "English"]
          , s = Ft(()=>lO[t.value])
          , n = Ft(()=>[{
            href: "gamesetting-display-tab",
            text: s.value.display.name,
            active: !0
        }, {
            href: "gamesetting-graphics-tab",
            text: s.value.graphics.name
        }, {
            href: "gamesetting-gameplay-tab",
            text: s.value.gameplay.name
        }, {
            href: "gamesetting-hud-tab",
            text: "HUD"
        }])
          , r = new Map;
        let o = 0
          , a = 0;
        const l = s.value.content;
        Object.keys(Rd).forEach(f=>{
            const p = l[o];
            if (!(o >= l.length)) {
                if (a < p.length)
                    r.set(o + "-" + a, f);
                else {
                    if (o++,
                    a = 0,
                    o >= l.length)
                        return;
                    r.set(o + "-" + a, f)
                }
                a++
            }
        }
        );
        const c = (f,p)=>H[r.get(f + "-" + p)];
        function h(f) {
            t.value = Pc[f],
            e.value = f,
            localStorage.setItem("locale", f)
        }
        function u(f, p, m) {
            const g = r.get(f + "-" + p);
            H[g] = m,
            A.emit(Ut[g]),
            localStorage.setItem("gconfig", JSON.stringify(H))
        }
        function d(f) {
            for (let p = 0; p < l[f].length; p++) {
                const m = r.get(f + "-" + p);
                H[m] = Rd[m],
                A.emit(Ut[m])
            }
            localStorage.setItem("gconfig", JSON.stringify(H))
        }
        return {
            tabs: n,
            localeIndex: e,
            localeOpt: i,
            t: s,
            localeChange: h,
            value: c,
            change: u,
            reset: d
        }
    }
}
  , Dy = e=>(gs("data-v-c48775c0"),
e = e(),
vs(),
e)
  , hD = {
    class: "tab-pane active",
    id: "setting-gamesetting"
}
  , uD = {
    class: "tab-content"
}
  , dD = {
    class: "tab-pane active",
    id: "gamesetting-display-tab"
}
  , fD = {
    class: "container-inline"
}
  , pD = {
    class: "container-col"
}
  , mD = {
    class: "container-col"
}
  , gD = {
    class: "tab-pane",
    id: "gamesetting-graphics-tab"
}
  , vD = {
    class: "container-inline"
}
  , _D = {
    class: "container-col"
}
  , yD = Dy(()=>b("div", {
    class: "container-col"
}, null, -1))
  , bD = {
    class: "tab-pane",
    id: "gamesetting-gameplay-tab"
}
  , xD = {
    class: "container-inline"
}
  , wD = {
    class: "container-col"
}
  , TD = {
    class: "container-col"
}
  , ED = {
    class: "tab-pane",
    id: "gamesetting-hud-tab"
}
  , SD = {
    class: "container-inline"
}
  , CD = {
    class: "container-col"
}
  , AD = {
    class: "container-col"
}
  , ID = Dy(()=>b("div", {
    class: "filler"
}, null, -1));
function MD(e, t, i, s, n, r) {
    const o = se("sub-nav")
      , a = se("dividing-line")
      , l = se("setting-radio")
      , c = se("btn-group")
      , h = se("setting-slider")
      , u = se("setting-switch")
      , d = se("common-select");
    return st(),
    nt("div", hD, [X(o, {
        tabs: s.tabs
    }, null, 8, ["tabs"]), b("div", uD, [b("div", dD, [b("div", fD, [b("div", pD, [X(a, {
        name: s.t.display.divide.basic
    }, null, 8, ["name"]), X(l, {
        id: "tag-style",
        name: s.t.content[0][0][0],
        checked: s.value(0, 0),
        options: [s.t.content[0][0][1], s.t.content[0][0][2], s.t.content[0][0][3]],
        onChangeVal: t[0] || (t[0] = f=>s.change(0, 0, f))
    }, null, 8, ["name", "checked", "options"]), (st(),
    nt(Nt, null, Jt(4, (f,p)=>X(Ne("setting-switch"), {
        key: p,
        name: s.t.content[0][p + 1],
        val: s.value(0, p + 1),
        onChangeVal: m=>s.change(0, p + 1, m)
    }, null, 8, ["name", "val", "onChangeVal"])), 64)), X(l, {
        id: "virus-style",
        name: s.t.content[0][5][0],
        checked: s.value(0, 5),
        options: [s.t.content[0][5][1], s.t.content[0][5][2]],
        onChangeVal: t[1] || (t[1] = f=>s.change(0, 5, f))
    }, null, 8, ["name", "checked", "options"]), X(a, {
        name: s.t.display.divide.assistance
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(5, (f,p)=>X(Ne("setting-switch"), {
        key: p + 6,
        name: s.t.content[0][p + 6],
        val: s.value(0, p + 6),
        onChangeVal: m=>s.change(0, p + 6, m)
    }, null, 8, ["name", "val", "onChangeVal"])), 64)), X(l, {
        id: "shoot-hint",
        name: s.t.content[0][11][0],
        checked: s.value(0, 11),
        options: [s.t.content[0][11][1], s.t.content[0][11][2], s.t.content[0][11][3]],
        onChangeVal: t[2] || (t[2] = f=>s.change(0, 11, f))
    }, null, 8, ["name", "checked", "options"])]), b("div", mD, [X(a, {
        name: s.t.display.divide.importance
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(4, (f,p)=>X(Ne("setting-slider"), {
        key: p,
        name: s.t.content[1][p][0],
        min: s.t.content[1][p][1],
        max: s.t.content[1][p][2],
        step: s.t.content[1][p][3],
        val: s.value(1, p),
        onChangeVal: m=>s.change(1, p, m)
    }, null, 8, ["name", "min", "max", "step", "val", "onChangeVal"])), 64)), X(a, {
        name: s.t.display.divide.animation
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(3, (f,p)=>X(Ne("setting-switch"), {
        key: p + 4,
        name: s.t.content[1][p + 4],
        val: s.value(1, p + 4),
        onChangeVal: m=>s.change(1, p + 4, m)
    }, null, 8, ["name", "val", "onChangeVal"])), 64))])]), X(c, {
        reset: !0,
        onOnReset: t[3] || (t[3] = f=>(s.reset(0),
        s.reset(1)))
    })]), b("div", gD, [b("div", vD, [b("div", _D, [X(a, {
        name: s.t.graphics.divide.basic
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[2][0][0],
        min: s.t.content[2][0][1],
        max: s.t.content[2][0][2],
        step: s.t.content[2][0][3],
        val: s.value(2, 0),
        onChangeVal: t[4] || (t[4] = f=>s.change(2, 0, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), X(h, {
        name: s.t.content[2][1][0],
        min: s.t.content[2][1][1],
        max: s.t.content[2][1][2],
        step: s.t.content[2][1][3],
        val: s.value(2, 1),
        onChangeVal: t[5] || (t[5] = f=>s.change(2, 1, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), (st(),
    nt(Nt, null, Jt(2, (f,p)=>X(Ne("setting-switch"), {
        key: p + 4,
        name: s.t.content[2][p + 2],
        val: s.value(2, p + 2),
        onChangeVal: m=>s.change(2, p + 2, m)
    }, null, 8, ["name", "val", "onChangeVal"])), 64))]), yD]), X(c, {
        reset: !0,
        onOnReset: t[6] || (t[6] = f=>s.reset(2))
    })]), b("div", bD, [b("div", xD, [b("div", wD, [X(a, {
        name: s.t.gameplay.divide.basic
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[3][0][0],
        min: s.t.content[3][0][1],
        max: s.t.content[3][0][2],
        step: s.t.content[3][0][3],
        val: s.value(3, 0),
        onChangeVal: t[7] || (t[7] = f=>s.change(3, 0, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), (st(),
    nt(Nt, null, Jt(5, (f,p)=>X(u, {
        is: "setting-switch",
        key: p,
        name: s.t.content[3][p + 1],
        val: s.value(3, p + 1),
        onChangeVal: m=>s.change(3, p + 1, m)
    }, null, 8, ["name", "val", "onChangeVal"])), 64))]), b("div", TD, [X(a, {
        name: s.t.gameplay.divide.language
    }, null, 8, ["name"]), X(d, {
        class: Ai("select-lang"),
        selected: s.localeIndex,
        options: s.localeOpt,
        onChange: s.localeChange
    }, null, 8, ["selected", "options", "onChange"])])]), X(c, {
        reset: !0,
        onOnReset: t[8] || (t[8] = f=>s.reset(3))
    })]), b("div", ED, [b("div", SD, [b("div", CD, [X(a, {
        name: s.t.HUD.divide.display
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(7, (f,p)=>X(Ne("setting-switch"), {
        key: p,
        name: s.t.content[4][p],
        val: s.value(4, p),
        onChangeVal: m=>s.change(4, p, m)
    }, null, 8, ["name", "val", "onChangeVal"])), 64))]), b("div", AD, [X(a, {
        name: s.t.HUD.divide.minimap
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[4][7][0],
        min: s.t.content[4][7][1],
        max: s.t.content[4][7][2],
        step: s.t.content[4][7][3],
        val: s.value(4, 7),
        onChangeVal: t[9] || (t[9] = f=>s.change(4, 7, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), X(a, {
        name: s.t.HUD.divide.leaderboard
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[4][8][0],
        min: s.t.content[4][8][1],
        max: s.t.content[4][8][2],
        step: s.t.content[4][8][3],
        val: s.value(4, 8),
        onChangeVal: t[10] || (t[10] = f=>s.change(4, 8, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), X(a, {
        name: s.t.HUD.divide.teamRanking
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[4][9][0],
        min: s.t.content[4][9][1],
        max: s.t.content[4][9][2],
        step: s.t.content[4][9][3],
        val: s.value(4, 9),
        onChangeVal: t[11] || (t[11] = f=>s.change(4, 9, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), X(a, {
        name: s.t.HUD.divide.performance
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[4][10][0],
        min: s.t.content[4][10][1],
        max: s.t.content[4][10][2],
        step: s.t.content[4][10][3],
        val: s.value(4, 10),
        onChangeVal: t[12] || (t[12] = f=>s.change(4, 10, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), X(a, {
        name: s.t.HUD.divide.gamestatus
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[4][11][0],
        min: s.t.content[4][11][1],
        max: s.t.content[4][11][2],
        step: s.t.content[4][11][3],
        val: s.value(4, 11),
        onChangeVal: t[13] || (t[13] = f=>s.change(4, 11, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), X(a, {
        name: s.t.HUD.divide.chatroom
    }, null, 8, ["name"]), X(u, {
        name: s.t.content[4][12],
        val: s.value(4, 12),
        onChangeVal: t[14] || (t[14] = f=>s.change(4, 12, f))
    }, null, 8, ["name", "val"]), ID])]), X(c, {
        reset: !0,
        onOnReset: t[15] || (t[15] = f=>s.reset(4))
    })])])])
}
var RD = ue(cD, [["render", MD], ["__scopeId", "data-v-c48775c0"]]);
const kD = {
    content: [["\u5410\u7403", "\u5FEB\u901F\u5410\u7403", "\u5206\u88C2 1X", "\u5206\u88C2 2X", "\u5206\u88C2 3X", "\u5206\u88C2 4X", "\u505C\u6B62", "\u505C\u6B62(\u5207\u6362)", "\u6563\u5F00", "\u53CC\u5F00\u5207\u6362", "\u53CC\u5F00\u81EA\u52A8\u5207\u6362", "\u56DB\u5F00\u6A21\u5F0F\u5207\u6362", "\u590D\u6D3B", "\u5149\u6807\u7EBF", "\u654C\u6211\u533A\u5206", "\u8D28\u91CF\u6307\u793A", "\u5206\u88C2\u987A\u5E8F\u6307\u793A", "\u81EA\u52A8\u5206\u88C2\u63D0\u793A", "\u589E\u52A0\u8D28\u91CF", "\u51CF\u5C11\u8D28\u91CF", "\u6E05\u7406\u591A\u4F59\u7EC6\u80DE", "\u5FEB\u901F\u5F55\u5236"], ["\u540D\u5B57", "\u8D28\u91CF", "\u76AE\u80A4", "\u98DF\u7269", "\u5C0F\u5730\u56FE", "\u6392\u884C\u699C", "\u961F\u4F0D\u6392\u884C", "\u6027\u80FD\u72B6\u6001", "\u6E38\u620F\u72B6\u6001", "\u804A\u5929\u5BA4", "\u56DE\u653E\u9762\u677F"]],
    gameplay: {
        name: "\u6E38\u620F\u4E2D",
        divide: {
            control: "\u63A7\u5236",
            assistance: "\u8F85\u52A9",
            sandbox: "\u6C99\u76D2",
            other: "\u5176\u4ED6"
        }
    },
    display: {
        name: "\u663E\u793A",
        divide: {
            entity: "\u5B9E\u4F53"
        }
    },
    command: {
        name: "\u6307\u4EE4"
    },
    mouse: {
        name: "\u9F20\u6807",
        content: ["\u5DE6\u952E", "\u4E2D\u952E", "\u53F3\u952E", "\u4FA7\u952E\u4E00", "\u4FA7\u952E\u4E8C"],
        values: ["\u5410\u7403", "\u5FEB\u901F\u5410\u7403", "\u5206\u88C2 1X", "\u5206\u88C2 2X", "\u5206\u88C2 3X", "\u5206\u88C2 4X", "\u505C\u6B62", "\u70B9\u51FB\u79FB\u52A8", "\u4FE1\u53F7", "\u53CC\u5F00\u5207\u6362", "\u589E\u52A0\u8D28\u91CF", "\u51CF\u5C11\u8D28\u91CF", "\u6E05\u7406\u591A\u4F59\u7EC6\u80DE"],
        signalHint: "\u53D1\u9001\u4E86\u4E00\u4E2A\u4FE1\u53F7"
    }
}
  , PD = {
    content: [["\u5410\u7403", "\u5FEB\u901F\u5410\u7403", "\u5206\u88C2 1X", "\u5206\u88C2 2X", "\u5206\u88C2 3X", "\u5206\u88C2 4X", "\u505C\u6B62", "\u505C\u6B62(\u5207\u63DB)", "\u6563\u958B", "\u96D9\u958B\u5207\u63DB", "\u96D9\u958B\u81EA\u52D5\u5207\u63DB", "\u56DB\u958B\u6A21\u5F0F\u5207\u63DB", "\u590D\u6D3B", "\u5149\u6A19\u7DDA", "\u6575\u6211\u5340\u5206", "\u8CEA\u91CF\u6307\u793A", "\u5206\u88C2\u9806\u5E8F\u6307\u793A", "\u81EA\u52D5\u5206\u88C2\u63D0\u793A", "\u589E\u52A0\u8CEA\u91CF", "\u6E1B\u5C11\u8CEA\u91CF", "\u6E05\u7406\u591A\u9918\u7D30\u80DE", "\u5FEB\u901F\u9304\u88FD"], ["\u540D\u5B57", "\u8CEA\u91CF", "\u76AE\u819A", "\u98DF\u7269", "\u5C0F\u5730\u5716", "\u6392\u884C\u699C", "\u968A\u4F0D\u6392\u884C", "\u6027\u80FD\u72C0\u614B", "\u904A\u6232\u72C0\u614B", "\u804A\u5929\u5BA4", "\u56DE\u653E\u9762\u677F"]],
    gameplay: {
        name: "\u904A\u6232\u4E2D",
        divide: {
            control: "\u63A7\u5236",
            assistance: "\u8F14\u52A9",
            sandbox: "\u6C99\u76D2",
            other: "\u5176\u4ED6"
        }
    },
    display: {
        name: "\u986F\u793A",
        divide: {
            entity: "\u5BE6\u9AD4"
        }
    },
    command: {
        name: "\u6307\u4EE4"
    },
    mouse: {
        name: "\u6ED1\u9F20",
        content: ["\u5DE6\u9375", "\u4E2D\u9375", "\u53F3\u9375", "\u5074\u9375\u4E00", "\u5074\u9375\u4E8C"],
        values: ["\u5410\u7403", "\u5FEB\u901F\u5410\u7403", "\u5206\u88C2 1X", "\u5206\u88C2 2X", "\u5206\u88C2 3X", "\u5206\u88C2 4X", "\u505C\u6B62", "\u9EDE\u64CA\u79FB\u52D5", "\u4FE1\u865F", "\u96D9\u958B\u5207\u63DB", "\u589E\u52A0\u8CEA\u91CF", "\u6E1B\u5C11\u8CEA\u91CF", "\u6E05\u7406\u591A\u9918\u7D30\u80DE"],
        signalHint: "\u767C\u9001\u4E86\u4E00\u500B\u4FE1\u865F"
    }
}
  , LD = {
    content: [["\u990C\u5358\u767A", "\u990C\u9023\u5C04", "\u5206\u88C2 1X", "\u5206\u88C2 2X", "\u5206\u88C2 3X", "\u5206\u88C2 4X", "\u305D\u306E\u5834\u3067\u505C\u6B62", "\u305D\u306E\u5834\u3067\u505C\u6B62(\u30C8\u30B0\u30EB)", "\u7D30\u80DE\u3092\u5206\u6563\u3059\u308B", "\u30BF\u30D6\u5207\u66FF", "\u30BF\u30D6\u81EA\u52D5\u5207\u66FF", "4\u30BF\u30D6\u30E2\u30FC\u30C9\u5207\u66FF", "\u518D\u751F", "\u30AB\u30FC\u30BD\u30EB\u7DDA", "\u6575\u5473\u65B9\u533A\u5225", "\u8CEA\u91CF\u30DE\u30FC\u30AB\u30FC", "\u5206\u88C2\u9806\u5E8F\u30DE\u30FC\u30AB\u30FC", "\u81EA\u7136\u5206\u88C2\u30A2\u30E9\u30FC\u30C8", "\u8CEA\u91CF\u5897\u52A0", "\u8CEA\u91CF\u6E1B\u5C11", "\u5C0F\u3055\u3044\u7D30\u80DE\u3092\u6D88\u3059", "\u30AF\u30A4\u30C3\u30AF\u30AD\u30E3\u30D7\u30C1\u30E3"], ["\u540D\u524D", "\u8CEA\u91CF", "\u30B9\u30AD\u30F3", "\u98DF\u7269", "\u30DF\u30CB\u30DE\u30C3\u30D7", "\u30EA\u30FC\u30C0\u30FC\u30DC\u30FC\u30C9", "\u30C1\u30FC\u30E0\u30E9\u30F3\u30AD\u30F3\u30B0", "\u6027\u80FD\u72B6\u614B", "\u30B2\u30FC\u30E0\u72B6\u614B", "\u30C1\u30E3\u30C3\u30C8\u30EB\u30FC\u30E0", "\u30EA\u30D7\u30EC\u30A4\u30D0\u30FC"]],
    gameplay: {
        name: "\u30B2\u30FC\u30E0\u4E2D",
        divide: {
            control: "\u30B3\u30F3\u30C8\u30ED\u30FC\u30EB",
            assistance: "\u30A2\u30B7\u30B9\u30BF\u30F3\u30B9",
            sandbox: "\u30B5\u30F3\u30C9\u30DC\u30C3\u30AF\u30B9",
            other: "\u305D\u306E\u4ED6"
        }
    },
    display: {
        name: "\u8868\u793A",
        divide: {
            entity: "\u5B9F\u4F53"
        }
    },
    command: {
        name: "\u30B3\u30DE\u30F3\u30C9"
    },
    mouse: {
        name: "\u30DE\u30A6\u30B9",
        content: ["\u5DE6\u30DC\u30BF\u30F3", "\u4E2D\u30DC\u30BF\u30F3", "\u53F3\u30DC\u30BF\u30F3", "\u30B5\u30A4\u30C9\u30DC\u30BF\u30F3\u4E00", "\u30B5\u30A4\u30C9\u30DC\u30BF\u30F3\u4E8C"],
        values: ["\u990C\u5358\u767A", "\u990C\u9023\u5C04", "\u5206\u88C2 1X", "\u5206\u88C2 2X", "\u5206\u88C2 3X", "\u5206\u88C2 4X", "\u305D\u306E\u5834\u3067\u505C\u6B62", "\u30AF\u30EA\u30C3\u30AF\u79FB\u52D5", "\u4FE1\u53F7", "\u30BF\u30D6\u5207\u66FF", "\u8CEA\u91CF\u5897\u52A0", "\u8CEA\u91CF\u6E1B\u5C11", "\u5C0F\u3055\u3044\u7D30\u80DE\u3092\u6D88\u3059"],
        signalHint: "\u306F\u4FE1\u53F7\u3092\u9001\u3063\u305F"
    }
}
  , OD = {
    content: [["Feed Once", "Macro Feed", "Split 1X", "Split 2X", "Split 3X", "Split 4X", "Pause", "Pause (Toggle)", "Scatter Cells", "Switch Tab", "Auto Switch Tab", "Switch 4-Tab mode", "Respawn", "Cursor Line", "Enemy Hint", "Mass Marker", "Split Order Marker", "Autosplit Alert", "Increase Mass", "Decrease Mass", "Clear small cells", "Quick Capture"], ["Nick", "Mass", "Skin", "Food", "Minimap", "Leaderboard", "Team Ranking", "Performance Status", "Game Status", "Chat Room", "Replay Bar"]],
    gameplay: {
        name: "GAMEPLAY",
        divide: {
            control: "CONTROL",
            assistance: "ASSISTANCE",
            sandbox: "SANDBOX",
            other: "OTHER"
        }
    },
    display: {
        name: "DISPLAY",
        divide: {
            entity: "ENTITY"
        }
    },
    command: {
        name: "COMMAND"
    },
    mouse: {
        name: "MOUSE",
        content: ["Left Button", "Middle Button", "Right Button", "Side Button \u2160", "Side Button \u2161"],
        values: ["Feed Once", "Macro Feed", "Split 1X", "Split 2X", "Split 3X", "Split 4X", "Pause", "Click Move", "Signal", "Switch Tab", "Increase Mass", "Decrease Mass", "Clear small cells"],
        signalHint: "sent out a signal"
    }
};
var Ny = {
    zh_CN: kD,
    zh: PD,
    ja: LD,
    en: OD
};
const DD = {
    name: "setting-hotkey",
    props: {
        name: String,
        defVal: {
            type: String,
            default: ""
        },
        val: String
    },
    setup(e, {emit: t}) {
        const i = ut(null);
        function s({target: r}) {
            t("focus", r)
        }
        function n() {
            i.value.style.fontSize = i.value.value.indexOf("Num") === 0 || i.value.value.indexOf("Control") === 0 || i.value.value.indexOf("Alt") === 0 ? ".8rem" : "1rem"
        }
        return Ve(()=>n()),
        Pr(()=>n()),
        {
            input: i,
            focus: s
        }
    }
}
  , ND = {
    class: "hotkey-row"
}
  , FD = {
    class: "hotkey-name"
}
  , BD = {
    class: "hotkey-default"
}
  , UD = {
    class: "hotkey-input"
}
  , GD = ["value"];
function HD(e, t, i, s, n, r) {
    return st(),
    nt("div", ND, [b("div", FD, Dt(i.name), 1), b("div", BD, Dt(i.defVal), 1), b("div", UD, [b("input", {
        class: "form-control rounded-0",
        type: "text",
        maxlength: "0",
        ref: "input",
        value: i.val,
        onFocus: t[0] || (t[0] = (...o)=>s.focus && s.focus(...o))
    }, null, 40, GD)])])
}
var VD = ue(DD, [["render", HD], ["__scopeId", "data-v-0f607577"]]);
const zD = {
    name: "command-hotkey",
    props: {
        val: String,
        command: String
    },
    setup(e, {emit: t}) {
        const i = ut(null)
          , s = ut(null);
        function n({target: a}) {
            t("focus", a)
        }
        function r() {
            i.value.style.fontSize = i.value.value.indexOf("Num") === 0 || i.value.value.indexOf("Control") === 0 || i.value.value.indexOf("Alt") === 0 ? ".8rem" : "1rem"
        }
        function o() {
            t("changeVal", s.value.value)
        }
        return Ve(()=>r()),
        Pr(()=>r()),
        {
            keyInput: i,
            commandInput: s,
            focus: n,
            change: o
        }
    }
}
  , $D = {
    class: "hotkey-row"
}
  , jD = {
    class: "hotkey-command"
}
  , WD = ["value"]
  , XD = {
    class: "hotkey-input"
}
  , YD = ["value"];
function KD(e, t, i, s, n, r) {
    return st(),
    nt("div", $D, [b("div", jD, [b("input", {
        class: "form-control rounded-0",
        type: "text",
        maxlength: "64",
        size: "64",
        ref: "commandInput",
        value: i.command,
        onChange: t[0] || (t[0] = (...o)=>s.change && s.change(...o))
    }, null, 40, WD)]), b("div", XD, [b("input", {
        class: "form-control rounded-0",
        type: "text",
        maxlength: "0",
        ref: "keyInput",
        value: i.val,
        onFocus: t[1] || (t[1] = (...o)=>s.focus && s.focus(...o))
    }, null, 40, YD)])])
}
var ZD = ue(zD, [["render", KD], ["__scopeId", "data-v-06928186"]]);
const qD = {
    none: "\u65E0"
}
  , JD = {
    none: "\u7121"
}
  , QD = {
    none: "\u7121\u3057"
}
  , tN = {
    none: "None"
};
var eN = {
    zh_CN: qD,
    zh: JD,
    ja: QD,
    en: tN
};
const iN = {
    name: "setting-select",
    components: {
        "common-select": vp
    },
    props: {
        name: {
            type: String,
            default: ""
        },
        selected: Number,
        options: {
            type: Array,
            default: []
        }
    },
    setup(e, {emit: t}) {
        const i = Ft(()=>eN[yi("locale").value]);
        function s(n) {
            t("changeVal", n)
        }
        return {
            t: i,
            change: s
        }
    }
}
  , sN = {
    class: "select-row"
}
  , nN = {
    class: "select-name"
};
function rN(e, t, i, s, n, r) {
    const o = se("common-select");
    return st(),
    nt("div", sN, [b("div", nN, Dt(i.name), 1), X(o, {
        class: Ai("desc-select"),
        selected: i.selected,
        options: [s.t.none, ...i.options],
        onChange: s.change
    }, null, 8, ["selected", "options", "onChange"])])
}
var oN = ue(iN, [["render", rN], ["__scopeId", "data-v-8576c920"]]);
const aN = {
    name: "hotkey-pane",
    components: {
        "sub-nav": _p,
        "btn-group": yp,
        "dividing-line": bp,
        "setting-hotkey": VD,
        "command-hotkey": ZD,
        "setting-select": oN
    },
    setup() {
        const e = Ft(()=>Ny[yi("locale").value])
          , t = Ft(()=>[{
            href: "hotkey-gameplay-tab",
            text: e.value.gameplay.name,
            active: !0
        }, {
            href: "hotkey-display-tab",
            text: e.value.display.name
        }, {
            href: "hotkey-mouse-tab",
            text: e.value.mouse.name
        }])
          , i = _i({})
          , s = _i(bi)
          , n = _i(tl)
          , r = new Map;
        Object.keys(s).forEach(v=>{
            i[v] = s[v]
        }
        );
        let o = 0
          , a = 0;
        const l = e.value.content;
        Object.keys(bi).forEach(v=>{
            const _ = l[o];
            a < _.length || (o++,
            a = 0),
            r.set(o + "-" + a, v),
            a++
        }
        );
        const c = (v,_)=>i[r.get(v + "-" + _)]
          , h = (v,_)=>sc[r.get(v + "-" + _)]
          , u = (v,_,C)=>i[r.get(v + "-" + _)] = C;
        function d(v, _, C) {
            C.addEventListener("keydown", k=>{
                k.preventDefault();
                const S = yo(k);
                switch (S) {
                case "Escape":
                case "Enter":
                case "NumpadEnter":
                    break;
                case "Backspace":
                    {
                        u(v, _, "");
                        break
                    }
                default:
                    (function() {
                        for (let T = 0; T < 2; T++)
                            for (let L = 0; c(T, L); L++) {
                                const D = v == 0 && _ >= 13 && _ <= 17 || v == 1
                                  , O = T == 0 && L >= 13 && L <= 17 || T == 1;
                                if (!(D && O) && S === c(T, L)) {
                                    u(T, L, "");
                                    return
                                }
                            }
                    }
                    )(),
                    u(v, _, S)
                }
            }
            ),
            C.addEventListener("keyup", ()=>{
                C.blur()
            }
            )
        }
        const f = ["None", "FeedOnce", "MacroFeed", "Split1X", "Split2X", "Split3X", "Split4X", "Pause", "ClickMove", "Signal", "SwitchTab", "IncreaseMass", "DecreaseMass", "ClearSmallCells"]
          , p = v=>f.indexOf(n[v]);
        function m(v, _) {
            n[v] = f[_],
            localStorage.setItem("mouse_map", JSON.stringify(n))
        }
        function g() {
            for (let v = 0; v < 5; v++)
                n[v] = G1[v];
            localStorage.setItem("mouse_map", JSON.stringify(n))
        }
        function y() {
            Object.keys(s).forEach(v=>{
                s[v] = sc[v]
            }
            ),
            Object.keys(i).forEach(v=>{
                i[v] = sc[v]
            }
            ),
            localStorage.setItem("key_map", JSON.stringify(s))
        }
        function x() {
            Object.keys(s).forEach(v=>{
                s[v] = i[v]
            }
            ),
            localStorage.setItem("key_map", JSON.stringify(s))
        }
        return Ve(()=>{
            A.on("hotkeyCheck", ()=>{
                Object.keys(s).forEach(v=>{
                    i[v] = s[v]
                }
                )
            }
            )
        }
        ),
        {
            t: e,
            tabs: t,
            mouseMap: n,
            defVal: h,
            cache: c,
            selected: p,
            setMouse: m,
            resetMouse: g,
            convert: U1,
            focus: d,
            reset: y,
            save: x
        }
    }
}
  , lN = e=>(gs("data-v-042c43d8"),
e = e(),
vs(),
e)
  , cN = {
    class: "tab-pane",
    id: "setting-hotkey"
}
  , hN = {
    class: "tab-content"
}
  , uN = {
    class: "tab-pane active",
    id: "hotkey-gameplay-tab"
}
  , dN = {
    class: "container-inline hotkey-inline"
}
  , fN = {
    class: "container-col"
}
  , pN = {
    class: "container-col"
}
  , mN = lN(()=>b("div", {
    class: "filler"
}, null, -1))
  , gN = {
    class: "tab-pane",
    id: "hotkey-display-tab"
}
  , vN = {
    class: "container-inline hotkey-inline"
}
  , _N = {
    class: "container-col"
}
  , yN = {
    class: "container-col"
}
  , bN = {
    class: "tab-pane",
    id: "hotkey-mouse-tab"
}
  , xN = {
    class: "container-inline hotkey-inline"
}
  , wN = {
    class: "container-col"
}
  , TN = {
    class: "container-col"
};
function EN(e, t, i, s, n, r) {
    const o = se("sub-nav")
      , a = se("dividing-line")
      , l = se("btn-group");
    return st(),
    nt("div", cN, [X(o, {
        tabs: s.tabs
    }, null, 8, ["tabs"]), b("div", hN, [b("div", uN, [b("div", dN, [b("div", fN, [X(a, {
        name: s.t.gameplay.divide.control
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(11, (c,h)=>X(Ne("setting-hotkey"), {
        key: h,
        name: s.t.content[0][h],
        defVal: s.convert(s.defVal(0, h)),
        val: s.convert(s.cache(0, h)),
        onFocus: u=>s.focus(0, h, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64)), (st(),
    nt(Nt, null, Jt(1, (c,h)=>X(Ne("setting-hotkey"), {
        key: h,
        name: s.t.content[0][h + 12],
        defVal: s.convert(s.defVal(0, h + 12)),
        val: s.convert(s.cache(0, h + 12)),
        onFocus: u=>s.focus(0, h + 12, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64))]), b("div", pN, [X(a, {
        name: s.t.gameplay.divide.assistance
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(5, (c,h)=>X(Ne("setting-hotkey"), {
        key: h + 13,
        name: s.t.content[0][h + 13],
        defVal: s.convert(s.defVal(0, h + 13)),
        val: s.convert(s.cache(0, h + 13)),
        onFocus: u=>s.focus(0, h + 13, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64)), X(a, {
        name: s.t.gameplay.divide.sandbox
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(3, (c,h)=>X(Ne("setting-hotkey"), {
        key: h + 18,
        name: s.t.content[0][h + 18],
        defVal: s.convert(s.defVal(0, h + 18)),
        val: s.convert(s.cache(0, h + 18)),
        onFocus: u=>s.focus(0, h + 18, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64)), X(a, {
        name: s.t.gameplay.divide.other
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(1, (c,h)=>X(Ne("setting-hotkey"), {
        key: h + 21,
        name: s.t.content[0][h + 21],
        defVal: s.convert(s.defVal(0, h + 21)),
        val: s.convert(s.cache(0, h + 21)),
        onFocus: u=>s.focus(0, h + 21, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64)), mN])]), X(l, {
        reset: !0,
        save: !0,
        onOnReset: s.reset,
        onOnSave: s.save
    }, null, 8, ["onOnReset", "onOnSave"])]), b("div", gN, [b("div", vN, [b("div", _N, [X(a, {
        name: s.t.display.divide.entity
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(4, (c,h)=>X(Ne("setting-hotkey"), {
        key: h,
        name: s.t.content[1][h],
        defVal: s.convert(s.defVal(1, h)),
        val: s.convert(s.cache(1, h)),
        onFocus: u=>s.focus(1, h, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64))]), b("div", yN, [X(a, {
        name: "HUD"
    }), (st(),
    nt(Nt, null, Jt(7, (c,h)=>X(Ne("setting-hotkey"), {
        key: h + 4,
        name: s.t.content[1][h + 4],
        defVal: s.convert(s.defVal(1, h + 4)),
        val: s.convert(s.cache(1, h + 4)),
        onFocus: u=>s.focus(1, h + 4, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64))])]), X(l, {
        reset: !0,
        save: !0,
        onOnReset: s.reset,
        onOnSave: s.save
    }, null, 8, ["onOnReset", "onOnSave"])]), b("div", bN, [b("div", xN, [b("div", wN, [X(a), (st(),
    nt(Nt, null, Jt(3, (c,h)=>X(Ne("setting-select"), {
        key: h,
        style: jt({
            marginTop: 48 * h + "px"
        }),
        name: s.t.mouse.content[h],
        selected: s.selected(h),
        options: s.t.mouse.values,
        onChangeVal: u=>s.setMouse(h, u)
    }, null, 8, ["style", "name", "selected", "options", "onChangeVal"])), 64))]), b("div", TN, [X(a), (st(),
    nt(Nt, null, Jt(2, (c,h)=>X(Ne("setting-select"), {
        key: h,
        style: jt({
            marginTop: 48 * h + "px"
        }),
        name: s.t.mouse.content[h + 3],
        selected: s.selected(h + 3),
        options: s.t.mouse.values,
        onChangeVal: u=>s.setMouse(h + 3, u)
    }, null, 8, ["style", "name", "selected", "options", "onChangeVal"])), 64))])]), X(l, {
        reset: !0,
        style: {
            zIndex: 0
        },
        onOnReset: t[0] || (t[0] = c=>s.resetMouse())
    })])])])
}
var SN = ue(aN, [["render", EN], ["__scopeId", "data-v-042c43d8"]]);
const CN = {
    content: [["\u5410\u7403", "\u98DF\u7269", "\u7EFF\u523A", "\u7EA2\u523A", "\u6587\u672C", "\u6587\u672C\u63CF\u8FB9", "\u7EC6\u80DE", "\u76AE\u80A4", "\u76AE\u80A4\u586B\u5145", "\u5149\u6807\u7EBF", "\u8D28\u91CF\u6307\u793A", "\u5206\u88C2\u987A\u5E8F\u6307\u793A", "\u81EA\u52A8\u5206\u88C2\u63D0\u793A", "\u76EE\u7684\u5730\u70B9", "\u4FE1\u53F7"], ["\u5750\u6807\u5B57\u4F53", "\u5750\u6807\u7F51\u683C", "\u8FB9\u754C", "\u8FB9\u754C\u53D1\u5149", "\u80CC\u666F\u8272", "\u80CC\u666F\u56FE"], ["\u5750\u6807\u5B57\u4F53", "\u5750\u6807\u7F51\u683C", "\u80CC\u666F\u8272", "\u5B9A\u4F4D\u7EBF", "\u89C6\u91CE", "\u5B9E\u4F53", "\u5B9E\u4F53\u4FE1\u606F", "\u80CC\u666F", "\u80CC\u666F", "\u80CC\u666F"]],
    playerType: ["\u4E2A\u4EBA", "\u961F\u4F0D", "\u654C\u4EBA", "\u6240\u6709"],
    display: {
        name: "\u663E\u793A",
        divide: {
            basic: "\u57FA\u7840",
            player: "\u73A9\u5BB6",
            assistance: "\u8F85\u52A9"
        }
    },
    map: {
        name: "\u5730\u56FE",
        divide: {
            basic: "\u57FA\u7840"
        }
    },
    HUD: {
        divide: {
            minimap: "\u5C0F\u5730\u56FE",
            leaderboard: "\u6392\u884C\u699C",
            teamRankings: "\u961F\u4F0D\u6392\u884C",
            perfPanel: "\u6027\u80FD\u72B6\u6001"
        }
    },
    menu: {
        name: "\u83DC\u5355"
    }
}
  , AN = {
    content: [["\u5410\u7403", "\u98DF\u7269", "\u7DA0\u523A", "\u7D05\u523A", "\u6587\u672C", "\u6587\u672C\u63CF\u908A", "\u7D30\u80DE", "\u76AE\u819A", "\u76AE\u819A\u586B\u5145", "\u5149\u6A19\u7DDA", "\u8CEA\u91CF\u6307\u793A", "\u5206\u88C2\u9806\u5E8F\u6307\u793A", "\u81EA\u52D5\u5206\u88C2\u63D0\u793A", "\u76EE\u7684\u5730\u9EDE", "\u4FE1\u865F"], ["\u5750\u6A19\u5B57\u9AD4", "\u5750\u6A19\u7DB2\u683C", "\u908A\u754C", "\u908A\u754C\u767C\u5149", "\u80CC\u666F\u8272", "\u80CC\u666F\u5716"], ["\u5750\u6A19\u5B57\u9AD4", "\u5750\u6A19\u7DB2\u683C", "\u80CC\u666F\u8272", "\u5B9A\u4F4D\u7DDA", "\u8996\u91CE", "\u5BE6\u9AD4", "\u5BE6\u9AD4\u4FE1\u606F", "\u80CC\u666F", "\u80CC\u666F", "\u80CC\u666F"]],
    playerType: ["\u500B\u4EBA", "\u968A\u4F0D", "\u6575\u4EBA", "\u6240\u6709"],
    display: {
        name: "\u986F\u793A",
        divide: {
            basic: "\u57FA\u790E",
            player: "\u73A9\u5BB6",
            assistance: "\u8F14\u52A9"
        }
    },
    map: {
        name: "\u5730\u5716",
        divide: {
            basic: "\u57FA\u790E"
        }
    },
    HUD: {
        divide: {
            minimap: "\u5C0F\u5730\u5716",
            leaderboard: "\u6392\u884C\u699C",
            teamRankings: "\u968A\u4F0D\u6392\u884C",
            perfPanel: "\u6027\u80FD\u72C0\u614B"
        }
    },
    menu: {
        name: "\u9078\u55AE"
    }
}
  , IN = {
    content: [["\u990C", "\u98DF\u7269", "\u68D8", "\u8D64\u68D8", "\u6587\u5B57", "\u6587\u5B57\u306E\u56F2\u3044", "\u7D30\u80DE", "\u30B9\u30AD\u30F3", "\u30B9\u30AD\u30F3\u3067\u6E80\u305F\u3059", "\u30AB\u30FC\u30BD\u30EB\u7DDA", "\u8CEA\u91CF\u30DE\u30FC\u30AB\u30FC", "\u5206\u88C2\u9806\u5E8F\u30DE\u30FC\u30AB\u30FC", "\u81EA\u7136\u5206\u88C2\u30A2\u30E9\u30FC\u30C8", "\u76EE\u7684\u5730\u70B9", "\u4FE1\u53F7"], ["\u5EA7\u6A19\u30D5\u30A9\u30F3\u30C8", "\u5EA7\u6A19\u30B0\u30EA\u30C3\u30C9", "\u67A0", "\u67A0\u767A\u5149", "\u80CC\u666F", "\u80CC\u666F\u753B\u50CF"], ["\u5EA7\u6A19\u30D5\u30A9\u30F3\u30C8", "\u5EA7\u6A19\u30B0\u30EA\u30C3\u30C9", "\u80CC\u666F", "\u30ED\u30B1\u30FC\u30B7\u30E7\u30F3\u30E9\u30A4\u30F3", "\u8996\u91CE", "\u5B9F\u4F53", "\u5B9F\u4F53\u60C5\u5831", "\u80CC\u666F", "\u80CC\u666F", "\u80CC\u666F"]],
    playerType: ["\u500B\u4EBA", "\u30C1\u30FC\u30E0", "\u6575", "\u5168\u3066"],
    display: {
        name: "\u8868\u793A",
        divide: {
            basic: "\u57FA\u672C",
            player: "\u30D7\u30EC\u30A4\u30E4\u30FC",
            assistance: "\u30A2\u30B7\u30B9\u30BF\u30F3\u30B9"
        }
    },
    map: {
        name: "\u30DE\u30C3\u30D7",
        divide: {
            basic: "\u57FA\u672C"
        }
    },
    HUD: {
        divide: {
            minimap: "\u30DF\u30CB\u30DE\u30C3\u30D7",
            leaderboard: "\u30EA\u30FC\u30C0\u30FC\u30DC\u30FC\u30C9",
            teamRankings: "\u30C1\u30FC\u30E0\u30E9\u30F3\u30AD\u30F3\u30B0",
            perfPanel: "\u6027\u80FD\u72B6\u614B"
        }
    },
    menu: {
        name: "\u30E1\u30CB\u30E5\u30FC"
    }
}
  , MN = {
    content: [["Ejected Cell", "Food", "Virus", "Red Virus", "Text", "Text Stroke", "Cell", "Skin", "Skin Fill", "Cursor Line", "Mass Marker", "Split Order Marker", "Autosplit Alert", "Destination Point", "Signal"], ["Coords Font", "Coords Grid", "Border", "Border Glow", "Background", "Image"], ["Coords Font", "Coords Grid", "Background", "Location Line", "View", "Entity", "Entity Information", "Background", "Background", "Background"]],
    playerType: ["Self", "Team", "Enemy", "All"],
    display: {
        name: "DISPLAY",
        divide: {
            basic: "BASIC",
            player: "PLAYER",
            assistance: "ASSISTANCE"
        }
    },
    map: {
        name: "MAP",
        divide: {
            basic: "BASIC"
        }
    },
    HUD: {
        divide: {
            minimap: "MINIMAP",
            leaderboard: "LEADERBOARD",
            teamRankings: "TEAM RANKING",
            perfPanel: "PERFORMANCE PANEL"
        }
    },
    menu: {
        name: "MENU"
    }
};
var RN = {
    zh_CN: CN,
    zh: AN,
    ja: IN,
    en: MN
};
const kN = {
    name: "picker-button",
    props: {
        name: String
    }
}
  , PN = {
    class: "picker-button"
}
  , LN = {
    class: "btn btn-dark rounded-0"
};
function ON(e, t, i, s, n, r) {
    return st(),
    nt("div", PN, [b("button", LN, Dt(i.name), 1)])
}
var DN = ue(kN, [["render", ON], ["__scopeId", "data-v-6e4feacd"]]);
const NN = {
    default: "\u9ED8\u8BA4",
    size: "\u5927\u5C0F",
    teamColor: "\u4F7F\u7528\u961F\u4F0D\u989C\u8272",
    bgUrl: "\u80CC\u666F\u56FE\u94FE\u63A5"
}
  , FN = {
    default: "\u9ED8\u8A8D",
    size: "\u5927\u5C0F",
    teamColor: "\u4F7F\u7528\u968A\u4F0D\u984F\u8272",
    bgUrl: "\u80CC\u666F\u5716\u93C8\u63A5"
}
  , BN = {
    default: "\u30C7\u30D5\u30A9\u30EB\u30C8",
    size: "\u30B5\u30A4\u30BA",
    teamColor: "\u30C1\u30FC\u30E0\u30AB\u30E9\u30FC",
    bgUrl: "\u80CC\u666F\u306EURL"
}
  , UN = {
    default: "Default",
    size: "Size",
    teamColor: "Use team color",
    bgUrl: "Background Image URL"
};
var GN = {
    zh_CN: NN,
    zh: FN,
    ja: BN,
    en: UN
};
/*!
 * iro.js v5.3.1
 * 2016-2020 James Daniel
 * Licensed under MPL 2.0
 * github.com/jaames/iro.js
 */
var Pe, Dc, Fy, $d, By, An = {}, xp = [], HN = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;
function En(e, t) {
    for (var i in t)
        e[i] = t[i];
    return e
}
function Uy(e) {
    var t = e.parentNode;
    t && t.removeChild(e)
}
function Lt(e, t, i) {
    var s, n, r, o, a = arguments;
    if (t = En({}, t),
    arguments.length > 3)
        for (i = [i],
        s = 3; s < arguments.length; s++)
            i.push(a[s]);
    if (i != null && (t.children = i),
    e != null && e.defaultProps != null)
        for (n in e.defaultProps)
            t[n] === void 0 && (t[n] = e.defaultProps[n]);
    return o = t.key,
    (r = t.ref) != null && delete t.ref,
    o != null && delete t.key,
    jd(e, t, o, r)
}
function jd(e, t, i, s) {
    var n = {
        type: e,
        props: t,
        key: i,
        ref: s,
        __k: null,
        __p: null,
        __b: 0,
        __e: null,
        l: null,
        __c: null,
        constructor: void 0
    };
    return Pe.vnode && Pe.vnode(n),
    n
}
function Th(e) {
    return e.children
}
function VN(e) {
    if (e == null || typeof e == "boolean")
        return null;
    if (typeof e == "string" || typeof e == "number")
        return jd(null, e, null, null);
    if (e.__e != null || e.__c != null) {
        var t = jd(e.type, e.props, e.key, null);
        return t.__e = e.__e,
        t
    }
    return e
}
function bo(e, t) {
    this.props = e,
    this.context = t
}
function Nc(e, t) {
    if (t == null)
        return e.__p ? Nc(e.__p, e.__p.__k.indexOf(e) + 1) : null;
    for (var i; t < e.__k.length; t++)
        if ((i = e.__k[t]) != null && i.__e != null)
            return i.__e;
    return typeof e.type == "function" ? Nc(e) : null
}
function Gy(e) {
    var t, i;
    if ((e = e.__p) != null && e.__c != null) {
        for (e.__e = e.__c.base = null,
        t = 0; t < e.__k.length; t++)
            if ((i = e.__k[t]) != null && i.__e != null) {
                e.__e = e.__c.base = i.__e;
                break
            }
        return Gy(e)
    }
}
function Tu(e) {
    (!e.__d && (e.__d = !0) && Dc.push(e) === 1 || $d !== Pe.debounceRendering) && ($d = Pe.debounceRendering,
    (Pe.debounceRendering || Fy)(zN))
}
function zN() {
    var e, t, i, s, n, r, o, a;
    for (Dc.sort(function(l, c) {
        return c.__v.__b - l.__v.__b
    }); e = Dc.pop(); )
        e.__d && (i = void 0,
        s = void 0,
        r = (n = (t = e).__v).__e,
        o = t.__P,
        a = t.u,
        t.u = !1,
        o && (i = [],
        s = Tp(o, n, En({}, n), t.__n, o.ownerSVGElement !== void 0, null, i, a, r ?? Nc(n)),
        Vy(i, n),
        s != r && Gy(n)))
}
function Hy(e, t, i, s, n, r, o, a, l) {
    var c, h, u, d, f, p, m, g = i && i.__k || xp, y = g.length;
    if (a == An && (a = r != null ? r[0] : y ? Nc(i, 0) : null),
    c = 0,
    t.__k = wp(t.__k, function(x) {
        if (x != null) {
            if (x.__p = t,
            x.__b = t.__b + 1,
            (u = g[c]) === null || u && x.key == u.key && x.type === u.type)
                g[c] = void 0;
            else
                for (h = 0; h < y; h++) {
                    if ((u = g[h]) && x.key == u.key && x.type === u.type) {
                        g[h] = void 0;
                        break
                    }
                    u = null
                }
            if (d = Tp(e, x, u = u || An, s, n, r, o, null, a, l),
            (h = x.ref) && u.ref != h && (m || (m = [])).push(h, x.__c || d, x),
            d != null) {
                if (p == null && (p = d),
                x.l != null)
                    d = x.l,
                    x.l = null;
                else if (r == u || d != a || d.parentNode == null) {
                    t: if (a == null || a.parentNode !== e)
                        e.appendChild(d);
                    else {
                        for (f = a,
                        h = 0; (f = f.nextSibling) && h < y; h += 2)
                            if (f == d)
                                break t;
                        e.insertBefore(d, a)
                    }
                    t.type == "option" && (e.value = "")
                }
                a = d.nextSibling,
                typeof t.type == "function" && (t.l = d)
            }
        }
        return c++,
        x
    }),
    t.__e = p,
    r != null && typeof t.type != "function")
        for (c = r.length; c--; )
            r[c] != null && Uy(r[c]);
    for (c = y; c--; )
        g[c] != null && $y(g[c], g[c]);
    if (m)
        for (c = 0; c < m.length; c++)
            zy(m[c], m[++c], m[++c])
}
function wp(e, t, i) {
    if (i == null && (i = []),
    e == null || typeof e == "boolean")
        t && i.push(t(null));
    else if (Array.isArray(e))
        for (var s = 0; s < e.length; s++)
            wp(e[s], t, i);
    else
        i.push(t ? t(VN(e)) : e);
    return i
}
function $N(e, t, i, s, n) {
    var r;
    for (r in i)
        r in t || h0(e, r, null, i[r], s);
    for (r in t)
        n && typeof t[r] != "function" || r === "value" || r === "checked" || i[r] === t[r] || h0(e, r, t[r], i[r], s)
}
function c0(e, t, i) {
    t[0] === "-" ? e.setProperty(t, i) : e[t] = typeof i == "number" && HN.test(t) === !1 ? i + "px" : i ?? ""
}
function h0(e, t, i, s, n) {
    var r, o, a, l, c;
    if (!((t = n ? t === "className" ? "class" : t : t === "class" ? "className" : t) === "key" || t === "children"))
        if (t === "style")
            if (r = e.style,
            typeof i == "string")
                r.cssText = i;
            else {
                if (typeof s == "string" && (r.cssText = "",
                s = null),
                s)
                    for (o in s)
                        i && o in i || c0(r, o, "");
                if (i)
                    for (a in i)
                        s && i[a] === s[a] || c0(r, a, i[a])
            }
        else
            t[0] === "o" && t[1] === "n" ? (l = t !== (t = t.replace(/Capture$/, "")),
            c = t.toLowerCase(),
            t = (c in e ? c : t).slice(2),
            i ? (s || e.addEventListener(t, u0, l),
            (e.t || (e.t = {}))[t] = i) : e.removeEventListener(t, u0, l)) : t !== "list" && t !== "tagName" && t !== "form" && !n && t in e ? e[t] = i ?? "" : typeof i != "function" && t !== "dangerouslySetInnerHTML" && (t !== (t = t.replace(/^xlink:?/, "")) ? i == null || i === !1 ? e.removeAttributeNS("http://www.w3.org/1999/xlink", t.toLowerCase()) : e.setAttributeNS("http://www.w3.org/1999/xlink", t.toLowerCase(), i) : i == null || i === !1 ? e.removeAttribute(t) : e.setAttribute(t, i))
}
function u0(e) {
    return this.t[e.type](Pe.event ? Pe.event(e) : e)
}
function Tp(e, t, i, s, n, r, o, a, l, c) {
    var h, u, d, f, p, m, g, y, x, v, _ = t.type;
    if (t.constructor !== void 0)
        return null;
    (h = Pe.__b) && h(t);
    try {
        t: if (typeof _ == "function") {
            if (y = t.props,
            x = (h = _.contextType) && s[h.__c],
            v = h ? x ? x.props.value : h.__p : s,
            i.__c ? g = (u = t.__c = i.__c).__p = u.__E : ("prototype"in _ && _.prototype.render ? t.__c = u = new _(y,v) : (t.__c = u = new bo(y,v),
            u.constructor = _,
            u.render = WN),
            x && x.sub(u),
            u.props = y,
            u.state || (u.state = {}),
            u.context = v,
            u.__n = s,
            d = u.__d = !0,
            u.__h = []),
            u.__s == null && (u.__s = u.state),
            _.getDerivedStateFromProps != null && En(u.__s == u.state ? u.__s = En({}, u.__s) : u.__s, _.getDerivedStateFromProps(y, u.__s)),
            d)
                _.getDerivedStateFromProps == null && u.componentWillMount != null && u.componentWillMount(),
                u.componentDidMount != null && o.push(u);
            else {
                if (_.getDerivedStateFromProps == null && a == null && u.componentWillReceiveProps != null && u.componentWillReceiveProps(y, v),
                !a && u.shouldComponentUpdate != null && u.shouldComponentUpdate(y, u.__s, v) === !1) {
                    for (u.props = y,
                    u.state = u.__s,
                    u.__d = !1,
                    u.__v = t,
                    t.__e = l != null ? l !== i.__e ? l : i.__e : null,
                    t.__k = i.__k,
                    h = 0; h < t.__k.length; h++)
                        t.__k[h] && (t.__k[h].__p = t);
                    break t
                }
                u.componentWillUpdate != null && u.componentWillUpdate(y, u.__s, v)
            }
            for (f = u.props,
            p = u.state,
            u.context = v,
            u.props = y,
            u.state = u.__s,
            (h = Pe.__r) && h(t),
            u.__d = !1,
            u.__v = t,
            u.__P = e,
            h = u.render(u.props, u.state, u.context),
            t.__k = wp(h != null && h.type == Th && h.key == null ? h.props.children : h),
            u.getChildContext != null && (s = En(En({}, s), u.getChildContext())),
            d || u.getSnapshotBeforeUpdate == null || (m = u.getSnapshotBeforeUpdate(f, p)),
            Hy(e, t, i, s, n, r, o, l, c),
            u.base = t.__e; h = u.__h.pop(); )
                u.__s && (u.state = u.__s),
                h.call(u);
            d || f == null || u.componentDidUpdate == null || u.componentDidUpdate(f, p, m),
            g && (u.__E = u.__p = null)
        } else
            t.__e = jN(i.__e, t, i, s, n, r, o, c);
        (h = Pe.diffed) && h(t)
    } catch (C) {
        Pe.__e(C, t, i)
    }
    return t.__e
}
function Vy(e, t) {
    for (var i; i = e.pop(); )
        try {
            i.componentDidMount()
        } catch (s) {
            Pe.__e(s, i.__v)
        }
    Pe.__c && Pe.__c(t)
}
function jN(e, t, i, s, n, r, o, a) {
    var l, c, h, u, d = i.props, f = t.props;
    if (n = t.type === "svg" || n,
    e == null && r != null) {
        for (l = 0; l < r.length; l++)
            if ((c = r[l]) != null && (t.type === null ? c.nodeType === 3 : c.localName === t.type)) {
                e = c,
                r[l] = null;
                break
            }
    }
    if (e == null) {
        if (t.type === null)
            return document.createTextNode(f);
        e = n ? document.createElementNS("http://www.w3.org/2000/svg", t.type) : document.createElement(t.type),
        r = null
    }
    return t.type === null ? d !== f && (r != null && (r[r.indexOf(e)] = null),
    e.data = f) : t !== i && (r != null && (r = xp.slice.call(e.childNodes)),
    h = (d = i.props || An).dangerouslySetInnerHTML,
    u = f.dangerouslySetInnerHTML,
    a || (u || h) && (u && h && u.__html == h.__html || (e.innerHTML = u && u.__html || "")),
    $N(e, f, d, n, a),
    t.__k = t.props.children,
    u || Hy(e, t, i, s, t.type !== "foreignObject" && n, r, o, An, a),
    a || ("value"in f && f.value !== void 0 && f.value !== e.value && (e.value = f.value == null ? "" : f.value),
    "checked"in f && f.checked !== void 0 && f.checked !== e.checked && (e.checked = f.checked))),
    e
}
function zy(e, t, i) {
    try {
        typeof e == "function" ? e(t) : e.current = t
    } catch (s) {
        Pe.__e(s, i)
    }
}
function $y(e, t, i) {
    var s, n, r;
    if (Pe.unmount && Pe.unmount(e),
    (s = e.ref) && zy(s, null, t),
    i || typeof e.type == "function" || (i = (n = e.__e) != null),
    e.__e = e.l = null,
    (s = e.__c) != null) {
        if (s.componentWillUnmount)
            try {
                s.componentWillUnmount()
            } catch (o) {
                Pe.__e(o, t)
            }
        s.base = s.__P = null
    }
    if (s = e.__k)
        for (r = 0; r < s.length; r++)
            s[r] && $y(s[r], t, i);
    n != null && Uy(n)
}
function WN(e, t, i) {
    return this.constructor(e, i)
}
function XN(e, t, i) {
    var s, n, r;
    Pe.__p && Pe.__p(e, t),
    n = (s = i === By) ? null : i && i.__k || t.__k,
    e = Lt(Th, null, [e]),
    r = [],
    Tp(t, s ? t.__k = e : (i || t).__k = e, n || An, An, t.ownerSVGElement !== void 0, i && !s ? [i] : n ? null : xp.slice.call(t.childNodes), r, !1, i || An, s),
    Vy(r, e)
}
Pe = {},
bo.prototype.setState = function(e, t) {
    var i = this.__s !== this.state && this.__s || (this.__s = En({}, this.state));
    (typeof e != "function" || (e = e(i, this.props))) && En(i, e),
    e != null && this.__v && (this.u = !1,
    t && this.__h.push(t),
    Tu(this))
}
,
bo.prototype.forceUpdate = function(e) {
    this.__v && (e && this.__h.push(e),
    this.u = !0,
    Tu(this))
}
,
bo.prototype.render = Th,
Dc = [],
Fy = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout,
$d = Pe.debounceRendering,
Pe.__e = function(e, t, i) {
    for (var s; t = t.__p; )
        if ((s = t.__c) && !s.__p)
            try {
                if (s.constructor && s.constructor.getDerivedStateFromError != null)
                    s.setState(s.constructor.getDerivedStateFromError(e));
                else {
                    if (s.componentDidCatch == null)
                        continue;
                    s.componentDidCatch(e)
                }
                return Tu(s.__E = s)
            } catch (n) {
                e = n
            }
    throw e
}
,
By = An;
function d0(e, t) {
    for (var i = 0; i < t.length; i++) {
        var s = t[i];
        s.enumerable = s.enumerable || !1,
        s.configurable = !0,
        "value"in s && (s.writable = !0),
        Object.defineProperty(e, s.key, s)
    }
}
function YN(e, t, i) {
    return t && d0(e.prototype, t),
    i && d0(e, i),
    e
}
function pi() {
    return pi = Object.assign || function(e) {
        for (var t = arguments, i = 1; i < arguments.length; i++) {
            var s = t[i];
            for (var n in s)
                Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
        }
        return e
    }
    ,
    pi.apply(this, arguments)
}
var KN = "[-\\+]?\\d+%?"
  , ZN = "[-\\+]?\\d*\\.\\d+%?"
  , pr = "(?:" + ZN + ")|(?:" + KN + ")"
  , jy = "[\\s|\\(]+(" + pr + ")[,|\\s]+(" + pr + ")[,|\\s]+(" + pr + ")\\s*\\)?"
  , Wy = "[\\s|\\(]+(" + pr + ")[,|\\s]+(" + pr + ")[,|\\s]+(" + pr + ")[,|\\s]+(" + pr + ")\\s*\\)?"
  , qN = new RegExp("rgb" + jy)
  , JN = new RegExp("rgba" + Wy)
  , QN = new RegExp("hsl" + jy)
  , t7 = new RegExp("hsla" + Wy)
  , Eh = "^(?:#?|0x?)"
  , mr = "([0-9a-fA-F]{1})"
  , gr = "([0-9a-fA-F]{2})"
  , e7 = new RegExp(Eh + mr + mr + mr + "$")
  , i7 = new RegExp(Eh + mr + mr + mr + mr + "$")
  , s7 = new RegExp(Eh + gr + gr + gr + "$")
  , n7 = new RegExp(Eh + gr + gr + gr + gr + "$")
  , r7 = 2e3
  , o7 = 4e4
  , zl = Math.log
  , Yr = Math.round
  , ha = Math.floor;
function Oi(e, t, i) {
    return Math.min(Math.max(e, t), i)
}
function di(e, t) {
    var i = e.indexOf("%") > -1
      , s = parseFloat(e);
    return i ? t / 100 * s : s
}
function fi(e) {
    return parseInt(e, 16)
}
function $n(e) {
    return e.toString(16).padStart(2, "0")
}
var co = function() {
    function e(i, s) {
        this.$ = {
            h: 0,
            s: 0,
            v: 0,
            a: 1
        },
        i && this.set(i),
        this.onChange = s,
        this.initialValue = pi({}, this.$)
    }
    var t = e.prototype;
    return t.set = function(s) {
        if (typeof s == "string")
            /^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(s) ? this.hexString = s : /^rgba?/.test(s) ? this.rgbString = s : /^hsla?/.test(s) && (this.hslString = s);
        else if (typeof s == "object")
            s instanceof e ? this.hsv = s.hsv : typeof s == "object" && "r"in s && "g"in s && "b"in s ? this.rgb = s : typeof s == "object" && "h"in s && "s"in s && "v"in s ? this.hsv = s : typeof s == "object" && "h"in s && "s"in s && "l"in s && (this.hsl = s);
        else
            throw new Error("Invalid color value")
    }
    ,
    t.setChannel = function(s, n, r) {
        var o;
        this[s] = pi({}, this[s], (o = {},
        o[n] = r,
        o))
    }
    ,
    t.reset = function() {
        this.hsva = this.initialValue
    }
    ,
    t.clone = function() {
        return new e(this)
    }
    ,
    t.unbind = function() {
        this.onChange = void 0
    }
    ,
    e.hsvToRgb = function(s) {
        var n = s.h / 60
          , r = s.s / 100
          , o = s.v / 100
          , a = ha(n)
          , l = n - a
          , c = o * (1 - r)
          , h = o * (1 - l * r)
          , u = o * (1 - (1 - l) * r)
          , d = a % 6
          , f = [o, h, c, c, u, o][d]
          , p = [u, o, o, h, c, c][d]
          , m = [c, c, u, o, o, h][d];
        return {
            r: Oi(f * 255, 0, 255),
            g: Oi(p * 255, 0, 255),
            b: Oi(m * 255, 0, 255)
        }
    }
    ,
    e.rgbToHsv = function(s) {
        var n = s.r / 255
          , r = s.g / 255
          , o = s.b / 255
          , a = Math.max(n, r, o)
          , l = Math.min(n, r, o)
          , c = a - l
          , h = 0
          , u = a
          , d = a === 0 ? 0 : c / a;
        switch (a) {
        case l:
            h = 0;
            break;
        case n:
            h = (r - o) / c + (r < o ? 6 : 0);
            break;
        case r:
            h = (o - n) / c + 2;
            break;
        case o:
            h = (n - r) / c + 4;
            break
        }
        return {
            h: h * 60 % 360,
            s: Oi(d * 100, 0, 100),
            v: Oi(u * 100, 0, 100)
        }
    }
    ,
    e.hsvToHsl = function(s) {
        var n = s.s / 100
          , r = s.v / 100
          , o = (2 - n) * r
          , a = o <= 1 ? o : 2 - o
          , l = a < 1e-9 ? 0 : n * r / a;
        return {
            h: s.h,
            s: Oi(l * 100, 0, 100),
            l: Oi(o * 50, 0, 100)
        }
    }
    ,
    e.hslToHsv = function(s) {
        var n = s.l * 2
          , r = s.s * (n <= 100 ? n : 200 - n) / 100
          , o = n + r < 1e-9 ? 0 : 2 * r / (n + r);
        return {
            h: s.h,
            s: Oi(o * 100, 0, 100),
            v: Oi((n + r) / 2, 0, 100)
        }
    }
    ,
    e.kelvinToRgb = function(s) {
        var n = s / 100, r, o, a;
        return n < 66 ? (r = 255,
        o = -155.25485562709179 - .44596950469579133 * (o = n - 2) + 104.49216199393888 * zl(o),
        a = n < 20 ? 0 : -254.76935184120902 + .8274096064007395 * (a = n - 10) + 115.67994401066147 * zl(a)) : (r = 351.97690566805693 + .114206453784165 * (r = n - 55) - 40.25366309332127 * zl(r),
        o = 325.4494125711974 + .07943456536662342 * (o = n - 50) - 28.0852963507957 * zl(o),
        a = 255),
        {
            r: Oi(ha(r), 0, 255),
            g: Oi(ha(o), 0, 255),
            b: Oi(ha(a), 0, 255)
        }
    }
    ,
    e.rgbToKelvin = function(s) {
        for (var n = s.r, r = s.b, o = .4, a = r7, l = o7, c; l - a > o; ) {
            c = (l + a) * .5;
            var h = e.kelvinToRgb(c);
            h.b / h.r >= r / n ? l = c : a = c
        }
        return c
    }
    ,
    YN(e, [{
        key: "hsv",
        get: function() {
            var s = this.$;
            return {
                h: s.h,
                s: s.s,
                v: s.v
            }
        },
        set: function(s) {
            var n = this.$;
            if (s = pi({}, n, s),
            this.onChange) {
                var r = {
                    h: !1,
                    v: !1,
                    s: !1,
                    a: !1
                };
                for (var o in n)
                    r[o] = s[o] != n[o];
                this.$ = s,
                (r.h || r.s || r.v || r.a) && this.onChange(this, r)
            } else
                this.$ = s
        }
    }, {
        key: "hsva",
        get: function() {
            return pi({}, this.$)
        },
        set: function(s) {
            this.hsv = s
        }
    }, {
        key: "hue",
        get: function() {
            return this.$.h
        },
        set: function(s) {
            this.hsv = {
                h: s
            }
        }
    }, {
        key: "saturation",
        get: function() {
            return this.$.s
        },
        set: function(s) {
            this.hsv = {
                s
            }
        }
    }, {
        key: "value",
        get: function() {
            return this.$.v
        },
        set: function(s) {
            this.hsv = {
                v: s
            }
        }
    }, {
        key: "alpha",
        get: function() {
            return this.$.a
        },
        set: function(s) {
            this.hsv = pi({}, this.hsv, {
                a: s
            })
        }
    }, {
        key: "kelvin",
        get: function() {
            return e.rgbToKelvin(this.rgb)
        },
        set: function(s) {
            this.rgb = e.kelvinToRgb(s)
        }
    }, {
        key: "red",
        get: function() {
            var s = this.rgb;
            return s.r
        },
        set: function(s) {
            this.rgb = pi({}, this.rgb, {
                r: s
            })
        }
    }, {
        key: "green",
        get: function() {
            var s = this.rgb;
            return s.g
        },
        set: function(s) {
            this.rgb = pi({}, this.rgb, {
                g: s
            })
        }
    }, {
        key: "blue",
        get: function() {
            var s = this.rgb;
            return s.b
        },
        set: function(s) {
            this.rgb = pi({}, this.rgb, {
                b: s
            })
        }
    }, {
        key: "rgb",
        get: function() {
            var s = e.hsvToRgb(this.$)
              , n = s.r
              , r = s.g
              , o = s.b;
            return {
                r: Yr(n),
                g: Yr(r),
                b: Yr(o)
            }
        },
        set: function(s) {
            this.hsv = pi({}, e.rgbToHsv(s), {
                a: s.a === void 0 ? 1 : s.a
            })
        }
    }, {
        key: "rgba",
        get: function() {
            return pi({}, this.rgb, {
                a: this.alpha
            })
        },
        set: function(s) {
            this.rgb = s
        }
    }, {
        key: "hsl",
        get: function() {
            var s = e.hsvToHsl(this.$)
              , n = s.h
              , r = s.s
              , o = s.l;
            return {
                h: Yr(n),
                s: Yr(r),
                l: Yr(o)
            }
        },
        set: function(s) {
            this.hsv = pi({}, e.hslToHsv(s), {
                a: s.a === void 0 ? 1 : s.a
            })
        }
    }, {
        key: "hsla",
        get: function() {
            return pi({}, this.hsl, {
                a: this.alpha
            })
        },
        set: function(s) {
            this.hsl = s
        }
    }, {
        key: "rgbString",
        get: function() {
            var s = this.rgb;
            return "rgb(" + s.r + ", " + s.g + ", " + s.b + ")"
        },
        set: function(s) {
            var n, r, o, a, l = 1;
            if ((n = qN.exec(s)) ? (r = di(n[1], 255),
            o = di(n[2], 255),
            a = di(n[3], 255)) : (n = JN.exec(s)) && (r = di(n[1], 255),
            o = di(n[2], 255),
            a = di(n[3], 255),
            l = di(n[4], 1)),
            n)
                this.rgb = {
                    r,
                    g: o,
                    b: a,
                    a: l
                };
            else
                throw new Error("Invalid rgb string")
        }
    }, {
        key: "rgbaString",
        get: function() {
            var s = this.rgba;
            return "rgba(" + s.r + ", " + s.g + ", " + s.b + ", " + s.a + ")"
        },
        set: function(s) {
            this.rgbString = s
        }
    }, {
        key: "hexString",
        get: function() {
            var s = this.rgb;
            return "#" + $n(s.r) + $n(s.g) + $n(s.b)
        },
        set: function(s) {
            var n, r, o, a, l = 255;
            if ((n = e7.exec(s)) ? (r = fi(n[1]) * 17,
            o = fi(n[2]) * 17,
            a = fi(n[3]) * 17) : (n = i7.exec(s)) ? (r = fi(n[1]) * 17,
            o = fi(n[2]) * 17,
            a = fi(n[3]) * 17,
            l = fi(n[4]) * 17) : (n = s7.exec(s)) ? (r = fi(n[1]),
            o = fi(n[2]),
            a = fi(n[3])) : (n = n7.exec(s)) && (r = fi(n[1]),
            o = fi(n[2]),
            a = fi(n[3]),
            l = fi(n[4])),
            n)
                this.rgb = {
                    r,
                    g: o,
                    b: a,
                    a: l / 255
                };
            else
                throw new Error("Invalid hex string")
        }
    }, {
        key: "hex8String",
        get: function() {
            var s = this.rgba;
            return "#" + $n(s.r) + $n(s.g) + $n(s.b) + $n(ha(s.a * 255))
        },
        set: function(s) {
            this.hexString = s
        }
    }, {
        key: "hslString",
        get: function() {
            var s = this.hsl;
            return "hsl(" + s.h + ", " + s.s + "%, " + s.l + "%)"
        },
        set: function(s) {
            var n, r, o, a, l = 1;
            if ((n = QN.exec(s)) ? (r = di(n[1], 360),
            o = di(n[2], 100),
            a = di(n[3], 100)) : (n = t7.exec(s)) && (r = di(n[1], 360),
            o = di(n[2], 100),
            a = di(n[3], 100),
            l = di(n[4], 1)),
            n)
                this.hsl = {
                    h: r,
                    s: o,
                    l: a,
                    a: l
                };
            else
                throw new Error("Invalid hsl string")
        }
    }, {
        key: "hslaString",
        get: function() {
            var s = this.hsla;
            return "hsl(" + s.h + ", " + s.s + "%, " + s.l + "%, " + s.a + ")"
        },
        set: function(s) {
            this.hslString = s
        }
    }]),
    e
}()
  , a7 = {
    sliderShape: "bar",
    sliderType: "value",
    minTemperature: 2200,
    maxTemperature: 11e3
};
function Ep(e) {
    var t, i = e.width, s = e.sliderSize, n = e.borderWidth, r = e.handleRadius, o = e.padding, a = e.sliderShape, l = e.layoutDirection === "horizontal";
    return s = (t = s) != null ? t : o * 2 + r * 2 + n * 2,
    a === "circle" ? {
        handleStart: e.padding + e.handleRadius,
        handleRange: i - o * 2 - r * 2 - n * 2,
        width: i,
        height: i,
        cx: i / 2,
        cy: i / 2,
        radius: i / 2 - n / 2
    } : {
        handleStart: s / 2,
        handleRange: i - s,
        radius: s / 2,
        x: 0,
        y: 0,
        width: l ? s : i,
        height: l ? i : s
    }
}
function l7(e, t) {
    var i = t.hsva
      , s = t.rgb;
    switch (e.sliderType) {
    case "red":
        return s.r / 2.55;
    case "green":
        return s.g / 2.55;
    case "blue":
        return s.b / 2.55;
    case "alpha":
        return i.a * 100;
    case "kelvin":
        var n = e.minTemperature
          , r = e.maxTemperature
          , o = r - n
          , a = (t.kelvin - n) / o * 100;
        return Math.max(0, Math.min(a, 100));
    case "hue":
        return i.h /= 3.6;
    case "saturation":
        return i.s;
    case "value":
    default:
        return i.v
    }
}
function c7(e, t, i) {
    var s = Ep(e), n = s.handleRange, r = s.handleStart, o;
    e.layoutDirection === "horizontal" ? o = -1 * i + n + r : o = t - r,
    o = Math.max(Math.min(o, n), 0);
    var a = Math.round(100 / n * o);
    switch (e.sliderType) {
    case "kelvin":
        var l = e.minTemperature
          , c = e.maxTemperature
          , h = c - l;
        return l + h * (a / 100);
    case "alpha":
        return a / 100;
    case "hue":
        return a * 3.6;
    case "red":
    case "blue":
    case "green":
        return a * 2.55;
    default:
        return a
    }
}
function h7(e, t) {
    var i = Ep(e)
      , s = i.width
      , n = i.height
      , r = i.handleRange
      , o = i.handleStart
      , a = e.layoutDirection === "horizontal"
      , l = l7(e, t)
      , c = a ? s / 2 : n / 2
      , h = o + l / 100 * r;
    return a && (h = -1 * h + r + o * 2),
    {
        x: a ? c : h,
        y: a ? h : c
    }
}
function u7(e, t) {
    var i = t.hsv
      , s = t.rgb;
    switch (e.sliderType) {
    case "red":
        return [[0, "rgb(" + 0 + "," + s.g + "," + s.b + ")"], [100, "rgb(" + 255 + "," + s.g + "," + s.b + ")"]];
    case "green":
        return [[0, "rgb(" + s.r + "," + 0 + "," + s.b + ")"], [100, "rgb(" + s.r + "," + 255 + "," + s.b + ")"]];
    case "blue":
        return [[0, "rgb(" + s.r + "," + s.g + "," + 0 + ")"], [100, "rgb(" + s.r + "," + s.g + "," + 255 + ")"]];
    case "alpha":
        return [[0, "rgba(" + s.r + "," + s.g + "," + s.b + ",0)"], [100, "rgb(" + s.r + "," + s.g + "," + s.b + ")"]];
    case "kelvin":
        for (var n = [], r = e.minTemperature, o = e.maxTemperature, a = 8, l = o - r, c = r, h = 0; c < o; c += l / a,
        h += 1) {
            var u = co.kelvinToRgb(c)
              , d = u.r
              , f = u.g
              , p = u.b;
            n.push([100 / a * h, "rgb(" + d + "," + f + "," + p + ")"])
        }
        return n;
    case "hue":
        return [[0, "#f00"], [16.666, "#ff0"], [33.333, "#0f0"], [50, "#0ff"], [66.666, "#00f"], [83.333, "#f0f"], [100, "#f00"]];
    case "saturation":
        var m = co.hsvToHsl({
            h: i.h,
            s: 0,
            v: i.v
        })
          , g = co.hsvToHsl({
            h: i.h,
            s: 100,
            v: i.v
        });
        return [[0, "hsl(" + m.h + "," + m.s + "%," + m.l + "%)"], [100, "hsl(" + g.h + "," + g.s + "%," + g.l + "%)"]];
    case "value":
    default:
        var y = co.hsvToHsl({
            h: i.h,
            s: i.s,
            v: 100
        });
        return [[0, "#000"], [100, "hsl(" + y.h + "," + y.s + "%," + y.l + "%)"]]
    }
}
function d7(e) {
    var t = e.layoutDirection === "horizontal";
    return {
        x1: "0%",
        y1: t ? "100%" : "0%",
        x2: t ? "0%" : "100%",
        y2: "0%"
    }
}
function Sp(e) {
    var t = e.width / 2;
    return {
        width: e.width,
        radius: t - e.borderWidth,
        cx: t,
        cy: t
    }
}
function Cp(e, t, i) {
    var s = e.wheelAngle
      , n = e.wheelDirection;
    return !i && n === "clockwise" || i && n === "anticlockwise" ? t = (i ? 180 : 360) - (s - t) : t = s + t,
    (t % 360 + 360) % 360
}
function f7(e, t) {
    var i = t.hsv
      , s = Sp(e)
      , n = s.cx
      , r = s.cy
      , o = e.width / 2 - e.padding - e.handleRadius - e.borderWidth
      , a = (180 + Cp(e, i.h, !0)) * (Math.PI / 180)
      , l = i.s / 100 * o
      , c = e.wheelDirection === "clockwise" ? -1 : 1;
    return {
        x: n + l * Math.cos(a) * c,
        y: r + l * Math.sin(a) * c
    }
}
function f0(e, t, i) {
    var s = Sp(e)
      , n = s.cx
      , r = s.cy
      , o = e.width / 2 - e.padding - e.handleRadius - e.borderWidth;
    t = n - t,
    i = r - i;
    var a = Cp(e, Math.atan2(-i, -t) * (180 / Math.PI))
      , l = Math.min(Math.sqrt(t * t + i * i), o);
    return {
        h: Math.round(a),
        s: Math.round(100 / o * l)
    }
}
function Ap(e) {
    var t = e.width
      , i = e.boxHeight
      , s = e.padding
      , n = e.handleRadius;
    return {
        width: t,
        height: i ?? t,
        radius: s + n
    }
}
function p0(e, t, i) {
    var s = Ap(e)
      , n = s.width
      , r = s.height
      , o = s.radius
      , a = o
      , l = n - o * 2
      , c = r - o * 2
      , h = (t - a) / l * 100
      , u = (i - a) / c * 100;
    return {
        s: Math.max(0, Math.min(h, 100)),
        v: Math.max(0, Math.min(100 - u, 100))
    }
}
function p7(e, t) {
    var i = Ap(e)
      , s = i.width
      , n = i.height
      , r = i.radius
      , o = t.hsv
      , a = r
      , l = s - r * 2
      , c = n - r * 2;
    return {
        x: a + o.s / 100 * l,
        y: a + (c - o.v / 100 * c)
    }
}
function m7(e, t) {
    var i = t.hue;
    return [[[0, "#fff"], [100, "hsl(" + i + ",100%,50%)"]], [[0, "rgba(0,0,0,0)"], [100, "#000"]]]
}
var Eu;
function In(e) {
    Eu || (Eu = document.getElementsByTagName("base"));
    var t = window.navigator.userAgent
      , i = /^((?!chrome|android).)*safari/i.test(t)
      , s = /iPhone|iPod|iPad/i.test(t)
      , n = window.location;
    return (i || s) && Eu.length > 0 ? n.protocol + "//" + n.host + n.pathname + n.search + e : e
}
function g7(e, t, i, s, n) {
    var r = n - s <= 180 ? 0 : 1;
    s *= Math.PI / 180,
    n *= Math.PI / 180;
    var o = e + i * Math.cos(n)
      , a = t + i * Math.sin(n)
      , l = e + i * Math.cos(s)
      , c = t + i * Math.sin(s);
    return "M " + o + " " + a + " A " + i + " " + i + " 0 " + r + " 0 " + l + " " + c
}
function Xy(e, t, i, s) {
    for (var n = 0; n < s.length; n++) {
        var r = s[n].x - t
          , o = s[n].y - i
          , a = Math.sqrt(r * r + o * o);
        if (a < e.handleRadius)
            return n
    }
    return null
}
var v7 = {
    width: 300,
    height: 300,
    color: "#fff",
    colors: [],
    padding: 6,
    layoutDirection: "vertical",
    borderColor: "#fff",
    borderWidth: 0,
    handleRadius: 8,
    handleSvg: null,
    handleProps: {
        x: 0,
        y: 0
    },
    wheelLightness: !0,
    wheelAngle: 0,
    wheelDirection: "anticlockwise",
    sliderSize: null,
    sliderMargin: 12,
    boxHeight: null
}
  , m0 = ["mousemove", "touchmove", "mouseup", "touchend"]
  , Sh = function(e) {
    function t(i) {
        e.call(this, i),
        this.uid = (Math.random() + 1).toString(36).substring(5)
    }
    return e && (t.__proto__ = e),
    t.prototype = Object.create(e && e.prototype),
    t.prototype.constructor = t,
    t.prototype.render = function(s) {
        var n = this.handleEvent.bind(this)
          , r = {
            onMouseDown: n,
            ontouchstart: n
        }
          , o = s.layoutDirection === "horizontal"
          , a = s.margin === null ? s.sliderMargin : s.margin
          , l = {
            overflow: "visible",
            display: o ? "inline-block" : "block"
        };
        return s.index > 0 && (l[o ? "marginLeft" : "marginTop"] = a),
        Lt(Th, null, s.children(this.uid, r, l))
    }
    ,
    t.prototype.handleEvent = function(s) {
        var n = this
          , r = this.props.onInput
          , o = this.base.getBoundingClientRect();
        s.preventDefault();
        var a = s.touches ? s.changedTouches[0] : s
          , l = a.clientX - o.left
          , c = a.clientY - o.top;
        switch (s.type) {
        case "mousedown":
        case "touchstart":
            m0.forEach(function(h) {
                document.addEventListener(h, n, {
                    passive: !1
                })
            }),
            r(l, c, 0);
            break;
        case "mousemove":
        case "touchmove":
            r(l, c, 1);
            break;
        case "mouseup":
        case "touchend":
            r(l, c, 2),
            m0.forEach(function(h) {
                document.removeEventListener(h, n)
            });
            break
        }
    }
    ,
    t
}(bo);
function Ir(e) {
    var t = e.r
      , i = e.url;
    return Lt("svg", {
        className: "IroHandle IroHandle--" + e.index + " " + (e.isActive ? "IroHandle--isActive" : ""),
        x: e.x,
        y: e.y,
        style: {
            overflow: "visible"
        }
    }, i && Lt("use", Object.assign({
        xlinkHref: In(i)
    }, e.props)), !i && Lt("circle", {
        r: t,
        fill: "none",
        "stroke-width": 2,
        stroke: "#000"
    }), !i && Lt("circle", {
        r: t - 2,
        fill: e.fill,
        "stroke-width": 2,
        stroke: "#fff"
    }))
}
Ir.defaultProps = {
    fill: "none",
    x: 0,
    y: 0,
    r: 8,
    url: null,
    props: {
        x: 0,
        y: 0
    }
};
function Fc(e) {
    var t = e.activeIndex
      , i = t !== void 0 && t < e.colors.length ? e.colors[t] : e.color
      , s = Ep(e)
      , n = s.width
      , r = s.height
      , o = s.radius
      , a = h7(e, i)
      , l = u7(e, i)
      , c = e.sliderType === "alpha";
    function h(u, d, f) {
        var p = c7(e, u, d);
        e.parent.inputActive = !0,
        i[e.sliderType] = p,
        e.onInput(f, e.id)
    }
    return Lt(Sh, Object.assign({}, e, {
        onInput: h
    }), function(u, d, f) {
        return Lt("svg", Object.assign({}, d, {
            className: "IroSlider",
            width: n,
            height: r,
            style: f
        }), Lt("defs", null, Lt("linearGradient", Object.assign({
            id: "g" + u
        }, d7(e)), l.map(function(p) {
            var m = p[0]
              , g = p[1];
            return Lt("stop", {
                offset: m + "%",
                "stop-color": g
            })
        })), c && Lt("pattern", {
            id: "b" + u,
            width: "8",
            height: "8",
            patternUnits: "userSpaceOnUse"
        }, Lt("rect", {
            x: "0",
            y: "0",
            width: "8",
            height: "8",
            fill: "#fff"
        }), Lt("rect", {
            x: "0",
            y: "0",
            width: "4",
            height: "4",
            fill: "#ccc"
        }), Lt("rect", {
            x: "4",
            y: "4",
            width: "4",
            height: "4",
            fill: "#ccc"
        })), c && Lt("pattern", {
            id: "f" + u,
            width: "100%",
            height: "100%"
        }, Lt("rect", {
            x: "0",
            y: "0",
            width: "100%",
            height: "100%",
            fill: "url(" + In("#b" + u) + ")"
        }), Lt("rect", {
            x: "0",
            y: "0",
            width: "100%",
            height: "100%",
            fill: "url(" + In("#g" + u) + ")"
        }))), Lt("rect", {
            className: "IroSliderBg",
            rx: o,
            ry: o,
            x: e.borderWidth / 2,
            y: e.borderWidth / 2,
            width: n - e.borderWidth,
            height: r - e.borderWidth,
            "stroke-width": e.borderWidth,
            stroke: e.borderColor,
            fill: "url(" + In((c ? "#f" : "#g") + u) + ")"
        }), Lt(Ir, {
            isActive: !0,
            index: i.index,
            r: e.handleRadius,
            url: e.handleSvg,
            props: e.handleProps,
            x: a.x,
            y: a.y
        }))
    })
}
Fc.defaultProps = Object.assign({}, a7);
function _7(e) {
    var t = Ap(e)
      , i = t.width
      , s = t.height
      , n = t.radius
      , r = e.colors
      , o = e.parent
      , a = e.activeIndex
      , l = a !== void 0 && a < e.colors.length ? e.colors[a] : e.color
      , c = m7(e, l)
      , h = r.map(function(d) {
        return p7(e, d)
    });
    function u(d, f, p) {
        if (p === 0) {
            var m = Xy(e, d, f, h);
            m !== null ? o.setActiveColor(m) : (o.inputActive = !0,
            l.hsv = p0(e, d, f),
            e.onInput(p, e.id))
        } else
            p === 1 && (o.inputActive = !0,
            l.hsv = p0(e, d, f));
        e.onInput(p, e.id)
    }
    return Lt(Sh, Object.assign({}, e, {
        onInput: u
    }), function(d, f, p) {
        return Lt("svg", Object.assign({}, f, {
            className: "IroBox",
            width: i,
            height: s,
            style: p
        }), Lt("defs", null, Lt("linearGradient", {
            id: "s" + d,
            x1: "0%",
            y1: "0%",
            x2: "100%",
            y2: "0%"
        }, c[0].map(function(m) {
            var g = m[0]
              , y = m[1];
            return Lt("stop", {
                offset: g + "%",
                "stop-color": y
            })
        })), Lt("linearGradient", {
            id: "l" + d,
            x1: "0%",
            y1: "0%",
            x2: "0%",
            y2: "100%"
        }, c[1].map(function(m) {
            var g = m[0]
              , y = m[1];
            return Lt("stop", {
                offset: g + "%",
                "stop-color": y
            })
        })), Lt("pattern", {
            id: "f" + d,
            width: "100%",
            height: "100%"
        }, Lt("rect", {
            x: "0",
            y: "0",
            width: "100%",
            height: "100%",
            fill: "url(" + In("#s" + d) + ")"
        }), Lt("rect", {
            x: "0",
            y: "0",
            width: "100%",
            height: "100%",
            fill: "url(" + In("#l" + d) + ")"
        }))), Lt("rect", {
            className: "IroBoxBg",
            rx: n,
            ry: n,
            x: e.borderWidth / 2,
            y: e.borderWidth / 2,
            width: i - e.borderWidth,
            height: s - e.borderWidth,
            "stroke-width": e.borderWidth,
            stroke: e.borderColor,
            fill: "url(" + In("#f" + d) + ")"
        }), r.filter(function(m) {
            return m !== l
        }).map(function(m) {
            return Lt(Ir, {
                isActive: !1,
                index: m.index,
                fill: m.hslString,
                r: e.handleRadius,
                url: e.handleSvg,
                props: e.handleProps,
                x: h[m.index].x,
                y: h[m.index].y
            })
        }), Lt(Ir, {
            isActive: !0,
            index: l.index,
            fill: l.hslString,
            r: e.handleRadius,
            url: e.handleSvg,
            props: e.handleProps,
            x: h[l.index].x,
            y: h[l.index].y
        }))
    })
}
var y7 = Array.apply(null, {
    length: 360
}).map(function(e, t) {
    return t
});
function Yy(e) {
    var t = Sp(e)
      , i = t.width
      , s = t.radius
      , n = t.cx
      , r = t.cy
      , o = e.colors
      , a = e.borderWidth
      , l = e.parent
      , c = e.color
      , h = c.hsv
      , u = o.map(function(f) {
        return f7(e, f)
    });
    function d(f, p, m) {
        if (m === 0) {
            var g = Xy(e, f, p, u);
            g !== null ? l.setActiveColor(g) : (l.inputActive = !0,
            c.hsv = f0(e, f, p),
            e.onInput(m, e.id))
        } else
            m === 1 && (l.inputActive = !0,
            c.hsv = f0(e, f, p));
        e.onInput(m, e.id)
    }
    return Lt(Sh, Object.assign({}, e, {
        onInput: d
    }), function(f, p, m) {
        return Lt("svg", Object.assign({}, p, {
            className: "IroWheel",
            width: i,
            height: i,
            style: m
        }), Lt("defs", null, Lt("radialGradient", {
            id: f
        }, Lt("stop", {
            offset: "0%",
            "stop-color": "#fff"
        }), Lt("stop", {
            offset: "100%",
            "stop-color": "#fff",
            "stop-opacity": "0"
        }))), Lt("g", {
            className: "IroWheelHue",
            "stroke-width": s,
            fill: "none"
        }, y7.map(function(g) {
            return Lt("path", {
                key: g,
                d: g7(n, r, s / 2, g, g + 1.5),
                stroke: "hsl(" + Cp(e, g) + ", 100%, 50%)"
            })
        })), Lt("circle", {
            className: "IroWheelSaturation",
            cx: n,
            cy: r,
            r: s,
            fill: "url(" + In("#" + f) + ")"
        }), e.wheelLightness && Lt("circle", {
            className: "IroWheelLightness",
            cx: n,
            cy: r,
            r: s,
            fill: "#000",
            opacity: 1 - h.v / 100
        }), Lt("circle", {
            className: "IroWheelBorder",
            cx: n,
            cy: r,
            r: s,
            fill: "none",
            stroke: e.borderColor,
            "stroke-width": a
        }), o.filter(function(g) {
            return g !== c
        }).map(function(g) {
            return Lt(Ir, {
                isActive: !1,
                index: g.index,
                fill: g.hslString,
                r: e.handleRadius,
                url: e.handleSvg,
                props: e.handleProps,
                x: u[g.index].x,
                y: u[g.index].y
            })
        }), Lt(Ir, {
            isActive: !0,
            index: c.index,
            fill: c.hslString,
            r: e.handleRadius,
            url: e.handleSvg,
            props: e.handleProps,
            x: u[c.index].x,
            y: u[c.index].y
        }))
    })
}
function b7(e) {
    var t = function(i, s) {
        var n, r = document.createElement("div");
        XN(Lt(e, Object.assign({}, {
            ref: function(a) {
                return n = a
            }
        }, s)), r);
        function o() {
            var a = i instanceof Element ? i : document.querySelector(i);
            a.appendChild(n.base),
            n.onMount(a)
        }
        return document.readyState !== "loading" ? o() : document.addEventListener("DOMContentLoaded", o),
        n
    };
    return t.prototype = e.prototype,
    Object.assign(t, e),
    t.__component = e,
    t
}
var Ky = function(e) {
    function t(i) {
        var s = this;
        e.call(this, i),
        this.colors = [],
        this.inputActive = !1,
        this.events = {},
        this.activeEvents = {},
        this.deferredEvents = {},
        this.id = i.id;
        var n = i.colors.length > 0 ? i.colors : [i.color];
        n.forEach(function(r) {
            return s.addColor(r)
        }),
        this.setActiveColor(0),
        this.state = Object.assign({}, i, {
            color: this.color,
            colors: this.colors,
            layout: i.layout
        })
    }
    return e && (t.__proto__ = e),
    t.prototype = Object.create(e && e.prototype),
    t.prototype.constructor = t,
    t.prototype.addColor = function(s, n) {
        n === void 0 && (n = this.colors.length);
        var r = new co(s,this.onColorChange.bind(this));
        this.colors.splice(n, 0, r),
        this.colors.forEach(function(o, a) {
            return o.index = a
        }),
        this.state && this.setState({
            colors: this.colors
        }),
        this.deferredEmit("color:init", r)
    }
    ,
    t.prototype.removeColor = function(s) {
        var n = this.colors.splice(s, 1)[0];
        n.unbind(),
        this.colors.forEach(function(r, o) {
            return r.index = o
        }),
        this.state && this.setState({
            colors: this.colors
        }),
        n.index === this.color.index && this.setActiveColor(0),
        this.emit("color:remove", n)
    }
    ,
    t.prototype.setActiveColor = function(s) {
        this.color = this.colors[s],
        this.state && this.setState({
            color: this.color
        }),
        this.emit("color:setActive", this.color)
    }
    ,
    t.prototype.setColors = function(s) {
        var n = this;
        this.colors.forEach(function(r) {
            return r.unbind()
        }),
        this.colors = [],
        s.forEach(function(r) {
            return n.addColor(r)
        }),
        this.setActiveColor(0),
        this.emit("color:setAll", this.colors)
    }
    ,
    t.prototype.on = function(s, n) {
        var r = this
          , o = this.events;
        (Array.isArray(s) ? s : [s]).forEach(function(a) {
            (o[a] || (o[a] = [])).push(n),
            r.deferredEvents[a] && (r.deferredEvents[a].forEach(function(l) {
                n.apply(null, l)
            }),
            r.deferredEvents[a] = [])
        })
    }
    ,
    t.prototype.off = function(s, n) {
        var r = this;
        (Array.isArray(s) ? s : [s]).forEach(function(o) {
            var a = r.events[o];
            a && a.splice(a.indexOf(n), 1)
        })
    }
    ,
    t.prototype.emit = function(s) {
        for (var n = this, r = [], o = arguments.length - 1; o-- > 0; )
            r[o] = arguments[o + 1];
        var a = this.activeEvents
          , l = a.hasOwnProperty(s) ? a[s] : !1;
        if (!l) {
            a[s] = !0;
            var c = this.events[s] || [];
            c.forEach(function(h) {
                return h.apply(n, r)
            }),
            a[s] = !1
        }
    }
    ,
    t.prototype.deferredEmit = function(s) {
        for (var n, r = [], o = arguments.length - 1; o-- > 0; )
            r[o] = arguments[o + 1];
        var a = this.deferredEvents;
        (n = this).emit.apply(n, [s].concat(r)),
        (a[s] || (a[s] = [])).push(r)
    }
    ,
    t.prototype.setOptions = function(s) {
        this.setState(Object.assign({}, this.state, s))
    }
    ,
    t.prototype.resize = function(s) {
        this.setOptions({
            width: s
        })
    }
    ,
    t.prototype.reset = function() {
        this.colors.forEach(function(s) {
            return s.reset()
        }),
        this.setState({
            colors: this.colors
        })
    }
    ,
    t.prototype.onMount = function(s) {
        this.el = s,
        this.deferredEmit("mount", this)
    }
    ,
    t.prototype.onColorChange = function(s, n) {
        this.setState({
            color: this.color
        }),
        this.inputActive && (this.inputActive = !1,
        this.emit("input:change", s, n)),
        this.emit("color:change", s, n)
    }
    ,
    t.prototype.emitInputEvent = function(s, n) {
        s === 0 ? this.emit("input:start", this.color, n) : s === 1 ? this.emit("input:move", this.color, n) : s === 2 && this.emit("input:end", this.color, n)
    }
    ,
    t.prototype.render = function(s, n) {
        var r = this
          , o = n.layout;
        if (!Array.isArray(o)) {
            switch (o) {
            default:
                o = [{
                    component: Yy
                }, {
                    component: Fc
                }]
            }
            n.transparency && o.push({
                component: Fc,
                options: {
                    sliderType: "alpha"
                }
            })
        }
        return Lt("div", {
            class: "IroColorPicker",
            id: n.id,
            style: {
                display: n.display
            }
        }, o.map(function(a, l) {
            var c = a.component
              , h = a.options;
            return Lt(c, Object.assign({}, n, h, {
                ref: void 0,
                onInput: r.emitInputEvent.bind(r),
                parent: r,
                index: l
            }))
        }))
    }
    ,
    t
}(bo);
Ky.defaultProps = Object.assign({}, v7, {
    colors: [],
    display: "block",
    id: null,
    layout: "default",
    margin: null
});
var x7 = b7(Ky), Wd;
(function(e) {
    e.version = "5.3.1",
    e.Color = co,
    e.ColorPicker = x7,
    function(t) {
        t.h = Lt,
        t.ComponentBase = Sh,
        t.Handle = Ir,
        t.Slider = Fc,
        t.Wheel = Yy,
        t.Box = _7
    }(e.ui || (e.ui = {}))
}
)(Wd || (Wd = {}));
var $l = Wd;
const w7 = {
    name: "color-picker",
    props: {
        currTheme: String
    },
    components: {
        "theme-slider": Oy,
        "theme-switch": Ly
    },
    setup(e, {emit: t}) {
        const i = Ft(()=>GN[yi("locale").value]);
        let s = null;
        const n = ut(null)
          , r = ut("")
          , o = ut(1)
          , a = Ft(()=>r.value.slice(1))
          , l = Ft(()=>({
            backgroundColor: r.value,
            opacity: o.value
        }));
        let c = !1;
        const h = ut(!1)
          , u = ut("")
          , d = ut(!1)
          , f = ut(null)
          , p = ut("25")
          , m = ut("0")
          , g = ut(!1)
          , y = ut(null);
        let x = null;
        function v(P) {
            const N = parseInt(P, 16);
            return {
                r: N >> 16 & 255,
                g: N >> 8 & 255,
                b: N & 255
            }
        }
        function _({target: P}) {
            const {value: N} = P;
            /^#([a-fA-F\d]{6}|[a-fA-F\d]{3})$/.test(N) ? s.color.set({
                ...v(N.slice(1)),
                a: o.value
            }) : P.value = r.value
        }
        function C() {
            t("regain")
        }
        function k(P) {
            f.value = P,
            L()
        }
        function S(P) {
            y.value = y.value & 3 | P << 2,
            L()
        }
        function T({target: P}) {
            const {value: N} = P;
            /^(0(\.\d{1,2})?|1(\.0{1,2})?)$/.test(N) ? s.color.setChannel("rgba", "a", N) : P.value = o.value
        }
        function L() {
            if (!x || c)
                return;
            const P = B[x];
            g.value ? t("changeVal", [a.value, o.value, f.value, y.value]) : d.value ? t("changeVal", [a.value, o.value, f.value, P[3]]) : h.value ? t("changeVal", [a.value, o.value, u.value]) : t("changeVal", [a.value, o.value])
        }
        function D({hexString: P, alpha: N}) {
            o.value = N,
            (r.value || P !== "#ffffff") && (r.value = P),
            L()
        }
        function O() {
            t("changeVal", [a.value, o.value, u.value])
        }
        function K(P) {
            c = !0,
            x = P;
            const N = B[P];
            P == "BackgroundImage" ? (h.value = !0,
            u.value = N[2]) : h.value = !1,
            N.length == 4 ? (d.value = !0,
            f.value = N[2]) : d.value = !1,
            N[3] & 2 ? m.value = "10" : m.value = "0",
            N[3] & 1 ? (g.value = !0,
            y.value = N[3]) : g.value = !1;
            const [W,V] = N;
            W ? (r.value = `#${W}`,
            o.value = V,
            s.color.set({
                ...v(W),
                a: V
            })) : (r.value = W,
            o.value = V,
            s.color.set({
                r: 255,
                g: 255,
                b: 255,
                a: V
            })),
            c = !1
        }
        return Ve(()=>{
            s = new $l.ColorPicker(n.value,{
                width: 205,
                padding: -2,
                margin: 36,
                handleRadius: 9,
                layoutDirection: "horizontal",
                layout: [{
                    component: $l.ui.Wheel,
                    options: {
                        borderWidth: 1
                    }
                }, {
                    component: $l.ui.Slider,
                    options: {
                        sliderType: "value"
                    }
                }, {
                    component: $l.ui.Slider,
                    options: {
                        sliderType: "alpha"
                    }
                }]
            }),
            s.on("color:change", D)
        }
        ),
        {
            t: i,
            pickerEl: n,
            hex: r,
            alpha: o,
            showBgUrl: h,
            url: u,
            style: l,
            showSize: d,
            size: f,
            max: p,
            min: m,
            showSwitch: g,
            teamColor: y,
            regain: C,
            hexCheck: _,
            alphaCheck: T,
            sizeCheck: k,
            switchCheck: S,
            backgroundChange: O,
            bind: K
        }
    }
}
  , T7 = {
    class: "color-picker"
}
  , E7 = {
    class: "picker-container"
}
  , S7 = {
    ref: "pickerEl"
}
  , C7 = {
    class: "picker-input"
}
  , A7 = ["value"]
  , I7 = ["value"]
  , M7 = {
    class: "picker-input"
}
  , R7 = ["placeholder"];
function k7(e, t, i, s, n, r) {
    const o = se("theme-slider")
      , a = se("theme-switch");
    return st(),
    nt("div", T7, [b("button", {
        class: "btn btn-dark rounded-0 default-btn",
        onClick: t[0] || (t[0] = (...l)=>s.regain && s.regain(...l))
    }, Dt(s.t.default), 1), b("div", E7, [b("div", S7, null, 512)]), b("div", C7, [b("div", {
        class: "color-preview",
        style: jt(s.style)
    }, null, 4), b("input", {
        class: "rounded-0 form-control menu-input hex-input",
        type: "text",
        value: s.hex,
        onBlur: t[1] || (t[1] = (...l)=>s.hexCheck && s.hexCheck(...l))
    }, null, 40, A7), b("input", {
        class: "rounded-0 form-control menu-input alpha-input",
        type: "text",
        value: s.alpha,
        onBlur: t[2] || (t[2] = (...l)=>s.alphaCheck && s.alphaCheck(...l))
    }, null, 40, I7)]), ee(b("div", M7, [ee(b("input", {
        class: "rounded-0 form-control menu-input background-input",
        type: "text",
        placeholder: s.t.bgUrl,
        maxlength: "128",
        "onUpdate:modelValue": t[3] || (t[3] = l=>s.url = l),
        onBlur: t[4] || (t[4] = (...l)=>s.backgroundChange && s.backgroundChange(...l))
    }, null, 40, R7), [[nr, s.url]])], 512), [[ye, s.showBgUrl]]), ee(X(o, {
        class: "theme-slider",
        name: s.t.size,
        min: s.min,
        max: s.max,
        step: "0.5",
        val: s.size,
        onChangeVal: t[5] || (t[5] = l=>s.sizeCheck(l))
    }, null, 8, ["name", "min", "max", "step", "val"]), [[ye, s.showSize]]), ee(X(a, {
        class: "theme-switch",
        name: s.t.teamColor,
        val: s.teamColor & 4,
        onChangeVal: t[6] || (t[6] = l=>s.switchCheck(l))
    }, null, 8, ["name", "val"]), [[ye, s.showSwitch]])])
}
var P7 = ue(w7, [["render", k7], ["__scopeId", "data-v-e190b4ce"]]);
const L7 = {
    name: "theme-radio",
    props: {
        id: String,
        checked: Number,
        options: Array
    },
    setup(e, {emit: t}) {
        function i(s) {
            t("changeVal", Number(s.target.value))
        }
        return {
            change: i
        }
    }
}
  , O7 = {
    class: "radio-row"
}
  , D7 = {
    class: "radio-box"
}
  , N7 = ["id", "value", "checked"]
  , F7 = ["for"];
function B7(e, t, i, s, n, r) {
    return st(),
    nt("div", O7, [b("div", D7, [(st(!0),
    nt(Nt, null, Jt(i.options, (o,a)=>(st(),
    nt("div", {
        class: "radio-btn",
        key: a
    }, [b("input", {
        type: "radio",
        id: "radio-" + i.id + a,
        value: a,
        checked: i.checked === a,
        onChange: t[0] || (t[0] = (...l)=>s.change && s.change(...l))
    }, null, 40, N7), b("label", {
        for: "radio-" + i.id + a
    }, Dt(o), 9, F7)]))), 128))])])
}
var U7 = ue(L7, [["render", B7], ["__scopeId", "data-v-6e5a62d6"]]);
const G7 = {
    name: "theme-pane",
    components: {
        "common-select": vp,
        "sub-nav": _p,
        "btn-group": yp,
        "dividing-line": bp,
        "picker-button": DN,
        "color-picker": P7,
        "theme-radio": U7
    },
    setup() {
        const e = Ft(()=>RN[yi("locale").value])
          , t = Ft(()=>[{
            href: "theme-entity-tab",
            text: e.value.display.name,
            func: ()=>f(0),
            active: !0
        }, {
            href: "theme-background-tab",
            text: e.value.map.name,
            func: ()=>f(1)
        }, {
            href: "theme-hud-tab",
            text: "HUD",
            func: ()=>f(2)
        }])
          , i = ut(0);
        function s(y) {
            i.value = y,
            f(0, y * 2 + 6)
        }
        const n = ut(-1)
          , r = _i([0, 0, 0, 0])
          , o = ut(null)
          , a = new Map;
        let l = 0
          , c = 0;
        const h = e.value.content;
        Object.keys(nc).forEach(y=>{
            const x = h[l]
              , v = l == 0 ? 24 : x.length;
            c < v || (l++,
            c = 0),
            a.set(l + "-" + c, y),
            c++
        }
        );
        const u = ut(null);
        function d(y, x) {
            return {
                backgroundColor: n.value === y && r[y] === x ? "var(--slider-selection-color)" : "rgba(20, 20, 20, 0.15)"
            }
        }
        function f(y, x) {
            n.value = y,
            arguments.length === 2 ? r[y] = x : x = r[y],
            u.value = a.get(y + "-" + x),
            o.value.bind(u.value)
        }
        function p(y) {
            const x = u.value;
            B[x] = y,
            A.emit(Ht[x]),
            localStorage.setItem("theme_data", JSON.stringify(B))
        }
        function m() {
            const y = u.value;
            B[y] = nc[y],
            A.emit(Ht[y]),
            localStorage.setItem("theme_data", JSON.stringify(B)),
            o.value.bind(u.value)
        }
        function g() {
            const y = n.value
              , x = h[y]
              , v = y == 0 ? 23 : x.length;
            for (let _ = 0; _ < v; _++) {
                const C = a.get(y + "-" + _);
                console.log(C),
                B[C] = nc[C],
                A.emit(Ht[C])
            }
            localStorage.setItem("theme_data", JSON.stringify(B)),
            o.value.bind(u.value)
        }
        return Ve(()=>f(0, 0)),
        {
            t: e,
            tabs: t,
            playerType: i,
            playerTypeChange: s,
            picker: o,
            currTheme: u,
            backgroundColor: d,
            coordChange: f,
            change: p,
            regain: m,
            reset: g
        }
    }
}
  , Ip = e=>(gs("data-v-7a02e428"),
e = e(),
vs(),
e)
  , H7 = {
    class: "tab-pane",
    id: "setting-theme"
}
  , V7 = {
    class: "tab-content"
}
  , z7 = {
    class: "tab-pane active",
    id: "theme-entity-tab"
}
  , $7 = {
    class: "container-inline"
}
  , j7 = {
    class: "container-col picker-col"
}
  , W7 = Ip(()=>b("div", {
    class: "container-col picker-col"
}, null, -1))
  , X7 = {
    class: "tab-pane",
    id: "theme-background-tab"
}
  , Y7 = {
    class: "container-inline"
}
  , K7 = {
    class: "container-col picker-col"
}
  , Z7 = Ip(()=>b("div", {
    class: "container-col picker-col"
}, null, -1))
  , q7 = {
    class: "tab-pane",
    id: "theme-hud-tab"
}
  , J7 = {
    class: "container-inline"
}
  , Q7 = {
    class: "container-col picker-col"
}
  , t9 = Ip(()=>b("div", {
    class: "container-col picker-col"
}, null, -1));
function e9(e, t, i, s, n, r) {
    const o = se("sub-nav")
      , a = se("dividing-line")
      , l = se("theme-radio")
      , c = se("btn-group")
      , h = se("picker-button")
      , u = se("color-picker");
    return st(),
    nt("div", H7, [X(o, {
        tabs: s.tabs
    }, null, 8, ["tabs"]), b("div", V7, [b("div", z7, [b("div", $7, [b("div", j7, [X(a, {
        name: s.t.display.divide.basic
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(6, (d,f)=>X(Ne("picker-button"), {
        style: jt(s.backgroundColor(0, f)),
        key: f,
        name: s.t.content[0][f],
        onClick: p=>s.coordChange(0, f)
    }, null, 8, ["style", "name", "onClick"])), 64)), X(a, {
        name: s.t.display.divide.player
    }, null, 8, ["name"]), X(l, {
        id: "tPlayerType",
        checked: s.playerType,
        options: s.t.playerType,
        onChangeVal: s.playerTypeChange
    }, null, 8, ["checked", "options", "onChangeVal"]), (st(),
    nt(Nt, null, Jt(3, (d,f)=>X(Ne("picker-button"), {
        style: jt(s.backgroundColor(0, f + 6 + s.playerType * 3)),
        key: f + 6 + s.playerType * 3,
        name: s.t.content[0][f + 6],
        onClick: p=>s.coordChange(0, f + 6 + s.playerType * 3)
    }, null, 8, ["style", "name", "onClick"])), 64)), X(a, {
        name: s.t.display.divide.assistance
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(6, (d,f)=>X(Ne("picker-button"), {
        style: jt(s.backgroundColor(0, f + 18)),
        key: f + 18,
        name: s.t.content[0][f + 9],
        onClick: p=>s.coordChange(0, f + 18)
    }, null, 8, ["style", "name", "onClick"])), 64))]), W7]), X(c, {
        reset: !0,
        onOnReset: s.reset
    }, null, 8, ["onOnReset"])]), b("div", X7, [b("div", Y7, [b("div", K7, [X(a, {
        name: s.t.map.divide.basic
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(6, (d,f)=>X(Ne("picker-button"), {
        style: jt(s.backgroundColor(1, f)),
        key: f,
        name: s.t.content[1][f],
        onClick: p=>s.coordChange(1, f)
    }, null, 8, ["style", "name", "onClick"])), 64))]), Z7]), X(c, {
        reset: !0,
        onOnReset: s.reset
    }, null, 8, ["onOnReset"])]), b("div", q7, [b("div", J7, [b("div", Q7, [X(a, {
        name: s.t.HUD.divide.minimap
    }, null, 8, ["name"]), (st(),
    nt(Nt, null, Jt(7, (d,f)=>X(Ne("picker-button"), {
        style: jt(s.backgroundColor(2, f)),
        key: f,
        name: s.t.content[2][f],
        onClick: p=>s.coordChange(2, f)
    }, null, 8, ["style", "name", "onClick"])), 64)), X(a, {
        name: s.t.HUD.divide.leaderboard
    }, null, 8, ["name"]), X(h, {
        style: jt(s.backgroundColor(2, 7)),
        name: s.t.content[2][7],
        onClick: t[0] || (t[0] = d=>s.coordChange(2, 7))
    }, null, 8, ["style", "name"]), X(a, {
        name: s.t.HUD.divide.teamRankings
    }, null, 8, ["name"]), X(h, {
        style: jt(s.backgroundColor(2, 8)),
        name: s.t.content[2][8],
        onClick: t[1] || (t[1] = d=>s.coordChange(2, 8))
    }, null, 8, ["style", "name"]), X(a, {
        name: s.t.HUD.divide.perfPanel
    }, null, 8, ["name"]), X(h, {
        style: jt(s.backgroundColor(2, 9)),
        name: s.t.content[2][9],
        onClick: t[2] || (t[2] = d=>s.coordChange(2, 9))
    }, null, 8, ["style", "name"])]), t9]), X(c, {
        reset: !0,
        onOnReset: s.reset
    }, null, 8, ["onOnReset"])])]), X(u, {
        ref: "picker",
        currTheme: s.currTheme,
        onChangeVal: s.change,
        onRegain: s.regain
    }, null, 8, ["currTheme", "onChangeVal", "onRegain"])])
}
var i9 = ue(G7, [["render", e9], ["__scopeId", "data-v-7a02e428"]]);
const s9 = {
    name: "setting-menu",
    components: {
        "gamesetting-pane": RD,
        "hotkey-pane": SN,
        "theme-pane": i9
    },
    setup() {
        function e(t) {
            document.getElementById("setting-gamesetting").classList.remove("show", "active"),
            document.getElementById("setting-hotkey").classList.remove("show", "active"),
            document.getElementById("setting-theme").classList.remove("show", "active"),
            document.getElementById(t).classList.add("show", "active")
        }
        return {
            click: e
        }
    }
}
  , Zy = e=>(gs("data-v-2a52a778"),
e = e(),
vs(),
e)
  , n9 = {
    id: "setting-menu",
    action: "javascript:;"
}
  , r9 = {
    class: "nav setting-nav"
}
  , o9 = Zy(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "24",
    height: "24",
    fill: "var(--main-theme-color)"
}, [b("path", {
    d: "M800 128c57.6 32 96 83.2 121.6 140.8 12.8 32 25.6 64 32 96 12.8 32 19.2 70.4 25.6 108.8 6.4 38.4 12.8 70.4 12.8 108.8 0 32 6.4 70.4 6.4 102.4 0 25.6-6.4 51.2-19.2 76.8-38.4 76.8-121.6 102.4-198.4 64-25.6-12.8-38.4-25.6-51.2-44.8-12.8-19.2-25.6-32-32-51.2-19.2-38.4-44.8-70.4-76.8-89.6-57.6-38.4-160-38.4-217.6 0-32 19.2-51.2 51.2-76.8 89.6-6.4 19.2-19.2 38.4-32 51.2-12.8 19.2-32 32-51.2 44.8-108.8 51.2-211.2-25.6-217.6-140.8 0-32 0-70.4 6.4-102.4 0-32 6.4-70.4 12.8-108.8 0-38.4 12.8-70.4 19.2-108.8 6.4-32 19.2-64 32-96 32-57.6 70.4-108.8 128-140.8 76.8-44.8 147.2-38.4 217.6-32 25.6 0 44.8 6.4 70.4 6.4 25.6 0 44.8 0 70.4-6.4 76.8-6.4 140.8-12.8 217.6 32zM454.4 492.8c-12.8 0-25.6-12.8-25.6-19.2 6.4-12.8 12.8-25.6 25.6-25.6h115.2c12.8 0 25.6 12.8 25.6 25.6s-12.8 19.2-25.6 19.2H454.4z m0-204.8c-12.8 0-25.6-12.8-25.6-19.2 0-12.8 12.8-25.6 25.6-25.6h115.2c12.8 0 25.6 12.8 25.6 25.6s-12.8 19.2-25.6 19.2H454.4z m-153.6-25.6c0-12.8 12.8-25.6 19.2-25.6 12.8 0 25.6 12.8 25.6 25.6v83.2h83.2c12.8 0 19.2 6.4 19.2 19.2 0 12.8-12.8 25.6-25.6 25.6H345.6v83.2c0 12.8-12.8 25.6-25.6 25.6s-19.2-12.8-19.2-25.6V390.4H224c-12.8 0-19.2-12.8-19.2-25.6s12.8-25.6 19.2-25.6h83.2V262.4h-6.4z m403.2 0c19.2 0 38.4 19.2 38.4 38.4s-19.2 38.4-38.4 38.4-38.4-19.2-38.4-38.4 19.2-38.4 38.4-38.4z m-25.6 102.4c0 19.2-19.2 38.4-38.4 38.4s-38.4-19.2-38.4-38.4 19.2-38.4 38.4-38.4c19.2 6.4 38.4 19.2 38.4 38.4z m25.6 32c19.2 0 38.4 19.2 38.4 38.4s-19.2 38.4-38.4 38.4-38.4-19.2-38.4-38.4c0-25.6 19.2-38.4 38.4-38.4z m102.4-32c0 19.2-19.2 38.4-38.4 38.4s-38.4-19.2-38.4-38.4 19.2-38.4 38.4-38.4c25.6 6.4 38.4 19.2 38.4 38.4zM761.6 192c-57.6-32-115.2-25.6-172.8-19.2H512c-25.6 0-51.2 0-76.8-6.4-64 0-121.6-6.4-172.8 25.6-44.8 25.6-76.8 64-96 108.8-12.8 25.6-19.2 57.6-32 83.2-6.4 32-12.8 70.4-19.2 102.4-6.4 32-6.4 64-12.8 102.4 0 32-6.4 64 0 96 0 19.2 6.4 32 12.8 44.8 25.6 57.6 89.6 51.2 128 6.4 0-12.8 12.8-32 19.2-44.8 25.6-51.2 57.6-89.6 96-115.2 83.2-57.6 217.6-57.6 300.8 0 38.4 25.6 70.4 64 96 115.2 6.4 12.8 19.2 32 25.6 38.4 38.4 44.8 102.4 51.2 128-6.4 6.4-12.8 12.8-25.6 12.8-44.8V582.4c0-32-6.4-64-12.8-102.4-6.4-32-12.8-64-25.6-102.4-6.4-32-19.2-64-32-89.6-12.8-32-44.8-70.4-89.6-96z",
    fill: "",
    "p-id": "31375"
})], -1))
  , a9 = [o9]
  , l9 = Zy(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    fill: "var(--main-theme-color)",
    width: "24",
    height: "24"
}, [b("path", {
    d: "M870.108 408.615 870.108 307.646 769.139 307.646l0 100.969L870.108 408.615zM870.108 562.453 870.108 461.484 769.139 461.484l0 100.969L870.108 562.453zM716.27 408.615 716.27 307.646 615.301 307.646l0 100.969L716.27 408.615zM716.27 562.453 716.27 461.484 615.301 461.484l0 100.969L716.27 562.453zM716.27 769.212 716.27 665.832 307.625 665.832l0 103.379L716.27 769.211zM254.756 408.615 254.756 307.646 153.787 307.646l0 100.969L254.756 408.615zM254.756 562.453 254.756 461.484 153.787 461.484l0 100.969L254.756 562.453zM307.676 461.535l0 100.969 100.969 0L408.645 461.535 307.676 461.535zM307.676 307.697l0 100.969 100.969 0L408.645 307.697 307.676 307.697zM461.514 461.535l0 100.969 100.969 0L562.483 461.535 461.514 461.535zM461.514 307.697l0 100.969 100.969 0L562.483 307.697 461.514 307.697zM923.028 153.859c27.246 0 50.886 10.017 70.919 30.05s30.05 43.673 30.05 70.919l0 514.383c0 27.246-10.017 50.886-30.05 70.919s-43.673 30.05-70.919 30.05L100.969 870.18c-27.246 0-50.886-10.017-70.919-30.05S0 796.458 0 769.212L0 254.828c0-27.246 10.017-50.886 30.05-70.919s43.673-30.05 70.919-30.05L923.028 153.859z"
})], -1))
  , c9 = [l9]
  , h9 = ih('<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" fill="var(--main-theme-color)" width="24" height="24" data-v-2a52a778><path d="M517.78756813 963.02833313c-248.20624839 0-450.14412281-201.93786116-450.14412292-450.14412274s201.93786116-450.14412281 450.14412292-450.14412293 450.14412281 201.93786116 450.14412269 450.14412293c0 110.01201254-54.54782202 174.46299818-176.8584166 208.99548464-18.13438105 5.1444977-34.40386711 7.25053268-56.09117547 7.25053245-7.3469941 0-15.54605323-0.24115299-25.04729943-0.67521515a469.43601209 469.43601209 0 0 0-20.4493977-0.51445125c-36.55813255 0-45.46455228 5.56250078-59.16180948 26.09228721-12.13781811 18.19868433-15.41743385 34.01803535 3.68154668 61.05883651 1.55942577 2.21856863 3.05100963 4.38890686 5.11233931 6.97723435l5.56250076 7.29876343c17.10547892 22.47505743 31.49401053 45.49671041 19.9349601 79.64335214l-1.89704011 5.59464564-3.42430764 4.8229824C629.53584301 961.27598479 594.40853004 963.02833313 517.78756813 963.02833313z m0-819.90536181c-203.88313189 0-369.76123919 165.87810694-369.76123914 369.76123907s165.87810694 369.76123919 369.76123914 369.76123899c37.2976513 0 55.09443111-0.90028283 64.30630705-2.79732269-0.41798999-0.57875404-0.90028283-1.18966641-1.38258884-1.81665161l-5.53034276-7.25053241a322.01381491 322.01381491 0 0 1-6.88077321-9.3726402c-36.23660395-51.26820641-37.89249105-102.4238655-4.87119975-151.95579598 34.24310269-51.34858158 75.05799728-61.89481598 126.04034521-61.894816 7.45952764 0 15.43350624 0.22506734 24.05055567 0.61089915 26.68711402 1.17359408 39.86990654 0.83597968 55.65711286-3.64937491 88.51762698-24.98299647 118.35575041-58.18112471 118.35575039-131.63500434 0.01607252-203.88313189-165.84594893-369.76123919-369.74516662-369.76123907z" data-v-2a52a778></path><path d="M300.75380167 440.53962147m-56.26802518 0a56.26801236 56.26801236 0 1 0 112.53603734 0 56.26801236 56.26801236 0 1 0-112.53603734 0Z" data-v-2a52a778></path><path d="M734.82133467 440.53962147m-56.26801214 0a56.26801236 56.26801236 0 1 0 112.53603733 0 56.26801236 56.26801236 0 1 0-112.53603733 0Z" data-v-2a52a778></path><path d="M429.3664027 295.85044411m-56.26801231 0a56.26801236 56.26801236 0 1 0 112.53602443 0 56.26801236 56.26801236 0 1 0-112.53602443 0Z" data-v-2a52a778></path><path d="M606.2087337 295.85044411m-56.26801201 0a56.26801236 56.26801236 0 1 0 112.5360242 0 56.26801236 56.26801236 0 1 0-112.5360242 0Z" data-v-2a52a778></path></svg>', 1)
  , u9 = [h9]
  , d9 = {
    class: "tab-content setting-container"
};
function f9(e, t, i, s, n, r) {
    const o = se("gamesetting-pane")
      , a = se("hotkey-pane")
      , l = se("theme-pane");
    return st(),
    nt("div", n9, [b("nav", r9, [b("a", {
        class: "nav-link active",
        onClick: t[0] || (t[0] = c=>s.click("setting-gamesetting")),
        "data-bs-toggle": "pill"
    }, a9), b("a", {
        class: "nav-link",
        onClick: t[1] || (t[1] = c=>s.click("setting-hotkey")),
        "data-bs-toggle": "pill"
    }, c9), b("a", {
        class: "nav-link",
        onClick: t[2] || (t[2] = c=>s.click("setting-theme")),
        "data-bs-toggle": "pill"
    }, u9)]), b("div", d9, [X(o), X(a), X(l)])])
}
var p9 = ue(s9, [["render", f9], ["__scopeId", "data-v-2a52a778"]]);
const m9 = {
    global: "\u5168\u670D",
    all: "\u5168\u90E8",
    team: "\u961F\u4F0D",
    server: "\u670D\u52A1\u5668"
}
  , g9 = {
    global: "\u5168\u670D",
    all: "\u5168\u90E8",
    team: "\u968A\u4F0D",
    server: "\u4F3A\u670D\u5668"
}
  , v9 = {
    global: "\u30B0\u30ED\u30FC\u30D0\u30EB",
    all: "\u5168\u3066",
    team: "\u30C1\u30FC\u30E0",
    server: "\u30B5\u30FC\u30D0\u30FC"
}
  , _9 = {
    global: "GLOBAL",
    all: "ALL",
    team: "TEAM",
    server: "SERVER"
};
var qy = {
    zh_CN: m9,
    zh: g9,
    ja: v9,
    en: _9
};
const y9 = {
    name: "chat-text",
    props: {
        time: String,
        type: Number,
        nick: String,
        msg: String,
        skin: String,
        player: Object
    },
    setup(e) {
        const t = Ft(()=>e.type == 4)
          , i = e.type != 4
          , s = Ft(()=>{
            const n = qy[yi("locale").value]
              , r = o=>"[" + o + "]";
            return [r(n.global), r(n.all), r(n.team), r(n.private), n.server]
        }
        );
        return {
            emitter: A,
            showType: t,
            nonServer: i,
            displayTypes: s
        }
    }
}
  , b9 = {
    class: "chat-text"
}
  , x9 = {
    class: "chat-time"
}
  , w9 = {
    class: "chat-msg"
};
function T9(e, t, i, s, n, r) {
    return st(),
    nt("p", b9, [b("span", x9, Dt(i.time), 1), ee(b("span", {
        class: "chat-skin",
        style: jt({
            "background-image": i.skin
        }),
        onClick: t[0] || (t[0] = o=>s.emitter.emit("checkPlayer", i.player))
    }, null, 4), [[ye, i.skin]]), ee(b("span", {
        class: "chat-type"
    }, Dt(s.displayTypes[i.type]), 513), [[ye, s.showType]]), ee(b("span", {
        class: "chat-nick"
    }, Dt(" " + i.nick + " "), 513), [[ye, s.nonServer]]), b("span", w9, Dt(i.msg), 1)])
}
var E9 = ue(y9, [["render", T9], ["__scopeId", "data-v-7bc95e5d"]]);
const S9 = {
    name: "common-select",
    props: {
        class: String,
        selected: {
            type: Number,
            default: 0
        },
        options: {
            type: Array,
            default: []
        }
    },
    setup(e, {emit: t}) {
        const i = ut(null)
          , s = Ft(()=>e.options.length * -32.5 + "px")
          , n = Ft(()=>e.selected * -32.5 + "px")
          , r = ut("(0deg)");
        let o = !1;
        function a() {
            i.value.classList.contains("open") || i.value.classList.add("open"),
            i.value.style.cssText = "--t:" + s.value,
            r.value = "(180deg)"
        }
        function l() {
            o || (i.value.classList.remove("open"),
            i.value.style.cssText = "--t: 32.5px",
            r.value = "(0deg)")
        }
        function c(h) {
            h !== e.selected && (t("change", h),
            o = !0,
            setTimeout(()=>{
                i.value.classList.remove("open"),
                o = !1,
                l()
            }
            , 240))
        }
        return Ve(()=>{
            i.value.classList.add(e.class),
            i.value.style.cssText = "--t: 32.5px"
        }
        ),
        {
            o: s,
            t: n,
            r,
            menu: i,
            open: a,
            close: l,
            change: c
        }
    }
}
  , C9 = e=>(gs("data-v-4aa2d6e5"),
e = e(),
vs(),
e)
  , A9 = {
    "data-menu": ""
}
  , I9 = ["value", "selected"]
  , M9 = C9(()=>b("path", {
    d: "M533.333333 465.066667L358.4 640 298.666667 580.266667l234.666666-234.666667 234.666667 234.666667-64 59.733333-170.666667-174.933333z"
}, null, -1))
  , R9 = [M9]
  , k9 = ["onClick"];
function P9(e, t, i, s, n, r) {
    return st(),
    nt("div", {
        class: "select-menu rounded-0",
        ref: "menu",
        tabindex: "-1",
        onBlur: t[1] || (t[1] = (...o)=>s.close && s.close(...o))
    }, [b("select", A9, [(st(!0),
    nt(Nt, null, Jt(i.options, (o,a)=>(st(),
    nt("option", {
        key: a,
        value: a,
        selected: i.selected === a
    }, Dt(o), 9, I9))), 128))]), b("div", {
        class: "select-button",
        style: jt({
            "--t": s.t
        }),
        onClick: t[0] || (t[0] = (...o)=>s.open && s.open(...o))
    }, [(st(),
    nt("svg", {
        class: "select-status",
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        fill: "#707070",
        style: jt({
            transform: "rotateZ" + s.r
        })
    }, R9, 4)), b("ul", null, [(st(!0),
    nt(Nt, null, Jt(i.options, (o,a)=>(st(),
    nt("li", {
        key: a
    }, Dt(o), 1))), 128))])], 4), b("ul", null, [(st(!0),
    nt(Nt, null, Jt(i.options, (o,a)=>(st(),
    nt("li", {
        key: a,
        onClick: l=>s.change(a)
    }, Dt(o), 9, k9))), 128))])], 544)
}
var Jy = ue(S9, [["render", P9], ["__scopeId", "data-v-4aa2d6e5"]]);
const L9 = {
    name: "chat-input",
    components: {
        "common-select": Jy
    },
    props: {
        type: Number,
        toId: Number
    },
    setup(e, {emit: t}) {
        const i = ut(null)
          , s = ut(0)
          , n = ut("")
          , r = new $t(()=>{
            if (s.value ^= 1,
            !s.value) {
                if (document.querySelector("canvas").focus(),
                n.value) {
                    if (at.SANDBOX && n.value == "/tp") {
                        U.tp ^= 1;
                        const u = `INFO: 
TP mode ` + (U.tp ? "enabled" : "disabled");
                        A.emit("receiveChatMsg", {
                            type: 4,
                            id: 0,
                            msg: u
                        })
                    } else
                        n.value.charAt(0) == "/" ? (at.writer.writeUint8(25).writeStringUTF8(n.value),
                        at.send()) : e.type == 3 ? (at.writer.writeUint8(24).writeUint8(3).writeStringUTF8(n.value).writeUint16(e.toId),
                        at.send()) : e.type != 0 && (at.writer.writeUint8(24).writeUint8(e.type).writeStringUTF8(n.value),
                        at.send());
                    n.value = ""
                }
                a()
            }
        }
        );
        function o() {
            t("show")
        }
        function a() {
            t("hide"),
            s.value = 0,
            A.emit("focusGameCanvas")
        }
        let l = !1;
        function c(u) {
            if (l)
                return;
            const {code: d} = u;
            (d === "Enter" || d === "NumpadEnter") && r.execute(),
            d === "Tab" && u.preventDefault()
        }
        function h(u) {
            if (l)
                return;
            const {code: d} = u;
            (d === "Enter" || d === "NumpadEnter") && r.end(),
            d === "Tab" && u.preventDefault()
        }
        return Ve(()=>{
            document.addEventListener("keydown", c),
            document.addEventListener("keyup", h),
            document.addEventListener("compositionstart", ()=>l = !0),
            document.addEventListener("compositionend", ()=>l = !1)
        }
        ),
        Pr(()=>{
            s.value === 1 && i.value.focus()
        }
        ),
        {
            emitter: A,
            input: i,
            inputState: s,
            msg: n,
            focus: o,
            blur: a
        }
    }
}
  , O9 = {
    key: 0,
    id: "chat-input"
};
function D9(e, t, i, s, n, r) {
    return s.inputState ? (st(),
    nt("div", O9, [ee(b("input", {
        class: "btn-dark rounded-0 form-control",
        type: "text",
        maxlength: "256",
        size: "256",
        ref: "input",
        "onUpdate:modelValue": t[0] || (t[0] = o=>s.msg = o),
        onFocus: t[1] || (t[1] = (...o)=>s.focus && s.focus(...o))
    }, null, 544), [[nr, s.msg]])])) : FS("", !0)
}
var N9 = ue(L9, [["render", D9], ["__scopeId", "data-v-6677b75f"]]);
const F9 = {
    name: "notice-input",
    setup(e) {
        const t = ut("");
        A.on("syncNotice", l=>{
            t.value = U.notice
        }
        ),
        A.on("saveEdition", ()=>{
            A.emit("sendNotice", t.value)
        }
        );
        function i() {
            document.addEventListener("keydown", n),
            document.addEventListener("keyup", r),
            document.addEventListener("compositionstart", o),
            document.addEventListener("compositionend", a)
        }
        function s() {
            document.removeEventListener("keydown", n),
            document.removeEventListener("keyup", r),
            document.removeEventListener("compositionstart", o),
            document.removeEventListener("compositionend", a)
        }
        function n(l) {
            const {code: c} = l;
            c === "Tab" && l.preventDefault()
        }
        function r(l) {
            const {code: c} = l;
            c === "Tab" && l.preventDefault()
        }
        function o(l) {
            document.removeEventListener("keydown", n),
            document.removeEventListener("keyup", r)
        }
        function a(l) {
            document.addEventListener("keydown", n),
            document.addEventListener("keyup", r)
        }
        return {
            msg: t,
            focus: i,
            blur: s,
            compositionstart: o,
            compositionend: a
        }
    }
}
  , B9 = {
    class: "chat-input"
};
function U9(e, t, i, s, n, r) {
    return st(),
    nt("div", B9, [ee(b("textarea", {
        class: "btn-dark rounded-0 form-control",
        type: "text",
        maxlength: "256",
        size: "256",
        "onUpdate:modelValue": t[0] || (t[0] = o=>s.msg = o),
        onFocus: t[1] || (t[1] = (...o)=>s.focus && s.focus(...o)),
        onBlur: t[2] || (t[2] = (...o)=>s.blur && s.blur(...o))
    }, null, 544), [[nr, s.msg]])])
}
var G9 = ue(F9, [["render", U9], ["__scopeId", "data-v-547ea6a2"]]);
const Ch = ut([])
  , ja = ut(0);
let Xd = !1;
A.on("waitListUpdate", ()=>Xd = !0);
A.on("updateVueComp", ()=>{
    if (Xd) {
        const e = Ch.value;
        let t = 0;
        Vt.forEach(i=>{
            if (!i.isBot && i.enableChat) {
                if (ja.value && !i.isTeammate)
                    return;
                e[t++] = i
            }
        }
        ),
        Vt.forEach(i=>{
            if (!i.isBot && !i.enableChat) {
                if (ja.value && !i.isTeammate)
                    return;
                e[t++] = i
            }
        }
        ),
        e.length = t,
        Xd = !1
    }
}
);
const Mp = Ft(()=>{
    let e = 0;
    return Vt.forEach(t=>{
        if (t.activity) {
            if (ja.value && !t.isTeammate)
                return;
            e += 1
        }
    }
    ),
    e
}
)
  , Qy = Ft(()=>Ch.value.length - Mp.value)
  , H9 = {
    name: "chat-menu",
    components: {
        "notice-input": G9
    },
    props: {
        player: Object,
        options: Array
    },
    setup(e) {
        const t = ut(!1)
          , i = Ft(()=>{
            const f = e.player;
            return f ? f.id == U.id : !1
        }
        )
          , s = ut(!1);
        function n(f) {
            e.player.block = !0,
            xn.push(f.bfp),
            localStorage.setItem("blocked_users", JSON.stringify(xn))
        }
        function r(f) {
            e.player.block = !1,
            xn.splice(xn.indexOf(f.bfp), 1),
            localStorage.setItem("blocked_users", JSON.stringify(xn))
        }
        function o() {
            H.EnableChat ^= 1;
            const f = document.getElementById("chat-switch");
            H.EnableChat ? f.style.fill = "#33FF33" : f.style.fill = "#CC0000",
            A.emit("updateChatState"),
            localStorage.setItem("gconfig", JSON.stringify(H))
        }
        function a() {
            A.emit("syncNotice"),
            t.value = !0
        }
        function l() {
            A.emit("saveEdition"),
            t.value = !1
        }
        function c() {
            t.value = !1
        }
        function h(f) {
            ja.value = f
        }
        function u(f) {
            return f.enableChat ? "#33FF33" : "#CC0000"
        }
        function d(f) {
            const p = f.latency - 75
              , m = f.latency - 125
              , g = f.latency - 200
              , y = Math.max(Math.min(p / (125 - 75), 1), 0)
              , x = Math.max(Math.min(m / (200 - 125), 1), 0)
              , v = Math.max(Math.min(g / (300 - 200), 1), 0)
              , _ = 255 * y - 51 * x - 102 * v << 16 | 255 * (1 - x) << 8 | 0;
            return Qa(_)
        }
        return Ve(()=>{
            const f = document.getElementById("chat-switch");
            H.EnableChat ? f.style.fill = "#33FF33" : f.style.fill = "#CC0000"
        }
        ),
        Pr(()=>{}
        ),
        {
            emitter: A,
            editing: t,
            isSelf: i,
            inputNotice: s,
            block: n,
            unblock: r,
            checkSkin: lo,
            changeChatUsability: o,
            editNotice: a,
            saveEdition: l,
            cancelEdition: c,
            play: Mp,
            spec: Qy,
            listType: ja,
            list: Ch,
            changeListType: h,
            getOnlineColor: u,
            getLatencyColor: d
        }
    }
}
  , ln = e=>(gs("data-v-499ffd15"),
e = e(),
vs(),
e)
  , V9 = {
    id: "chat-menu"
}
  , z9 = {
    class: "player-profile"
}
  , $9 = {
    class: "player-avatar-border"
}
  , j9 = {
    id: "btn-group-1"
}
  , W9 = ln(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "22",
    height: "22",
    fill: "var(--main-theme-color)",
    transform: "translate(0,0)"
}, [b("path", {
    d: "M896 832h-246.4L512 960.48 374.4 832H128a96 96 0 0 1-96-96V160a96 96 0 0 1 96-96h768a96 96 0 0 1 96 96v576a96 96 0 0 1-96 96z m32-672a32 32 0 0 0-32-32H128a32 32 0 0 0-32 32v576a32 32 0 0 0 32 32h275.616L512 869.152 620.352 768H896a32 32 0 0 0 32-32V160z m-192 352a64 64 0 1 1 64-64 64 64 0 0 1-64 64z m-224 0a64 64 0 1 1 64-64 64 64 0 0 1-64 64z m-224 0a64 64 0 1 1 64-64 64 64 0 0 1-64 64z"
})], -1))
  , X9 = [W9]
  , Y9 = ln(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "19",
    height: "19",
    fill: "var(--main-theme-color)",
    transform: "translate(0,0)"
}, [b("path", {
    d: "M512 12.624658C235.660274 12.624658 11.221918 238.465753 11.221918 513.40274c0 276.339726 224.438356 500.778082 500.778082 500.778082 276.339726 0 500.778082-224.438356 500.778082-500.778082C1012.778082 238.465753 788.339726 12.624658 512 12.624658z m0 70.136986c106.608219 0 203.39726 39.276712 277.742466 102.4L183.758904 792.547945c-64.526027-75.747945-102.4-172.536986-102.4-277.742466 0-238.465753 193.578082-432.043836 430.641096-432.043835z m0 861.282192c-106.608219 0-203.39726-39.276712-277.742466-102.4l605.983562-605.983562c64.526027 75.747945 102.4 172.536986 102.4 277.742466 0 238.465753-193.578082 430.641096-430.641096 430.641096z"
})], -1))
  , K9 = [Y9]
  , Z9 = ln(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "22",
    height: "22",
    fill: "var(--main-theme-color)",
    transform: "translate(0,-0.5)"
}, [b("path", {
    d: "M922.8 338.3c-22.5-53.2-54.7-101-95.7-142s-88.8-73.2-142-95.7C630 77.3 571.5 65.5 511.2 65.5c-60.3 0-118.8 11.8-173.9 35.1-53.2 22.5-101 54.7-142 95.7s-73.2 88.8-95.7 142c-23.3 55.1-35.1 113.6-35.1 173.9S76.3 631 99.6 686.1c22.5 53.2 54.7 101 95.7 142s88.8 73.2 142 95.7c55.1 23.3 113.6 35.1 173.9 35.1 60.3 0 118.8-11.8 173.9-35.1 53.2-22.5 101-54.7 142-95.7s73.2-88.8 95.7-142c23.3-55.1 35.1-113.6 35.1-173.9s-11.8-118.8-35.1-173.9z m-141 444.5c-72.3 72.3-168.4 112.1-270.6 112.1s-198.3-39.8-270.6-112.1c-72.3-72.3-112.1-168.4-112.1-270.6 0-102.2 39.8-198.3 112.1-270.6 72.3-72.3 168.4-112.1 270.6-112.1s198.3 39.8 270.6 112.1S893.9 410 893.9 512.2c0 102.2-39.8 198.4-112.1 270.6z"
}), b("path", {
    d: "M766.9 385.5c-12.5-12.5-32.8-12.5-45.3 0L449 658.2 302.2 511.5c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l169.4 169.4c12.5 12.5 32.8 12.5 45.3 0L767 430.8c12.4-12.6 12.4-32.8-0.1-45.3z"
})], -1))
  , q9 = [Z9]
  , J9 = {
    id: "btn-group-2"
}
  , Q9 = ln(()=>b("svg", {
    id: "chat-switch",
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "22",
    height: "22",
    transform: "translate(0,-0.5)"
}, [b("path", {
    d: "M561.312102 68.191078l-98.624205 0 0 493.121024 98.624205 0L561.312102 68.191078zM799.735283 174.951591l-69.77618 69.77618c77.420277 63.36619 127.225613 159.27761 127.225613 267.271206 0 190.590779-154.592914 345.184717-345.184717 345.184717S166.815283 702.590779 166.815283 512c0-107.993596 49.805336-203.905016 127.225613-267.271206l-69.77618-69.77618C129.0911 256.316713 68.191078 376.884696 68.191078 512c0 245.080811 198.72811 443.808922 443.808922 443.808922s443.808922-198.72811 443.808922-443.808922C955.808922 376.884696 894.907876 256.316713 799.735283 174.951591z"
})], -1))
  , tF = [Q9]
  , eF = ln(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "22",
    height: "22",
    fill: "var(--main-theme-color)",
    transform: "translate(0,0)"
}, [b("path", {
    d: "M927.692008 304.704873c17.665497 0 31.937622 14.37193 31.937622 31.937622v586.853801c0 17.665497-14.272125 31.937622-31.937622 31.937622h-828.382066c-17.665497 0-31.937622-14.272125-31.937622-31.937622v-586.853801c0-17.665497 14.272125-31.937622 31.937622-31.937622h156.793762c8.683041 0 17.066667-3.493177 23.05497-9.780896L490.545809 75.153216c12.575439-13.074464 33.434698-13.074464 46.010136 0l211.28733 219.770761c6.088109 6.287719 14.37193 9.780897 23.054971 9.780896h156.793762z m-564.397661 0h300.413255L513.500975 152.801559 363.294347 304.704873z m532.460039 63.875244h-764.506823v522.978557h764.506823v-522.978557z m-592.842105 148.809357c-19.761404 0-35.929825-14.37193-35.929825-31.937622s16.168421-31.937622 35.929825-31.937622h401.615594c19.761404 0 35.929825 14.37193 35.929825 31.937622s-16.168421 31.937622-35.929825 31.937622H302.912281zM797.047173 591.844055c19.761404 0 35.929825 14.37193 35.929825 31.937621s-16.168421 31.937622-35.929825 31.937622H210.392982c-19.761404 0-35.929825-14.37193-35.929824-31.937622s16.168421-31.937622 35.929824-31.937621h586.654191zM298.121637 730.872515c19.761404 0 35.929825 14.37193 35.929825 31.937621s-16.168421 31.937622-35.929825 31.937622h-83.037816c-19.761404 0-35.929825-14.37193-35.929825-31.937622s16.168421-31.937622 35.929825-31.937621h83.037816z m494.134893-0.299416c19.761404 0 35.929825 14.37193 35.929825 31.937622s-16.168421 31.937622-35.929825 31.937622H424.674464c-19.761404 0-35.929825-14.37193-35.929825-31.937622s16.168421-31.937622 35.929825-31.937622h367.582066z"
})], -1))
  , iF = [eF]
  , sF = {
    id: "btn-group-3"
}
  , nF = ln(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "22",
    height: "22",
    fill: "var(--main-theme-color)",
    transform: "translate(0,-0.5)"
}, [b("path", {
    d: "M377.8 832.3c-12.5 0-25-4.8-34.5-14.3L76.5 551.2c-19.1-19.1-19.1-50 0-69.1 19.1-19.1 50-19.1 69.1 0L412.4 749c19.1 19.1 19.1 50 0 69.1-9.6 9.5-22.1 14.2-34.6 14.2z"
}), b("path", {
    d: "M377.8 832.3c-12.5 0-25-4.8-34.5-14.3-19.1-19.1-19.1-50 0-69.1L877 215.3c19.1-19.1 50-19.1 69.1 0s19.1 50 0 69.1L412.4 818c-9.6 9.6-22.1 14.3-34.6 14.3z"
})], -1))
  , rF = [nF]
  , oF = ln(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    fill: "var(--main-theme-color)",
    transform: "translate(-1,0.5)"
}, [b("path", {
    d: "M839.68 899.072c-13.312 0-26.624-5.12-36.864-15.36l-655.36-675.84c-19.456-20.48-18.944-52.736 1.024-72.192 20.48-19.456 52.736-18.944 72.192 1.024l655.36 675.84c19.456 20.48 18.944 52.736-1.024 72.192-9.728 9.728-22.528 14.336-35.328 14.336z"
}), b("path", {
    d: "M174.08 888.832c-13.312 0-26.624-5.12-36.864-15.36-19.456-20.48-18.944-52.736 1.024-72.192l675.84-655.36c20.48-19.456 52.736-18.944 72.192 1.024 19.456 20.48 18.944 52.736-1.024 72.192l-675.84 655.36c-9.728 9.728-22.528 14.336-35.328 14.336z"
})], -1))
  , aF = [oF]
  , lF = {
    class: "scroll-box"
}
  , cF = {
    class: "player-nick"
}
  , hF = {
    class: "player-notice"
}
  , uF = {
    id: "player-list"
}
  , dF = {
    class: "player-list-top"
}
  , fF = ln(()=>b("div", {
    class: "player-list-top-fill"
}, null, -1))
  , pF = {
    class: "player-list-inner"
}
  , mF = {
    class: "player-list-item"
}
  , gF = ["onClick"]
  , vF = ln(()=>b("path", {
    d: "M514.048 128q79.872 0 149.504 30.208t121.856 82.432 82.432 122.368 30.208 150.016q0 78.848-30.208 148.48t-82.432 121.856-121.856 82.432-149.504 30.208-149.504-30.208-121.856-82.432-82.432-121.856-30.208-148.48q0-79.872 30.208-150.016t82.432-122.368 121.856-82.432 149.504-30.208z"
}, null, -1))
  , _F = [vF]
  , yF = {
    class: "item-nick"
};
function bF(e, t, i, s, n, r) {
    const o = se("notice-input");
    return st(),
    nt("div", V9, [b("div", z9, [b("div", $9, [b("div", {
        class: "player-avatar",
        style: jt({
            backgroundImage: s.checkSkin(i.player)
        })
    }, null, 4), ee(b("div", j9, [b("button", {
        class: "btn rounded-0 first-btn chat-menu-btn",
        type: "button",
        onClick: t[0] || (t[0] = a=>s.emitter.emit("openDM"))
    }, X9), ee(b("button", {
        class: "btn rounded-0 second-btn chat-menu-btn",
        type: "button",
        onClick: t[1] || (t[1] = a=>s.block(i.player))
    }, K9, 512), [[ye, i.player && !i.player.block]]), ee(b("button", {
        class: "btn rounded-0 second-btn chat-menu-btn",
        type: "button",
        onClick: t[2] || (t[2] = a=>s.unblock(i.player))
    }, q9, 512), [[ye, i.player && i.player.block]])], 512), [[ye, !s.editing && !s.isSelf && i.player]]), ee(b("div", J9, [b("button", {
        class: "btn rounded-0 first-btn chat-menu-btn",
        type: "button",
        onClick: t[3] || (t[3] = a=>s.changeChatUsability())
    }, tF), b("button", {
        class: "btn rounded-0 second-btn chat-menu-btn",
        type: "button",
        onClick: t[4] || (t[4] = a=>s.editNotice())
    }, iF)], 512), [[ye, !s.editing && s.isSelf]]), ee(b("div", sF, [b("button", {
        class: "btn rounded-0 first-btn chat-menu-btn",
        type: "button",
        onClick: t[5] || (t[5] = a=>s.saveEdition())
    }, rF), b("button", {
        class: "btn rounded-0 second-btn chat-menu-btn",
        type: "button",
        onClick: t[6] || (t[6] = a=>s.cancelEdition())
    }, aF)], 512), [[ye, s.editing]])]), ee(b("div", lF, [ee(b("p", {
        class: "player-tag"
    }, Dt(i.player ? i.player.tag : ""), 513), [[ye, i.player && i.player.tag]]), b("p", cF, Dt(i.player ? i.player.nick : ""), 1), b("p", hF, Dt(i.player ? i.player.notice : ""), 1)], 512), [[ye, !s.editing]]), ee(X(o, {
        class: Ai("notice-input")
    }, null, 512), [[ye, s.editing]])]), b("div", uF, [b("div", dF, [b("div", {
        class: Ai("list-option" + (s.listType == 0 ? " active" : "")),
        onClick: t[7] || (t[7] = a=>s.changeListType(0))
    }, Dt(i.options[0]), 3), b("div", {
        class: Ai("list-option" + (s.listType == 1 ? " active" : "")),
        onClick: t[8] || (t[8] = a=>s.changeListType(1))
    }, Dt(i.options[1]), 3), fF]), b("ul", pF, [(st(!0),
    nt(Nt, null, Jt(s.list, (a,l)=>(st(),
    nt("li", {
        key: l
    }, [ee(b("div", mF, [b("div", {
        class: "skin-card",
        style: jt({
            "background-image": s.checkSkin(a)
        }),
        onClick: c=>s.emitter.emit("checkPlayer", a)
    }, null, 12, gF), (st(),
    nt("svg", {
        class: "online-state",
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "10",
        height: "10",
        transform: "translate(0,-1.5)",
        style: jt({
            fill: s.getOnlineColor(a)
        })
    }, _F, 4)), b("div", yF, Dt(a.tagNick), 1), b("div", {
        class: "item-latency",
        style: jt({
            color: s.getLatencyColor(a)
        })
    }, Dt(a.latency), 5)], 512), [[ye, a.enableChat || a.isSelf]])]))), 128))])])])
}
var xF = ue(H9, [["render", bF], ["__scopeId", "data-v-499ffd15"]]);
const wF = {
    name: "chat-room",
    components: {
        "chat-text": E9,
        "chat-input": N9,
        "chat-menu": xF,
        "common-select": Jy
    },
    setup() {
        const e = ut(null)
          , t = ut(H.ShowChatRoom)
          , i = Ft(()=>Vt.size ? Vt.get(U.id) : null)
          , s = ut(null)
          , n = ut(null)
          , r = Ft(()=>{
            let J = [];
            return Vt.forEach(wt=>{
                wt.msg.length && wt.enableChat && wt != n.value && J.push(wt)
            }
            ),
            J
        }
        )
          , o = Ft(()=>{
            let J = [];
            if (Vt.size) {
                let wt = i.value;
                Vt.forEach(Tt=>{
                    Tt.nick != "Bot" && Tt.team == wt.team && Tt.enableChat && Tt.id != wt.id && J.push(Tt)
                }
                )
            }
            return J
        }
        )
          , a = ut(!1);
        function l(J) {
            s.value = J,
            g(0)
        }
        A.on("checkPlayer", l);
        const c = ut({
            left: "-235px",
            opacity: 1,
            transition: "0"
        })
          , h = ut(null);
        let u = null;
        const d = Ft(()=>{
            const J = h.value;
            if (!J)
                return "";
            const wt = J.msg.length;
            return J.msg[wt - 1][4]
        }
        );
        A.on("receiveChatMsg", ({type: J, id: wt, msg: Tt, toId: Bt})=>{
            if (J == 3)
                if (Bt == U.id) {
                    let kt = Vt.get(wt);
                    if (kt.block)
                        return;
                    if (kt.msg.push([mu(), 3, kt.tag + kt.nick, lo(kt), Tt, kt]),
                    K.value || (n.value = kt),
                    u && clearTimeout(u),
                    f.value == 3 && n.value == kt) {
                        C();
                        return
                    }
                    c.value = {
                        left: "-235px",
                        opacity: 1,
                        transition: "0s"
                    },
                    u = setTimeout(()=>{
                        h.value = kt,
                        c.value = {
                            left: "2px",
                            transition: "0.2s"
                        },
                        u = setTimeout(()=>{
                            c.value = {
                                left: "-10px",
                                opacity: 0,
                                transition: "0.125s"
                            }
                        }
                        , 2e3)
                    }
                    , 50)
                } else {
                    let kt = Vt.get(Bt);
                    kt.msg.push([mu(), 3, U.tag + U.nick, lo(U), Tt, kt]),
                    C()
                }
        }
        );
        const f = ut(2)
          , p = J=>f.value == J ? "chat-room-label active" : "chat-room-label"
          , m = Ft(()=>{
            const J = qy[yi("locale").value];
            return [J.all, J.team, J.private]
        }
        );
        function g(J) {
            switch (a.value = !1,
            O(J),
            J) {
            case 0:
                {
                    a.value = !0;
                    break
                }
            case 1:
                document.getElementById("clabel-all").style.boxShadow = null;
                break;
            case 2:
                document.getElementById("clabel-team").style.boxShadow = null;
                break;
            case 3:
                {
                    f.value == J && Q();
                    break
                }
            }
            f.value = J,
            J != 3 && n.value && !n.value.msg.length && !r.value.length && (n.value = null)
        }
        const y = ut(null)
          , x = []
          , v = _i([])
          , _ = ut(f.value);
        function C() {
            const J = y.value;
            J.scroll(0, J.scrollHeight)
        }
        function k() {
            t.value = H.ShowChatRoom,
            St()
        }
        let S;
        function T({type: J, id: wt, msg: Tt}) {
            if (J == 3)
                return;
            let Bt, kt, re;
            wt === 0 ? Bt = "" : (re = Vt.get(wt),
            Bt = re.tagNick,
            kt = lo(re));
            const Xt = [mu(), J, Bt, kt, Tt, re];
            x.push(Xt),
            (f.value == J || J == 4) && fa(()=>{
                fa(()=>{
                    C()
                }
                )
            }
            ),
            J == 1 && f.value != 1 ? document.getElementById("clabel-all").style.boxShadow = "inset 0 0 2.5px 0.1px var(--main-theme-color)" : J == 2 && f.value != 2 && (document.getElementById("clabel-team").style.boxShadow = "inset 0 0 2.5px 0.1px var(--main-theme-color)");
            let ce = S.length - 1;
            for (; ce >= 0; ce--)
                if (Xt[1] == S[ce]) {
                    v.push(Xt),
                    St();
                    return
                }
            St()
        }
        function L() {
            x.length = 0,
            v.length = 0
        }
        function D(J) {
            at.writer.writeUint8(24).writeUint8(2).writeStringUTF8(J),
            at.send(),
            St()
        }
        function O(J) {
            switch (_.value = J,
            J) {
            case 0:
                return;
            case 1:
                S = [1, 4];
                break;
            case 2:
                S = [2, 4];
                break;
            case 3:
                return
            }
            v.length = 0,
            fa(()=>x.forEach(wt=>{
                let Tt = S.length - 1;
                for (; Tt >= 0; Tt--)
                    if (wt[1] == S[Tt]) {
                        v.push(wt);
                        return
                    }
            }
            )),
            St()
        }
        const K = Ft(()=>{
            const J = n.value;
            let wt = !1;
            return J && (wt = J.enableChat),
            fa(()=>{
                !wt && r.value.length && (n.value = r.value[0])
            }
            ),
            wt
        }
        )
          , P = ut(!1)
          , N = ut("(-180deg)")
          , W = Ft(()=>P.value ? 0 : -2 - 4 * 29 + "px")
          , V = Ft(()=>P.value ? 1 : 0);
        function Q() {
            !r.value.length || (N.value = "(0deg)",
            P.value = !0,
            document.getElementById("clabel-private").classList.add("open"),
            document.getElementById("interlocutor-skin").style.opacity = 0,
            document.getElementById("list-hint").style.opacity = 1)
        }
        function pt() {
            N.value = "(-180deg)",
            P.value = !1,
            document.getElementById("clabel-private").classList.remove("open"),
            document.getElementById("interlocutor-skin").style.opacity = null,
            document.getElementById("list-hint").style.opacity = null
        }
        function bt(J) {
            n.value = J
        }
        let ct, gt;
        function xt() {
            clearTimeout(gt),
            clearTimeout(ct),
            e.value.style.opacity = 1,
            e.value.style.display = "block"
        }
        function It() {
            H.AutoHideChatRoom === 1 && (ct = setTimeout(()=>{
                e.value.style.opacity = 0,
                gt = setTimeout(()=>{
                    e.value.style.opacity == 0 && (e.value.style.display = "none")
                }
                , 1e3)
            }
            , 3e3))
        }
        function St() {
            xt(),
            It()
        }
        return Ve(()=>{
            const J = e.value;
            J.style.userSelect = "none",
            J.addEventListener("mouseenter", ()=>{
                J.style.userSelect = "auto",
                xt()
            }
            ),
            J.addEventListener("mouseleave", ()=>{
                J.style.userSelect = "none",
                !P.value && A.emit("focusGameCanvas")
            }
            ),
            O(_.value),
            It()
        }
        ),
        A.on("joinSelf", ()=>{
            s.value = U
        }
        ),
        A.on(Ut.ShowChatRoom, k),
        A.on(Ut.AutoHideChatRoom, St),
        A.on("receiveChatMsg", T),
        A.on("clearChatMsg", L),
        A.on("sendQuickMsg", D),
        A.on("initGame", ()=>{
            s.value = null,
            n.value = null
        }
        ),
        A.on("openDM", ()=>{
            g(3),
            n.value = s.value
        }
        ),
        {
            box: e,
            boxState: t,
            chosenPlayer: s,
            interlocutor: n,
            dm: r,
            team: o,
            inMenu: a,
            nPlayer: h,
            nStyle: c,
            latestDM: d,
            checkSkin: lo,
            lbOpt: m,
            labelClass: p,
            click: g,
            container: y,
            displayType: _,
            displayMsg: v,
            changeDisplayType: O,
            fadeIn: xt,
            fadeOut: It,
            showDM: K,
            r: N,
            t: W,
            o: V,
            openDMList: Q,
            closeDMList: pt,
            changeInterlocutor: bt,
            list: Ch,
            play: Mp,
            spec: Qy
        }
    }
}
  , sl = e=>(gs("data-v-36e688fb"),
e = e(),
vs(),
e)
  , TF = {
    id: "chat-room",
    ref: "box"
}
  , EF = {
    class: "notification-msg"
}
  , SF = {
    class: "chat-room-top"
}
  , CF = sl(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "20",
    height: "20",
    fill: "var(--main-theme-color)",
    transform: "translate(-0.5,-1.5)"
}, [b("path", {
    d: "M341.333333 170.666667h554.666667v85.333333H341.333333V170.666667z m-213.333333-21.333334h128v128H128v-128z m0 298.666667h128v128H128v-128z m0 298.666667h128v128H128v-128zM341.333333 469.333333h554.666667v85.333334H341.333333v-85.333334z m0 298.666667h554.666667v85.333333H341.333333v-85.333333z"
})], -1))
  , AF = [CF]
  , IF = sl(()=>b("path", {
    d: "M533.333333 465.066667L358.4 640 298.666667 580.266667l234.666666-234.666667 234.666667 234.666667-64 59.733333-170.666667-174.933333z"
}, null, -1))
  , MF = [IF]
  , RF = {
    id: "dm-list-outer"
}
  , kF = {
    class: "dm-list-item"
}
  , PF = ["title", "onClick"]
  , LF = {
    id: "chat-room-outer"
}
  , OF = {
    class: "chat-room-inner tab-content box-container"
}
  , DF = {
    class: "scroll-container",
    ref: "container"
}
  , NF = {
    class: "player-info"
}
  , FF = {
    class: "player-play"
}
  , BF = sl(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "18",
    height: "18",
    fill: "var(--main-theme-color)",
    transform: "translate(2,-1.5)"
}, [b("path", {
    d: "M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
}), b("path", {
    d: "M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
})], -1))
  , UF = {
    class: "player-spec"
}
  , GF = sl(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "18",
    height: "18",
    fill: "var(--main-theme-color)",
    transform: "translate(2,-1.5)"
}, [b("path", {
    d: "M512 277.333333c242.432 0 384 195.541333 384 234.666667 0 39.125333-141.568 234.666667-384 234.666667S128 551.125333 128 512C128 472.874667 269.568 277.333333 512 277.333333zM512 341.333333a170.666667 170.666667 0 1 0 0 341.333334 170.666667 170.666667 0 0 0 0-341.333334z"
}), b("path", {
    d: "M512 512m-128 0a128 128 0 1 0 256 0 128 128 0 1 0-256 0Z"
})], -1))
  , HF = {
    class: "player-total"
}
  , VF = sl(()=>b("svg", {
    viewBox: "0 0 1024 1024",
    xmlns: "http://www.w3.org/2000/svg",
    width: "18",
    height: "18",
    fill: "var(--main-theme-color)",
    transform: "translate(2,-1.5)"
}, [b("path", {
    d: "M261.7 522.6h0.2c19.3 0 35-15.7 35-35s-15.7-35-35-35c-31.9 0-58.8-37.7-58.8-82.4s26.9-82.4 58.8-82.4c19.3 0 35-15.7 35-35s-15.7-35-35-35c-35.4 0-69.5 17.3-93.7 47.5-22.6 28.4-35.1 65.6-35.1 104.9s12.5 76.5 35.1 104.9c0.6 0.8 1.3 1.6 2 2.4-22.9 13.2-43.4 31-61.1 53.2-38.3 48-59.5 111.4-59.5 178.4 0 19.3 15.7 35 35 35s35-15.7 35-35c0-51.2 15.7-99.1 44.1-134.7 26.6-33.3 61.3-51.7 97.7-51.7 0.2 0 0.3-0.1 0.3-0.1zM914.8 530.7c-17.7-22.2-38.2-40-61.1-53.2 0.7-0.8 1.3-1.6 2-2.4 22.6-28.4 35.1-65.6 35.1-104.9s-12.5-76.5-35.1-104.9c-24.1-30.2-58.3-47.5-93.7-47.5-19.3 0-35 15.7-35 35s15.7 35 35 35c31.9 0 58.8 37.7 58.8 82.4s-26.9 82.4-58.8 82.4c-19.3 0-35 15.7-35 35s15.7 35 35 35H762.3c36.4 0 71.1 18.4 97.7 51.7 28.5 35.6 44.1 83.5 44.1 134.7 0 19.3 15.7 35 35 35s35-15.7 35-35c0.2-67-21-130.3-59.3-178.3z"
}), b("path", {
    d: "M747.4 541c-30.9-30.8-66.9-54.7-106.1-70.8 40.3-34.7 65.8-86 65.8-143.2 0-104.2-84.8-188.9-188.9-188.9-104.2 0-188.9 84.8-188.9 188.9 0 57 25.4 108.2 65.4 142.9C355.2 486 318.9 510 287.8 541c-61.2 61.1-95.1 142.4-95.5 228.9V850.8c0 19.3 15.7 35 35 35h580.5c19.3 0 35-15.7 35-35v-80.2-0.8c-0.3-86.4-34.2-167.6-95.4-228.8zM518.2 208.1c65.6 0 118.9 53.4 118.9 118.9s-53.4 118.9-118.9 118.9S399.3 392.6 399.3 327s53.4-118.9 118.9-118.9z m254.7 607.8H262.3v-44.6-0.6c0.2-140.5 114.8-254.8 255.3-254.8s255 114.3 255.3 254.8v45.2z"
})], -1));
function zF(e, t, i, s, n, r) {
    const o = se("chat-menu")
      , a = se("chat-input");
    return st(),
    nt(Nt, null, [ee(b("div", TF, [b("div", {
        id: "dm-notification",
        style: jt(s.nStyle)
    }, [b("div", {
        class: "notification-avatar",
        style: jt({
            "background-image": s.checkSkin(s.nPlayer)
        })
    }, null, 4), b("div", EF, Dt(s.latestDM), 1)], 4), b("nav", SF, [b("div", {
        class: Ai(s.labelClass(0)),
        id: "clabel-menu",
        onClick: t[0] || (t[0] = l=>s.click(0))
    }, AF, 2), b("div", {
        class: Ai(s.labelClass(1)),
        id: "clabel-all",
        onClick: t[1] || (t[1] = l=>s.click(1))
    }, Dt(" " + s.lbOpt[0] + " "), 3), b("div", {
        class: Ai(s.labelClass(2)),
        id: "clabel-team",
        onClick: t[2] || (t[2] = l=>s.click(2))
    }, Dt(" " + s.lbOpt[1] + " "), 3), b("div", {
        class: Ai(s.labelClass(3)),
        id: "clabel-private",
        tabindex: "-1",
        style: jt({
            paddingRight: "1px",
            display: s.showDM ? "block" : "none"
        }),
        onClick: t[3] || (t[3] = l=>s.click(3)),
        onBlur: t[4] || (t[4] = (...l)=>s.closeDMList && s.closeDMList(...l))
    }, [(st(),
    nt("svg", {
        id: "list-hint",
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        fill: "#707070",
        style: jt({
            transform: "rotateZ" + s.r,
            opacity: s.dm.length ? null : 0
        })
    }, MF, 4)), b("div", {
        id: "interlocutor-skin",
        style: jt({
            backgroundImage: s.checkSkin(s.interlocutor),
            opacity: s.dm.length ? null : 1
        })
    }, null, 4), b("div", RF, [b("ul", {
        id: "dm-list-inner",
        style: jt({
            marginTop: s.t,
            opacity: s.o
        })
    }, [(st(!0),
    nt(Nt, null, Jt(s.dm, (l,c)=>(st(),
    nt("li", {
        key: c
    }, [b("div", kF, [b("div", {
        class: "item-skin",
        title: l.tagNick,
        style: jt({
            "background-image": s.checkSkin(l)
        }),
        onClick: h=>s.changeInterlocutor(l)
    }, null, 12, PF)])]))), 128))], 4)])], 38)]), b("div", LF, [ee(b("div", OF, [b("div", DF, [(st(!0),
    nt(Nt, null, Jt(s.displayType == 3 ? s.interlocutor.msg : s.displayMsg, (l,c)=>(st(),
    Rf(Ne("chat-text"), {
        key: c,
        time: l[0],
        type: l[1],
        nick: l[2],
        skin: l[3],
        msg: l[4],
        player: l[5]
    }, null, 8, ["time", "type", "nick", "skin", "msg", "player"]))), 128))], 512)], 512), [[ye, !s.inMenu]]), ee(X(o, {
        player: s.chosenPlayer,
        options: s.lbOpt
    }, null, 8, ["player", "options"]), [[ye, s.inMenu]])]), b("div", NF, [b("div", FF, [BF, po(" " + Dt(s.play), 1)]), b("div", UF, [GF, po(" " + Dt(s.spec), 1)]), b("div", HF, [VF, po(" " + Dt(s.list.length), 1)])])], 512), [[ye, s.boxState]]), X(a, {
        type: s.displayType,
        toId: s.interlocutor ? s.interlocutor.id : 0,
        onShow: s.fadeIn,
        onHide: s.fadeOut
    }, null, 8, ["type", "toId", "onShow", "onHide"])], 64)
}
var $F = ue(wF, [["render", zF], ["__scopeId", "data-v-36e688fb"]]);
const jF = {
    name: "hint",
    setup() {
        const e = Ft(()=>Ny[yi("locale").value])
          , t = ut(null)
          , i = ut(null);
        let s;
        A.on("signalHint", ([o,a])=>{
            clearTimeout(s),
            t.value = o,
            i.value = Qa(a);
            const l = document.getElementById("signal-hint");
            l.style.visibility = "visible",
            l.style.transition = "opacity 0.35s",
            l.style.opacity = 1,
            s = setTimeout(()=>{
                l.style.transition = "0.75s",
                l.style.opacity = 0,
                l.style.visibility = "hidden"
            }
            , 1600)
        }
        );
        const n = ut(null)
          , r = ut(null);
        return A.on("updateVueComp", ()=>{
            if (U.state < 2) {
                n.value = null;
                return
            }
            if (U.specMode == 2) {
                let a;
                Vt.forEach(l=>{
                    l.isBot || (!a || l.totalMass > a.totalMass) && (a = l)
                }
                ),
                n.value = a
            } else
                U.specMode == 1 ? n.value = null : U.specMode == 0 && (n.value = U.specTarget);
            const o = n.value;
            o && (r.value = o.nick + "\u2014" + (o.totalMass / 1e3).toFixed(1) + "K")
        }
        ),
        {
            emitter: A,
            t: e,
            sender: t,
            hintColor: i,
            specTarget: n,
            specInfo: r,
            checkSkin: lo
        }
    }
};
function WF(e, t, i, s, n, r) {
    return st(),
    nt(Nt, null, [b("div", {
        id: "signal-hint",
        onClick: t[0] || (t[0] = o=>s.emitter.emit("checkPlayer", s.sender))
    }, [b("div", {
        id: "signal-color",
        style: jt({
            boxShadow: "0 0 16px 4px " + s.hintColor
        })
    }, null, 4), b("div", {
        id: "sender-avatar",
        style: jt({
            backgroundImage: s.checkSkin(s.sender)
        })
    }, null, 4), po(" " + Dt((s.sender ? s.sender.nick : "") + " " + s.t.mouse.signalHint), 1)]), ee(b("div", {
        id: "spec-hint",
        onClick: t[1] || (t[1] = o=>s.emitter.emit("checkPlayer", s.specTarget))
    }, [b("div", {
        id: "spec-avatar",
        style: jt({
            backgroundImage: s.checkSkin(s.specTarget)
        })
    }, null, 4), po(" " + Dt(s.specInfo), 1)], 512), [[ye, s.specTarget && s.specTarget.cellCount]])], 64)
}
var XF = ue(jF, [["render", WF], ["__scopeId", "data-v-0b6e4036"]]);
const YF = {
    name: "home",
    components: {
        "main-menu": sO,
        "setting-menu": p9,
        "chat-room": $F,
        "replay-bar": rp,
        hint: XF
    },
    setup() {
        const e = ut(!1)
          , t = ut(!0)
          , i = new $t(()=>{
            !t.value && !e.value ? s() : n()
        }
        );
        function s() {
            A.emit("clearEvent"),
            document.body.querySelector("canvas").blur(),
            H.PauseAfterOpeningMenu && (at.writer.writeUint8(6).writeUint8(1),
            at.send()),
            t.value = !0
        }
        function n() {
            if (A.emit("focusGameCanvas"),
            e.value) {
                e.value = !1;
                return
            }
            U.pause && (at.writer.writeUint8(6).writeUint8(2),
            at.send()),
            t.value = !1
        }
        function r(u) {
            typeof u < "u" ? e.value = u : e.value ^= 1,
            e.value && (t.value = !1,
            A.emit("hotkeyCheck"))
        }
        function o() {
            !t.value && H.ShowMenuAfterDeath && (n(),
            s())
        }
        const a = new $t(()=>{
            A.emit("quickStart")
        }
        );
        function l(u) {
            const d = yo(u);
            d === "Escape" ? i.execute() : d === bi.Respawn && U.currentOpUnit.cellCount == 0 && (u.preventDefault(),
            u.stopImmediatePropagation(),
            a.execute())
        }
        function c(u) {
            const d = yo(u);
            d === "Escape" ? i.end() : d === bi.Respawn && a.end()
        }
        function h(u) {
            yo(u) === bi.Respawn && u.stopPropagation()
        }
        return Ve(()=>{}
        ),
        document.addEventListener("mousedown", u=>{
            u.button > 2 && u.preventDefault()
        }
        ),
        document.addEventListener("mouseup", u=>{
            u.button > 2 && u.preventDefault()
        }
        ),
        document.addEventListener("keydown", l),
        document.addEventListener("keyup", c),
        A.on("switchMenu", u=>{
            u ? s() : n()
        }
        ),
        A.on("switchSettings", r),
        A.on("menuHide", n),
        A.on("death", o),
        {
            menuState: t,
            settingsState: e,
            menuShow: s,
            menuHide: n,
            switchSettings: r,
            checkBubble: h
        }
    }
};
function KF(e, t, i, s, n, r) {
    const o = se("main-menu")
      , a = se("setting-menu")
      , l = se("chat-room")
      , c = se("replay-bar")
      , h = se("hint");
    return st(),
    nt("div", {
        onKeydown: t[0] || (t[0] = (...u)=>s.checkBubble && s.checkBubble(...u))
    }, [X(o, {
        ref: "menuEl",
        menuState: s.menuState
    }, null, 8, ["menuState"]), ee(X(a, null, null, 512), [[ye, s.settingsState]]), X(l), X(c), X(h)], 32)
}
var ZF = ue(YF, [["render", KF]]);
const qF = {
    name: "App",
    components: {
        home: ZF
    },
    setup() {
        Uv("locale", ut(tR));
        function e(i) {
            ((i.ctrlKey === !0 || i.metaKey === !0) && (i.code === "Minus" || i.code === "Equal") || i.code === "NumpadAdd" || i.code === "NumpadSubtract") && i.preventDefault()
        }
        function t(i) {
            (i.ctrlKey || i.metaKey) && i.preventDefault()
        }
        window.oncontextmenu = ()=>!1,
        document.addEventListener("keydown", e),
        document.addEventListener("wheel", t, {
            passive: !1
        })
    }
};
function JF(e, t, i, s, n, r) {
    const o = se("home");
    return st(),
    Rf(o)
}
var QF = ue(qF, [["render", JF]]);
A.on("startClient", ()=>{
    const e = "#app";
    SC(QF).mount(e),
    new $8(e)
}
);
