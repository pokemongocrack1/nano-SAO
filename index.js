var eb = Object.defineProperty;
var ib = (e, t, i) => t in e ? eb(e, t, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: i
}) : e[t] = i;
var I = (e, t, i) => (ib(e, typeof t != "symbol" ? t + "" : t, i), i);
const sb = function() {
    const t = document.createElement("link").relList;
    if (t && t.supports && t.supports("modulepreload")) return;
    for (const n of document.querySelectorAll('link[rel="modulepreload"]')) s(n);
    new MutationObserver(n => {
        for (const r of n)
            if (r.type === "childList")
                for (const o of r.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && s(o)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function i(n) {
        const r = {};
        return n.integrity && (r.integrity = n.integrity), n.referrerpolicy && (r.referrerPolicy = n.referrerpolicy), n.crossorigin === "use-credentials" ? r.credentials = "include" : n.crossorigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin", r
    }

    function s(n) {
        if (n.ep) return;
        n.ep = !0;
        const r = i(n);
        fetch(n.href, r)
    }
};
sb();
var ai = "top",
    Ii = "bottom",
    Mi = "right",
    li = "left",
    Bc = "auto",
    Bo = [ai, Ii, Mi, li],
    Sr = "start",
    xo = "end",
    g0 = "clippingParents",
    Wd = "viewport",
    Kr = "popper",
    v0 = "reference",
    Su = Bo.reduce(function(e, t) {
        return e.concat([t + "-" + Sr, t + "-" + xo])
    }, []),
    Xd = [].concat(Bo, [Bc]).reduce(function(e, t) {
        return e.concat([t, t + "-" + Sr, t + "-" + xo])
    }, []),
    _0 = "beforeRead",
    y0 = "read",
    b0 = "afterRead",
    x0 = "beforeMain",
    w0 = "main",
    T0 = "afterMain",
    E0 = "beforeWrite",
    S0 = "write",
    C0 = "afterWrite",
    A0 = [_0, y0, b0, x0, w0, T0, E0, S0, C0];

function Os(e) {
    return e ? (e.nodeName || "").toLowerCase() : null
}

function ps(e) {
    if (e == null) return window;
    if (e.toString() !== "[object Window]") {
        var t = e.ownerDocument;
        return t && t.defaultView || window
    }
    return e
}

function wo(e) {
    var t = ps(e).Element;
    return e instanceof t || e instanceof Element
}

function zi(e) {
    var t = ps(e).HTMLElement;
    return e instanceof t || e instanceof HTMLElement
}

function Yd(e) {
    if (typeof ShadowRoot > "u") return !1;
    var t = ps(e).ShadowRoot;
    return e instanceof t || e instanceof ShadowRoot
}

function nb(e) {
    var t = e.state;
    Object.keys(t.elements).forEach(function(i) {
        var s = t.styles[i] || {},
            n = t.attributes[i] || {},
            r = t.elements[i];
        !zi(r) || !Os(r) || (Object.assign(r.style, s), Object.keys(n).forEach(function(o) {
            var a = n[o];
            a === !1 ? r.removeAttribute(o) : r.setAttribute(o, a === !0 ? "" : a)
        }))
    })
}

function rb(e) {
    var t = e.state,
        i = {
            popper: {
                position: t.options.strategy,
                left: "0",
                top: "0",
                margin: "0"
            },
            arrow: {
                position: "absolute"
            },
            reference: {}
        };
    return Object.assign(t.elements.popper.style, i.popper), t.styles = i, t.elements.arrow && Object.assign(t.elements.arrow.style, i.arrow),
        function() {
            Object.keys(t.elements).forEach(function(s) {
                var n = t.elements[s],
                    r = t.attributes[s] || {},
                    o = Object.keys(t.styles.hasOwnProperty(s) ? t.styles[s] : i[s]),
                    a = o.reduce(function(l, c) {
                        return l[c] = "", l
                    }, {});
                !zi(n) || !Os(n) || (Object.assign(n.style, a), Object.keys(r).forEach(function(l) {
                    n.removeAttribute(l)
                }))
            })
        }
}
var Kd = {
    name: "applyStyles",
    enabled: !0,
    phase: "write",
    fn: nb,
    effect: rb,
    requires: ["computeStyles"]
};

function Rs(e) {
    return e.split("-")[0]
}
var vr = Math.max,
    cc = Math.min,
    To = Math.round;

function Eo(e, t) {
    t === void 0 && (t = !1);
    var i = e.getBoundingClientRect(),
        s = 1,
        n = 1;
    if (zi(e) && t) {
        var r = e.offsetHeight,
            o = e.offsetWidth;
        o > 0 && (s = To(i.width) / o || 1), r > 0 && (n = To(i.height) / r || 1)
    }
    return {
        width: i.width / s,
        height: i.height / n,
        top: i.top / n,
        right: i.right / s,
        bottom: i.bottom / n,
        left: i.left / s,
        x: i.left / s,
        y: i.top / n
    }
}

function Zd(e) {
    var t = Eo(e),
        i = e.offsetWidth,
        s = e.offsetHeight;
    return Math.abs(t.width - i) <= 1 && (i = t.width), Math.abs(t.height - s) <= 1 && (s = t.height), {
        x: e.offsetLeft,
        y: e.offsetTop,
        width: i,
        height: s
    }
}

function I0(e, t) {
    var i = t.getRootNode && t.getRootNode();
    if (e.contains(t)) return !0;
    if (i && Yd(i)) {
        var s = t;
        do {
            if (s && e.isSameNode(s)) return !0;
            s = s.parentNode || s.host
        } while (s)
    }
    return !1
}

function Js(e) {
    return ps(e).getComputedStyle(e)
}

function ob(e) {
    return ["table", "td", "th"].indexOf(Os(e)) >= 0
}

function Fn(e) {
    return ((wo(e) ? e.ownerDocument : e.document) || window.document).documentElement
}

function Uc(e) {
    return Os(e) === "html" ? e : e.assignedSlot || e.parentNode || (Yd(e) ? e.host : null) || Fn(e)
}

function Ip(e) {
    return !zi(e) || Js(e).position === "fixed" ? null : e.offsetParent
}

function ab(e) {
    var t = navigator.userAgent.toLowerCase().indexOf("firefox") !== -1,
        i = navigator.userAgent.indexOf("Trident") !== -1;
    if (i && zi(e)) {
        var s = Js(e);
        if (s.position === "fixed") return null
    }
    var n = Uc(e);
    for (Yd(n) && (n = n.host); zi(n) && ["html", "body"].indexOf(Os(n)) < 0;) {
        var r = Js(n);
        if (r.transform !== "none" || r.perspective !== "none" || r.contain === "paint" || ["transform", "perspective"].indexOf(r.willChange) !== -1 || t && r.willChange === "filter" || t && r.filter && r.filter !== "none") return n;
        n = n.parentNode
    }
    return null
}

function Wa(e) {
    for (var t = ps(e), i = Ip(e); i && ob(i) && Js(i).position === "static";) i = Ip(i);
    return i && (Os(i) === "html" || Os(i) === "body" && Js(i).position === "static") ? t : i || ab(e) || t
}

function qd(e) {
    return ["top", "bottom"].indexOf(e) >= 0 ? "x" : "y"
}

function wa(e, t, i) {
    return vr(e, cc(t, i))
}

function lb(e, t, i) {
    var s = wa(e, t, i);
    return s > i ? i : s
}

function M0() {
    return {
        top: 0,
        right: 0,
        bottom: 0,
        left: 0
    }
}

function R0(e) {
    return Object.assign({}, M0(), e)
}

function k0(e, t) {
    return t.reduce(function(i, s) {
        return i[s] = e, i
    }, {})
}
var cb = function(t, i) {
    return t = typeof t == "function" ? t(Object.assign({}, i.rects, {
        placement: i.placement
    })) : t, R0(typeof t != "number" ? t : k0(t, Bo))
};

function hb(e) {
    var t, i = e.state,
        s = e.name,
        n = e.options,
        r = i.elements.arrow,
        o = i.modifiersData.popperOffsets,
        a = Rs(i.placement),
        l = qd(a),
        c = [li, Mi].indexOf(a) >= 0,
        h = c ? "height" : "width";
    if (!(!r || !o)) {
        var u = cb(n.padding, i),
            d = Zd(r),
            f = l === "y" ? ai : li,
            p = l === "y" ? Ii : Mi,
            m = i.rects.reference[h] + i.rects.reference[l] - o[l] - i.rects.popper[h],
            g = o[l] - i.rects.reference[l],
            y = Wa(r),
            x = y ? l === "y" ? y.clientHeight || 0 : y.clientWidth || 0 : 0,
            v = m / 2 - g / 2,
            _ = u[f],
            C = x - d[h] - u[p],
            k = x / 2 - d[h] / 2 + v,
            S = wa(_, k, C),
            T = l;
        i.modifiersData[s] = (t = {}, t[T] = S, t.centerOffset = S - k, t)
    }
}

function ub(e) {
    var t = e.state,
        i = e.options,
        s = i.element,
        n = s === void 0 ? "[data-popper-arrow]" : s;
    n != null && (typeof n == "string" && (n = t.elements.popper.querySelector(n), !n) || !I0(t.elements.popper, n) || (t.elements.arrow = n))
}
var P0 = {
    name: "arrow",
    enabled: !0,
    phase: "main",
    fn: hb,
    effect: ub,
    requires: ["popperOffsets"],
    requiresIfExists: ["preventOverflow"]
};

function So(e) {
    return e.split("-")[1]
}
var db = {
    top: "auto",
    right: "auto",
    bottom: "auto",
    left: "auto"
};

function fb(e) {
    var t = e.x,
        i = e.y,
        s = window,
        n = s.devicePixelRatio || 1;
    return {
        x: To(t * n) / n || 0,
        y: To(i * n) / n || 0
    }
}

function Mp(e) {
    var t, i = e.popper,
        s = e.popperRect,
        n = e.placement,
        r = e.variation,
        o = e.offsets,
        a = e.position,
        l = e.gpuAcceleration,
        c = e.adaptive,
        h = e.roundOffsets,
        u = e.isFixed,
        d = o.x,
        f = d === void 0 ? 0 : d,
        p = o.y,
        m = p === void 0 ? 0 : p,
        g = typeof h == "function" ? h({
            x: f,
            y: m
        }) : {
            x: f,
            y: m
        };
    f = g.x, m = g.y;
    var y = o.hasOwnProperty("x"),
        x = o.hasOwnProperty("y"),
        v = li,
        _ = ai,
        C = window;
    if (c) {
        var k = Wa(i),
            S = "clientHeight",
            T = "clientWidth";
        if (k === ps(i) && (k = Fn(i), Js(k).position !== "static" && a === "absolute" && (S = "scrollHeight", T = "scrollWidth")), k = k, n === ai || (n === li || n === Mi) && r === xo) {
            _ = Ii;
            var L = u && k === C && C.visualViewport ? C.visualViewport.height : k[S];
            m -= L - s.height, m *= l ? 1 : -1
        }
        if (n === li || (n === ai || n === Ii) && r === xo) {
            v = Mi;
            var D = u && k === C && C.visualViewport ? C.visualViewport.width : k[T];
            f -= D - s.width, f *= l ? 1 : -1
        }
    }
    var O = Object.assign({
            position: a
        }, c && db),
        K = h === !0 ? fb({
            x: f,
            y: m
        }) : {
            x: f,
            y: m
        };
    if (f = K.x, m = K.y, l) {
        var P;
        return Object.assign({}, O, (P = {}, P[_] = x ? "0" : "", P[v] = y ? "0" : "", P.transform = (C.devicePixelRatio || 1) <= 1 ? "translate(" + f + "px, " + m + "px)" : "translate3d(" + f + "px, " + m + "px, 0)", P))
    }
    return Object.assign({}, O, (t = {}, t[_] = x ? m + "px" : "", t[v] = y ? f + "px" : "", t.transform = "", t))
}

function pb(e) {
    var t = e.state,
        i = e.options,
        s = i.gpuAcceleration,
        n = s === void 0 ? !0 : s,
        r = i.adaptive,
        o = r === void 0 ? !0 : r,
        a = i.roundOffsets,
        l = a === void 0 ? !0 : a,
        c = {
            placement: Rs(t.placement),
            variation: So(t.placement),
            popper: t.elements.popper,
            popperRect: t.rects.popper,
            gpuAcceleration: n,
            isFixed: t.options.strategy === "fixed"
        };
    t.modifiersData.popperOffsets != null && (t.styles.popper = Object.assign({}, t.styles.popper, Mp(Object.assign({}, c, {
        offsets: t.modifiersData.popperOffsets,
        position: t.options.strategy,
        adaptive: o,
        roundOffsets: l
    })))), t.modifiersData.arrow != null && (t.styles.arrow = Object.assign({}, t.styles.arrow, Mp(Object.assign({}, c, {
        offsets: t.modifiersData.arrow,
        position: "absolute",
        adaptive: !1,
        roundOffsets: l
    })))), t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-placement": t.placement
    })
}
var Jd = {
        name: "computeStyles",
        enabled: !0,
        phase: "beforeWrite",
        fn: pb,
        data: {}
    },
    nl = {
        passive: !0
    };

function mb(e) {
    var t = e.state,
        i = e.instance,
        s = e.options,
        n = s.scroll,
        r = n === void 0 ? !0 : n,
        o = s.resize,
        a = o === void 0 ? !0 : o,
        l = ps(t.elements.popper),
        c = [].concat(t.scrollParents.reference, t.scrollParents.popper);
    return r && c.forEach(function(h) {
            h.addEventListener("scroll", i.update, nl)
        }), a && l.addEventListener("resize", i.update, nl),
        function() {
            r && c.forEach(function(h) {
                h.removeEventListener("scroll", i.update, nl)
            }), a && l.removeEventListener("resize", i.update, nl)
        }
}
var Qd = {
        name: "eventListeners",
        enabled: !0,
        phase: "write",
        fn: function() {},
        effect: mb,
        data: {}
    },
    gb = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
    };

function jl(e) {
    return e.replace(/left|right|bottom|top/g, function(t) {
        return gb[t]
    })
}
var vb = {
    start: "end",
    end: "start"
};

function Rp(e) {
    return e.replace(/start|end/g, function(t) {
        return vb[t]
    })
}

function tf(e) {
    var t = ps(e),
        i = t.pageXOffset,
        s = t.pageYOffset;
    return {
        scrollLeft: i,
        scrollTop: s
    }
}

function ef(e) {
    return Eo(Fn(e)).left + tf(e).scrollLeft
}

function _b(e) {
    var t = ps(e),
        i = Fn(e),
        s = t.visualViewport,
        n = i.clientWidth,
        r = i.clientHeight,
        o = 0,
        a = 0;
    return s && (n = s.width, r = s.height, /^((?!chrome|android).)*safari/i.test(navigator.userAgent) || (o = s.offsetLeft, a = s.offsetTop)), {
        width: n,
        height: r,
        x: o + ef(e),
        y: a
    }
}

function yb(e) {
    var t, i = Fn(e),
        s = tf(e),
        n = (t = e.ownerDocument) == null ? void 0 : t.body,
        r = vr(i.scrollWidth, i.clientWidth, n ? n.scrollWidth : 0, n ? n.clientWidth : 0),
        o = vr(i.scrollHeight, i.clientHeight, n ? n.scrollHeight : 0, n ? n.clientHeight : 0),
        a = -s.scrollLeft + ef(e),
        l = -s.scrollTop;
    return Js(n || i).direction === "rtl" && (a += vr(i.clientWidth, n ? n.clientWidth : 0) - r), {
        width: r,
        height: o,
        x: a,
        y: l
    }
}

function sf(e) {
    var t = Js(e),
        i = t.overflow,
        s = t.overflowX,
        n = t.overflowY;
    return /auto|scroll|overlay|hidden/.test(i + n + s)
}

function L0(e) {
    return ["html", "body", "#document"].indexOf(Os(e)) >= 0 ? e.ownerDocument.body : zi(e) && sf(e) ? e : L0(Uc(e))
}

function Ta(e, t) {
    var i;
    t === void 0 && (t = []);
    var s = L0(e),
        n = s === ((i = e.ownerDocument) == null ? void 0 : i.body),
        r = ps(s),
        o = n ? [r].concat(r.visualViewport || [], sf(s) ? s : []) : s,
        a = t.concat(o);
    return n ? a : a.concat(Ta(Uc(o)))
}

function Cu(e) {
    return Object.assign({}, e, {
        left: e.x,
        top: e.y,
        right: e.x + e.width,
        bottom: e.y + e.height
    })
}

function bb(e) {
    var t = Eo(e);
    return t.top = t.top + e.clientTop, t.left = t.left + e.clientLeft, t.bottom = t.top + e.clientHeight, t.right = t.left + e.clientWidth, t.width = e.clientWidth, t.height = e.clientHeight, t.x = t.left, t.y = t.top, t
}

function kp(e, t) {
    return t === Wd ? Cu(_b(e)) : wo(t) ? bb(t) : Cu(yb(Fn(e)))
}

function xb(e) {
    var t = Ta(Uc(e)),
        i = ["absolute", "fixed"].indexOf(Js(e).position) >= 0,
        s = i && zi(e) ? Wa(e) : e;
    return wo(s) ? t.filter(function(n) {
        return wo(n) && I0(n, s) && Os(n) !== "body"
    }) : []
}

function wb(e, t, i) {
    var s = t === "clippingParents" ? xb(e) : [].concat(t),
        n = [].concat(s, [i]),
        r = n[0],
        o = n.reduce(function(a, l) {
            var c = kp(e, l);
            return a.top = vr(c.top, a.top), a.right = cc(c.right, a.right), a.bottom = cc(c.bottom, a.bottom), a.left = vr(c.left, a.left), a
        }, kp(e, r));
    return o.width = o.right - o.left, o.height = o.bottom - o.top, o.x = o.left, o.y = o.top, o
}

function O0(e) {
    var t = e.reference,
        i = e.element,
        s = e.placement,
        n = s ? Rs(s) : null,
        r = s ? So(s) : null,
        o = t.x + t.width / 2 - i.width / 2,
        a = t.y + t.height / 2 - i.height / 2,
        l;
    switch (n) {
        case ai:
            l = {
                x: o,
                y: t.y - i.height
            };
            break;
        case Ii:
            l = {
                x: o,
                y: t.y + t.height
            };
            break;
        case Mi:
            l = {
                x: t.x + t.width,
                y: a
            };
            break;
        case li:
            l = {
                x: t.x - i.width,
                y: a
            };
            break;
        default:
            l = {
                x: t.x,
                y: t.y
            }
    }
    var c = n ? qd(n) : null;
    if (c != null) {
        var h = c === "y" ? "height" : "width";
        switch (r) {
            case Sr:
                l[c] = l[c] - (t[h] / 2 - i[h] / 2);
                break;
            case xo:
                l[c] = l[c] + (t[h] / 2 - i[h] / 2);
                break
        }
    }
    return l
}

function Co(e, t) {
    t === void 0 && (t = {});
    var i = t,
        s = i.placement,
        n = s === void 0 ? e.placement : s,
        r = i.boundary,
        o = r === void 0 ? g0 : r,
        a = i.rootBoundary,
        l = a === void 0 ? Wd : a,
        c = i.elementContext,
        h = c === void 0 ? Kr : c,
        u = i.altBoundary,
        d = u === void 0 ? !1 : u,
        f = i.padding,
        p = f === void 0 ? 0 : f,
        m = R0(typeof p != "number" ? p : k0(p, Bo)),
        g = h === Kr ? v0 : Kr,
        y = e.rects.popper,
        x = e.elements[d ? g : h],
        v = wb(wo(x) ? x : x.contextElement || Fn(e.elements.popper), o, l),
        _ = Eo(e.elements.reference),
        C = O0({
            reference: _,
            element: y,
            strategy: "absolute",
            placement: n
        }),
        k = Cu(Object.assign({}, y, C)),
        S = h === Kr ? k : _,
        T = {
            top: v.top - S.top + m.top,
            bottom: S.bottom - v.bottom + m.bottom,
            left: v.left - S.left + m.left,
            right: S.right - v.right + m.right
        },
        L = e.modifiersData.offset;
    if (h === Kr && L) {
        var D = L[n];
        Object.keys(T).forEach(function(O) {
            var K = [Mi, Ii].indexOf(O) >= 0 ? 1 : -1,
                P = [ai, Ii].indexOf(O) >= 0 ? "y" : "x";
            T[O] += D[P] * K
        })
    }
    return T
}

function Tb(e, t) {
    t === void 0 && (t = {});
    var i = t,
        s = i.placement,
        n = i.boundary,
        r = i.rootBoundary,
        o = i.padding,
        a = i.flipVariations,
        l = i.allowedAutoPlacements,
        c = l === void 0 ? Xd : l,
        h = So(s),
        u = h ? a ? Su : Su.filter(function(p) {
            return So(p) === h
        }) : Bo,
        d = u.filter(function(p) {
            return c.indexOf(p) >= 0
        });
    d.length === 0 && (d = u);
    var f = d.reduce(function(p, m) {
        return p[m] = Co(e, {
            placement: m,
            boundary: n,
            rootBoundary: r,
            padding: o
        })[Rs(m)], p
    }, {});
    return Object.keys(f).sort(function(p, m) {
        return f[p] - f[m]
    })
}

function Eb(e) {
    if (Rs(e) === Bc) return [];
    var t = jl(e);
    return [Rp(e), t, Rp(t)]
}

function Sb(e) {
    var t = e.state,
        i = e.options,
        s = e.name;
    if (!t.modifiersData[s]._skip) {
        for (var n = i.mainAxis, r = n === void 0 ? !0 : n, o = i.altAxis, a = o === void 0 ? !0 : o, l = i.fallbackPlacements, c = i.padding, h = i.boundary, u = i.rootBoundary, d = i.altBoundary, f = i.flipVariations, p = f === void 0 ? !0 : f, m = i.allowedAutoPlacements, g = t.options.placement, y = Rs(g), x = y === g, v = l || (x || !p ? [jl(g)] : Eb(g)), _ = [g].concat(v).reduce(function(St, J) {
                return St.concat(Rs(J) === Bc ? Tb(t, {
                    placement: J,
                    boundary: h,
                    rootBoundary: u,
                    padding: c,
                    flipVariations: p,
                    allowedAutoPlacements: m
                }) : J)
            }, []), C = t.rects.reference, k = t.rects.popper, S = new Map, T = !0, L = _[0], D = 0; D < _.length; D++) {
            var O = _[D],
                K = Rs(O),
                P = So(O) === Sr,
                N = [ai, Ii].indexOf(K) >= 0,
                W = N ? "width" : "height",
                V = Co(t, {
                    placement: O,
                    boundary: h,
                    rootBoundary: u,
                    altBoundary: d,
                    padding: c
                }),
                Q = N ? P ? Mi : li : P ? Ii : ai;
            C[W] > k[W] && (Q = jl(Q));
            var pt = jl(Q),
                bt = [];
            if (r && bt.push(V[K] <= 0), a && bt.push(V[Q] <= 0, V[pt] <= 0), bt.every(function(St) {
                    return St
                })) {
                L = O, T = !1;
                break
            }
            S.set(O, bt)
        }
        if (T)
            for (var ct = p ? 3 : 1, gt = function(J) {
                    var wt = _.find(function(Tt) {
                        var Bt = S.get(Tt);
                        if (Bt) return Bt.slice(0, J).every(function(kt) {
                            return kt
                        })
                    });
                    if (wt) return L = wt, "break"
                }, xt = ct; xt > 0; xt--) {
                var It = gt(xt);
                if (It === "break") break
            }
        t.placement !== L && (t.modifiersData[s]._skip = !0, t.placement = L, t.reset = !0)
    }
}
var D0 = {
    name: "flip",
    enabled: !0,
    phase: "main",
    fn: Sb,
    requiresIfExists: ["offset"],
    data: {
        _skip: !1
    }
};

function Pp(e, t, i) {
    return i === void 0 && (i = {
        x: 0,
        y: 0
    }), {
        top: e.top - t.height - i.y,
        right: e.right - t.width + i.x,
        bottom: e.bottom - t.height + i.y,
        left: e.left - t.width - i.x
    }
}

function Lp(e) {
    return [ai, Mi, Ii, li].some(function(t) {
        return e[t] >= 0
    })
}

function Cb(e) {
    var t = e.state,
        i = e.name,
        s = t.rects.reference,
        n = t.rects.popper,
        r = t.modifiersData.preventOverflow,
        o = Co(t, {
            elementContext: "reference"
        }),
        a = Co(t, {
            altBoundary: !0
        }),
        l = Pp(o, s),
        c = Pp(a, n, r),
        h = Lp(l),
        u = Lp(c);
    t.modifiersData[i] = {
        referenceClippingOffsets: l,
        popperEscapeOffsets: c,
        isReferenceHidden: h,
        hasPopperEscaped: u
    }, t.attributes.popper = Object.assign({}, t.attributes.popper, {
        "data-popper-reference-hidden": h,
        "data-popper-escaped": u
    })
}
var N0 = {
    name: "hide",
    enabled: !0,
    phase: "main",
    requiresIfExists: ["preventOverflow"],
    fn: Cb
};

function Ab(e, t, i) {
    var s = Rs(e),
        n = [li, ai].indexOf(s) >= 0 ? -1 : 1,
        r = typeof i == "function" ? i(Object.assign({}, t, {
            placement: e
        })) : i,
        o = r[0],
        a = r[1];
    return o = o || 0, a = (a || 0) * n, [li, Mi].indexOf(s) >= 0 ? {
        x: a,
        y: o
    } : {
        x: o,
        y: a
    }
}

function Ib(e) {
    var t = e.state,
        i = e.options,
        s = e.name,
        n = i.offset,
        r = n === void 0 ? [0, 0] : n,
        o = Xd.reduce(function(h, u) {
            return h[u] = Ab(u, t.rects, r), h
        }, {}),
        a = o[t.placement],
        l = a.x,
        c = a.y;
    t.modifiersData.popperOffsets != null && (t.modifiersData.popperOffsets.x += l, t.modifiersData.popperOffsets.y += c), t.modifiersData[s] = o
}
var F0 = {
    name: "offset",
    enabled: !0,
    phase: "main",
    requires: ["popperOffsets"],
    fn: Ib
};

function Mb(e) {
    var t = e.state,
        i = e.name;
    t.modifiersData[i] = O0({
        reference: t.rects.reference,
        element: t.rects.popper,
        strategy: "absolute",
        placement: t.placement
    })
}
var nf = {
    name: "popperOffsets",
    enabled: !0,
    phase: "read",
    fn: Mb,
    data: {}
};

function Rb(e) {
    return e === "x" ? "y" : "x"
}

function kb(e) {
    var t = e.state,
        i = e.options,
        s = e.name,
        n = i.mainAxis,
        r = n === void 0 ? !0 : n,
        o = i.altAxis,
        a = o === void 0 ? !1 : o,
        l = i.boundary,
        c = i.rootBoundary,
        h = i.altBoundary,
        u = i.padding,
        d = i.tether,
        f = d === void 0 ? !0 : d,
        p = i.tetherOffset,
        m = p === void 0 ? 0 : p,
        g = Co(t, {
            boundary: l,
            rootBoundary: c,
            padding: u,
            altBoundary: h
        }),
        y = Rs(t.placement),
        x = So(t.placement),
        v = !x,
        _ = qd(y),
        C = Rb(_),
        k = t.modifiersData.popperOffsets,
        S = t.rects.reference,
        T = t.rects.popper,
        L = typeof m == "function" ? m(Object.assign({}, t.rects, {
            placement: t.placement
        })) : m,
        D = typeof L == "number" ? {
            mainAxis: L,
            altAxis: L
        } : Object.assign({
            mainAxis: 0,
            altAxis: 0
        }, L),
        O = t.modifiersData.offset ? t.modifiersData.offset[t.placement] : null,
        K = {
            x: 0,
            y: 0
        };
    if (!!k) {
        if (r) {
            var P, N = _ === "y" ? ai : li,
                W = _ === "y" ? Ii : Mi,
                V = _ === "y" ? "height" : "width",
                Q = k[_],
                pt = Q + g[N],
                bt = Q - g[W],
                ct = f ? -T[V] / 2 : 0,
                gt = x === Sr ? S[V] : T[V],
                xt = x === Sr ? -T[V] : -S[V],
                It = t.elements.arrow,
                St = f && It ? Zd(It) : {
                    width: 0,
                    height: 0
                },
                J = t.modifiersData["arrow#persistent"] ? t.modifiersData["arrow#persistent"].padding : M0(),
                wt = J[N],
                Tt = J[W],
                Bt = wa(0, S[V], St[V]),
                kt = v ? S[V] / 2 - ct - Bt - wt - D.mainAxis : gt - Bt - wt - D.mainAxis,
                re = v ? -S[V] / 2 + ct + Bt + Tt + D.mainAxis : xt + Bt + Tt + D.mainAxis,
                Xt = t.elements.arrow && Wa(t.elements.arrow),
                ce = Xt ? _ === "y" ? Xt.clientTop || 0 : Xt.clientLeft || 0 : 0,
                E = (P = O?.[_]) != null ? P : 0,
                M = Q + kt - E - ce,
                F = Q + re - E,
                $ = wa(f ? cc(pt, M) : pt, Q, f ? vr(bt, F) : bt);
            k[_] = $, K[_] = $ - Q
        }
        if (a) {
            var Y, rt = _ === "x" ? ai : li,
                dt = _ === "x" ? Ii : Mi,
                tt = k[C],
                it = C === "y" ? "height" : "width",
                Z = tt + g[rt],
                Ct = tt - g[dt],
                yt = [ai, li].indexOf(y) !== -1,
                At = (Y = O?.[C]) != null ? Y : 0,
                Pt = yt ? Z : tt - S[it] - T[it] - At + D.altAxis,
                Kt = yt ? tt + S[it] + T[it] - At - D.altAxis : Ct,
                me = f && yt ? lb(Pt, tt, Kt) : wa(f ? Pt : Z, tt, f ? Kt : Ct);
            k[C] = me, K[C] = me - tt
        }
        t.modifiersData[s] = K
    }
}
var B0 = {
    name: "preventOverflow",
    enabled: !0,
    phase: "main",
    fn: kb,
    requiresIfExists: ["offset"]
};

function Pb(e) {
    return {
        scrollLeft: e.scrollLeft,
        scrollTop: e.scrollTop
    }
}

function Lb(e) {
    return e === ps(e) || !zi(e) ? tf(e) : Pb(e)
}

function Ob(e) {
    var t = e.getBoundingClientRect(),
        i = To(t.width) / e.offsetWidth || 1,
        s = To(t.height) / e.offsetHeight || 1;
    return i !== 1 || s !== 1
}

function Db(e, t, i) {
    i === void 0 && (i = !1);
    var s = zi(t),
        n = zi(t) && Ob(t),
        r = Fn(t),
        o = Eo(e, n),
        a = {
            scrollLeft: 0,
            scrollTop: 0
        },
        l = {
            x: 0,
            y: 0
        };
    return (s || !s && !i) && ((Os(t) !== "body" || sf(r)) && (a = Lb(t)), zi(t) ? (l = Eo(t, !0), l.x += t.clientLeft, l.y += t.clientTop) : r && (l.x = ef(r))), {
        x: o.left + a.scrollLeft - l.x,
        y: o.top + a.scrollTop - l.y,
        width: o.width,
        height: o.height
    }
}

function Nb(e) {
    var t = new Map,
        i = new Set,
        s = [];
    e.forEach(function(r) {
        t.set(r.name, r)
    });

    function n(r) {
        i.add(r.name);
        var o = [].concat(r.requires || [], r.requiresIfExists || []);
        o.forEach(function(a) {
            if (!i.has(a)) {
                var l = t.get(a);
                l && n(l)
            }
        }), s.push(r)
    }
    return e.forEach(function(r) {
        i.has(r.name) || n(r)
    }), s
}

function Fb(e) {
    var t = Nb(e);
    return A0.reduce(function(i, s) {
        return i.concat(t.filter(function(n) {
            return n.phase === s
        }))
    }, [])
}

function Bb(e) {
    var t;
    return function() {
        return t || (t = new Promise(function(i) {
            Promise.resolve().then(function() {
                t = void 0, i(e())
            })
        })), t
    }
}

function Ub(e) {
    var t = e.reduce(function(i, s) {
        var n = i[s.name];
        return i[s.name] = n ? Object.assign({}, n, s, {
            options: Object.assign({}, n.options, s.options),
            data: Object.assign({}, n.data, s.data)
        }) : s, i
    }, {});
    return Object.keys(t).map(function(i) {
        return t[i]
    })
}
var Op = {
    placement: "bottom",
    modifiers: [],
    strategy: "absolute"
};

function Dp() {
    for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++) t[i] = arguments[i];
    return !t.some(function(s) {
        return !(s && typeof s.getBoundingClientRect == "function")
    })
}

function Gc(e) {
    e === void 0 && (e = {});
    var t = e,
        i = t.defaultModifiers,
        s = i === void 0 ? [] : i,
        n = t.defaultOptions,
        r = n === void 0 ? Op : n;
    return function(a, l, c) {
        c === void 0 && (c = r);
        var h = {
                placement: "bottom",
                orderedModifiers: [],
                options: Object.assign({}, Op, r),
                modifiersData: {},
                elements: {
                    reference: a,
                    popper: l
                },
                attributes: {},
                styles: {}
            },
            u = [],
            d = !1,
            f = {
                state: h,
                setOptions: function(y) {
                    var x = typeof y == "function" ? y(h.options) : y;
                    m(), h.options = Object.assign({}, r, h.options, x), h.scrollParents = {
                        reference: wo(a) ? Ta(a) : a.contextElement ? Ta(a.contextElement) : [],
                        popper: Ta(l)
                    };
                    var v = Fb(Ub([].concat(s, h.options.modifiers)));
                    return h.orderedModifiers = v.filter(function(_) {
                        return _.enabled
                    }), p(), f.update()
                },
                forceUpdate: function() {
                    if (!d) {
                        var y = h.elements,
                            x = y.reference,
                            v = y.popper;
                        if (!!Dp(x, v)) {
                            h.rects = {
                                reference: Db(x, Wa(v), h.options.strategy === "fixed"),
                                popper: Zd(v)
                            }, h.reset = !1, h.placement = h.options.placement, h.orderedModifiers.forEach(function(D) {
                                return h.modifiersData[D.name] = Object.assign({}, D.data)
                            });
                            for (var _ = 0; _ < h.orderedModifiers.length; _++) {
                                if (h.reset === !0) {
                                    h.reset = !1, _ = -1;
                                    continue
                                }
                                var C = h.orderedModifiers[_],
                                    k = C.fn,
                                    S = C.options,
                                    T = S === void 0 ? {} : S,
                                    L = C.name;
                                typeof k == "function" && (h = k({
                                    state: h,
                                    options: T,
                                    name: L,
                                    instance: f
                                }) || h)
                            }
                        }
                    }
                },
                update: Bb(function() {
                    return new Promise(function(g) {
                        f.forceUpdate(), g(h)
                    })
                }),
                destroy: function() {
                    m(), d = !0
                }
            };
        if (!Dp(a, l)) return f;
        f.setOptions(c).then(function(g) {
            !d && c.onFirstUpdate && c.onFirstUpdate(g)
        });

        function p() {
            h.orderedModifiers.forEach(function(g) {
                var y = g.name,
                    x = g.options,
                    v = x === void 0 ? {} : x,
                    _ = g.effect;
                if (typeof _ == "function") {
                    var C = _({
                            state: h,
                            name: y,
                            instance: f,
                            options: v
                        }),
                        k = function() {};
                    u.push(C || k)
                }
            })
        }

        function m() {
            u.forEach(function(g) {
                return g()
            }), u = []
        }
        return f
    }
}
var Gb = Gc(),
    Hb = [Qd, nf, Jd, Kd],
    Vb = Gc({
        defaultModifiers: Hb
    }),
    zb = [Qd, nf, Jd, Kd, F0, D0, B0, P0, N0],
    rf = Gc({
        defaultModifiers: zb
    }),
    U0 = Object.freeze(Object.defineProperty({
        __proto__: null,
        popperGenerator: Gc,
        detectOverflow: Co,
        createPopperBase: Gb,
        createPopper: rf,
        createPopperLite: Vb,
        top: ai,
        bottom: Ii,
        right: Mi,
        left: li,
        auto: Bc,
        basePlacements: Bo,
        start: Sr,
        end: xo,
        clippingParents: g0,
        viewport: Wd,
        popper: Kr,
        reference: v0,
        variationPlacements: Su,
        placements: Xd,
        beforeRead: _0,
        read: y0,
        afterRead: b0,
        beforeMain: x0,
        main: w0,
        afterMain: T0,
        beforeWrite: E0,
        write: S0,
        afterWrite: C0,
        modifierPhases: A0,
        applyStyles: Kd,
        arrow: P0,
        computeStyles: Jd,
        eventListeners: Qd,
        flip: D0,
        hide: N0,
        offset: F0,
        popperOffsets: nf,
        preventOverflow: B0
    }, Symbol.toStringTag, {
        value: "Module"
    }));
/*!
 * Bootstrap v5.2.0 (https://getbootstrap.com/)
 * Copyright 2011-2022 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)
 * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)
 */
const $b = 1e6,
    jb = 1e3,
    Au = "transitionend",
    Wb = e => e == null ? `${e}` : Object.prototype.toString.call(e).match(/\s([a-z]+)/i)[1].toLowerCase(),
    Xb = e => {
        do e += Math.floor(Math.random() * $b); while (document.getElementById(e));
        return e
    },
    G0 = e => {
        let t = e.getAttribute("data-bs-target");
        if (!t || t === "#") {
            let i = e.getAttribute("href");
            if (!i || !i.includes("#") && !i.startsWith(".")) return null;
            i.includes("#") && !i.startsWith("#") && (i = `#${i.split("#")[1]}`), t = i && i !== "#" ? i.trim() : null
        }
        return t
    },
    H0 = e => {
        const t = G0(e);
        return t && document.querySelector(t) ? t : null
    },
    Xs = e => {
        const t = G0(e);
        return t ? document.querySelector(t) : null
    },
    Yb = e => {
        if (!e) return 0;
        let {
            transitionDuration: t,
            transitionDelay: i
        } = window.getComputedStyle(e);
        const s = Number.parseFloat(t),
            n = Number.parseFloat(i);
        return !s && !n ? 0 : (t = t.split(",")[0], i = i.split(",")[0], (Number.parseFloat(t) + Number.parseFloat(i)) * jb)
    },
    V0 = e => {
        e.dispatchEvent(new Event(Au))
    },
    Ys = e => !e || typeof e != "object" ? !1 : (typeof e.jquery < "u" && (e = e[0]), typeof e.nodeType < "u"),
    Mn = e => Ys(e) ? e.jquery ? e[0] : e : typeof e == "string" && e.length > 0 ? document.querySelector(e) : null,
    Uo = e => {
        if (!Ys(e) || e.getClientRects().length === 0) return !1;
        const t = getComputedStyle(e).getPropertyValue("visibility") === "visible",
            i = e.closest("details:not([open])");
        if (!i) return t;
        if (i !== e) {
            const s = e.closest("summary");
            if (s && s.parentNode !== i || s === null) return !1
        }
        return t
    },
    Rn = e => !e || e.nodeType !== Node.ELEMENT_NODE || e.classList.contains("disabled") ? !0 : typeof e.disabled < "u" ? e.disabled : e.hasAttribute("disabled") && e.getAttribute("disabled") !== "false",
    z0 = e => {
        if (!document.documentElement.attachShadow) return null;
        if (typeof e.getRootNode == "function") {
            const t = e.getRootNode();
            return t instanceof ShadowRoot ? t : null
        }
        return e instanceof ShadowRoot ? e : e.parentNode ? z0(e.parentNode) : null
    },
    hc = () => {},
    Xa = e => {
        e.offsetHeight
    },
    $0 = () => window.jQuery && !document.body.hasAttribute("data-bs-no-jquery") ? window.jQuery : null,
    Ah = [],
    Kb = e => {
        document.readyState === "loading" ? (Ah.length || document.addEventListener("DOMContentLoaded", () => {
            for (const t of Ah) t()
        }), Ah.push(e)) : e()
    },
    ji = () => document.documentElement.dir === "rtl",
    Wi = e => {
        Kb(() => {
            const t = $0();
            if (t) {
                const i = e.NAME,
                    s = t.fn[i];
                t.fn[i] = e.jQueryInterface, t.fn[i].Constructor = e, t.fn[i].noConflict = () => (t.fn[i] = s, e.jQueryInterface)
            }
        })
    },
    $s = e => {
        typeof e == "function" && e()
    },
    j0 = (e, t, i = !0) => {
        if (!i) {
            $s(e);
            return
        }
        const s = 5,
            n = Yb(t) + s;
        let r = !1;
        const o = ({
            target: a
        }) => {
            a === t && (r = !0, t.removeEventListener(Au, o), $s(e))
        };
        t.addEventListener(Au, o), setTimeout(() => {
            r || V0(t)
        }, n)
    },
    of = (e, t, i, s) => {
        const n = e.length;
        let r = e.indexOf(t);
        return r === -1 ? !i && s ? e[n - 1] : e[0] : (r += i ? 1 : -1, s && (r = (r + n) % n), e[Math.max(0, Math.min(r, n - 1))])
    },
    Zb = /[^.]*(?=\..*)\.|.*/,
    qb = /\..*/,
    Jb = /::\d+$/,
    Ih = {};
let Np = 1;
const W0 = {
        mouseenter: "mouseover",
        mouseleave: "mouseout"
    },
    Qb = new Set(["click", "dblclick", "mouseup", "mousedown", "contextmenu", "mousewheel", "DOMMouseScroll", "mouseover", "mouseout", "mousemove", "selectstart", "selectend", "keydown", "keypress", "keyup", "orientationchange", "touchstart", "touchmove", "touchend", "touchcancel", "pointerdown", "pointermove", "pointerup", "pointerleave", "pointercancel", "gesturestart", "gesturechange", "gestureend", "focus", "blur", "change", "reset", "select", "submit", "focusin", "focusout", "load", "unload", "beforeunload", "resize", "move", "DOMContentLoaded", "readystatechange", "error", "abort", "scroll"]);

function X0(e, t) {
    return t && `${t}::${Np++}` || e.uidEvent || Np++
}

function Y0(e) {
    const t = X0(e);
    return e.uidEvent = t, Ih[t] = Ih[t] || {}, Ih[t]
}

function tx(e, t) {
    return function i(s) {
        return af(s, {
            delegateTarget: e
        }), i.oneOff && q.off(e, s.type, t), t.apply(e, [s])
    }
}

function ex(e, t, i) {
    return function s(n) {
        const r = e.querySelectorAll(t);
        for (let {
                target: o
            } = n; o && o !== this; o = o.parentNode)
            for (const a of r)
                if (a === o) return af(n, {
                    delegateTarget: o
                }), s.oneOff && q.off(e, n.type, t, i), i.apply(o, [n])
    }
}

function K0(e, t, i = null) {
    return Object.values(e).find(s => s.callable === t && s.delegationSelector === i)
}

function Z0(e, t, i) {
    const s = typeof t == "string",
        n = s ? i : t || i;
    let r = q0(e);
    return Qb.has(r) || (r = e), [s, n, r]
}

function Fp(e, t, i, s, n) {
    if (typeof t != "string" || !e) return;
    let [r, o, a] = Z0(t, i, s);
    t in W0 && (o = (p => function(m) {
        if (!m.relatedTarget || m.relatedTarget !== m.delegateTarget && !m.delegateTarget.contains(m.relatedTarget)) return p.call(this, m)
    })(o));
    const l = Y0(e),
        c = l[a] || (l[a] = {}),
        h = K0(c, o, r ? i : null);
    if (h) {
        h.oneOff = h.oneOff && n;
        return
    }
    const u = X0(o, t.replace(Zb, "")),
        d = r ? ex(e, i, o) : tx(e, o);
    d.delegationSelector = r ? i : null, d.callable = o, d.oneOff = n, d.uidEvent = u, c[u] = d, e.addEventListener(a, d, r)
}

function Iu(e, t, i, s, n) {
    const r = K0(t[i], s, n);
    !r || (e.removeEventListener(i, r, Boolean(n)), delete t[i][r.uidEvent])
}

function ix(e, t, i, s) {
    const n = t[i] || {};
    for (const r of Object.keys(n))
        if (r.includes(s)) {
            const o = n[r];
            Iu(e, t, i, o.callable, o.delegationSelector)
        }
}

function q0(e) {
    return e = e.replace(qb, ""), W0[e] || e
}
const q = {
    on(e, t, i, s) {
        Fp(e, t, i, s, !1)
    },
    one(e, t, i, s) {
        Fp(e, t, i, s, !0)
    },
    off(e, t, i, s) {
        if (typeof t != "string" || !e) return;
        const [n, r, o] = Z0(t, i, s), a = o !== t, l = Y0(e), c = l[o] || {}, h = t.startsWith(".");
        if (typeof r < "u") {
            if (!Object.keys(c).length) return;
            Iu(e, l, o, r, n ? i : null);
            return
        }
        if (h)
            for (const u of Object.keys(l)) ix(e, l, u, t.slice(1));
        for (const u of Object.keys(c)) {
            const d = u.replace(Jb, "");
            if (!a || t.includes(d)) {
                const f = c[u];
                Iu(e, l, o, f.callable, f.delegationSelector)
            }
        }
    },
    trigger(e, t, i) {
        if (typeof t != "string" || !e) return null;
        const s = $0(),
            n = q0(t),
            r = t !== n;
        let o = null,
            a = !0,
            l = !0,
            c = !1;
        r && s && (o = s.Event(t, i), s(e).trigger(o), a = !o.isPropagationStopped(), l = !o.isImmediatePropagationStopped(), c = o.isDefaultPrevented());
        let h = new Event(t, {
            bubbles: a,
            cancelable: !0
        });
        return h = af(h, i), c && h.preventDefault(), l && e.dispatchEvent(h), h.defaultPrevented && o && o.preventDefault(), h
    }
};

function af(e, t) {
    for (const [i, s] of Object.entries(t || {})) try {
        e[i] = s
    } catch {
        Object.defineProperty(e, i, {
            configurable: !0,
            get() {
                return s
            }
        })
    }
    return e
}
const cn = new Map,
    Mh = {
        set(e, t, i) {
            cn.has(e) || cn.set(e, new Map);
            const s = cn.get(e);
            if (!s.has(t) && s.size !== 0) {
                console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(s.keys())[0]}.`);
                return
            }
            s.set(t, i)
        },
        get(e, t) {
            return cn.has(e) && cn.get(e).get(t) || null
        },
        remove(e, t) {
            if (!cn.has(e)) return;
            const i = cn.get(e);
            i.delete(t), i.size === 0 && cn.delete(e)
        }
    };

function Bp(e) {
    if (e === "true") return !0;
    if (e === "false") return !1;
    if (e === Number(e).toString()) return Number(e);
    if (e === "" || e === "null") return null;
    if (typeof e != "string") return e;
    try {
        return JSON.parse(decodeURIComponent(e))
    } catch {
        return e
    }
}

function Rh(e) {
    return e.replace(/[A-Z]/g, t => `-${t.toLowerCase()}`)
}
const Ks = {
    setDataAttribute(e, t, i) {
        e.setAttribute(`data-bs-${Rh(t)}`, i)
    },
    removeDataAttribute(e, t) {
        e.removeAttribute(`data-bs-${Rh(t)}`)
    },
    getDataAttributes(e) {
        if (!e) return {};
        const t = {},
            i = Object.keys(e.dataset).filter(s => s.startsWith("bs") && !s.startsWith("bsConfig"));
        for (const s of i) {
            let n = s.replace(/^bs/, "");
            n = n.charAt(0).toLowerCase() + n.slice(1, n.length), t[n] = Bp(e.dataset[s])
        }
        return t
    },
    getDataAttribute(e, t) {
        return Bp(e.getAttribute(`data-bs-${Rh(t)}`))
    }
};
class Ya {
    static get Default() {
        return {}
    }
    static get DefaultType() {
        return {}
    }
    static get NAME() {
        throw new Error('You have to implement the static method "NAME", for each component!')
    }
    _getConfig(t) {
        return t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
    }
    _configAfterMerge(t) {
        return t
    }
    _mergeConfigObj(t, i) {
        const s = Ys(i) ? Ks.getDataAttribute(i, "config") : {};
        return {
            ...this.constructor.Default,
            ...typeof s == "object" ? s : {},
            ...Ys(i) ? Ks.getDataAttributes(i) : {},
            ...typeof t == "object" ? t : {}
        }
    }
    _typeCheckConfig(t, i = this.constructor.DefaultType) {
        for (const s of Object.keys(i)) {
            const n = i[s],
                r = t[s],
                o = Ys(r) ? "element" : Wb(r);
            if (!new RegExp(n).test(o)) throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option "${s}" provided type "${o}" but expected type "${n}".`)
        }
    }
}
const sx = "5.2.0";
class ms extends Ya {
    constructor(t, i) {
        super(), t = Mn(t), t && (this._element = t, this._config = this._getConfig(i), Mh.set(this._element, this.constructor.DATA_KEY, this))
    }
    dispose() {
        Mh.remove(this._element, this.constructor.DATA_KEY), q.off(this._element, this.constructor.EVENT_KEY);
        for (const t of Object.getOwnPropertyNames(this)) this[t] = null
    }
    _queueCallback(t, i, s = !0) {
        j0(t, i, s)
    }
    _getConfig(t) {
        return t = this._mergeConfigObj(t, this._element), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
    }
    static getInstance(t) {
        return Mh.get(Mn(t), this.DATA_KEY)
    }
    static getOrCreateInstance(t, i = {}) {
        return this.getInstance(t) || new this(t, typeof i == "object" ? i : null)
    }
    static get VERSION() {
        return sx
    }
    static get DATA_KEY() {
        return `bs.${this.NAME}`
    }
    static get EVENT_KEY() {
        return `.${this.DATA_KEY}`
    }
    static eventName(t) {
        return `${t}${this.EVENT_KEY}`
    }
}
const Hc = (e, t = "hide") => {
        const i = `click.dismiss${e.EVENT_KEY}`,
            s = e.NAME;
        q.on(document, i, `[data-bs-dismiss="${s}"]`, function(n) {
            if (["A", "AREA"].includes(this.tagName) && n.preventDefault(), Rn(this)) return;
            const r = Xs(this) || this.closest(`.${s}`);
            e.getOrCreateInstance(r)[t]()
        })
    },
    nx = "alert",
    rx = "bs.alert",
    J0 = `.${rx}`,
    ox = `close${J0}`,
    ax = `closed${J0}`,
    lx = "fade",
    cx = "show";
class Vc extends ms {
    static get NAME() {
        return nx
    }
    close() {
        if (q.trigger(this._element, ox).defaultPrevented) return;
        this._element.classList.remove(cx);
        const i = this._element.classList.contains(lx);
        this._queueCallback(() => this._destroyElement(), this._element, i)
    }
    _destroyElement() {
        this._element.remove(), q.trigger(this._element, ax), this.dispose()
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = Vc.getOrCreateInstance(this);
            if (typeof t == "string") {
                if (i[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`);
                i[t](this)
            }
        })
    }
}
Hc(Vc, "close");
Wi(Vc);
const hx = "button",
    ux = "bs.button",
    dx = `.${ux}`,
    fx = ".data-api",
    px = "active",
    Up = '[data-bs-toggle="button"]',
    mx = `click${dx}${fx}`;
class zc extends ms {
    static get NAME() {
        return hx
    }
    toggle() {
        this._element.setAttribute("aria-pressed", this._element.classList.toggle(px))
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = zc.getOrCreateInstance(this);
            t === "toggle" && i[t]()
        })
    }
}
q.on(document, mx, Up, e => {
    e.preventDefault();
    const t = e.target.closest(Up);
    zc.getOrCreateInstance(t).toggle()
});
Wi(zc);
const te = {
        find(e, t = document.documentElement) {
            return [].concat(...Element.prototype.querySelectorAll.call(t, e))
        },
        findOne(e, t = document.documentElement) {
            return Element.prototype.querySelector.call(t, e)
        },
        children(e, t) {
            return [].concat(...e.children).filter(i => i.matches(t))
        },
        parents(e, t) {
            const i = [];
            let s = e.parentNode.closest(t);
            for (; s;) i.push(s), s = s.parentNode.closest(t);
            return i
        },
        prev(e, t) {
            let i = e.previousElementSibling;
            for (; i;) {
                if (i.matches(t)) return [i];
                i = i.previousElementSibling
            }
            return []
        },
        next(e, t) {
            let i = e.nextElementSibling;
            for (; i;) {
                if (i.matches(t)) return [i];
                i = i.nextElementSibling
            }
            return []
        },
        focusableChildren(e) {
            const t = ["a", "button", "input", "textarea", "select", "details", "[tabindex]", '[contenteditable="true"]'].map(i => `${i}:not([tabindex^="-"])`).join(",");
            return this.find(t, e).filter(i => !Rn(i) && Uo(i))
        }
    },
    gx = "swipe",
    Go = ".bs.swipe",
    vx = `touchstart${Go}`,
    _x = `touchmove${Go}`,
    yx = `touchend${Go}`,
    bx = `pointerdown${Go}`,
    xx = `pointerup${Go}`,
    wx = "touch",
    Tx = "pen",
    Ex = "pointer-event",
    Sx = 40,
    Cx = {
        endCallback: null,
        leftCallback: null,
        rightCallback: null
    },
    Ax = {
        endCallback: "(function|null)",
        leftCallback: "(function|null)",
        rightCallback: "(function|null)"
    };
class uc extends Ya {
    constructor(t, i) {
        super(), this._element = t, !(!t || !uc.isSupported()) && (this._config = this._getConfig(i), this._deltaX = 0, this._supportPointerEvents = Boolean(window.PointerEvent), this._initEvents())
    }
    static get Default() {
        return Cx
    }
    static get DefaultType() {
        return Ax
    }
    static get NAME() {
        return gx
    }
    dispose() {
        q.off(this._element, Go)
    }
    _start(t) {
        if (!this._supportPointerEvents) {
            this._deltaX = t.touches[0].clientX;
            return
        }
        this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX)
    }
    _end(t) {
        this._eventIsPointerPenTouch(t) && (this._deltaX = t.clientX - this._deltaX), this._handleSwipe(), $s(this._config.endCallback)
    }
    _move(t) {
        this._deltaX = t.touches && t.touches.length > 1 ? 0 : t.touches[0].clientX - this._deltaX
    }
    _handleSwipe() {
        const t = Math.abs(this._deltaX);
        if (t <= Sx) return;
        const i = t / this._deltaX;
        this._deltaX = 0, i && $s(i > 0 ? this._config.rightCallback : this._config.leftCallback)
    }
    _initEvents() {
        this._supportPointerEvents ? (q.on(this._element, bx, t => this._start(t)), q.on(this._element, xx, t => this._end(t)), this._element.classList.add(Ex)) : (q.on(this._element, vx, t => this._start(t)), q.on(this._element, _x, t => this._move(t)), q.on(this._element, yx, t => this._end(t)))
    }
    _eventIsPointerPenTouch(t) {
        return this._supportPointerEvents && (t.pointerType === Tx || t.pointerType === wx)
    }
    static isSupported() {
        return "ontouchstart" in document.documentElement || navigator.maxTouchPoints > 0
    }
}
const Ix = "carousel",
    Mx = "bs.carousel",
    Bn = `.${Mx}`,
    Q0 = ".data-api",
    Rx = "ArrowLeft",
    kx = "ArrowRight",
    Px = 500,
    Xo = "next",
    Nr = "prev",
    Zr = "left",
    Wl = "right",
    Lx = `slide${Bn}`,
    kh = `slid${Bn}`,
    Ox = `keydown${Bn}`,
    Dx = `mouseenter${Bn}`,
    Nx = `mouseleave${Bn}`,
    Fx = `dragstart${Bn}`,
    Bx = `load${Bn}${Q0}`,
    Ux = `click${Bn}${Q0}`,
    tv = "carousel",
    rl = "active",
    Gx = "slide",
    Hx = "carousel-item-end",
    Vx = "carousel-item-start",
    zx = "carousel-item-next",
    $x = "carousel-item-prev",
    ev = ".active",
    iv = ".carousel-item",
    jx = ev + iv,
    Wx = ".carousel-item img",
    Xx = ".carousel-indicators",
    Yx = "[data-bs-slide], [data-bs-slide-to]",
    Kx = '[data-bs-ride="carousel"]',
    Zx = {
        [Rx]: Wl,
        [kx]: Zr
    },
    qx = {
        interval: 5e3,
        keyboard: !0,
        pause: "hover",
        ride: !1,
        touch: !0,
        wrap: !0
    },
    Jx = {
        interval: "(number|boolean)",
        keyboard: "boolean",
        pause: "(string|boolean)",
        ride: "(boolean|string)",
        touch: "boolean",
        wrap: "boolean"
    };
class Ka extends ms {
    constructor(t, i) {
        super(t, i), this._interval = null, this._activeElement = null, this._isSliding = !1, this.touchTimeout = null, this._swipeHelper = null, this._indicatorsElement = te.findOne(Xx, this._element), this._addEventListeners(), this._config.ride === tv && this.cycle()
    }
    static get Default() {
        return qx
    }
    static get DefaultType() {
        return Jx
    }
    static get NAME() {
        return Ix
    }
    next() {
        this._slide(Xo)
    }
    nextWhenVisible() {
        !document.hidden && Uo(this._element) && this.next()
    }
    prev() {
        this._slide(Nr)
    }
    pause() {
        this._isSliding && V0(this._element), this._clearInterval()
    }
    cycle() {
        this._clearInterval(), this._updateInterval(), this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval)
    }
    _maybeEnableCycle() {
        if (!!this._config.ride) {
            if (this._isSliding) {
                q.one(this._element, kh, () => this.cycle());
                return
            }
            this.cycle()
        }
    }
    to(t) {
        const i = this._getItems();
        if (t > i.length - 1 || t < 0) return;
        if (this._isSliding) {
            q.one(this._element, kh, () => this.to(t));
            return
        }
        const s = this._getItemIndex(this._getActive());
        if (s === t) return;
        const n = t > s ? Xo : Nr;
        this._slide(n, i[t])
    }
    dispose() {
        this._swipeHelper && this._swipeHelper.dispose(), super.dispose()
    }
    _configAfterMerge(t) {
        return t.defaultInterval = t.interval, t
    }
    _addEventListeners() {
        this._config.keyboard && q.on(this._element, Ox, t => this._keydown(t)), this._config.pause === "hover" && (q.on(this._element, Dx, () => this.pause()), q.on(this._element, Nx, () => this._maybeEnableCycle())), this._config.touch && uc.isSupported() && this._addTouchEventListeners()
    }
    _addTouchEventListeners() {
        for (const s of te.find(Wx, this._element)) q.on(s, Fx, n => n.preventDefault());
        const i = {
            leftCallback: () => this._slide(this._directionToOrder(Zr)),
            rightCallback: () => this._slide(this._directionToOrder(Wl)),
            endCallback: () => {
                this._config.pause === "hover" && (this.pause(), this.touchTimeout && clearTimeout(this.touchTimeout), this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), Px + this._config.interval))
            }
        };
        this._swipeHelper = new uc(this._element, i)
    }
    _keydown(t) {
        if (/input|textarea/i.test(t.target.tagName)) return;
        const i = Zx[t.key];
        i && (t.preventDefault(), this._slide(this._directionToOrder(i)))
    }
    _getItemIndex(t) {
        return this._getItems().indexOf(t)
    }
    _setActiveIndicatorElement(t) {
        if (!this._indicatorsElement) return;
        const i = te.findOne(ev, this._indicatorsElement);
        i.classList.remove(rl), i.removeAttribute("aria-current");
        const s = te.findOne(`[data-bs-slide-to="${t}"]`, this._indicatorsElement);
        s && (s.classList.add(rl), s.setAttribute("aria-current", "true"))
    }
    _updateInterval() {
        const t = this._activeElement || this._getActive();
        if (!t) return;
        const i = Number.parseInt(t.getAttribute("data-bs-interval"), 10);
        this._config.interval = i || this._config.defaultInterval
    }
    _slide(t, i = null) {
        if (this._isSliding) return;
        const s = this._getActive(),
            n = t === Xo,
            r = i || of(this._getItems(), s, n, this._config.wrap);
        if (r === s) return;
        const o = this._getItemIndex(r),
            a = f => q.trigger(this._element, f, {
                relatedTarget: r,
                direction: this._orderToDirection(t),
                from: this._getItemIndex(s),
                to: o
            });
        if (a(Lx).defaultPrevented || !s || !r) return;
        const c = Boolean(this._interval);
        this.pause(), this._isSliding = !0, this._setActiveIndicatorElement(o), this._activeElement = r;
        const h = n ? Vx : Hx,
            u = n ? zx : $x;
        r.classList.add(u), Xa(r), s.classList.add(h), r.classList.add(h);
        const d = () => {
            r.classList.remove(h, u), r.classList.add(rl), s.classList.remove(rl, u, h), this._isSliding = !1, a(kh)
        };
        this._queueCallback(d, s, this._isAnimated()), c && this.cycle()
    }
    _isAnimated() {
        return this._element.classList.contains(Gx)
    }
    _getActive() {
        return te.findOne(jx, this._element)
    }
    _getItems() {
        return te.find(iv, this._element)
    }
    _clearInterval() {
        this._interval && (clearInterval(this._interval), this._interval = null)
    }
    _directionToOrder(t) {
        return ji() ? t === Zr ? Nr : Xo : t === Zr ? Xo : Nr
    }
    _orderToDirection(t) {
        return ji() ? t === Nr ? Zr : Wl : t === Nr ? Wl : Zr
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = Ka.getOrCreateInstance(this, t);
            if (typeof t == "number") {
                i.to(t);
                return
            }
            if (typeof t == "string") {
                if (i[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        })
    }
}
q.on(document, Ux, Yx, function(e) {
    const t = Xs(this);
    if (!t || !t.classList.contains(tv)) return;
    e.preventDefault();
    const i = Ka.getOrCreateInstance(t),
        s = this.getAttribute("data-bs-slide-to");
    if (s) {
        i.to(s), i._maybeEnableCycle();
        return
    }
    if (Ks.getDataAttribute(this, "slide") === "next") {
        i.next(), i._maybeEnableCycle();
        return
    }
    i.prev(), i._maybeEnableCycle()
});
q.on(window, Bx, () => {
    const e = te.find(Kx);
    for (const t of e) Ka.getOrCreateInstance(t)
});
Wi(Ka);
const Qx = "collapse",
    t2 = "bs.collapse",
    Za = `.${t2}`,
    e2 = ".data-api",
    i2 = `show${Za}`,
    s2 = `shown${Za}`,
    n2 = `hide${Za}`,
    r2 = `hidden${Za}`,
    o2 = `click${Za}${e2}`,
    Ph = "show",
    ro = "collapse",
    ol = "collapsing",
    a2 = "collapsed",
    l2 = `:scope .${ro} .${ro}`,
    c2 = "collapse-horizontal",
    h2 = "width",
    u2 = "height",
    d2 = ".collapse.show, .collapse.collapsing",
    Mu = '[data-bs-toggle="collapse"]',
    f2 = {
        parent: null,
        toggle: !0
    },
    p2 = {
        parent: "(null|element)",
        toggle: "boolean"
    };
class Ra extends ms {
    constructor(t, i) {
        super(t, i), this._isTransitioning = !1, this._triggerArray = [];
        const s = te.find(Mu);
        for (const n of s) {
            const r = H0(n),
                o = te.find(r).filter(a => a === this._element);
            r !== null && o.length && this._triggerArray.push(n)
        }
        this._initializeChildren(), this._config.parent || this._addAriaAndCollapsedClass(this._triggerArray, this._isShown()), this._config.toggle && this.toggle()
    }
    static get Default() {
        return f2
    }
    static get DefaultType() {
        return p2
    }
    static get NAME() {
        return Qx
    }
    toggle() {
        this._isShown() ? this.hide() : this.show()
    }
    show() {
        if (this._isTransitioning || this._isShown()) return;
        let t = [];
        if (this._config.parent && (t = this._getFirstLevelChildren(d2).filter(a => a !== this._element).map(a => Ra.getOrCreateInstance(a, {
                toggle: !1
            }))), t.length && t[0]._isTransitioning || q.trigger(this._element, i2).defaultPrevented) return;
        for (const a of t) a.hide();
        const s = this._getDimension();
        this._element.classList.remove(ro), this._element.classList.add(ol), this._element.style[s] = 0, this._addAriaAndCollapsedClass(this._triggerArray, !0), this._isTransitioning = !0;
        const n = () => {
                this._isTransitioning = !1, this._element.classList.remove(ol), this._element.classList.add(ro, Ph), this._element.style[s] = "", q.trigger(this._element, s2)
            },
            o = `scroll${s[0].toUpperCase()+s.slice(1)}`;
        this._queueCallback(n, this._element, !0), this._element.style[s] = `${this._element[o]}px`
    }
    hide() {
        if (this._isTransitioning || !this._isShown() || q.trigger(this._element, n2).defaultPrevented) return;
        const i = this._getDimension();
        this._element.style[i] = `${this._element.getBoundingClientRect()[i]}px`, Xa(this._element), this._element.classList.add(ol), this._element.classList.remove(ro, Ph);
        for (const n of this._triggerArray) {
            const r = Xs(n);
            r && !this._isShown(r) && this._addAriaAndCollapsedClass([n], !1)
        }
        this._isTransitioning = !0;
        const s = () => {
            this._isTransitioning = !1, this._element.classList.remove(ol), this._element.classList.add(ro), q.trigger(this._element, r2)
        };
        this._element.style[i] = "", this._queueCallback(s, this._element, !0)
    }
    _isShown(t = this._element) {
        return t.classList.contains(Ph)
    }
    _configAfterMerge(t) {
        return t.toggle = Boolean(t.toggle), t.parent = Mn(t.parent), t
    }
    _getDimension() {
        return this._element.classList.contains(c2) ? h2 : u2
    }
    _initializeChildren() {
        if (!this._config.parent) return;
        const t = this._getFirstLevelChildren(Mu);
        for (const i of t) {
            const s = Xs(i);
            s && this._addAriaAndCollapsedClass([i], this._isShown(s))
        }
    }
    _getFirstLevelChildren(t) {
        const i = te.find(l2, this._config.parent);
        return te.find(t, this._config.parent).filter(s => !i.includes(s))
    }
    _addAriaAndCollapsedClass(t, i) {
        if (!!t.length)
            for (const s of t) s.classList.toggle(a2, !i), s.setAttribute("aria-expanded", i)
    }
    static jQueryInterface(t) {
        const i = {};
        return typeof t == "string" && /show|hide/.test(t) && (i.toggle = !1), this.each(function() {
            const s = Ra.getOrCreateInstance(this, i);
            if (typeof t == "string") {
                if (typeof s[t] > "u") throw new TypeError(`No method named "${t}"`);
                s[t]()
            }
        })
    }
}
q.on(document, o2, Mu, function(e) {
    (e.target.tagName === "A" || e.delegateTarget && e.delegateTarget.tagName === "A") && e.preventDefault();
    const t = H0(this),
        i = te.find(t);
    for (const s of i) Ra.getOrCreateInstance(s, {
        toggle: !1
    }).toggle()
});
Wi(Ra);
const Gp = "dropdown",
    m2 = "bs.dropdown",
    Mr = `.${m2}`,
    lf = ".data-api",
    g2 = "Escape",
    Hp = "Tab",
    v2 = "ArrowUp",
    Vp = "ArrowDown",
    _2 = 2,
    y2 = `hide${Mr}`,
    b2 = `hidden${Mr}`,
    x2 = `show${Mr}`,
    w2 = `shown${Mr}`,
    sv = `click${Mr}${lf}`,
    nv = `keydown${Mr}${lf}`,
    T2 = `keyup${Mr}${lf}`,
    qr = "show",
    E2 = "dropup",
    S2 = "dropend",
    C2 = "dropstart",
    A2 = "dropup-center",
    I2 = "dropdown-center",
    $c = '[data-bs-toggle="dropdown"]:not(.disabled):not(:disabled)',
    M2 = `${$c}.${qr}`,
    rv = ".dropdown-menu",
    R2 = ".navbar",
    k2 = ".navbar-nav",
    P2 = ".dropdown-menu .dropdown-item:not(.disabled):not(:disabled)",
    L2 = ji() ? "top-end" : "top-start",
    O2 = ji() ? "top-start" : "top-end",
    D2 = ji() ? "bottom-end" : "bottom-start",
    N2 = ji() ? "bottom-start" : "bottom-end",
    F2 = ji() ? "left-start" : "right-start",
    B2 = ji() ? "right-start" : "left-start",
    U2 = "top",
    G2 = "bottom",
    H2 = {
        autoClose: !0,
        boundary: "clippingParents",
        display: "dynamic",
        offset: [0, 2],
        popperConfig: null,
        reference: "toggle"
    },
    V2 = {
        autoClose: "(boolean|string)",
        boundary: "(string|element)",
        display: "string",
        offset: "(array|string|function)",
        popperConfig: "(null|object|function)",
        reference: "(string|element|object)"
    };
class ks extends ms {
    constructor(t, i) {
        super(t, i), this._popper = null, this._parent = this._element.parentNode, this._menu = te.findOne(rv, this._parent), this._inNavbar = this._detectNavbar()
    }
    static get Default() {
        return H2
    }
    static get DefaultType() {
        return V2
    }
    static get NAME() {
        return Gp
    }
    toggle() {
        return this._isShown() ? this.hide() : this.show()
    }
    show() {
        if (Rn(this._element) || this._isShown()) return;
        const t = {
            relatedTarget: this._element
        };
        if (!q.trigger(this._element, x2, t).defaultPrevented) {
            if (this._createPopper(), "ontouchstart" in document.documentElement && !this._parent.closest(k2))
                for (const s of [].concat(...document.body.children)) q.on(s, "mouseover", hc);
            this._element.focus(), this._element.setAttribute("aria-expanded", !0), this._menu.classList.add(qr), this._element.classList.add(qr), q.trigger(this._element, w2, t)
        }
    }
    hide() {
        if (Rn(this._element) || !this._isShown()) return;
        const t = {
            relatedTarget: this._element
        };
        this._completeHide(t)
    }
    dispose() {
        this._popper && this._popper.destroy(), super.dispose()
    }
    update() {
        this._inNavbar = this._detectNavbar(), this._popper && this._popper.update()
    }
    _completeHide(t) {
        if (!q.trigger(this._element, y2, t).defaultPrevented) {
            if ("ontouchstart" in document.documentElement)
                for (const s of [].concat(...document.body.children)) q.off(s, "mouseover", hc);
            this._popper && this._popper.destroy(), this._menu.classList.remove(qr), this._element.classList.remove(qr), this._element.setAttribute("aria-expanded", "false"), Ks.removeDataAttribute(this._menu, "popper"), q.trigger(this._element, b2, t)
        }
    }
    _getConfig(t) {
        if (t = super._getConfig(t), typeof t.reference == "object" && !Ys(t.reference) && typeof t.reference.getBoundingClientRect != "function") throw new TypeError(`${Gp.toUpperCase()}: Option "reference" provided type "object" without a required "getBoundingClientRect" method.`);
        return t
    }
    _createPopper() {
        if (typeof U0 > "u") throw new TypeError("Bootstrap's dropdowns require Popper (https://popper.js.org)");
        let t = this._element;
        this._config.reference === "parent" ? t = this._parent : Ys(this._config.reference) ? t = Mn(this._config.reference) : typeof this._config.reference == "object" && (t = this._config.reference);
        const i = this._getPopperConfig();
        this._popper = rf(t, this._menu, i)
    }
    _isShown() {
        return this._menu.classList.contains(qr)
    }
    _getPlacement() {
        const t = this._parent;
        if (t.classList.contains(S2)) return F2;
        if (t.classList.contains(C2)) return B2;
        if (t.classList.contains(A2)) return U2;
        if (t.classList.contains(I2)) return G2;
        const i = getComputedStyle(this._menu).getPropertyValue("--bs-position").trim() === "end";
        return t.classList.contains(E2) ? i ? O2 : L2 : i ? N2 : D2
    }
    _detectNavbar() {
        return this._element.closest(R2) !== null
    }
    _getOffset() {
        const {
            offset: t
        } = this._config;
        return typeof t == "string" ? t.split(",").map(i => Number.parseInt(i, 10)) : typeof t == "function" ? i => t(i, this._element) : t
    }
    _getPopperConfig() {
        const t = {
            placement: this._getPlacement(),
            modifiers: [{
                name: "preventOverflow",
                options: {
                    boundary: this._config.boundary
                }
            }, {
                name: "offset",
                options: {
                    offset: this._getOffset()
                }
            }]
        };
        return (this._inNavbar || this._config.display === "static") && (Ks.setDataAttribute(this._menu, "popper", "static"), t.modifiers = [{
            name: "applyStyles",
            enabled: !1
        }]), {
            ...t,
            ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(t) : this._config.popperConfig
        }
    }
    _selectMenuItem({
        key: t,
        target: i
    }) {
        const s = te.find(P2, this._menu).filter(n => Uo(n));
        !s.length || of(s, i, t === Vp, !s.includes(i)).focus()
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = ks.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (typeof i[t] > "u") throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        })
    }
    static clearMenus(t) {
        if (t.button === _2 || t.type === "keyup" && t.key !== Hp) return;
        const i = te.find(M2);
        for (const s of i) {
            const n = ks.getInstance(s);
            if (!n || n._config.autoClose === !1) continue;
            const r = t.composedPath(),
                o = r.includes(n._menu);
            if (r.includes(n._element) || n._config.autoClose === "inside" && !o || n._config.autoClose === "outside" && o || n._menu.contains(t.target) && (t.type === "keyup" && t.key === Hp || /input|select|option|textarea|form/i.test(t.target.tagName))) continue;
            const a = {
                relatedTarget: n._element
            };
            t.type === "click" && (a.clickEvent = t), n._completeHide(a)
        }
    }
    static dataApiKeydownHandler(t) {
        const i = /input|textarea/i.test(t.target.tagName),
            s = t.key === g2,
            n = [v2, Vp].includes(t.key);
        if (!n && !s || i && !s) return;
        t.preventDefault();
        const r = te.findOne($c, t.delegateTarget.parentNode),
            o = ks.getOrCreateInstance(r);
        if (n) {
            t.stopPropagation(), o.show(), o._selectMenuItem(t);
            return
        }
        o._isShown() && (t.stopPropagation(), o.hide(), r.focus())
    }
}
q.on(document, nv, $c, ks.dataApiKeydownHandler);
q.on(document, nv, rv, ks.dataApiKeydownHandler);
q.on(document, sv, ks.clearMenus);
q.on(document, T2, ks.clearMenus);
q.on(document, sv, $c, function(e) {
    e.preventDefault(), ks.getOrCreateInstance(this).toggle()
});
Wi(ks);
const zp = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top",
    $p = ".sticky-top",
    al = "padding-right",
    jp = "margin-right";
class Ru {
    constructor() {
        this._element = document.body
    }
    getWidth() {
        const t = document.documentElement.clientWidth;
        return Math.abs(window.innerWidth - t)
    }
    hide() {
        const t = this.getWidth();
        this._disableOverFlow(), this._setElementAttributes(this._element, al, i => i + t), this._setElementAttributes(zp, al, i => i + t), this._setElementAttributes($p, jp, i => i - t)
    }
    reset() {
        this._resetElementAttributes(this._element, "overflow"), this._resetElementAttributes(this._element, al), this._resetElementAttributes(zp, al), this._resetElementAttributes($p, jp)
    }
    isOverflowing() {
        return this.getWidth() > 0
    }
    _disableOverFlow() {
        this._saveInitialAttribute(this._element, "overflow"), this._element.style.overflow = "hidden"
    }
    _setElementAttributes(t, i, s) {
        const n = this.getWidth(),
            r = o => {
                if (o !== this._element && window.innerWidth > o.clientWidth + n) return;
                this._saveInitialAttribute(o, i);
                const a = window.getComputedStyle(o).getPropertyValue(i);
                o.style.setProperty(i, `${s(Number.parseFloat(a))}px`)
            };
        this._applyManipulationCallback(t, r)
    }
    _saveInitialAttribute(t, i) {
        const s = t.style.getPropertyValue(i);
        s && Ks.setDataAttribute(t, i, s)
    }
    _resetElementAttributes(t, i) {
        const s = n => {
            const r = Ks.getDataAttribute(n, i);
            if (r === null) {
                n.style.removeProperty(i);
                return
            }
            Ks.removeDataAttribute(n, i), n.style.setProperty(i, r)
        };
        this._applyManipulationCallback(t, s)
    }
    _applyManipulationCallback(t, i) {
        if (Ys(t)) {
            i(t);
            return
        }
        for (const s of te.find(t, this._element)) i(s)
    }
}
const ov = "backdrop",
    z2 = "fade",
    Wp = "show",
    Xp = `mousedown.bs.${ov}`,
    $2 = {
        className: "modal-backdrop",
        clickCallback: null,
        isAnimated: !1,
        isVisible: !0,
        rootElement: "body"
    },
    j2 = {
        className: "string",
        clickCallback: "(function|null)",
        isAnimated: "boolean",
        isVisible: "boolean",
        rootElement: "(element|string)"
    };
class av extends Ya {
    constructor(t) {
        super(), this._config = this._getConfig(t), this._isAppended = !1, this._element = null
    }
    static get Default() {
        return $2
    }
    static get DefaultType() {
        return j2
    }
    static get NAME() {
        return ov
    }
    show(t) {
        if (!this._config.isVisible) {
            $s(t);
            return
        }
        this._append();
        const i = this._getElement();
        this._config.isAnimated && Xa(i), i.classList.add(Wp), this._emulateAnimation(() => {
            $s(t)
        })
    }
    hide(t) {
        if (!this._config.isVisible) {
            $s(t);
            return
        }
        this._getElement().classList.remove(Wp), this._emulateAnimation(() => {
            this.dispose(), $s(t)
        })
    }
    dispose() {
        !this._isAppended || (q.off(this._element, Xp), this._element.remove(), this._isAppended = !1)
    }
    _getElement() {
        if (!this._element) {
            const t = document.createElement("div");
            t.className = this._config.className, this._config.isAnimated && t.classList.add(z2), this._element = t
        }
        return this._element
    }
    _configAfterMerge(t) {
        return t.rootElement = Mn(t.rootElement), t
    }
    _append() {
        if (this._isAppended) return;
        const t = this._getElement();
        this._config.rootElement.append(t), q.on(t, Xp, () => {
            $s(this._config.clickCallback)
        }), this._isAppended = !0
    }
    _emulateAnimation(t) {
        j0(t, this._getElement(), this._config.isAnimated)
    }
}
const W2 = "focustrap",
    X2 = "bs.focustrap",
    dc = `.${X2}`,
    Y2 = `focusin${dc}`,
    K2 = `keydown.tab${dc}`,
    Z2 = "Tab",
    q2 = "forward",
    Yp = "backward",
    J2 = {
        autofocus: !0,
        trapElement: null
    },
    Q2 = {
        autofocus: "boolean",
        trapElement: "element"
    };
class lv extends Ya {
    constructor(t) {
        super(), this._config = this._getConfig(t), this._isActive = !1, this._lastTabNavDirection = null
    }
    static get Default() {
        return J2
    }
    static get DefaultType() {
        return Q2
    }
    static get NAME() {
        return W2
    }
    activate() {
        this._isActive || (this._config.autofocus && this._config.trapElement.focus(), q.off(document, dc), q.on(document, Y2, t => this._handleFocusin(t)), q.on(document, K2, t => this._handleKeydown(t)), this._isActive = !0)
    }
    deactivate() {
        !this._isActive || (this._isActive = !1, q.off(document, dc))
    }
    _handleFocusin(t) {
        const {
            trapElement: i
        } = this._config;
        if (t.target === document || t.target === i || i.contains(t.target)) return;
        const s = te.focusableChildren(i);
        s.length === 0 ? i.focus() : this._lastTabNavDirection === Yp ? s[s.length - 1].focus() : s[0].focus()
    }
    _handleKeydown(t) {
        t.key === Z2 && (this._lastTabNavDirection = t.shiftKey ? Yp : q2)
    }
}
const tw = "modal",
    ew = "bs.modal",
    Bs = `.${ew}`,
    iw = ".data-api",
    sw = "Escape",
    nw = `hide${Bs}`,
    rw = `hidePrevented${Bs}`,
    cv = `hidden${Bs}`,
    hv = `show${Bs}`,
    ow = `shown${Bs}`,
    aw = `resize${Bs}`,
    lw = `mousedown.dismiss${Bs}`,
    cw = `keydown.dismiss${Bs}`,
    hw = `click${Bs}${iw}`,
    Kp = "modal-open",
    uw = "fade",
    Zp = "show",
    Lh = "modal-static",
    dw = ".modal.show",
    fw = ".modal-dialog",
    pw = ".modal-body",
    mw = '[data-bs-toggle="modal"]',
    gw = {
        backdrop: !0,
        focus: !0,
        keyboard: !0
    },
    vw = {
        backdrop: "(boolean|string)",
        focus: "boolean",
        keyboard: "boolean"
    };
class Ao extends ms {
    constructor(t, i) {
        super(t, i), this._dialog = te.findOne(fw, this._element), this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._isShown = !1, this._isTransitioning = !1, this._scrollBar = new Ru, this._addEventListeners()
    }
    static get Default() {
        return gw
    }
    static get DefaultType() {
        return vw
    }
    static get NAME() {
        return tw
    }
    toggle(t) {
        return this._isShown ? this.hide() : this.show(t)
    }
    show(t) {
        this._isShown || this._isTransitioning || q.trigger(this._element, hv, {
            relatedTarget: t
        }).defaultPrevented || (this._isShown = !0, this._isTransitioning = !0, this._scrollBar.hide(), document.body.classList.add(Kp), this._adjustDialog(), this._backdrop.show(() => this._showElement(t)))
    }
    hide() {
        !this._isShown || this._isTransitioning || q.trigger(this._element, nw).defaultPrevented || (this._isShown = !1, this._isTransitioning = !0, this._focustrap.deactivate(), this._element.classList.remove(Zp), this._queueCallback(() => this._hideModal(), this._element, this._isAnimated()))
    }
    dispose() {
        for (const t of [window, this._dialog]) q.off(t, Bs);
        this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
    }
    handleUpdate() {
        this._adjustDialog()
    }
    _initializeBackDrop() {
        return new av({
            isVisible: Boolean(this._config.backdrop),
            isAnimated: this._isAnimated()
        })
    }
    _initializeFocusTrap() {
        return new lv({
            trapElement: this._element
        })
    }
    _showElement(t) {
        document.body.contains(this._element) || document.body.append(this._element), this._element.style.display = "block", this._element.removeAttribute("aria-hidden"), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.scrollTop = 0;
        const i = te.findOne(pw, this._dialog);
        i && (i.scrollTop = 0), Xa(this._element), this._element.classList.add(Zp);
        const s = () => {
            this._config.focus && this._focustrap.activate(), this._isTransitioning = !1, q.trigger(this._element, ow, {
                relatedTarget: t
            })
        };
        this._queueCallback(s, this._dialog, this._isAnimated())
    }
    _addEventListeners() {
        q.on(this._element, cw, t => {
            if (t.key === sw) {
                if (this._config.keyboard) {
                    t.preventDefault(), this.hide();
                    return
                }
                this._triggerBackdropTransition()
            }
        }), q.on(window, aw, () => {
            this._isShown && !this._isTransitioning && this._adjustDialog()
        }), q.on(this._element, lw, t => {
            if (t.target === t.currentTarget) {
                if (this._config.backdrop === "static") {
                    this._triggerBackdropTransition();
                    return
                }
                this._config.backdrop && this.hide()
            }
        })
    }
    _hideModal() {
        this._element.style.display = "none", this._element.setAttribute("aria-hidden", !0), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._isTransitioning = !1, this._backdrop.hide(() => {
            document.body.classList.remove(Kp), this._resetAdjustments(), this._scrollBar.reset(), q.trigger(this._element, cv)
        })
    }
    _isAnimated() {
        return this._element.classList.contains(uw)
    }
    _triggerBackdropTransition() {
        if (q.trigger(this._element, rw).defaultPrevented) return;
        const i = this._element.scrollHeight > document.documentElement.clientHeight,
            s = this._element.style.overflowY;
        s === "hidden" || this._element.classList.contains(Lh) || (i || (this._element.style.overflowY = "hidden"), this._element.classList.add(Lh), this._queueCallback(() => {
            this._element.classList.remove(Lh), this._queueCallback(() => {
                this._element.style.overflowY = s
            }, this._dialog)
        }, this._dialog), this._element.focus())
    }
    _adjustDialog() {
        const t = this._element.scrollHeight > document.documentElement.clientHeight,
            i = this._scrollBar.getWidth(),
            s = i > 0;
        if (s && !t) {
            const n = ji() ? "paddingLeft" : "paddingRight";
            this._element.style[n] = `${i}px`
        }
        if (!s && t) {
            const n = ji() ? "paddingRight" : "paddingLeft";
            this._element.style[n] = `${i}px`
        }
    }
    _resetAdjustments() {
        this._element.style.paddingLeft = "", this._element.style.paddingRight = ""
    }
    static jQueryInterface(t, i) {
        return this.each(function() {
            const s = Ao.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (typeof s[t] > "u") throw new TypeError(`No method named "${t}"`);
                s[t](i)
            }
        })
    }
}
q.on(document, hw, mw, function(e) {
    const t = Xs(this);
    ["A", "AREA"].includes(this.tagName) && e.preventDefault(), q.one(t, hv, n => {
        n.defaultPrevented || q.one(t, cv, () => {
            Uo(this) && this.focus()
        })
    });
    const i = te.findOne(dw);
    i && Ao.getInstance(i).hide(), Ao.getOrCreateInstance(t).toggle(this)
});
Hc(Ao);
Wi(Ao);
const _w = "offcanvas",
    yw = "bs.offcanvas",
    sn = `.${yw}`,
    uv = ".data-api",
    bw = `load${sn}${uv}`,
    xw = "Escape",
    qp = "show",
    Jp = "showing",
    Qp = "hiding",
    ww = "offcanvas-backdrop",
    dv = ".offcanvas.show",
    Tw = `show${sn}`,
    Ew = `shown${sn}`,
    Sw = `hide${sn}`,
    tm = `hidePrevented${sn}`,
    fv = `hidden${sn}`,
    Cw = `resize${sn}`,
    Aw = `click${sn}${uv}`,
    Iw = `keydown.dismiss${sn}`,
    Mw = '[data-bs-toggle="offcanvas"]',
    Rw = {
        backdrop: !0,
        keyboard: !0,
        scroll: !1
    },
    kw = {
        backdrop: "(boolean|string)",
        keyboard: "boolean",
        scroll: "boolean"
    };
class kn extends ms {
    constructor(t, i) {
        super(t, i), this._isShown = !1, this._backdrop = this._initializeBackDrop(), this._focustrap = this._initializeFocusTrap(), this._addEventListeners()
    }
    static get Default() {
        return Rw
    }
    static get DefaultType() {
        return kw
    }
    static get NAME() {
        return _w
    }
    toggle(t) {
        return this._isShown ? this.hide() : this.show(t)
    }
    show(t) {
        if (this._isShown || q.trigger(this._element, Tw, {
                relatedTarget: t
            }).defaultPrevented) return;
        this._isShown = !0, this._backdrop.show(), this._config.scroll || new Ru().hide(), this._element.setAttribute("aria-modal", !0), this._element.setAttribute("role", "dialog"), this._element.classList.add(Jp);
        const s = () => {
            (!this._config.scroll || this._config.backdrop) && this._focustrap.activate(), this._element.classList.add(qp), this._element.classList.remove(Jp), q.trigger(this._element, Ew, {
                relatedTarget: t
            })
        };
        this._queueCallback(s, this._element, !0)
    }
    hide() {
        if (!this._isShown || q.trigger(this._element, Sw).defaultPrevented) return;
        this._focustrap.deactivate(), this._element.blur(), this._isShown = !1, this._element.classList.add(Qp), this._backdrop.hide();
        const i = () => {
            this._element.classList.remove(qp, Qp), this._element.removeAttribute("aria-modal"), this._element.removeAttribute("role"), this._config.scroll || new Ru().reset(), q.trigger(this._element, fv)
        };
        this._queueCallback(i, this._element, !0)
    }
    dispose() {
        this._backdrop.dispose(), this._focustrap.deactivate(), super.dispose()
    }
    _initializeBackDrop() {
        const t = () => {
                if (this._config.backdrop === "static") {
                    q.trigger(this._element, tm);
                    return
                }
                this.hide()
            },
            i = Boolean(this._config.backdrop);
        return new av({
            className: ww,
            isVisible: i,
            isAnimated: !0,
            rootElement: this._element.parentNode,
            clickCallback: i ? t : null
        })
    }
    _initializeFocusTrap() {
        return new lv({
            trapElement: this._element
        })
    }
    _addEventListeners() {
        q.on(this._element, Iw, t => {
            if (t.key === xw) {
                if (!this._config.keyboard) {
                    q.trigger(this._element, tm);
                    return
                }
                this.hide()
            }
        })
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = kn.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (i[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`);
                i[t](this)
            }
        })
    }
}
q.on(document, Aw, Mw, function(e) {
    const t = Xs(this);
    if (["A", "AREA"].includes(this.tagName) && e.preventDefault(), Rn(this)) return;
    q.one(t, fv, () => {
        Uo(this) && this.focus()
    });
    const i = te.findOne(dv);
    i && i !== t && kn.getInstance(i).hide(), kn.getOrCreateInstance(t).toggle(this)
});
q.on(window, bw, () => {
    for (const e of te.find(dv)) kn.getOrCreateInstance(e).show()
});
q.on(window, Cw, () => {
    for (const e of te.find("[aria-modal][class*=show][class*=offcanvas-]")) getComputedStyle(e).position !== "fixed" && kn.getOrCreateInstance(e).hide()
});
Hc(kn);
Wi(kn);
const Pw = new Set(["background", "cite", "href", "itemtype", "longdesc", "poster", "src", "xlink:href"]),
    Lw = /^aria-[\w-]*$/i,
    Ow = /^(?:(?:https?|mailto|ftp|tel|file|sms):|[^#&/:?]*(?:[#/?]|$))/i,
    Dw = /^data:(?:image\/(?:bmp|gif|jpeg|jpg|png|tiff|webp)|video\/(?:mpeg|mp4|ogg|webm)|audio\/(?:mp3|oga|ogg|opus));base64,[\d+/a-z]+=*$/i,
    Nw = (e, t) => {
        const i = e.nodeName.toLowerCase();
        return t.includes(i) ? Pw.has(i) ? Boolean(Ow.test(e.nodeValue) || Dw.test(e.nodeValue)) : !0 : t.filter(s => s instanceof RegExp).some(s => s.test(i))
    },
    pv = {
        "*": ["class", "dir", "id", "lang", "role", Lw],
        a: ["target", "href", "title", "rel"],
        area: [],
        b: [],
        br: [],
        col: [],
        code: [],
        div: [],
        em: [],
        hr: [],
        h1: [],
        h2: [],
        h3: [],
        h4: [],
        h5: [],
        h6: [],
        i: [],
        img: ["src", "srcset", "alt", "title", "width", "height"],
        li: [],
        ol: [],
        p: [],
        pre: [],
        s: [],
        small: [],
        span: [],
        sub: [],
        sup: [],
        strong: [],
        u: [],
        ul: []
    };

function Fw(e, t, i) {
    if (!e.length) return e;
    if (i && typeof i == "function") return i(e);
    const n = new window.DOMParser().parseFromString(e, "text/html"),
        r = [].concat(...n.body.querySelectorAll("*"));
    for (const o of r) {
        const a = o.nodeName.toLowerCase();
        if (!Object.keys(t).includes(a)) {
            o.remove();
            continue
        }
        const l = [].concat(...o.attributes),
            c = [].concat(t["*"] || [], t[a] || []);
        for (const h of l) Nw(h, c) || o.removeAttribute(h.nodeName)
    }
    return n.body.innerHTML
}
const Bw = "TemplateFactory",
    Uw = {
        allowList: pv,
        content: {},
        extraClass: "",
        html: !1,
        sanitize: !0,
        sanitizeFn: null,
        template: "<div></div>"
    },
    Gw = {
        allowList: "object",
        content: "object",
        extraClass: "(string|function)",
        html: "boolean",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        template: "string"
    },
    Hw = {
        entry: "(string|element|function|null)",
        selector: "(string|element)"
    };
class Vw extends Ya {
    constructor(t) {
        super(), this._config = this._getConfig(t)
    }
    static get Default() {
        return Uw
    }
    static get DefaultType() {
        return Gw
    }
    static get NAME() {
        return Bw
    }
    getContent() {
        return Object.values(this._config.content).map(t => this._resolvePossibleFunction(t)).filter(Boolean)
    }
    hasContent() {
        return this.getContent().length > 0
    }
    changeContent(t) {
        return this._checkContent(t), this._config.content = {
            ...this._config.content,
            ...t
        }, this
    }
    toHtml() {
        const t = document.createElement("div");
        t.innerHTML = this._maybeSanitize(this._config.template);
        for (const [n, r] of Object.entries(this._config.content)) this._setContent(t, r, n);
        const i = t.children[0],
            s = this._resolvePossibleFunction(this._config.extraClass);
        return s && i.classList.add(...s.split(" ")), i
    }
    _typeCheckConfig(t) {
        super._typeCheckConfig(t), this._checkContent(t.content)
    }
    _checkContent(t) {
        for (const [i, s] of Object.entries(t)) super._typeCheckConfig({
            selector: i,
            entry: s
        }, Hw)
    }
    _setContent(t, i, s) {
        const n = te.findOne(s, t);
        if (!!n) {
            if (i = this._resolvePossibleFunction(i), !i) {
                n.remove();
                return
            }
            if (Ys(i)) {
                this._putElementInTemplate(Mn(i), n);
                return
            }
            if (this._config.html) {
                n.innerHTML = this._maybeSanitize(i);
                return
            }
            n.textContent = i
        }
    }
    _maybeSanitize(t) {
        return this._config.sanitize ? Fw(t, this._config.allowList, this._config.sanitizeFn) : t
    }
    _resolvePossibleFunction(t) {
        return typeof t == "function" ? t(this) : t
    }
    _putElementInTemplate(t, i) {
        if (this._config.html) {
            i.innerHTML = "", i.append(t);
            return
        }
        i.textContent = t.textContent
    }
}
const zw = "tooltip",
    $w = new Set(["sanitize", "allowList", "sanitizeFn"]),
    Oh = "fade",
    jw = "modal",
    ll = "show",
    Ww = ".tooltip-inner",
    em = `.${jw}`,
    im = "hide.bs.modal",
    Yo = "hover",
    Dh = "focus",
    Xw = "click",
    Yw = "manual",
    Kw = "hide",
    Zw = "hidden",
    qw = "show",
    Jw = "shown",
    Qw = "inserted",
    tT = "click",
    eT = "focusin",
    iT = "focusout",
    sT = "mouseenter",
    nT = "mouseleave",
    rT = {
        AUTO: "auto",
        TOP: "top",
        RIGHT: ji() ? "left" : "right",
        BOTTOM: "bottom",
        LEFT: ji() ? "right" : "left"
    },
    oT = {
        allowList: pv,
        animation: !0,
        boundary: "clippingParents",
        container: !1,
        customClass: "",
        delay: 0,
        fallbackPlacements: ["top", "right", "bottom", "left"],
        html: !1,
        offset: [0, 0],
        placement: "top",
        popperConfig: null,
        sanitize: !0,
        sanitizeFn: null,
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        title: "",
        trigger: "hover focus"
    },
    aT = {
        allowList: "object",
        animation: "boolean",
        boundary: "(string|element)",
        container: "(string|element|boolean)",
        customClass: "(string|function)",
        delay: "(number|object)",
        fallbackPlacements: "array",
        html: "boolean",
        offset: "(array|string|function)",
        placement: "(string|function)",
        popperConfig: "(null|object|function)",
        sanitize: "boolean",
        sanitizeFn: "(null|function)",
        selector: "(string|boolean)",
        template: "string",
        title: "(string|element|function)",
        trigger: "string"
    };
class Ho extends ms {
    constructor(t, i) {
        if (typeof U0 > "u") throw new TypeError("Bootstrap's tooltips require Popper (https://popper.js.org)");
        super(t, i), this._isEnabled = !0, this._timeout = 0, this._isHovered = !1, this._activeTrigger = {}, this._popper = null, this._templateFactory = null, this._newContent = null, this.tip = null, this._setListeners()
    }
    static get Default() {
        return oT
    }
    static get DefaultType() {
        return aT
    }
    static get NAME() {
        return zw
    }
    enable() {
        this._isEnabled = !0
    }
    disable() {
        this._isEnabled = !1
    }
    toggleEnabled() {
        this._isEnabled = !this._isEnabled
    }
    toggle(t) {
        if (!!this._isEnabled) {
            if (t) {
                const i = this._initializeOnDelegatedTarget(t);
                i._activeTrigger.click = !i._activeTrigger.click, i._isWithActiveTrigger() ? i._enter() : i._leave();
                return
            }
            if (this._isShown()) {
                this._leave();
                return
            }
            this._enter()
        }
    }
    dispose() {
        clearTimeout(this._timeout), q.off(this._element.closest(em), im, this._hideModalHandler), this.tip && this.tip.remove(), this._disposePopper(), super.dispose()
    }
    show() {
        if (this._element.style.display === "none") throw new Error("Please use show on visible elements");
        if (!(this._isWithContent() && this._isEnabled)) return;
        const t = q.trigger(this._element, this.constructor.eventName(qw)),
            s = (z0(this._element) || this._element.ownerDocument.documentElement).contains(this._element);
        if (t.defaultPrevented || !s) return;
        this.tip && (this.tip.remove(), this.tip = null);
        const n = this._getTipElement();
        this._element.setAttribute("aria-describedby", n.getAttribute("id"));
        const {
            container: r
        } = this._config;
        if (this._element.ownerDocument.documentElement.contains(this.tip) || (r.append(n), q.trigger(this._element, this.constructor.eventName(Qw))), this._popper ? this._popper.update() : this._popper = this._createPopper(n), n.classList.add(ll), "ontouchstart" in document.documentElement)
            for (const a of [].concat(...document.body.children)) q.on(a, "mouseover", hc);
        const o = () => {
            const a = this._isHovered;
            this._isHovered = !1, q.trigger(this._element, this.constructor.eventName(Jw)), a && this._leave()
        };
        this._queueCallback(o, this.tip, this._isAnimated())
    }
    hide() {
        if (!this._isShown() || q.trigger(this._element, this.constructor.eventName(Kw)).defaultPrevented) return;
        const i = this._getTipElement();
        if (i.classList.remove(ll), "ontouchstart" in document.documentElement)
            for (const n of [].concat(...document.body.children)) q.off(n, "mouseover", hc);
        this._activeTrigger[Xw] = !1, this._activeTrigger[Dh] = !1, this._activeTrigger[Yo] = !1, this._isHovered = !1;
        const s = () => {
            this._isWithActiveTrigger() || (this._isHovered || i.remove(), this._element.removeAttribute("aria-describedby"), q.trigger(this._element, this.constructor.eventName(Zw)), this._disposePopper())
        };
        this._queueCallback(s, this.tip, this._isAnimated())
    }
    update() {
        this._popper && this._popper.update()
    }
    _isWithContent() {
        return Boolean(this._getTitle())
    }
    _getTipElement() {
        return this.tip || (this.tip = this._createTipElement(this._newContent || this._getContentForTemplate())), this.tip
    }
    _createTipElement(t) {
        const i = this._getTemplateFactory(t).toHtml();
        if (!i) return null;
        i.classList.remove(Oh, ll), i.classList.add(`bs-${this.constructor.NAME}-auto`);
        const s = Xb(this.constructor.NAME).toString();
        return i.setAttribute("id", s), this._isAnimated() && i.classList.add(Oh), i
    }
    setContent(t) {
        this._newContent = t, this._isShown() && (this._disposePopper(), this.show())
    }
    _getTemplateFactory(t) {
        return this._templateFactory ? this._templateFactory.changeContent(t) : this._templateFactory = new Vw({
            ...this._config,
            content: t,
            extraClass: this._resolvePossibleFunction(this._config.customClass)
        }), this._templateFactory
    }
    _getContentForTemplate() {
        return {
            [Ww]: this._getTitle()
        }
    }
    _getTitle() {
        return this._resolvePossibleFunction(this._config.title) || this._config.originalTitle
    }
    _initializeOnDelegatedTarget(t) {
        return this.constructor.getOrCreateInstance(t.delegateTarget, this._getDelegateConfig())
    }
    _isAnimated() {
        return this._config.animation || this.tip && this.tip.classList.contains(Oh)
    }
    _isShown() {
        return this.tip && this.tip.classList.contains(ll)
    }
    _createPopper(t) {
        const i = typeof this._config.placement == "function" ? this._config.placement.call(this, t, this._element) : this._config.placement,
            s = rT[i.toUpperCase()];
        return rf(this._element, t, this._getPopperConfig(s))
    }
    _getOffset() {
        const {
            offset: t
        } = this._config;
        return typeof t == "string" ? t.split(",").map(i => Number.parseInt(i, 10)) : typeof t == "function" ? i => t(i, this._element) : t
    }
    _resolvePossibleFunction(t) {
        return typeof t == "function" ? t.call(this._element) : t
    }
    _getPopperConfig(t) {
        const i = {
            placement: t,
            modifiers: [{
                name: "flip",
                options: {
                    fallbackPlacements: this._config.fallbackPlacements
                }
            }, {
                name: "offset",
                options: {
                    offset: this._getOffset()
                }
            }, {
                name: "preventOverflow",
                options: {
                    boundary: this._config.boundary
                }
            }, {
                name: "arrow",
                options: {
                    element: `.${this.constructor.NAME}-arrow`
                }
            }, {
                name: "preSetPlacement",
                enabled: !0,
                phase: "beforeMain",
                fn: s => {
                    this._getTipElement().setAttribute("data-popper-placement", s.state.placement)
                }
            }]
        };
        return {
            ...i,
            ...typeof this._config.popperConfig == "function" ? this._config.popperConfig(i) : this._config.popperConfig
        }
    }
    _setListeners() {
        const t = this._config.trigger.split(" ");
        for (const i of t)
            if (i === "click") q.on(this._element, this.constructor.eventName(tT), this._config.selector, s => this.toggle(s));
            else if (i !== Yw) {
            const s = i === Yo ? this.constructor.eventName(sT) : this.constructor.eventName(eT),
                n = i === Yo ? this.constructor.eventName(nT) : this.constructor.eventName(iT);
            q.on(this._element, s, this._config.selector, r => {
                const o = this._initializeOnDelegatedTarget(r);
                o._activeTrigger[r.type === "focusin" ? Dh : Yo] = !0, o._enter()
            }), q.on(this._element, n, this._config.selector, r => {
                const o = this._initializeOnDelegatedTarget(r);
                o._activeTrigger[r.type === "focusout" ? Dh : Yo] = o._element.contains(r.relatedTarget), o._leave()
            })
        }
        this._hideModalHandler = () => {
            this._element && this.hide()
        }, q.on(this._element.closest(em), im, this._hideModalHandler), this._config.selector ? this._config = {
            ...this._config,
            trigger: "manual",
            selector: ""
        } : this._fixTitle()
    }
    _fixTitle() {
        const t = this._config.originalTitle;
        !t || (!this._element.getAttribute("aria-label") && !this._element.textContent.trim() && this._element.setAttribute("aria-label", t), this._element.removeAttribute("title"))
    }
    _enter() {
        if (this._isShown() || this._isHovered) {
            this._isHovered = !0;
            return
        }
        this._isHovered = !0, this._setTimeout(() => {
            this._isHovered && this.show()
        }, this._config.delay.show)
    }
    _leave() {
        this._isWithActiveTrigger() || (this._isHovered = !1, this._setTimeout(() => {
            this._isHovered || this.hide()
        }, this._config.delay.hide))
    }
    _setTimeout(t, i) {
        clearTimeout(this._timeout), this._timeout = setTimeout(t, i)
    }
    _isWithActiveTrigger() {
        return Object.values(this._activeTrigger).includes(!0)
    }
    _getConfig(t) {
        const i = Ks.getDataAttributes(this._element);
        for (const s of Object.keys(i)) $w.has(s) && delete i[s];
        return t = {
            ...i,
            ...typeof t == "object" && t ? t : {}
        }, t = this._mergeConfigObj(t), t = this._configAfterMerge(t), this._typeCheckConfig(t), t
    }
    _configAfterMerge(t) {
        return t.container = t.container === !1 ? document.body : Mn(t.container), typeof t.delay == "number" && (t.delay = {
            show: t.delay,
            hide: t.delay
        }), t.originalTitle = this._element.getAttribute("title") || "", typeof t.title == "number" && (t.title = t.title.toString()), typeof t.content == "number" && (t.content = t.content.toString()), t
    }
    _getDelegateConfig() {
        const t = {};
        for (const i in this._config) this.constructor.Default[i] !== this._config[i] && (t[i] = this._config[i]);
        return t
    }
    _disposePopper() {
        this._popper && (this._popper.destroy(), this._popper = null)
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = Ho.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (typeof i[t] > "u") throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        })
    }
}
Wi(Ho);
const lT = "popover",
    cT = ".popover-header",
    hT = ".popover-body",
    uT = {
        ...Ho.Default,
        content: "",
        offset: [0, 8],
        placement: "right",
        template: '<div class="popover" role="tooltip"><div class="popover-arrow"></div><h3 class="popover-header"></h3><div class="popover-body"></div></div>',
        trigger: "click"
    },
    dT = {
        ...Ho.DefaultType,
        content: "(null|string|element|function)"
    };
class cf extends Ho {
    static get Default() {
        return uT
    }
    static get DefaultType() {
        return dT
    }
    static get NAME() {
        return lT
    }
    _isWithContent() {
        return this._getTitle() || this._getContent()
    }
    _getContentForTemplate() {
        return {
            [cT]: this._getTitle(),
            [hT]: this._getContent()
        }
    }
    _getContent() {
        return this._resolvePossibleFunction(this._config.content)
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = cf.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (typeof i[t] > "u") throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        })
    }
}
Wi(cf);
const fT = "scrollspy",
    pT = "bs.scrollspy",
    hf = `.${pT}`,
    mT = ".data-api",
    gT = `activate${hf}`,
    sm = `click${hf}`,
    vT = `load${hf}${mT}`,
    _T = "dropdown-item",
    Fr = "active",
    yT = '[data-bs-spy="scroll"]',
    Nh = "[href]",
    bT = ".nav, .list-group",
    nm = ".nav-link",
    xT = ".nav-item",
    wT = ".list-group-item",
    TT = `${nm}, ${xT} > ${nm}, ${wT}`,
    ET = ".dropdown",
    ST = ".dropdown-toggle",
    CT = {
        offset: null,
        rootMargin: "0px 0px -25%",
        smoothScroll: !1,
        target: null
    },
    AT = {
        offset: "(number|null)",
        rootMargin: "string",
        smoothScroll: "boolean",
        target: "element"
    };
class jc extends ms {
    constructor(t, i) {
        super(t, i), this._targetLinks = new Map, this._observableSections = new Map, this._rootElement = getComputedStyle(this._element).overflowY === "visible" ? null : this._element, this._activeTarget = null, this._observer = null, this._previousScrollData = {
            visibleEntryTop: 0,
            parentScrollTop: 0
        }, this.refresh()
    }
    static get Default() {
        return CT
    }
    static get DefaultType() {
        return AT
    }
    static get NAME() {
        return fT
    }
    refresh() {
        this._initializeTargetsAndObservables(), this._maybeEnableSmoothScroll(), this._observer ? this._observer.disconnect() : this._observer = this._getNewObserver();
        for (const t of this._observableSections.values()) this._observer.observe(t)
    }
    dispose() {
        this._observer.disconnect(), super.dispose()
    }
    _configAfterMerge(t) {
        return t.target = Mn(t.target) || document.body, t
    }
    _maybeEnableSmoothScroll() {
        !this._config.smoothScroll || (q.off(this._config.target, sm), q.on(this._config.target, sm, Nh, t => {
            const i = this._observableSections.get(t.target.hash);
            if (i) {
                t.preventDefault();
                const s = this._rootElement || window,
                    n = i.offsetTop - this._element.offsetTop;
                if (s.scrollTo) {
                    s.scrollTo({
                        top: n,
                        behavior: "smooth"
                    });
                    return
                }
                s.scrollTop = n
            }
        }))
    }
    _getNewObserver() {
        const t = {
            root: this._rootElement,
            threshold: [.1, .5, 1],
            rootMargin: this._getRootMargin()
        };
        return new IntersectionObserver(i => this._observerCallback(i), t)
    }
    _observerCallback(t) {
        const i = o => this._targetLinks.get(`#${o.target.id}`),
            s = o => {
                this._previousScrollData.visibleEntryTop = o.target.offsetTop, this._process(i(o))
            },
            n = (this._rootElement || document.documentElement).scrollTop,
            r = n >= this._previousScrollData.parentScrollTop;
        this._previousScrollData.parentScrollTop = n;
        for (const o of t) {
            if (!o.isIntersecting) {
                this._activeTarget = null, this._clearActiveClass(i(o));
                continue
            }
            const a = o.target.offsetTop >= this._previousScrollData.visibleEntryTop;
            if (r && a) {
                if (s(o), !n) return;
                continue
            }!r && !a && s(o)
        }
    }
    _getRootMargin() {
        return this._config.offset ? `${this._config.offset}px 0px -30%` : this._config.rootMargin
    }
    _initializeTargetsAndObservables() {
        this._targetLinks = new Map, this._observableSections = new Map;
        const t = te.find(Nh, this._config.target);
        for (const i of t) {
            if (!i.hash || Rn(i)) continue;
            const s = te.findOne(i.hash, this._element);
            Uo(s) && (this._targetLinks.set(i.hash, i), this._observableSections.set(i.hash, s))
        }
    }
    _process(t) {
        this._activeTarget !== t && (this._clearActiveClass(this._config.target), this._activeTarget = t, t.classList.add(Fr), this._activateParents(t), q.trigger(this._element, gT, {
            relatedTarget: t
        }))
    }
    _activateParents(t) {
        if (t.classList.contains(_T)) {
            te.findOne(ST, t.closest(ET)).classList.add(Fr);
            return
        }
        for (const i of te.parents(t, bT))
            for (const s of te.prev(i, TT)) s.classList.add(Fr)
    }
    _clearActiveClass(t) {
        t.classList.remove(Fr);
        const i = te.find(`${Nh}.${Fr}`, t);
        for (const s of i) s.classList.remove(Fr)
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = jc.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (i[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        })
    }
}
q.on(window, vT, () => {
    for (const e of te.find(yT)) jc.getOrCreateInstance(e)
});
Wi(jc);
const IT = "tab",
    MT = "bs.tab",
    Rr = `.${MT}`,
    RT = `hide${Rr}`,
    kT = `hidden${Rr}`,
    PT = `show${Rr}`,
    LT = `shown${Rr}`,
    OT = `click${Rr}`,
    DT = `keydown${Rr}`,
    NT = `load${Rr}`,
    FT = "ArrowLeft",
    rm = "ArrowRight",
    BT = "ArrowUp",
    om = "ArrowDown",
    yn = "active",
    am = "fade",
    Fh = "show",
    UT = "dropdown",
    GT = ".dropdown-toggle",
    HT = ".dropdown-menu",
    VT = ".dropdown-item",
    Bh = ":not(.dropdown-toggle)",
    zT = '.list-group, .nav, [role="tablist"]',
    $T = ".nav-item, .list-group-item",
    jT = `.nav-link${Bh}, .list-group-item${Bh}, [role="tab"]${Bh}`,
    mv = '[data-bs-toggle="tab"], [data-bs-toggle="pill"], [data-bs-toggle="list"]',
    Uh = `${jT}, ${mv}`,
    WT = `.${yn}[data-bs-toggle="tab"], .${yn}[data-bs-toggle="pill"], .${yn}[data-bs-toggle="list"]`;
class Io extends ms {
    constructor(t) {
        super(t), this._parent = this._element.closest(zT), this._parent && (this._setInitialAttributes(this._parent, this._getChildren()), q.on(this._element, DT, i => this._keydown(i)))
    }
    static get NAME() {
        return IT
    }
    show() {
        const t = this._element;
        if (this._elemIsActive(t)) return;
        const i = this._getActiveElem(),
            s = i ? q.trigger(i, RT, {
                relatedTarget: t
            }) : null;
        q.trigger(t, PT, {
            relatedTarget: i
        }).defaultPrevented || s && s.defaultPrevented || (this._deactivate(i, t), this._activate(t, i))
    }
    _activate(t, i) {
        if (!t) return;
        t.classList.add(yn), this._activate(Xs(t));
        const s = () => {
            if (t.getAttribute("role") !== "tab") {
                t.classList.add(Fh);
                return
            }
            t.focus(), t.removeAttribute("tabindex"), t.setAttribute("aria-selected", !0), this._toggleDropDown(t, !0), q.trigger(t, LT, {
                relatedTarget: i
            })
        };
        this._queueCallback(s, t, t.classList.contains(am))
    }
    _deactivate(t, i) {
        if (!t) return;
        t.classList.remove(yn), t.blur(), this._deactivate(Xs(t));
        const s = () => {
            if (t.getAttribute("role") !== "tab") {
                t.classList.remove(Fh);
                return
            }
            t.setAttribute("aria-selected", !1), t.setAttribute("tabindex", "-1"), this._toggleDropDown(t, !1), q.trigger(t, kT, {
                relatedTarget: i
            })
        };
        this._queueCallback(s, t, t.classList.contains(am))
    }
    _keydown(t) {
        if (![FT, rm, BT, om].includes(t.key)) return;
        t.stopPropagation(), t.preventDefault();
        const i = [rm, om].includes(t.key),
            s = of(this._getChildren().filter(n => !Rn(n)), t.target, i, !0);
        s && Io.getOrCreateInstance(s).show()
    }
    _getChildren() {
        return te.find(Uh, this._parent)
    }
    _getActiveElem() {
        return this._getChildren().find(t => this._elemIsActive(t)) || null
    }
    _setInitialAttributes(t, i) {
        this._setAttributeIfNotExists(t, "role", "tablist");
        for (const s of i) this._setInitialAttributesOnChild(s)
    }
    _setInitialAttributesOnChild(t) {
        t = this._getInnerElement(t);
        const i = this._elemIsActive(t),
            s = this._getOuterElement(t);
        t.setAttribute("aria-selected", i), s !== t && this._setAttributeIfNotExists(s, "role", "presentation"), i || t.setAttribute("tabindex", "-1"), this._setAttributeIfNotExists(t, "role", "tab"), this._setInitialAttributesOnTargetPanel(t)
    }
    _setInitialAttributesOnTargetPanel(t) {
        const i = Xs(t);
        !i || (this._setAttributeIfNotExists(i, "role", "tabpanel"), t.id && this._setAttributeIfNotExists(i, "aria-labelledby", `#${t.id}`))
    }
    _toggleDropDown(t, i) {
        const s = this._getOuterElement(t);
        if (!s.classList.contains(UT)) return;
        const n = (r, o) => {
            const a = te.findOne(r, s);
            a && a.classList.toggle(o, i)
        };
        n(GT, yn), n(HT, Fh), n(VT, yn), s.setAttribute("aria-expanded", i)
    }
    _setAttributeIfNotExists(t, i, s) {
        t.hasAttribute(i) || t.setAttribute(i, s)
    }
    _elemIsActive(t) {
        return t.classList.contains(yn)
    }
    _getInnerElement(t) {
        return t.matches(Uh) ? t : te.findOne(Uh, t)
    }
    _getOuterElement(t) {
        return t.closest($T) || t
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = Io.getOrCreateInstance(this);
            if (typeof t == "string") {
                if (i[t] === void 0 || t.startsWith("_") || t === "constructor") throw new TypeError(`No method named "${t}"`);
                i[t]()
            }
        })
    }
}
q.on(document, OT, mv, function(e) {
    ["A", "AREA"].includes(this.tagName) && e.preventDefault(), !Rn(this) && Io.getOrCreateInstance(this).show()
});
q.on(window, NT, () => {
    for (const e of te.find(WT)) Io.getOrCreateInstance(e)
});
Wi(Io);
const XT = "toast",
    YT = "bs.toast",
    Un = `.${YT}`,
    KT = `mouseover${Un}`,
    ZT = `mouseout${Un}`,
    qT = `focusin${Un}`,
    JT = `focusout${Un}`,
    QT = `hide${Un}`,
    tE = `hidden${Un}`,
    eE = `show${Un}`,
    iE = `shown${Un}`,
    sE = "fade",
    lm = "hide",
    cl = "show",
    hl = "showing",
    nE = {
        animation: "boolean",
        autohide: "boolean",
        delay: "number"
    },
    rE = {
        animation: !0,
        autohide: !0,
        delay: 5e3
    };
class Wc extends ms {
    constructor(t, i) {
        super(t, i), this._timeout = null, this._hasMouseInteraction = !1, this._hasKeyboardInteraction = !1, this._setListeners()
    }
    static get Default() {
        return rE
    }
    static get DefaultType() {
        return nE
    }
    static get NAME() {
        return XT
    }
    show() {
        if (q.trigger(this._element, eE).defaultPrevented) return;
        this._clearTimeout(), this._config.animation && this._element.classList.add(sE);
        const i = () => {
            this._element.classList.remove(hl), q.trigger(this._element, iE), this._maybeScheduleHide()
        };
        this._element.classList.remove(lm), Xa(this._element), this._element.classList.add(cl, hl), this._queueCallback(i, this._element, this._config.animation)
    }
    hide() {
        if (!this.isShown() || q.trigger(this._element, QT).defaultPrevented) return;
        const i = () => {
            this._element.classList.add(lm), this._element.classList.remove(hl, cl), q.trigger(this._element, tE)
        };
        this._element.classList.add(hl), this._queueCallback(i, this._element, this._config.animation)
    }
    dispose() {
        this._clearTimeout(), this.isShown() && this._element.classList.remove(cl), super.dispose()
    }
    isShown() {
        return this._element.classList.contains(cl)
    }
    _maybeScheduleHide() {
        !this._config.autohide || this._hasMouseInteraction || this._hasKeyboardInteraction || (this._timeout = setTimeout(() => {
            this.hide()
        }, this._config.delay))
    }
    _onInteraction(t, i) {
        switch (t.type) {
            case "mouseover":
            case "mouseout":
                this._hasMouseInteraction = i;
                break;
            case "focusin":
            case "focusout":
                this._hasKeyboardInteraction = i;
                break
        }
        if (i) {
            this._clearTimeout();
            return
        }
        const s = t.relatedTarget;
        this._element === s || this._element.contains(s) || this._maybeScheduleHide()
    }
    _setListeners() {
        q.on(this._element, KT, t => this._onInteraction(t, !0)), q.on(this._element, ZT, t => this._onInteraction(t, !1)), q.on(this._element, qT, t => this._onInteraction(t, !0)), q.on(this._element, JT, t => this._onInteraction(t, !1))
    }
    _clearTimeout() {
        clearTimeout(this._timeout), this._timeout = null
    }
    static jQueryInterface(t) {
        return this.each(function() {
            const i = Wc.getOrCreateInstance(this, t);
            if (typeof t == "string") {
                if (typeof i[t] > "u") throw new TypeError(`No method named "${t}"`);
                i[t](this)
            }
        })
    }
}
Hc(Wc);
Wi(Wc);

function uf(e, t) {
    const i = Object.create(null),
        s = e.split(",");
    for (let n = 0; n < s.length; n++) i[s[n]] = !0;
    return t ? n => !!i[n.toLowerCase()] : n => !!i[n]
}
const oE = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly",
    aE = uf(oE);

function gv(e) {
    return !!e || e === ""
}

function $t(e) {
    if (Wt(e)) {
        const t = {};
        for (let i = 0; i < e.length; i++) {
            const s = e[i],
                n = Ye(s) ? hE(s) : $t(s);
            if (n)
                for (const r in n) t[r] = n[r]
        }
        return t
    } else {
        if (Ye(e)) return e;
        if (Ke(e)) return e
    }
}
const lE = /;(?![^(]*\))/g,
    cE = /:(.+)/;

function hE(e) {
    const t = {};
    return e.split(lE).forEach(i => {
        if (i) {
            const s = i.split(cE);
            s.length > 1 && (t[s[0].trim()] = s[1].trim())
        }
    }), t
}

function Ai(e) {
    let t = "";
    if (Ye(e)) t = e;
    else if (Wt(e))
        for (let i = 0; i < e.length; i++) {
            const s = Ai(e[i]);
            s && (t += s + " ")
        } else if (Ke(e))
            for (const i in e) e[i] && (t += i + " ");
    return t.trim()
}
const Ot = e => e == null ? "" : Wt(e) || Ke(e) && (e.toString === xv || !Yt(e.toString)) ? JSON.stringify(e, vv, 2) : String(e),
    vv = (e, t) => t && t.__v_isRef ? vv(e, t.value) : uo(t) ? {
        [`Map(${t.size})`]: [...t.entries()].reduce((i, [s, n]) => (i[`${s} =>`] = n, i), {})
    } : yv(t) ? {
        [`Set(${t.size})`]: [...t.values()]
    } : Ke(t) && !Wt(t) && !wv(t) ? String(t) : t,
    xe = {},
    ho = [],
    as = () => {},
    uE = () => !1,
    dE = /^on[^a-z]/,
    Xc = e => dE.test(e),
    df = e => e.startsWith("onUpdate:"),
    Qe = Object.assign,
    _v = (e, t) => {
        const i = e.indexOf(t);
        i > -1 && e.splice(i, 1)
    },
    fE = Object.prototype.hasOwnProperty,
    he = (e, t) => fE.call(e, t),
    Wt = Array.isArray,
    uo = e => Yc(e) === "[object Map]",
    yv = e => Yc(e) === "[object Set]",
    Yt = e => typeof e == "function",
    Ye = e => typeof e == "string",
    ff = e => typeof e == "symbol",
    Ke = e => e !== null && typeof e == "object",
    bv = e => Ke(e) && Yt(e.then) && Yt(e.catch),
    xv = Object.prototype.toString,
    Yc = e => xv.call(e),
    pE = e => Yc(e).slice(8, -1),
    wv = e => Yc(e) === "[object Object]",
    pf = e => Ye(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e,
    Xl = uf(",key,ref,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"),
    Kc = e => {
        const t = Object.create(null);
        return i => t[i] || (t[i] = e(i))
    },
    mE = /-(\w)/g,
    Ds = Kc(e => e.replace(mE, (t, i) => i ? i.toUpperCase() : "")),
    gE = /\B([A-Z])/g,
    Vo = Kc(e => e.replace(gE, "-$1").toLowerCase()),
    Zc = Kc(e => e.charAt(0).toUpperCase() + e.slice(1)),
    Gh = Kc(e => e ? `on${Zc(e)}` : ""),
    ka = (e, t) => !Object.is(e, t),
    Yl = (e, t) => {
        for (let i = 0; i < e.length; i++) e[i](t)
    },
    fc = (e, t, i) => {
        Object.defineProperty(e, t, {
            configurable: !0,
            enumerable: !1,
            value: i
        })
    },
    ku = e => {
        const t = parseFloat(e);
        return isNaN(t) ? e : t
    };
let cm;
const vE = () => cm || (cm = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {});
let jn;
const ul = [];
class _E {
    constructor(t = !1) {
        this.active = !0, this.effects = [], this.cleanups = [], !t && jn && (this.parent = jn, this.index = (jn.scopes || (jn.scopes = [])).push(this) - 1)
    }
    run(t) {
        if (this.active) try {
            return this.on(), t()
        } finally {
            this.off()
        }
    }
    on() {
        this.active && (ul.push(this), jn = this)
    }
    off() {
        this.active && (ul.pop(), jn = ul[ul.length - 1])
    }
    stop(t) {
        if (this.active) {
            if (this.effects.forEach(i => i.stop()), this.cleanups.forEach(i => i()), this.scopes && this.scopes.forEach(i => i.stop(!0)), this.parent && !t) {
                const i = this.parent.scopes.pop();
                i && i !== this && (this.parent.scopes[this.index] = i, i.index = this.index)
            }
            this.active = !1
        }
    }
}

function yE(e, t) {
    t = t || jn, t && t.active && t.effects.push(e)
}
const mf = e => {
        const t = new Set(e);
        return t.w = 0, t.n = 0, t
    },
    Tv = e => (e.w & Pn) > 0,
    Ev = e => (e.n & Pn) > 0,
    bE = ({
        deps: e
    }) => {
        if (e.length)
            for (let t = 0; t < e.length; t++) e[t].w |= Pn
    },
    xE = e => {
        const {
            deps: t
        } = e;
        if (t.length) {
            let i = 0;
            for (let s = 0; s < t.length; s++) {
                const n = t[s];
                Tv(n) && !Ev(n) ? n.delete(e) : t[i++] = n, n.w &= ~Pn, n.n &= ~Pn
            }
            t.length = i
        }
    },
    Pu = new WeakMap;
let ua = 0,
    Pn = 1;
const Lu = 30,
    Ko = [];
let _r;
const yr = Symbol(""),
    Ou = Symbol("");
class gf {
    constructor(t, i = null, s) {
        this.fn = t, this.scheduler = i, this.active = !0, this.deps = [], yE(this, s)
    }
    run() {
        if (!this.active) return this.fn();
        if (!Ko.includes(this)) try {
            return Ko.push(_r = this), wE(), Pn = 1 << ++ua, ua <= Lu ? bE(this) : hm(this), this.fn()
        } finally {
            ua <= Lu && xE(this), Pn = 1 << --ua, kr(), Ko.pop();
            const t = Ko.length;
            _r = t > 0 ? Ko[t - 1] : void 0
        }
    }
    stop() {
        this.active && (hm(this), this.onStop && this.onStop(), this.active = !1)
    }
}

function hm(e) {
    const {
        deps: t
    } = e;
    if (t.length) {
        for (let i = 0; i < t.length; i++) t[i].delete(e);
        t.length = 0
    }
}
let Mo = !0;
const vf = [];

function zo() {
    vf.push(Mo), Mo = !1
}

function wE() {
    vf.push(Mo), Mo = !0
}

function kr() {
    const e = vf.pop();
    Mo = e === void 0 ? !0 : e
}

function Ri(e, t, i) {
    if (!Sv()) return;
    let s = Pu.get(e);
    s || Pu.set(e, s = new Map);
    let n = s.get(i);
    n || s.set(i, n = mf()), Cv(n)
}

function Sv() {
    return Mo && _r !== void 0
}

function Cv(e, t) {
    let i = !1;
    ua <= Lu ? Ev(e) || (e.n |= Pn, i = !Tv(e)) : i = !e.has(_r), i && (e.add(_r), _r.deps.push(e))
}

function Qs(e, t, i, s, n, r) {
    const o = Pu.get(e);
    if (!o) return;
    let a = [];
    if (t === "clear") a = [...o.values()];
    else if (i === "length" && Wt(e)) o.forEach((l, c) => {
        (c === "length" || c >= s) && a.push(l)
    });
    else switch (i !== void 0 && a.push(o.get(i)), t) {
        case "add":
            Wt(e) ? pf(i) && a.push(o.get("length")) : (a.push(o.get(yr)), uo(e) && a.push(o.get(Ou)));
            break;
        case "delete":
            Wt(e) || (a.push(o.get(yr)), uo(e) && a.push(o.get(Ou)));
            break;
        case "set":
            uo(e) && a.push(o.get(yr));
            break
    }
    if (a.length === 1) a[0] && Du(a[0]);
    else {
        const l = [];
        for (const c of a) c && l.push(...c);
        Du(mf(l))
    }
}

function Du(e, t) {
    for (const i of Wt(e) ? e : [...e])(i !== _r || i.allowRecurse) && (i.scheduler ? i.scheduler() : i.run())
}
const TE = uf("__proto__,__v_isRef,__isVue"),
    Av = new Set(Object.getOwnPropertyNames(Symbol).map(e => Symbol[e]).filter(ff)),
    EE = _f(),
    SE = _f(!1, !0),
    CE = _f(!0),
    um = AE();

function AE() {
    const e = {};
    return ["includes", "indexOf", "lastIndexOf"].forEach(t => {
        e[t] = function(...i) {
            const s = fe(this);
            for (let r = 0, o = this.length; r < o; r++) Ri(s, "get", r + "");
            const n = s[t](...i);
            return n === -1 || n === !1 ? s[t](...i.map(fe)) : n
        }
    }), ["push", "pop", "shift", "unshift", "splice"].forEach(t => {
        e[t] = function(...i) {
            zo();
            const s = fe(this)[t].apply(this, i);
            return kr(), s
        }
    }), e
}

function _f(e = !1, t = !1) {
    return function(s, n, r) {
        if (n === "__v_isReactive") return !e;
        if (n === "__v_isReadonly") return e;
        if (n === "__v_raw" && r === (e ? t ? zE : Pv : t ? kv : Rv).get(s)) return s;
        const o = Wt(s);
        if (!e && o && he(um, n)) return Reflect.get(um, n, r);
        const a = Reflect.get(s, n, r);
        return (ff(n) ? Av.has(n) : TE(n)) || (e || Ri(s, "get", n), t) ? a : xi(a) ? !o || !pf(n) ? a.value : a : Ke(a) ? e ? Lv(a) : _i(a) : a
    }
}
const IE = Iv(),
    ME = Iv(!0);

function Iv(e = !1) {
    return function(i, s, n, r) {
        let o = i[s];
        if (!e && !wf(n) && (n = fe(n), o = fe(o), !Wt(i) && xi(o) && !xi(n))) return o.value = n, !0;
        const a = Wt(i) && pf(s) ? Number(s) < i.length : he(i, s),
            l = Reflect.set(i, s, n, r);
        return i === fe(r) && (a ? ka(n, o) && Qs(i, "set", s, n) : Qs(i, "add", s, n)), l
    }
}

function RE(e, t) {
    const i = he(e, t);
    e[t];
    const s = Reflect.deleteProperty(e, t);
    return s && i && Qs(e, "delete", t, void 0), s
}

function kE(e, t) {
    const i = Reflect.has(e, t);
    return (!ff(t) || !Av.has(t)) && Ri(e, "has", t), i
}

function PE(e) {
    return Ri(e, "iterate", Wt(e) ? "length" : yr), Reflect.ownKeys(e)
}
const Mv = {
        get: EE,
        set: IE,
        deleteProperty: RE,
        has: kE,
        ownKeys: PE
    },
    LE = {
        get: CE,
        set(e, t) {
            return !0
        },
        deleteProperty(e, t) {
            return !0
        }
    },
    OE = Qe({}, Mv, {
        get: SE,
        set: ME
    }),
    yf = e => e,
    qc = e => Reflect.getPrototypeOf(e);

function dl(e, t, i = !1, s = !1) {
    e = e.__v_raw;
    const n = fe(e),
        r = fe(t);
    t !== r && !i && Ri(n, "get", t), !i && Ri(n, "get", r);
    const {
        has: o
    } = qc(n), a = s ? yf : i ? Tf : Pa;
    if (o.call(n, t)) return a(e.get(t));
    if (o.call(n, r)) return a(e.get(r));
    e !== n && e.get(t)
}

function fl(e, t = !1) {
    const i = this.__v_raw,
        s = fe(i),
        n = fe(e);
    return e !== n && !t && Ri(s, "has", e), !t && Ri(s, "has", n), e === n ? i.has(e) : i.has(e) || i.has(n)
}

function pl(e, t = !1) {
    return e = e.__v_raw, !t && Ri(fe(e), "iterate", yr), Reflect.get(e, "size", e)
}

function dm(e) {
    e = fe(e);
    const t = fe(this);
    return qc(t).has.call(t, e) || (t.add(e), Qs(t, "add", e, e)), this
}

function fm(e, t) {
    t = fe(t);
    const i = fe(this),
        {
            has: s,
            get: n
        } = qc(i);
    let r = s.call(i, e);
    r || (e = fe(e), r = s.call(i, e));
    const o = n.call(i, e);
    return i.set(e, t), r ? ka(t, o) && Qs(i, "set", e, t) : Qs(i, "add", e, t), this
}

function pm(e) {
    const t = fe(this),
        {
            has: i,
            get: s
        } = qc(t);
    let n = i.call(t, e);
    n || (e = fe(e), n = i.call(t, e)), s && s.call(t, e);
    const r = t.delete(e);
    return n && Qs(t, "delete", e, void 0), r
}

function mm() {
    const e = fe(this),
        t = e.size !== 0,
        i = e.clear();
    return t && Qs(e, "clear", void 0, void 0), i
}

function ml(e, t) {
    return function(s, n) {
        const r = this,
            o = r.__v_raw,
            a = fe(o),
            l = t ? yf : e ? Tf : Pa;
        return !e && Ri(a, "iterate", yr), o.forEach((c, h) => s.call(n, l(c), l(h), r))
    }
}

function gl(e, t, i) {
    return function(...s) {
        const n = this.__v_raw,
            r = fe(n),
            o = uo(r),
            a = e === "entries" || e === Symbol.iterator && o,
            l = e === "keys" && o,
            c = n[e](...s),
            h = i ? yf : t ? Tf : Pa;
        return !t && Ri(r, "iterate", l ? Ou : yr), {
            next() {
                const {
                    value: u,
                    done: d
                } = c.next();
                return d ? {
                    value: u,
                    done: d
                } : {
                    value: a ? [h(u[0]), h(u[1])] : h(u),
                    done: d
                }
            },
            [Symbol.iterator]() {
                return this
            }
        }
    }
}

function hn(e) {
    return function(...t) {
        return e === "delete" ? !1 : this
    }
}

function DE() {
    const e = {
            get(r) {
                return dl(this, r)
            },
            get size() {
                return pl(this)
            },
            has: fl,
            add: dm,
            set: fm,
            delete: pm,
            clear: mm,
            forEach: ml(!1, !1)
        },
        t = {
            get(r) {
                return dl(this, r, !1, !0)
            },
            get size() {
                return pl(this)
            },
            has: fl,
            add: dm,
            set: fm,
            delete: pm,
            clear: mm,
            forEach: ml(!1, !0)
        },
        i = {
            get(r) {
                return dl(this, r, !0)
            },
            get size() {
                return pl(this, !0)
            },
            has(r) {
                return fl.call(this, r, !0)
            },
            add: hn("add"),
            set: hn("set"),
            delete: hn("delete"),
            clear: hn("clear"),
            forEach: ml(!0, !1)
        },
        s = {
            get(r) {
                return dl(this, r, !0, !0)
            },
            get size() {
                return pl(this, !0)
            },
            has(r) {
                return fl.call(this, r, !0)
            },
            add: hn("add"),
            set: hn("set"),
            delete: hn("delete"),
            clear: hn("clear"),
            forEach: ml(!0, !0)
        };
    return ["keys", "values", "entries", Symbol.iterator].forEach(r => {
        e[r] = gl(r, !1, !1), i[r] = gl(r, !0, !1), t[r] = gl(r, !1, !0), s[r] = gl(r, !0, !0)
    }), [e, i, t, s]
}
const [NE, FE, BE, UE] = DE();

function bf(e, t) {
    const i = t ? e ? UE : BE : e ? FE : NE;
    return (s, n, r) => n === "__v_isReactive" ? !e : n === "__v_isReadonly" ? e : n === "__v_raw" ? s : Reflect.get(he(i, n) && n in s ? i : s, n, r)
}
const GE = {
        get: bf(!1, !1)
    },
    HE = {
        get: bf(!1, !0)
    },
    VE = {
        get: bf(!0, !1)
    },
    Rv = new WeakMap,
    kv = new WeakMap,
    Pv = new WeakMap,
    zE = new WeakMap;

function $E(e) {
    switch (e) {
        case "Object":
        case "Array":
            return 1;
        case "Map":
        case "Set":
        case "WeakMap":
        case "WeakSet":
            return 2;
        default:
            return 0
    }
}

function jE(e) {
    return e.__v_skip || !Object.isExtensible(e) ? 0 : $E(pE(e))
}

function _i(e) {
    return e && e.__v_isReadonly ? e : xf(e, !1, Mv, GE, Rv)
}

function WE(e) {
    return xf(e, !1, OE, HE, kv)
}

function Lv(e) {
    return xf(e, !0, LE, VE, Pv)
}

function xf(e, t, i, s, n) {
    if (!Ke(e) || e.__v_raw && !(t && e.__v_isReactive)) return e;
    const r = n.get(e);
    if (r) return r;
    const o = jE(e);
    if (o === 0) return e;
    const a = new Proxy(e, o === 2 ? s : i);
    return n.set(e, a), a
}

function fo(e) {
    return wf(e) ? fo(e.__v_raw) : !!(e && e.__v_isReactive)
}

function wf(e) {
    return !!(e && e.__v_isReadonly)
}

function Ov(e) {
    return fo(e) || wf(e)
}

function fe(e) {
    const t = e && e.__v_raw;
    return t ? fe(t) : e
}

function Ws(e) {
    return fc(e, "__v_skip", !0), e
}
const Pa = e => Ke(e) ? _i(e) : e,
    Tf = e => Ke(e) ? Lv(e) : e;

function Dv(e) {
    Sv() && (e = fe(e), e.dep || (e.dep = mf()), Cv(e.dep))
}

function Nv(e, t) {
    e = fe(e), e.dep && Du(e.dep)
}

function xi(e) {
    return Boolean(e && e.__v_isRef === !0)
}

function ft(e) {
    return XE(e, !1)
}

function XE(e, t) {
    return xi(e) ? e : new YE(e, t)
}
class YE {
    constructor(t, i) {
        this._shallow = i, this.dep = void 0, this.__v_isRef = !0, this._rawValue = i ? t : fe(t), this._value = i ? t : Pa(t)
    }
    get value() {
        return Dv(this), this._value
    }
    set value(t) {
        t = this._shallow ? t : fe(t), ka(t, this._rawValue) && (this._rawValue = t, this._value = this._shallow ? t : Pa(t), Nv(this))
    }
}

function KE(e) {
    return xi(e) ? e.value : e
}
const ZE = {
    get: (e, t, i) => KE(Reflect.get(e, t, i)),
    set: (e, t, i, s) => {
        const n = e[t];
        return xi(n) && !xi(i) ? (n.value = i, !0) : Reflect.set(e, t, i, s)
    }
};

function Fv(e) {
    return fo(e) ? e : new Proxy(e, ZE)
}
class qE {
    constructor(t, i, s) {
        this._setter = i, this.dep = void 0, this._dirty = !0, this.__v_isRef = !0, this.effect = new gf(t, () => {
            this._dirty || (this._dirty = !0, Nv(this))
        }), this.__v_isReadonly = s
    }
    get value() {
        const t = fe(this);
        return Dv(t), t._dirty && (t._dirty = !1, t._value = t.effect.run()), t._value
    }
    set value(t) {
        this._setter(t)
    }
}

function Ft(e, t) {
    let i, s;
    const n = Yt(e);
    return n ? (i = e, s = as) : (i = e.get, s = e.set), new qE(i, s, n || !s)
}
Promise.resolve();

function JE(e, t, ...i) {
    const s = e.vnode.props || xe;
    let n = i;
    const r = t.startsWith("update:"),
        o = r && t.slice(7);
    if (o && o in s) {
        const h = `${o==="modelValue"?"model":o}Modifiers`,
            {
                number: u,
                trim: d
            } = s[h] || xe;
        d ? n = i.map(f => f.trim()) : u && (n = i.map(ku))
    }
    let a, l = s[a = Gh(t)] || s[a = Gh(Ds(t))];
    !l && r && (l = s[a = Gh(Vo(t))]), l && $i(l, e, 6, n);
    const c = s[a + "Once"];
    if (c) {
        if (!e.emitted) e.emitted = {};
        else if (e.emitted[a]) return;
        e.emitted[a] = !0, $i(c, e, 6, n)
    }
}

function Bv(e, t, i = !1) {
    const s = t.emitsCache,
        n = s.get(e);
    if (n !== void 0) return n;
    const r = e.emits;
    let o = {},
        a = !1;
    if (!Yt(e)) {
        const l = c => {
            const h = Bv(c, t, !0);
            h && (a = !0, Qe(o, h))
        };
        !i && t.mixins.length && t.mixins.forEach(l), e.extends && l(e.extends), e.mixins && e.mixins.forEach(l)
    }
    return !r && !a ? (s.set(e, null), null) : (Wt(r) ? r.forEach(l => o[l] = null) : Qe(o, r), s.set(e, o), o)
}

function Ef(e, t) {
    return !e || !Xc(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), he(e, t[0].toLowerCase() + t.slice(1)) || he(e, Vo(t)) || he(e, t))
}
let Gi = null,
    Jc = null;

function pc(e) {
    const t = Gi;
    return Gi = e, Jc = e && e.type.__scopeId || null, t
}

function gs(e) {
    Jc = e
}

function vs() {
    Jc = null
}

function QE(e, t = Gi, i) {
    if (!t || e._n) return e;
    const s = (...n) => {
        s._d && Sm(-1);
        const r = pc(t),
            o = e(...n);
        return pc(r), s._d && Sm(1), o
    };
    return s._n = !0, s._c = !0, s._d = !0, s
}

function Hh(e) {
    const {
        type: t,
        vnode: i,
        proxy: s,
        withProxy: n,
        props: r,
        propsOptions: [o],
        slots: a,
        attrs: l,
        emit: c,
        render: h,
        renderCache: u,
        data: d,
        setupState: f,
        ctx: p,
        inheritAttrs: m
    } = e;
    let g, y;
    const x = pc(e);
    try {
        if (i.shapeFlag & 4) {
            const _ = n || s;
            g = Es(h.call(_, _, u, r, f, d, p)), y = l
        } else {
            const _ = t;
            g = Es(_.length > 1 ? _(r, {
                attrs: l,
                slots: a,
                emit: c
            }) : _(r, null)), y = t.props ? l : tS(l)
        }
    } catch (_) {
        Ea.length = 0, sh(_, e, 1), g = X(Ns)
    }
    let v = g;
    if (y && m !== !1) {
        const _ = Object.keys(y),
            {
                shapeFlag: C
            } = v;
        _.length && C & 7 && (o && _.some(df) && (y = eS(y, o)), v = Ro(v, y))
    }
    return i.dirs && (v.dirs = v.dirs ? v.dirs.concat(i.dirs) : i.dirs), i.transition && (v.transition = i.transition), g = v, pc(x), g
}
const tS = e => {
        let t;
        for (const i in e)(i === "class" || i === "style" || Xc(i)) && ((t || (t = {}))[i] = e[i]);
        return t
    },
    eS = (e, t) => {
        const i = {};
        for (const s in e)(!df(s) || !(s.slice(9) in t)) && (i[s] = e[s]);
        return i
    };

function iS(e, t, i) {
    const {
        props: s,
        children: n,
        component: r
    } = e, {
        props: o,
        children: a,
        patchFlag: l
    } = t, c = r.emitsOptions;
    if (t.dirs || t.transition) return !0;
    if (i && l >= 0) {
        if (l & 1024) return !0;
        if (l & 16) return s ? gm(s, o, c) : !!o;
        if (l & 8) {
            const h = t.dynamicProps;
            for (let u = 0; u < h.length; u++) {
                const d = h[u];
                if (o[d] !== s[d] && !Ef(c, d)) return !0
            }
        }
    } else return (n || a) && (!a || !a.$stable) ? !0 : s === o ? !1 : s ? o ? gm(s, o, c) : !0 : !!o;
    return !1
}

function gm(e, t, i) {
    const s = Object.keys(t);
    if (s.length !== Object.keys(e).length) return !0;
    for (let n = 0; n < s.length; n++) {
        const r = s[n];
        if (t[r] !== e[r] && !Ef(i, r)) return !0
    }
    return !1
}

function sS({
    vnode: e,
    parent: t
}, i) {
    for (; t && t.subTree === e;)(e = t.vnode).el = i, t = t.parent
}
const nS = e => e.__isSuspense;

function rS(e, t) {
    t && t.pendingBranch ? Wt(e) ? t.effects.push(...e) : t.effects.push(e) : tC(e)
}

function Uv(e, t) {
    if (je) {
        let i = je.provides;
        const s = je.parent && je.parent.provides;
        s === i && (i = je.provides = Object.create(s)), i[e] = t
    }
}

function yi(e, t, i = !1) {
    const s = je || Gi;
    if (s) {
        const n = s.parent == null ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides;
        if (n && e in n) return n[e];
        if (arguments.length > 1) return i && Yt(t) ? t.call(s.proxy) : t
    }
}

function oS() {
    const e = {
        isMounted: !1,
        isLeaving: !1,
        isUnmounting: !1,
        leavingVNodes: new Map
    };
    return Ve(() => {
        e.isMounted = !0
    }), $v(() => {
        e.isUnmounting = !0
    }), e
}
const Li = [Function, Array],
    aS = {
        name: "BaseTransition",
        props: {
            mode: String,
            appear: Boolean,
            persisted: Boolean,
            onBeforeEnter: Li,
            onEnter: Li,
            onAfterEnter: Li,
            onEnterCancelled: Li,
            onBeforeLeave: Li,
            onLeave: Li,
            onAfterLeave: Li,
            onLeaveCancelled: Li,
            onBeforeAppear: Li,
            onAppear: Li,
            onAfterAppear: Li,
            onAppearCancelled: Li
        },
        setup(e, {
            slots: t
        }) {
            const i = zS(),
                s = oS();
            let n;
            return () => {
                const r = t.default && Hv(t.default(), !0);
                if (!r || !r.length) return;
                const o = fe(e),
                    {
                        mode: a
                    } = o,
                    l = r[0];
                if (s.isLeaving) return Vh(l);
                const c = vm(l);
                if (!c) return Vh(l);
                const h = Nu(c, o, s, i);
                Fu(c, h);
                const u = i.subTree,
                    d = u && vm(u);
                let f = !1;
                const {
                    getTransitionKey: p
                } = c.type;
                if (p) {
                    const m = p();
                    n === void 0 ? n = m : m !== n && (n = m, f = !0)
                }
                if (d && d.type !== Ns && (!er(c, d) || f)) {
                    const m = Nu(d, o, s, i);
                    if (Fu(d, m), a === "out-in") return s.isLeaving = !0, m.afterLeave = () => {
                        s.isLeaving = !1, i.update()
                    }, Vh(l);
                    a === "in-out" && c.type !== Ns && (m.delayLeave = (g, y, x) => {
                        const v = Gv(s, d);
                        v[String(d.key)] = d, g._leaveCb = () => {
                            y(), g._leaveCb = void 0, delete h.delayedLeave
                        }, h.delayedLeave = x
                    })
                }
                return l
            }
        }
    },
    lS = aS;

function Gv(e, t) {
    const {
        leavingVNodes: i
    } = e;
    let s = i.get(t.type);
    return s || (s = Object.create(null), i.set(t.type, s)), s
}

function Nu(e, t, i, s) {
    const {
        appear: n,
        mode: r,
        persisted: o = !1,
        onBeforeEnter: a,
        onEnter: l,
        onAfterEnter: c,
        onEnterCancelled: h,
        onBeforeLeave: u,
        onLeave: d,
        onAfterLeave: f,
        onLeaveCancelled: p,
        onBeforeAppear: m,
        onAppear: g,
        onAfterAppear: y,
        onAppearCancelled: x
    } = t, v = String(e.key), _ = Gv(i, e), C = (S, T) => {
        S && $i(S, s, 9, T)
    }, k = {
        mode: r,
        persisted: o,
        beforeEnter(S) {
            let T = a;
            if (!i.isMounted)
                if (n) T = m || a;
                else return;
            S._leaveCb && S._leaveCb(!0);
            const L = _[v];
            L && er(e, L) && L.el._leaveCb && L.el._leaveCb(), C(T, [S])
        },
        enter(S) {
            let T = l,
                L = c,
                D = h;
            if (!i.isMounted)
                if (n) T = g || l, L = y || c, D = x || h;
                else return;
            let O = !1;
            const K = S._enterCb = P => {
                O || (O = !0, P ? C(D, [S]) : C(L, [S]), k.delayedLeave && k.delayedLeave(), S._enterCb = void 0)
            };
            T ? (T(S, K), T.length <= 1 && K()) : K()
        },
        leave(S, T) {
            const L = String(e.key);
            if (S._enterCb && S._enterCb(!0), i.isUnmounting) return T();
            C(u, [S]);
            let D = !1;
            const O = S._leaveCb = K => {
                D || (D = !0, T(), K ? C(p, [S]) : C(f, [S]), S._leaveCb = void 0, _[L] === e && delete _[L])
            };
            _[L] = e, d ? (d(S, O), d.length <= 1 && O()) : O()
        },
        clone(S) {
            return Nu(S, t, i, s)
        }
    };
    return k
}

function Vh(e) {
    if (Qc(e)) return e = Ro(e), e.children = null, e
}

function vm(e) {
    return Qc(e) ? e.children ? e.children[0] : void 0 : e
}

function Fu(e, t) {
    e.shapeFlag & 6 && e.component ? Fu(e.component.subTree, t) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t
}

function Hv(e, t = !1) {
    let i = [],
        s = 0;
    for (let n = 0; n < e.length; n++) {
        const r = e[n];
        r.type === Dt ? (r.patchFlag & 128 && s++, i = i.concat(Hv(r.children, t))) : (t || r.type !== Ns) && i.push(r)
    }
    if (s > 1)
        for (let n = 0; n < i.length; n++) i[n].patchFlag = -2;
    return i
}
const Bu = e => !!e.type.__asyncLoader,
    Qc = e => e.type.__isKeepAlive;

function cS(e, t) {
    Vv(e, "a", t)
}

function hS(e, t) {
    Vv(e, "da", t)
}

function Vv(e, t, i = je) {
    const s = e.__wdc || (e.__wdc = () => {
        let n = i;
        for (; n;) {
            if (n.isDeactivated) return;
            n = n.parent
        }
        return e()
    });
    if (th(t, s, i), i) {
        let n = i.parent;
        for (; n && n.parent;) Qc(n.parent.vnode) && uS(s, t, i, n), n = n.parent
    }
}

function uS(e, t, i, s) {
    const n = th(t, e, s, !0);
    jv(() => {
        _v(s[t], n)
    }, i)
}

function th(e, t, i = je, s = !1) {
    if (i) {
        const n = i[e] || (i[e] = []),
            r = t.__weh || (t.__weh = (...o) => {
                if (i.isUnmounted) return;
                zo(), ko(i);
                const a = $i(t, i, e, o);
                return xr(), kr(), a
            });
        return s ? n.unshift(r) : n.push(r), r
    }
}
const nn = e => (t, i = je) => (!_c || e === "sp") && th(e, t, i),
    zv = nn("bm"),
    Ve = nn("m"),
    dS = nn("bu"),
    Pr = nn("u"),
    $v = nn("bum"),
    jv = nn("um"),
    fS = nn("sp"),
    pS = nn("rtg"),
    mS = nn("rtc");

function gS(e, t = je) {
    th("ec", e, t)
}
let Uu = !0;

function vS(e) {
    const t = Xv(e),
        i = e.proxy,
        s = e.ctx;
    Uu = !1, t.beforeCreate && _m(t.beforeCreate, e, "bc");
    const {
        data: n,
        computed: r,
        methods: o,
        watch: a,
        provide: l,
        inject: c,
        created: h,
        beforeMount: u,
        mounted: d,
        beforeUpdate: f,
        updated: p,
        activated: m,
        deactivated: g,
        beforeDestroy: y,
        beforeUnmount: x,
        destroyed: v,
        unmounted: _,
        render: C,
        renderTracked: k,
        renderTriggered: S,
        errorCaptured: T,
        serverPrefetch: L,
        expose: D,
        inheritAttrs: O,
        components: K,
        directives: P,
        filters: N
    } = t;
    if (c && _S(c, s, null, e.appContext.config.unwrapInjectedRef), o)
        for (const Q in o) {
            const pt = o[Q];
            Yt(pt) && (s[Q] = pt.bind(i))
        }
    if (n) {
        const Q = n.call(i, i);
        Ke(Q) && (e.data = _i(Q))
    }
    if (Uu = !0, r)
        for (const Q in r) {
            const pt = r[Q],
                bt = Yt(pt) ? pt.bind(i, i) : Yt(pt.get) ? pt.get.bind(i, i) : as,
                ct = !Yt(pt) && Yt(pt.set) ? pt.set.bind(i) : as,
                gt = Ft({
                    get: bt,
                    set: ct
                });
            Object.defineProperty(s, Q, {
                enumerable: !0,
                configurable: !0,
                get: () => gt.value,
                set: xt => gt.value = xt
            })
        }
    if (a)
        for (const Q in a) Wv(a[Q], s, i, Q);
    if (l) {
        const Q = Yt(l) ? l.call(i) : l;
        Reflect.ownKeys(Q).forEach(pt => {
            Uv(pt, Q[pt])
        })
    }
    h && _m(h, e, "c");

    function V(Q, pt) {
        Wt(pt) ? pt.forEach(bt => Q(bt.bind(i))) : pt && Q(pt.bind(i))
    }
    if (V(zv, u), V(Ve, d), V(dS, f), V(Pr, p), V(cS, m), V(hS, g), V(gS, T), V(mS, k), V(pS, S), V($v, x), V(jv, _), V(fS, L), Wt(D))
        if (D.length) {
            const Q = e.exposed || (e.exposed = {});
            D.forEach(pt => {
                Object.defineProperty(Q, pt, {
                    get: () => i[pt],
                    set: bt => i[pt] = bt
                })
            })
        } else e.exposed || (e.exposed = {});
    C && e.render === as && (e.render = C), O != null && (e.inheritAttrs = O), K && (e.components = K), P && (e.directives = P)
}

function _S(e, t, i = as, s = !1) {
    Wt(e) && (e = Gu(e));
    for (const n in e) {
        const r = e[n];
        let o;
        Ke(r) ? "default" in r ? o = yi(r.from || n, r.default, !0) : o = yi(r.from || n) : o = yi(r), xi(o) && s ? Object.defineProperty(t, n, {
            enumerable: !0,
            configurable: !0,
            get: () => o.value,
            set: a => o.value = a
        }) : t[n] = o
    }
}

function _m(e, t, i) {
    $i(Wt(e) ? e.map(s => s.bind(t.proxy)) : e.bind(t.proxy), t, i)
}

function Wv(e, t, i, s) {
    const n = s.includes(".") ? p_(i, s) : () => i[s];
    if (Ye(e)) {
        const r = t[e];
        Yt(r) && Aa(n, r)
    } else if (Yt(e)) Aa(n, e.bind(i));
    else if (Ke(e))
        if (Wt(e)) e.forEach(r => Wv(r, t, i, s));
        else {
            const r = Yt(e.handler) ? e.handler.bind(i) : t[e.handler];
            Yt(r) && Aa(n, r, e)
        }
}

function Xv(e) {
    const t = e.type,
        {
            mixins: i,
            extends: s
        } = t,
        {
            mixins: n,
            optionsCache: r,
            config: {
                optionMergeStrategies: o
            }
        } = e.appContext,
        a = r.get(t);
    let l;
    return a ? l = a : !n.length && !i && !s ? l = t : (l = {}, n.length && n.forEach(c => mc(l, c, o, !0)), mc(l, t, o)), r.set(t, l), l
}

function mc(e, t, i, s = !1) {
    const {
        mixins: n,
        extends: r
    } = t;
    r && mc(e, r, i, !0), n && n.forEach(o => mc(e, o, i, !0));
    for (const o in t)
        if (!(s && o === "expose")) {
            const a = yS[o] || i && i[o];
            e[o] = a ? a(e[o], t[o]) : t[o]
        } return e
}
const yS = {
    data: ym,
    props: Wn,
    emits: Wn,
    methods: Wn,
    computed: Wn,
    beforeCreate: si,
    created: si,
    beforeMount: si,
    mounted: si,
    beforeUpdate: si,
    updated: si,
    beforeDestroy: si,
    beforeUnmount: si,
    destroyed: si,
    unmounted: si,
    activated: si,
    deactivated: si,
    errorCaptured: si,
    serverPrefetch: si,
    components: Wn,
    directives: Wn,
    watch: xS,
    provide: ym,
    inject: bS
};

function ym(e, t) {
    return t ? e ? function() {
        return Qe(Yt(e) ? e.call(this, this) : e, Yt(t) ? t.call(this, this) : t)
    } : t : e
}

function bS(e, t) {
    return Wn(Gu(e), Gu(t))
}

function Gu(e) {
    if (Wt(e)) {
        const t = {};
        for (let i = 0; i < e.length; i++) t[e[i]] = e[i];
        return t
    }
    return e
}

function si(e, t) {
    return e ? [...new Set([].concat(e, t))] : t
}

function Wn(e, t) {
    return e ? Qe(Qe(Object.create(null), e), t) : t
}

function xS(e, t) {
    if (!e) return t;
    if (!t) return e;
    const i = Qe(Object.create(null), e);
    for (const s in t) i[s] = si(e[s], t[s]);
    return i
}

function wS(e, t, i, s = !1) {
    const n = {},
        r = {};
    fc(r, eh, 1), e.propsDefaults = Object.create(null), Yv(e, t, n, r);
    for (const o in e.propsOptions[0]) o in n || (n[o] = void 0);
    i ? e.props = s ? n : WE(n) : e.type.props ? e.props = n : e.props = r, e.attrs = r
}

function TS(e, t, i, s) {
    const {
        props: n,
        attrs: r,
        vnode: {
            patchFlag: o
        }
    } = e, a = fe(n), [l] = e.propsOptions;
    let c = !1;
    if ((s || o > 0) && !(o & 16)) {
        if (o & 8) {
            const h = e.vnode.dynamicProps;
            for (let u = 0; u < h.length; u++) {
                let d = h[u];
                const f = t[d];
                if (l)
                    if (he(r, d)) f !== r[d] && (r[d] = f, c = !0);
                    else {
                        const p = Ds(d);
                        n[p] = Hu(l, a, p, f, e, !1)
                    }
                else f !== r[d] && (r[d] = f, c = !0)
            }
        }
    } else {
        Yv(e, t, n, r) && (c = !0);
        let h;
        for (const u in a)(!t || !he(t, u) && ((h = Vo(u)) === u || !he(t, h))) && (l ? i && (i[u] !== void 0 || i[h] !== void 0) && (n[u] = Hu(l, a, u, void 0, e, !0)) : delete n[u]);
        if (r !== a)
            for (const u in r)(!t || !he(t, u)) && (delete r[u], c = !0)
    }
    c && Qs(e, "set", "$attrs")
}

function Yv(e, t, i, s) {
    const [n, r] = e.propsOptions;
    let o = !1,
        a;
    if (t)
        for (let l in t) {
            if (Xl(l)) continue;
            const c = t[l];
            let h;
            n && he(n, h = Ds(l)) ? !r || !r.includes(h) ? i[h] = c : (a || (a = {}))[h] = c : Ef(e.emitsOptions, l) || (!(l in s) || c !== s[l]) && (s[l] = c, o = !0)
        }
    if (r) {
        const l = fe(i),
            c = a || xe;
        for (let h = 0; h < r.length; h++) {
            const u = r[h];
            i[u] = Hu(n, l, u, c[u], e, !he(c, u))
        }
    }
    return o
}

function Hu(e, t, i, s, n, r) {
    const o = e[i];
    if (o != null) {
        const a = he(o, "default");
        if (a && s === void 0) {
            const l = o.default;
            if (o.type !== Function && Yt(l)) {
                const {
                    propsDefaults: c
                } = n;
                i in c ? s = c[i] : (ko(n), s = c[i] = l.call(null, t), xr())
            } else s = l
        }
        o[0] && (r && !a ? s = !1 : o[1] && (s === "" || s === Vo(i)) && (s = !0))
    }
    return s
}

function Kv(e, t, i = !1) {
    const s = t.propsCache,
        n = s.get(e);
    if (n) return n;
    const r = e.props,
        o = {},
        a = [];
    let l = !1;
    if (!Yt(e)) {
        const h = u => {
            l = !0;
            const [d, f] = Kv(u, t, !0);
            Qe(o, d), f && a.push(...f)
        };
        !i && t.mixins.length && t.mixins.forEach(h), e.extends && h(e.extends), e.mixins && e.mixins.forEach(h)
    }
    if (!r && !l) return s.set(e, ho), ho;
    if (Wt(r))
        for (let h = 0; h < r.length; h++) {
            const u = Ds(r[h]);
            bm(u) && (o[u] = xe)
        } else if (r)
            for (const h in r) {
                const u = Ds(h);
                if (bm(u)) {
                    const d = r[h],
                        f = o[u] = Wt(d) || Yt(d) ? {
                            type: d
                        } : d;
                    if (f) {
                        const p = Tm(Boolean, f.type),
                            m = Tm(String, f.type);
                        f[0] = p > -1, f[1] = m < 0 || p < m, (p > -1 || he(f, "default")) && a.push(u)
                    }
                }
            }
    const c = [o, a];
    return s.set(e, c), c
}

function bm(e) {
    return e[0] !== "$"
}

function xm(e) {
    const t = e && e.toString().match(/^\s*function (\w+)/);
    return t ? t[1] : e === null ? "null" : ""
}

function wm(e, t) {
    return xm(e) === xm(t)
}

function Tm(e, t) {
    return Wt(t) ? t.findIndex(i => wm(i, e)) : Yt(t) && wm(t, e) ? 0 : -1
}
const Zv = e => e[0] === "_" || e === "$stable",
    Sf = e => Wt(e) ? e.map(Es) : [Es(e)],
    ES = (e, t, i) => {
        const s = QE((...n) => Sf(t(...n)), i);
        return s._c = !1, s
    },
    qv = (e, t, i) => {
        const s = e._ctx;
        for (const n in e) {
            if (Zv(n)) continue;
            const r = e[n];
            if (Yt(r)) t[n] = ES(n, r, s);
            else if (r != null) {
                const o = Sf(r);
                t[n] = () => o
            }
        }
    },
    Jv = (e, t) => {
        const i = Sf(t);
        e.slots.default = () => i
    },
    SS = (e, t) => {
        if (e.vnode.shapeFlag & 32) {
            const i = t._;
            i ? (e.slots = fe(t), fc(t, "_", i)) : qv(t, e.slots = {})
        } else e.slots = {}, t && Jv(e, t);
        fc(e.slots, eh, 1)
    },
    CS = (e, t, i) => {
        const {
            vnode: s,
            slots: n
        } = e;
        let r = !0,
            o = xe;
        if (s.shapeFlag & 32) {
            const a = t._;
            a ? i && a === 1 ? r = !1 : (Qe(n, t), !i && a === 1 && delete n._) : (r = !t.$stable, qv(t, n)), o = t
        } else t && (Jv(e, t), o = {
            default: 1
        });
        if (r)
            for (const a in n) !Zv(a) && !(a in o) && delete n[a]
    };

function ee(e, t) {
    const i = Gi;
    if (i === null) return e;
    const s = i.proxy,
        n = e.dirs || (e.dirs = []);
    for (let r = 0; r < t.length; r++) {
        let [o, a, l, c = xe] = t[r];
        Yt(o) && (o = {
            mounted: o,
            updated: o
        }), o.deep && sr(a), n.push({
            dir: o,
            instance: s,
            value: a,
            oldValue: void 0,
            arg: l,
            modifiers: c
        })
    }
    return e
}

function Gn(e, t, i, s) {
    const n = e.dirs,
        r = t && t.dirs;
    for (let o = 0; o < n.length; o++) {
        const a = n[o];
        r && (a.oldValue = r[o].value);
        let l = a.dir[s];
        l && (zo(), $i(l, i, 8, [e.el, a, e, t]), kr())
    }
}

function Qv() {
    return {
        app: null,
        config: {
            isNativeTag: uE,
            performance: !1,
            globalProperties: {},
            optionMergeStrategies: {},
            errorHandler: void 0,
            warnHandler: void 0,
            compilerOptions: {}
        },
        mixins: [],
        components: {},
        directives: {},
        provides: Object.create(null),
        optionsCache: new WeakMap,
        propsCache: new WeakMap,
        emitsCache: new WeakMap
    }
}
let AS = 0;

function IS(e, t) {
    return function(s, n = null) {
        n != null && !Ke(n) && (n = null);
        const r = Qv(),
            o = new Set;
        let a = !1;
        const l = r.app = {
            _uid: AS++,
            _component: s,
            _props: n,
            _container: null,
            _context: r,
            _instance: null,
            version: iC,
            get config() {
                return r.config
            },
            set config(c) {},
            use(c, ...h) {
                return o.has(c) || (c && Yt(c.install) ? (o.add(c), c.install(l, ...h)) : Yt(c) && (o.add(c), c(l, ...h))), l
            },
            mixin(c) {
                return r.mixins.includes(c) || r.mixins.push(c), l
            },
            component(c, h) {
                return h ? (r.components[c] = h, l) : r.components[c]
            },
            directive(c, h) {
                return h ? (r.directives[c] = h, l) : r.directives[c]
            },
            mount(c, h, u) {
                if (!a) {
                    const d = X(s, n);
                    return d.appContext = r, h && t ? t(d, c) : e(d, c, u), a = !0, l._container = c, c.__vue_app__ = l, Rf(d.component) || d.component.proxy
                }
            },
            unmount() {
                a && (e(null, l._container), delete l._container.__vue_app__)
            },
            provide(c, h) {
                return r.provides[c] = h, l
            }
        };
        return l
    }
}
const ni = rS;

function MS(e) {
    return RS(e)
}

function RS(e, t) {
    const i = vE();
    i.__VUE__ = !0;
    const {
        insert: s,
        remove: n,
        patchProp: r,
        createElement: o,
        createText: a,
        createComment: l,
        setText: c,
        setElementText: h,
        parentNode: u,
        nextSibling: d,
        setScopeId: f = as,
        cloneNode: p,
        insertStaticContent: m
    } = e, g = (E, M, F, $ = null, Y = null, rt = null, dt = !1, tt = null, it = !!M.dynamicChildren) => {
        if (E === M) return;
        E && !er(E, M) && ($ = Bt(E), It(E, Y, rt, !0), E = null), M.patchFlag === -2 && (it = !1, M.dynamicChildren = null);
        const {
            type: Z,
            ref: Ct,
            shapeFlag: yt
        } = M;
        switch (Z) {
            case Af:
                y(E, M, F, $);
                break;
            case Ns:
                x(E, M, F, $);
                break;
            case Kl:
                E == null && v(M, F, $, dt);
                break;
            case Dt:
                P(E, M, F, $, Y, rt, dt, tt, it);
                break;
            default:
                yt & 1 ? k(E, M, F, $, Y, rt, dt, tt, it) : yt & 6 ? N(E, M, F, $, Y, rt, dt, tt, it) : (yt & 64 || yt & 128) && Z.process(E, M, F, $, Y, rt, dt, tt, it, re)
        }
        Ct != null && Y && Vu(Ct, E && E.ref, rt, M || E, !M)
    }, y = (E, M, F, $) => {
        if (E == null) s(M.el = a(M.children), F, $);
        else {
            const Y = M.el = E.el;
            M.children !== E.children && c(Y, M.children)
        }
    }, x = (E, M, F, $) => {
        E == null ? s(M.el = l(M.children || ""), F, $) : M.el = E.el
    }, v = (E, M, F, $) => {
        [E.el, E.anchor] = m(E.children, M, F, $)
    }, _ = ({
        el: E,
        anchor: M
    }, F, $) => {
        let Y;
        for (; E && E !== M;) Y = d(E), s(E, F, $), E = Y;
        s(M, F, $)
    }, C = ({
        el: E,
        anchor: M
    }) => {
        let F;
        for (; E && E !== M;) F = d(E), n(E), E = F;
        n(M)
    }, k = (E, M, F, $, Y, rt, dt, tt, it) => {
        dt = dt || M.type === "svg", E == null ? S(M, F, $, Y, rt, dt, tt, it) : D(E, M, Y, rt, dt, tt, it)
    }, S = (E, M, F, $, Y, rt, dt, tt) => {
        let it, Z;
        const {
            type: Ct,
            props: yt,
            shapeFlag: At,
            transition: Pt,
            patchFlag: Kt,
            dirs: me
        } = E;
        if (E.el && p !== void 0 && Kt === -1) it = E.el = p(E.el);
        else {
            if (it = E.el = o(E.type, rt, yt && yt.is, yt), At & 8 ? h(it, E.children) : At & 16 && L(E.children, it, null, $, Y, rt && Ct !== "foreignObject", dt, tt), me && Gn(E, null, $, "created"), yt) {
                for (const oe in yt) oe !== "value" && !Xl(oe) && r(it, oe, null, yt[oe], rt, E.children, $, Y, Tt);
                "value" in yt && r(it, "value", null, yt.value), (Z = yt.onVnodeBeforeMount) && xs(Z, $, E)
            }
            T(it, E, E.scopeId, dt, $)
        }
        me && Gn(E, null, $, "beforeMount");
        const ge = (!Y || Y && !Y.pendingBranch) && Pt && !Pt.persisted;
        ge && Pt.beforeEnter(it), s(it, M, F), ((Z = yt && yt.onVnodeMounted) || ge || me) && ni(() => {
            Z && xs(Z, $, E), ge && Pt.enter(it), me && Gn(E, null, $, "mounted")
        }, Y)
    }, T = (E, M, F, $, Y) => {
        if (F && f(E, F), $)
            for (let rt = 0; rt < $.length; rt++) f(E, $[rt]);
        if (Y) {
            let rt = Y.subTree;
            if (M === rt) {
                const dt = Y.vnode;
                T(E, dt, dt.scopeId, dt.slotScopeIds, Y.parent)
            }
        }
    }, L = (E, M, F, $, Y, rt, dt, tt, it = 0) => {
        for (let Z = it; Z < E.length; Z++) {
            const Ct = E[Z] = tt ? vn(E[Z]) : Es(E[Z]);
            g(null, Ct, M, F, $, Y, rt, dt, tt)
        }
    }, D = (E, M, F, $, Y, rt, dt) => {
        const tt = M.el = E.el;
        let {
            patchFlag: it,
            dynamicChildren: Z,
            dirs: Ct
        } = M;
        it |= E.patchFlag & 16;
        const yt = E.props || xe,
            At = M.props || xe;
        let Pt;
        (Pt = At.onVnodeBeforeUpdate) && xs(Pt, F, M, E), Ct && Gn(M, E, F, "beforeUpdate");
        const Kt = Y && M.type !== "foreignObject";
        if (Z ? O(E.dynamicChildren, Z, tt, F, $, Kt, rt) : dt || bt(E, M, tt, null, F, $, Kt, rt, !1), it > 0) {
            if (it & 16) K(tt, M, yt, At, F, $, Y);
            else if (it & 2 && yt.class !== At.class && r(tt, "class", null, At.class, Y), it & 4 && r(tt, "style", yt.style, At.style, Y), it & 8) {
                const me = M.dynamicProps;
                for (let ge = 0; ge < me.length; ge++) {
                    const oe = me[ge],
                        ui = yt[oe],
                        w = At[oe];
                    (w !== ui || oe === "value") && r(tt, oe, ui, w, Y, E.children, F, $, Tt)
                }
            }
            it & 1 && E.children !== M.children && h(tt, M.children)
        } else !dt && Z == null && K(tt, M, yt, At, F, $, Y);
        ((Pt = At.onVnodeUpdated) || Ct) && ni(() => {
            Pt && xs(Pt, F, M, E), Ct && Gn(M, E, F, "updated")
        }, $)
    }, O = (E, M, F, $, Y, rt, dt) => {
        for (let tt = 0; tt < M.length; tt++) {
            const it = E[tt],
                Z = M[tt],
                Ct = it.el && (it.type === Dt || !er(it, Z) || it.shapeFlag & 70) ? u(it.el) : F;
            g(it, Z, Ct, null, $, Y, rt, dt, !0)
        }
    }, K = (E, M, F, $, Y, rt, dt) => {
        if (F !== $) {
            for (const tt in $) {
                if (Xl(tt)) continue;
                const it = $[tt],
                    Z = F[tt];
                it !== Z && tt !== "value" && r(E, tt, Z, it, dt, M.children, Y, rt, Tt)
            }
            if (F !== xe)
                for (const tt in F) !Xl(tt) && !(tt in $) && r(E, tt, F[tt], null, dt, M.children, Y, rt, Tt);
            "value" in $ && r(E, "value", F.value, $.value)
        }
    }, P = (E, M, F, $, Y, rt, dt, tt, it) => {
        const Z = M.el = E ? E.el : a(""),
            Ct = M.anchor = E ? E.anchor : a("");
        let {
            patchFlag: yt,
            dynamicChildren: At,
            slotScopeIds: Pt
        } = M;
        Pt && (tt = tt ? tt.concat(Pt) : Pt), E == null ? (s(Z, F, $), s(Ct, F, $), L(M.children, F, Ct, Y, rt, dt, tt, it)) : yt > 0 && yt & 64 && At && E.dynamicChildren ? (O(E.dynamicChildren, At, F, Y, rt, dt, tt), (M.key != null || Y && M === Y.subTree) && t_(E, M, !0)) : bt(E, M, F, Ct, Y, rt, dt, tt, it)
    }, N = (E, M, F, $, Y, rt, dt, tt, it) => {
        M.slotScopeIds = tt, E == null ? M.shapeFlag & 512 ? Y.ctx.activate(M, F, $, dt, it) : W(M, F, $, Y, rt, dt, it) : V(E, M, it)
    }, W = (E, M, F, $, Y, rt, dt) => {
        const tt = E.component = VS(E, $, Y);
        if (Qc(E) && (tt.ctx.renderer = re), $S(tt), tt.asyncDep) {
            if (Y && Y.registerDep(tt, Q), !E.el) {
                const it = tt.subTree = X(Ns);
                x(null, it, M, F)
            }
            return
        }
        Q(tt, E, M, F, Y, rt, dt)
    }, V = (E, M, F) => {
        const $ = M.component = E.component;
        if (iS(E, M, F))
            if ($.asyncDep && !$.asyncResolved) {
                pt($, M, F);
                return
            } else $.next = M, JS($.update), $.update();
        else M.component = E.component, M.el = E.el, $.vnode = M
    }, Q = (E, M, F, $, Y, rt, dt) => {
        const tt = () => {
                if (E.isMounted) {
                    let {
                        next: Ct,
                        bu: yt,
                        u: At,
                        parent: Pt,
                        vnode: Kt
                    } = E, me = Ct, ge;
                    it.allowRecurse = !1, Ct ? (Ct.el = Kt.el, pt(E, Ct, dt)) : Ct = Kt, yt && Yl(yt), (ge = Ct.props && Ct.props.onVnodeBeforeUpdate) && xs(ge, Pt, Ct, Kt), it.allowRecurse = !0;
                    const oe = Hh(E),
                        ui = E.subTree;
                    E.subTree = oe, g(ui, oe, u(ui.el), Bt(ui), E, Y, rt), Ct.el = oe.el, me === null && sS(E, oe.el), At && ni(At, Y), (ge = Ct.props && Ct.props.onVnodeUpdated) && ni(() => xs(ge, Pt, Ct, Kt), Y)
                } else {
                    let Ct;
                    const {
                        el: yt,
                        props: At
                    } = M, {
                        bm: Pt,
                        m: Kt,
                        parent: me
                    } = E, ge = Bu(M);
                    if (it.allowRecurse = !1, Pt && Yl(Pt), !ge && (Ct = At && At.onVnodeBeforeMount) && xs(Ct, me, M), it.allowRecurse = !0, yt && ce) {
                        const oe = () => {
                            E.subTree = Hh(E), ce(yt, E.subTree, E, Y, null)
                        };
                        ge ? M.type.__asyncLoader().then(() => !E.isUnmounted && oe()) : oe()
                    } else {
                        const oe = E.subTree = Hh(E);
                        g(null, oe, F, $, E, Y, rt), M.el = oe.el
                    }
                    if (Kt && ni(Kt, Y), !ge && (Ct = At && At.onVnodeMounted)) {
                        const oe = M;
                        ni(() => xs(Ct, me, oe), Y)
                    }
                    M.shapeFlag & 256 && E.a && ni(E.a, Y), E.isMounted = !0, M = F = $ = null
                }
            },
            it = new gf(tt, () => l_(E.update), E.scope),
            Z = E.update = it.run.bind(it);
        Z.id = E.uid, it.allowRecurse = Z.allowRecurse = !0, Z()
    }, pt = (E, M, F) => {
        M.component = E;
        const $ = E.vnode.props;
        E.vnode = M, E.next = null, TS(E, M.props, $, F), CS(E, M.children, F), zo(), Pf(void 0, E.update), kr()
    }, bt = (E, M, F, $, Y, rt, dt, tt, it = !1) => {
        const Z = E && E.children,
            Ct = E ? E.shapeFlag : 0,
            yt = M.children,
            {
                patchFlag: At,
                shapeFlag: Pt
            } = M;
        if (At > 0) {
            if (At & 128) {
                gt(Z, yt, F, $, Y, rt, dt, tt, it);
                return
            } else if (At & 256) {
                ct(Z, yt, F, $, Y, rt, dt, tt, it);
                return
            }
        }
        Pt & 8 ? (Ct & 16 && Tt(Z, Y, rt), yt !== Z && h(F, yt)) : Ct & 16 ? Pt & 16 ? gt(Z, yt, F, $, Y, rt, dt, tt, it) : Tt(Z, Y, rt, !0) : (Ct & 8 && h(F, ""), Pt & 16 && L(yt, F, $, Y, rt, dt, tt, it))
    }, ct = (E, M, F, $, Y, rt, dt, tt, it) => {
        E = E || ho, M = M || ho;
        const Z = E.length,
            Ct = M.length,
            yt = Math.min(Z, Ct);
        let At;
        for (At = 0; At < yt; At++) {
            const Pt = M[At] = it ? vn(M[At]) : Es(M[At]);
            g(E[At], Pt, F, null, Y, rt, dt, tt, it)
        }
        Z > Ct ? Tt(E, Y, rt, !0, !1, yt) : L(M, F, $, Y, rt, dt, tt, it, yt)
    }, gt = (E, M, F, $, Y, rt, dt, tt, it) => {
        let Z = 0;
        const Ct = M.length;
        let yt = E.length - 1,
            At = Ct - 1;
        for (; Z <= yt && Z <= At;) {
            const Pt = E[Z],
                Kt = M[Z] = it ? vn(M[Z]) : Es(M[Z]);
            if (er(Pt, Kt)) g(Pt, Kt, F, null, Y, rt, dt, tt, it);
            else break;
            Z++
        }
        for (; Z <= yt && Z <= At;) {
            const Pt = E[yt],
                Kt = M[At] = it ? vn(M[At]) : Es(M[At]);
            if (er(Pt, Kt)) g(Pt, Kt, F, null, Y, rt, dt, tt, it);
            else break;
            yt--, At--
        }
        if (Z > yt) {
            if (Z <= At) {
                const Pt = At + 1,
                    Kt = Pt < Ct ? M[Pt].el : $;
                for (; Z <= At;) g(null, M[Z] = it ? vn(M[Z]) : Es(M[Z]), F, Kt, Y, rt, dt, tt, it), Z++
            }
        } else if (Z > At)
            for (; Z <= yt;) It(E[Z], Y, rt, !0), Z++;
        else {
            const Pt = Z,
                Kt = Z,
                me = new Map;
            for (Z = Kt; Z <= At; Z++) {
                const et = M[Z] = it ? vn(M[Z]) : Es(M[Z]);
                et.key != null && me.set(et.key, Z)
            }
            let ge, oe = 0;
            const ui = At - Kt + 1;
            let w = !1,
                R = 0;
            const z = new Array(ui);
            for (Z = 0; Z < ui; Z++) z[Z] = 0;
            for (Z = Pt; Z <= yt; Z++) {
                const et = E[Z];
                if (oe >= ui) {
                    It(et, Y, rt, !0);
                    continue
                }
                let _t;
                if (et.key != null) _t = me.get(et.key);
                else
                    for (ge = Kt; ge <= At; ge++)
                        if (z[ge - Kt] === 0 && er(et, M[ge])) {
                            _t = ge;
                            break
                        } _t === void 0 ? It(et, Y, rt, !0) : (z[_t - Kt] = Z + 1, _t >= R ? R = _t : w = !0, g(et, M[_t], F, null, Y, rt, dt, tt, it), oe++)
            }
            const G = w ? kS(z) : ho;
            for (ge = G.length - 1, Z = ui - 1; Z >= 0; Z--) {
                const et = Kt + Z,
                    _t = M[et],
                    Mt = et + 1 < Ct ? M[et + 1].el : $;
                z[Z] === 0 ? g(null, _t, F, Mt, Y, rt, dt, tt, it) : w && (ge < 0 || Z !== G[ge] ? xt(_t, F, Mt, 2) : ge--)
            }
        }
    }, xt = (E, M, F, $, Y = null) => {
        const {
            el: rt,
            type: dt,
            transition: tt,
            children: it,
            shapeFlag: Z
        } = E;
        if (Z & 6) {
            xt(E.component.subTree, M, F, $);
            return
        }
        if (Z & 128) {
            E.suspense.move(M, F, $);
            return
        }
        if (Z & 64) {
            dt.move(E, M, F, re);
            return
        }
        if (dt === Dt) {
            s(rt, M, F);
            for (let yt = 0; yt < it.length; yt++) xt(it[yt], M, F, $);
            s(E.anchor, M, F);
            return
        }
        if (dt === Kl) {
            _(E, M, F);
            return
        }
        if ($ !== 2 && Z & 1 && tt)
            if ($ === 0) tt.beforeEnter(rt), s(rt, M, F), ni(() => tt.enter(rt), Y);
            else {
                const {
                    leave: yt,
                    delayLeave: At,
                    afterLeave: Pt
                } = tt, Kt = () => s(rt, M, F), me = () => {
                    yt(rt, () => {
                        Kt(), Pt && Pt()
                    })
                };
                At ? At(rt, Kt, me) : me()
            }
        else s(rt, M, F)
    }, It = (E, M, F, $ = !1, Y = !1) => {
        const {
            type: rt,
            props: dt,
            ref: tt,
            children: it,
            dynamicChildren: Z,
            shapeFlag: Ct,
            patchFlag: yt,
            dirs: At
        } = E;
        if (tt != null && Vu(tt, null, F, E, !0), Ct & 256) {
            M.ctx.deactivate(E);
            return
        }
        const Pt = Ct & 1 && At,
            Kt = !Bu(E);
        let me;
        if (Kt && (me = dt && dt.onVnodeBeforeUnmount) && xs(me, M, E), Ct & 6) wt(E.component, F, $);
        else {
            if (Ct & 128) {
                E.suspense.unmount(F, $);
                return
            }
            Pt && Gn(E, null, M, "beforeUnmount"), Ct & 64 ? E.type.remove(E, M, F, Y, re, $) : Z && (rt !== Dt || yt > 0 && yt & 64) ? Tt(Z, M, F, !1, !0) : (rt === Dt && yt & 384 || !Y && Ct & 16) && Tt(it, M, F), $ && St(E)
        }(Kt && (me = dt && dt.onVnodeUnmounted) || Pt) && ni(() => {
            me && xs(me, M, E), Pt && Gn(E, null, M, "unmounted")
        }, F)
    }, St = E => {
        const {
            type: M,
            el: F,
            anchor: $,
            transition: Y
        } = E;
        if (M === Dt) {
            J(F, $);
            return
        }
        if (M === Kl) {
            C(E);
            return
        }
        const rt = () => {
            n(F), Y && !Y.persisted && Y.afterLeave && Y.afterLeave()
        };
        if (E.shapeFlag & 1 && Y && !Y.persisted) {
            const {
                leave: dt,
                delayLeave: tt
            } = Y, it = () => dt(F, rt);
            tt ? tt(E.el, rt, it) : it()
        } else rt()
    }, J = (E, M) => {
        let F;
        for (; E !== M;) F = d(E), n(E), E = F;
        n(M)
    }, wt = (E, M, F) => {
        const {
            bum: $,
            scope: Y,
            update: rt,
            subTree: dt,
            um: tt
        } = E;
        $ && Yl($), Y.stop(), rt && (rt.active = !1, It(dt, E, M, F)), tt && ni(tt, M), ni(() => {
            E.isUnmounted = !0
        }, M), M && M.pendingBranch && !M.isUnmounted && E.asyncDep && !E.asyncResolved && E.suspenseId === M.pendingId && (M.deps--, M.deps === 0 && M.resolve())
    }, Tt = (E, M, F, $ = !1, Y = !1, rt = 0) => {
        for (let dt = rt; dt < E.length; dt++) It(E[dt], M, F, $, Y)
    }, Bt = E => E.shapeFlag & 6 ? Bt(E.component.subTree) : E.shapeFlag & 128 ? E.suspense.next() : d(E.anchor || E.el), kt = (E, M, F) => {
        E == null ? M._vnode && It(M._vnode, null, null, !0) : g(M._vnode || null, E, M, null, null, null, F), u_(), M._vnode = E
    }, re = {
        p: g,
        um: It,
        m: xt,
        r: St,
        mt: W,
        mc: L,
        pc: bt,
        pbc: O,
        n: Bt,
        o: e
    };
    let Xt, ce;
    return t && ([Xt, ce] = t(re)), {
        render: kt,
        hydrate: Xt,
        createApp: IS(kt, Xt)
    }
}

function Vu(e, t, i, s, n = !1) {
    if (Wt(e)) {
        e.forEach((d, f) => Vu(d, t && (Wt(t) ? t[f] : t), i, s, n));
        return
    }
    if (Bu(s) && !n) return;
    const r = s.shapeFlag & 4 ? Rf(s.component) || s.component.proxy : s.el,
        o = n ? null : r,
        {
            i: a,
            r: l
        } = e,
        c = t && t.r,
        h = a.refs === xe ? a.refs = {} : a.refs,
        u = a.setupState;
    if (c != null && c !== l && (Ye(c) ? (h[c] = null, he(u, c) && (u[c] = null)) : xi(c) && (c.value = null)), Ye(l)) {
        const d = () => {
            h[l] = o, he(u, l) && (u[l] = o)
        };
        o ? (d.id = -1, ni(d, i)) : d()
    } else if (xi(l)) {
        const d = () => {
            l.value = o
        };
        o ? (d.id = -1, ni(d, i)) : d()
    } else Yt(l) && Sn(l, a, 12, [o, h])
}

function xs(e, t, i, s = null) {
    $i(e, t, 7, [i, s])
}

function t_(e, t, i = !1) {
    const s = e.children,
        n = t.children;
    if (Wt(s) && Wt(n))
        for (let r = 0; r < s.length; r++) {
            const o = s[r];
            let a = n[r];
            a.shapeFlag & 1 && !a.dynamicChildren && ((a.patchFlag <= 0 || a.patchFlag === 32) && (a = n[r] = vn(n[r]), a.el = o.el), i || t_(o, a))
        }
}

function kS(e) {
    const t = e.slice(),
        i = [0];
    let s, n, r, o, a;
    const l = e.length;
    for (s = 0; s < l; s++) {
        const c = e[s];
        if (c !== 0) {
            if (n = i[i.length - 1], e[n] < c) {
                t[s] = n, i.push(s);
                continue
            }
            for (r = 0, o = i.length - 1; r < o;) a = r + o >> 1, e[i[a]] < c ? r = a + 1 : o = a;
            c < e[i[r]] && (r > 0 && (t[s] = i[r - 1]), i[r] = s)
        }
    }
    for (r = i.length, o = i[r - 1]; r-- > 0;) i[r] = o, o = t[o];
    return i
}
const PS = e => e.__isTeleport,
    Cf = "components";

function se(e, t) {
    return i_(Cf, e, !0, t) || e
}
const e_ = Symbol();

function De(e) {
    return Ye(e) ? i_(Cf, e, !1) || e : e || e_
}

function i_(e, t, i = !0, s = !1) {
    const n = Gi || je;
    if (n) {
        const r = n.type;
        if (e === Cf) {
            const a = YS(r);
            if (a && (a === t || a === Ds(t) || a === Zc(Ds(t)))) return r
        }
        const o = Em(n[e] || r[e], t) || Em(n.appContext[e], t);
        return !o && s ? r : o
    }
}

function Em(e, t) {
    return e && (e[t] || e[Ds(t)] || e[Zc(Ds(t))])
}
const Dt = Symbol(void 0),
    Af = Symbol(void 0),
    Ns = Symbol(void 0),
    Kl = Symbol(void 0),
    Ea = [];
let br = null;

function st(e = !1) {
    Ea.push(br = e ? null : [])
}

function LS() {
    Ea.pop(), br = Ea[Ea.length - 1] || null
}
let gc = 1;

function Sm(e) {
    gc += e
}

function s_(e) {
    return e.dynamicChildren = gc > 0 ? br || ho : null, LS(), gc > 0 && br && br.push(e), e
}

function nt(e, t, i, s, n, r) {
    return s_(b(e, t, i, s, n, r, !0))
}

function If(e, t, i, s, n) {
    return s_(X(e, t, i, s, n, !0))
}

function OS(e) {
    return e ? e.__v_isVNode === !0 : !1
}

function er(e, t) {
    return e.type === t.type && e.key === t.key
}
const eh = "__vInternal",
    n_ = ({
        key: e
    }) => e ?? null,
    Zl = ({
        ref: e
    }) => e != null ? Ye(e) || xi(e) || Yt(e) ? {
        i: Gi,
        r: e
    } : e : null;

function b(e, t = null, i = null, s = 0, n = null, r = e === Dt ? 0 : 1, o = !1, a = !1) {
    const l = {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e,
        props: t,
        key: t && n_(t),
        ref: t && Zl(t),
        scopeId: Jc,
        slotScopeIds: null,
        children: i,
        component: null,
        suspense: null,
        ssContent: null,
        ssFallback: null,
        dirs: null,
        transition: null,
        el: null,
        anchor: null,
        target: null,
        targetAnchor: null,
        staticCount: 0,
        shapeFlag: r,
        patchFlag: s,
        dynamicProps: n,
        dynamicChildren: null,
        appContext: null
    };
    return a ? (Mf(l, i), r & 128 && e.normalize(l)) : i && (l.shapeFlag |= Ye(i) ? 8 : 16), gc > 0 && !o && br && (l.patchFlag > 0 || r & 6) && l.patchFlag !== 32 && br.push(l), l
}
const X = DS;

function DS(e, t = null, i = null, s = 0, n = null, r = !1) {
    if ((!e || e === e_) && (e = Ns), OS(e)) {
        const a = Ro(e, t, !0);
        return i && Mf(a, i), a
    }
    if (KS(e) && (e = e.__vccOpts), t) {
        t = NS(t);
        let {
            class: a,
            style: l
        } = t;
        a && !Ye(a) && (t.class = Ai(a)), Ke(l) && (Ov(l) && !Wt(l) && (l = Qe({}, l)), t.style = $t(l))
    }
    const o = Ye(e) ? 1 : nS(e) ? 128 : PS(e) ? 64 : Ke(e) ? 4 : Yt(e) ? 2 : 0;
    return b(e, t, i, s, n, o, r, !0)
}

function NS(e) {
    return e ? Ov(e) || eh in e ? Qe({}, e) : e : null
}

function Ro(e, t, i = !1) {
    const {
        props: s,
        ref: n,
        patchFlag: r,
        children: o
    } = e, a = t ? BS(s || {}, t) : s;
    return {
        __v_isVNode: !0,
        __v_skip: !0,
        type: e.type,
        props: a,
        key: a && n_(a),
        ref: t && t.ref ? i && n ? Wt(n) ? n.concat(Zl(t)) : [n, Zl(t)] : Zl(t) : n,
        scopeId: e.scopeId,
        slotScopeIds: e.slotScopeIds,
        children: o,
        target: e.target,
        targetAnchor: e.targetAnchor,
        staticCount: e.staticCount,
        shapeFlag: e.shapeFlag,
        patchFlag: t && e.type !== Dt ? r === -1 ? 16 : r | 16 : r,
        dynamicProps: e.dynamicProps,
        dynamicChildren: e.dynamicChildren,
        appContext: e.appContext,
        dirs: e.dirs,
        transition: e.transition,
        component: e.component,
        suspense: e.suspense,
        ssContent: e.ssContent && Ro(e.ssContent),
        ssFallback: e.ssFallback && Ro(e.ssFallback),
        el: e.el,
        anchor: e.anchor
    }
}

function po(e = " ", t = 0) {
    return X(Af, null, e, t)
}

function ih(e, t) {
    const i = X(Kl, null, e);
    return i.staticCount = t, i
}

function FS(e = "", t = !1) {
    return t ? (st(), If(Ns, null, e)) : X(Ns, null, e)
}

function Es(e) {
    return e == null || typeof e == "boolean" ? X(Ns) : Wt(e) ? X(Dt, null, e.slice()) : typeof e == "object" ? vn(e) : X(Af, null, String(e))
}

function vn(e) {
    return e.el === null || e.memo ? e : Ro(e)
}

function Mf(e, t) {
    let i = 0;
    const {
        shapeFlag: s
    } = e;
    if (t == null) t = null;
    else if (Wt(t)) i = 16;
    else if (typeof t == "object")
        if (s & 65) {
            const n = t.default;
            n && (n._c && (n._d = !1), Mf(e, n()), n._c && (n._d = !0));
            return
        } else {
            i = 32;
            const n = t._;
            !n && !(eh in t) ? t._ctx = Gi : n === 3 && Gi && (Gi.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024))
        }
    else Yt(t) ? (t = {
        default: t,
        _ctx: Gi
    }, i = 32) : (t = String(t), s & 64 ? (i = 16, t = [po(t)]) : i = 8);
    e.children = t, e.shapeFlag |= i
}

function BS(...e) {
    const t = {};
    for (let i = 0; i < e.length; i++) {
        const s = e[i];
        for (const n in s)
            if (n === "class") t.class !== s.class && (t.class = Ai([t.class, s.class]));
            else if (n === "style") t.style = $t([t.style, s.style]);
        else if (Xc(n)) {
            const r = t[n],
                o = s[n];
            r !== o && !(Wt(r) && r.includes(o)) && (t[n] = r ? [].concat(r, o) : o)
        } else n !== "" && (t[n] = s[n])
    }
    return t
}

function Jt(e, t, i, s) {
    let n;
    const r = i && i[s];
    if (Wt(e) || Ye(e)) {
        n = new Array(e.length);
        for (let o = 0, a = e.length; o < a; o++) n[o] = t(e[o], o, void 0, r && r[o])
    } else if (typeof e == "number") {
        n = new Array(e);
        for (let o = 0; o < e; o++) n[o] = t(o + 1, o, void 0, r && r[o])
    } else if (Ke(e))
        if (e[Symbol.iterator]) n = Array.from(e, (o, a) => t(o, a, void 0, r && r[a]));
        else {
            const o = Object.keys(e);
            n = new Array(o.length);
            for (let a = 0, l = o.length; a < l; a++) {
                const c = o[a];
                n[a] = t(e[c], c, a, r && r[a])
            }
        }
    else n = [];
    return i && (i[s] = n), n
}
const zu = e => e ? r_(e) ? Rf(e) || e.proxy : zu(e.parent) : null,
    vc = Qe(Object.create(null), {
        $: e => e,
        $el: e => e.vnode.el,
        $data: e => e.data,
        $props: e => e.props,
        $attrs: e => e.attrs,
        $slots: e => e.slots,
        $refs: e => e.refs,
        $parent: e => zu(e.parent),
        $root: e => zu(e.root),
        $emit: e => e.emit,
        $options: e => Xv(e),
        $forceUpdate: e => () => l_(e.update),
        $nextTick: e => fa.bind(e.proxy),
        $watch: e => eC.bind(e)
    }),
    US = {
        get({
            _: e
        }, t) {
            const {
                ctx: i,
                setupState: s,
                data: n,
                props: r,
                accessCache: o,
                type: a,
                appContext: l
            } = e;
            let c;
            if (t[0] !== "$") {
                const f = o[t];
                if (f !== void 0) switch (f) {
                    case 1:
                        return s[t];
                    case 2:
                        return n[t];
                    case 4:
                        return i[t];
                    case 3:
                        return r[t]
                } else {
                    if (s !== xe && he(s, t)) return o[t] = 1, s[t];
                    if (n !== xe && he(n, t)) return o[t] = 2, n[t];
                    if ((c = e.propsOptions[0]) && he(c, t)) return o[t] = 3, r[t];
                    if (i !== xe && he(i, t)) return o[t] = 4, i[t];
                    Uu && (o[t] = 0)
                }
            }
            const h = vc[t];
            let u, d;
            if (h) return t === "$attrs" && Ri(e, "get", t), h(e);
            if ((u = a.__cssModules) && (u = u[t])) return u;
            if (i !== xe && he(i, t)) return o[t] = 4, i[t];
            if (d = l.config.globalProperties, he(d, t)) return d[t]
        },
        set({
            _: e
        }, t, i) {
            const {
                data: s,
                setupState: n,
                ctx: r
            } = e;
            if (n !== xe && he(n, t)) n[t] = i;
            else if (s !== xe && he(s, t)) s[t] = i;
            else if (he(e.props, t)) return !1;
            return t[0] === "$" && t.slice(1) in e ? !1 : (r[t] = i, !0)
        },
        has({
            _: {
                data: e,
                setupState: t,
                accessCache: i,
                ctx: s,
                appContext: n,
                propsOptions: r
            }
        }, o) {
            let a;
            return !!i[o] || e !== xe && he(e, o) || t !== xe && he(t, o) || (a = r[0]) && he(a, o) || he(s, o) || he(vc, o) || he(n.config.globalProperties, o)
        }
    },
    GS = Qv();
let HS = 0;

function VS(e, t, i) {
    const s = e.type,
        n = (t ? t.appContext : e.appContext) || GS,
        r = {
            uid: HS++,
            vnode: e,
            type: s,
            parent: t,
            appContext: n,
            root: null,
            next: null,
            subTree: null,
            update: null,
            scope: new _E(!0),
            render: null,
            proxy: null,
            exposed: null,
            exposeProxy: null,
            withProxy: null,
            provides: t ? t.provides : Object.create(n.provides),
            accessCache: null,
            renderCache: [],
            components: null,
            directives: null,
            propsOptions: Kv(s, n),
            emitsOptions: Bv(s, n),
            emit: null,
            emitted: null,
            propsDefaults: xe,
            inheritAttrs: s.inheritAttrs,
            ctx: xe,
            data: xe,
            props: xe,
            attrs: xe,
            slots: xe,
            refs: xe,
            setupState: xe,
            setupContext: null,
            suspense: i,
            suspenseId: i ? i.pendingId : 0,
            asyncDep: null,
            asyncResolved: !1,
            isMounted: !1,
            isUnmounted: !1,
            isDeactivated: !1,
            bc: null,
            c: null,
            bm: null,
            m: null,
            bu: null,
            u: null,
            um: null,
            bum: null,
            da: null,
            a: null,
            rtg: null,
            rtc: null,
            ec: null,
            sp: null
        };
    return r.ctx = {
        _: r
    }, r.root = t ? t.root : r, r.emit = JE.bind(null, r), e.ce && e.ce(r), r
}
let je = null;
const zS = () => je || Gi,
    ko = e => {
        je = e, e.scope.on()
    },
    xr = () => {
        je && je.scope.off(), je = null
    };

function r_(e) {
    return e.vnode.shapeFlag & 4
}
let _c = !1;

function $S(e, t = !1) {
    _c = t;
    const {
        props: i,
        children: s
    } = e.vnode, n = r_(e);
    wS(e, i, n, t), SS(e, s);
    const r = n ? jS(e, t) : void 0;
    return _c = !1, r
}

function jS(e, t) {
    const i = e.type;
    e.accessCache = Object.create(null), e.proxy = Ws(new Proxy(e.ctx, US));
    const {
        setup: s
    } = i;
    if (s) {
        const n = e.setupContext = s.length > 1 ? XS(e) : null;
        ko(e), zo();
        const r = Sn(s, e, 0, [e.props, n]);
        if (kr(), xr(), bv(r)) {
            if (r.then(xr, xr), t) return r.then(o => {
                Cm(e, o, t)
            }).catch(o => {
                sh(o, e, 0)
            });
            e.asyncDep = r
        } else Cm(e, r, t)
    } else o_(e, t)
}

function Cm(e, t, i) {
    Yt(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : Ke(t) && (e.setupState = Fv(t)), o_(e, i)
}
let Am;

function o_(e, t, i) {
    const s = e.type;
    if (!e.render) {
        if (!t && Am && !s.render) {
            const n = s.template;
            if (n) {
                const {
                    isCustomElement: r,
                    compilerOptions: o
                } = e.appContext.config, {
                    delimiters: a,
                    compilerOptions: l
                } = s, c = Qe(Qe({
                    isCustomElement: r,
                    delimiters: a
                }, o), l);
                s.render = Am(n, c)
            }
        }
        e.render = s.render || as
    }
    ko(e), zo(), vS(e), kr(), xr()
}

function WS(e) {
    return new Proxy(e.attrs, {
        get(t, i) {
            return Ri(e, "get", "$attrs"), t[i]
        }
    })
}

function XS(e) {
    const t = s => {
        e.exposed = s || {}
    };
    let i;
    return {
        get attrs() {
            return i || (i = WS(e))
        },
        slots: e.slots,
        emit: e.emit,
        expose: t
    }
}

function Rf(e) {
    if (e.exposed) return e.exposeProxy || (e.exposeProxy = new Proxy(Fv(Ws(e.exposed)), {
        get(t, i) {
            if (i in t) return t[i];
            if (i in vc) return vc[i](e)
        }
    }))
}

function YS(e) {
    return Yt(e) && e.displayName || e.name
}

function KS(e) {
    return Yt(e) && "__vccOpts" in e
}

function Sn(e, t, i, s) {
    let n;
    try {
        n = s ? e(...s) : e()
    } catch (r) {
        sh(r, t, i)
    }
    return n
}

function $i(e, t, i, s) {
    if (Yt(e)) {
        const r = Sn(e, t, i, s);
        return r && bv(r) && r.catch(o => {
            sh(o, t, i)
        }), r
    }
    const n = [];
    for (let r = 0; r < e.length; r++) n.push($i(e[r], t, i, s));
    return n
}

function sh(e, t, i, s = !0) {
    const n = t ? t.vnode : null;
    if (t) {
        let r = t.parent;
        const o = t.proxy,
            a = i;
        for (; r;) {
            const c = r.ec;
            if (c) {
                for (let h = 0; h < c.length; h++)
                    if (c[h](e, o, a) === !1) return
            }
            r = r.parent
        }
        const l = t.appContext.config.errorHandler;
        if (l) {
            Sn(l, null, 10, [e, o, a]);
            return
        }
    }
    ZS(e, i, n, s)
}

function ZS(e, t, i, s = !0) {
    console.error(e)
}
let yc = !1,
    $u = !1;
const Ci = [];
let js = 0;
const Sa = [];
let da = null,
    Jr = 0;
const Ca = [];
let pn = null,
    Qr = 0;
const a_ = Promise.resolve();
let kf = null,
    ju = null;

function fa(e) {
    const t = kf || a_;
    return e ? t.then(this ? e.bind(this) : e) : t
}

function qS(e) {
    let t = js + 1,
        i = Ci.length;
    for (; t < i;) {
        const s = t + i >>> 1;
        La(Ci[s]) < e ? t = s + 1 : i = s
    }
    return t
}

function l_(e) {
    (!Ci.length || !Ci.includes(e, yc && e.allowRecurse ? js + 1 : js)) && e !== ju && (e.id == null ? Ci.push(e) : Ci.splice(qS(e.id), 0, e), c_())
}

function c_() {
    !yc && !$u && ($u = !0, kf = a_.then(d_))
}

function JS(e) {
    const t = Ci.indexOf(e);
    t > js && Ci.splice(t, 1)
}

function h_(e, t, i, s) {
    Wt(e) ? i.push(...e) : (!t || !t.includes(e, e.allowRecurse ? s + 1 : s)) && i.push(e), c_()
}

function QS(e) {
    h_(e, da, Sa, Jr)
}

function tC(e) {
    h_(e, pn, Ca, Qr)
}

function Pf(e, t = null) {
    if (Sa.length) {
        for (ju = t, da = [...new Set(Sa)], Sa.length = 0, Jr = 0; Jr < da.length; Jr++) da[Jr]();
        da = null, Jr = 0, ju = null, Pf(e, t)
    }
}

function u_(e) {
    if (Ca.length) {
        const t = [...new Set(Ca)];
        if (Ca.length = 0, pn) {
            pn.push(...t);
            return
        }
        for (pn = t, pn.sort((i, s) => La(i) - La(s)), Qr = 0; Qr < pn.length; Qr++) pn[Qr]();
        pn = null, Qr = 0
    }
}
const La = e => e.id == null ? 1 / 0 : e.id;

function d_(e) {
    $u = !1, yc = !0, Pf(e), Ci.sort((i, s) => La(i) - La(s));
    const t = as;
    try {
        for (js = 0; js < Ci.length; js++) {
            const i = Ci[js];
            i && i.active !== !1 && Sn(i, null, 14)
        }
    } finally {
        js = 0, Ci.length = 0, u_(), yc = !1, kf = null, (Ci.length || Sa.length || Ca.length) && d_(e)
    }
}
const Im = {};

function Aa(e, t, i) {
    return f_(e, t, i)
}

function f_(e, t, {
    immediate: i,
    deep: s,
    flush: n,
    onTrack: r,
    onTrigger: o
} = xe) {
    const a = je;
    let l, c = !1,
        h = !1;
    if (xi(e) ? (l = () => e.value, c = !!e._shallow) : fo(e) ? (l = () => e, s = !0) : Wt(e) ? (h = !0, c = e.some(fo), l = () => e.map(y => {
            if (xi(y)) return y.value;
            if (fo(y)) return sr(y);
            if (Yt(y)) return Sn(y, a, 2)
        })) : Yt(e) ? t ? l = () => Sn(e, a, 2) : l = () => {
            if (!(a && a.isUnmounted)) return u && u(), $i(e, a, 3, [d])
        } : l = as, t && s) {
        const y = l;
        l = () => sr(y())
    }
    let u, d = y => {
        u = g.onStop = () => {
            Sn(y, a, 4)
        }
    };
    if (_c) return d = as, t ? i && $i(t, a, 3, [l(), h ? [] : void 0, d]) : l(), as;
    let f = h ? [] : Im;
    const p = () => {
        if (!!g.active)
            if (t) {
                const y = g.run();
                (s || c || (h ? y.some((x, v) => ka(x, f[v])) : ka(y, f))) && (u && u(), $i(t, a, 3, [y, f === Im ? void 0 : f, d]), f = y)
            } else g.run()
    };
    p.allowRecurse = !!t;
    let m;
    n === "sync" ? m = p : n === "post" ? m = () => ni(p, a && a.suspense) : m = () => {
        !a || a.isMounted ? QS(p) : p()
    };
    const g = new gf(l, m);
    return t ? i ? p() : f = g.run() : n === "post" ? ni(g.run.bind(g), a && a.suspense) : g.run(), () => {
        g.stop(), a && a.scope && _v(a.scope.effects, g)
    }
}

function eC(e, t, i) {
    const s = this.proxy,
        n = Ye(e) ? e.includes(".") ? p_(s, e) : () => s[e] : e.bind(s, s);
    let r;
    Yt(t) ? r = t : (r = t.handler, i = t);
    const o = je;
    ko(this);
    const a = f_(n, r.bind(s), i);
    return o ? ko(o) : xr(), a
}

function p_(e, t) {
    const i = t.split(".");
    return () => {
        let s = e;
        for (let n = 0; n < i.length && s; n++) s = s[i[n]];
        return s
    }
}

function sr(e, t) {
    if (!Ke(e) || e.__v_skip || (t = t || new Set, t.has(e))) return e;
    if (t.add(e), xi(e)) sr(e.value, t);
    else if (Wt(e))
        for (let i = 0; i < e.length; i++) sr(e[i], t);
    else if (yv(e) || uo(e)) e.forEach(i => {
        sr(i, t)
    });
    else if (wv(e))
        for (const i in e) sr(e[i], t);
    return e
}
const iC = "3.2.24",
    sC = "http://www.w3.org/2000/svg",
    Br = typeof document < "u" ? document : null,
    Mm = new Map,
    nC = {
        insert: (e, t, i) => {
            t.insertBefore(e, i || null)
        },
        remove: e => {
            const t = e.parentNode;
            t && t.removeChild(e)
        },
        createElement: (e, t, i, s) => {
            const n = t ? Br.createElementNS(sC, e) : Br.createElement(e, i ? {
                is: i
            } : void 0);
            return e === "select" && s && s.multiple != null && n.setAttribute("multiple", s.multiple), n
        },
        createText: e => Br.createTextNode(e),
        createComment: e => Br.createComment(e),
        setText: (e, t) => {
            e.nodeValue = t
        },
        setElementText: (e, t) => {
            e.textContent = t
        },
        parentNode: e => e.parentNode,
        nextSibling: e => e.nextSibling,
        querySelector: e => Br.querySelector(e),
        setScopeId(e, t) {
            e.setAttribute(t, "")
        },
        cloneNode(e) {
            const t = e.cloneNode(!0);
            return "_value" in e && (t._value = e._value), t
        },
        insertStaticContent(e, t, i, s) {
            const n = i ? i.previousSibling : t.lastChild;
            let r = Mm.get(e);
            if (!r) {
                const o = Br.createElement("template");
                if (o.innerHTML = s ? `<svg>${e}</svg>` : e, r = o.content, s) {
                    const a = r.firstChild;
                    for (; a.firstChild;) r.appendChild(a.firstChild);
                    r.removeChild(a)
                }
                Mm.set(e, r)
            }
            return t.insertBefore(r.cloneNode(!0), i), [n ? n.nextSibling : t.firstChild, i ? i.previousSibling : t.lastChild]
        }
    };

function rC(e, t, i) {
    const s = e._vtc;
    s && (t = (t ? [t, ...s] : [...s]).join(" ")), t == null ? e.removeAttribute("class") : i ? e.setAttribute("class", t) : e.className = t
}

function oC(e, t, i) {
    const s = e.style,
        n = Ye(i);
    if (i && !n) {
        for (const r in i) Wu(s, r, i[r]);
        if (t && !Ye(t))
            for (const r in t) i[r] == null && Wu(s, r, "")
    } else {
        const r = s.display;
        n ? t !== i && (s.cssText = i) : t && e.removeAttribute("style"), "_vod" in e && (s.display = r)
    }
}
const Rm = /\s*!important$/;

function Wu(e, t, i) {
    if (Wt(i)) i.forEach(s => Wu(e, t, s));
    else if (t.startsWith("--")) e.setProperty(t, i);
    else {
        const s = aC(e, t);
        Rm.test(i) ? e.setProperty(Vo(s), i.replace(Rm, ""), "important") : e[s] = i
    }
}
const km = ["Webkit", "Moz", "ms"],
    zh = {};

function aC(e, t) {
    const i = zh[t];
    if (i) return i;
    let s = Ds(t);
    if (s !== "filter" && s in e) return zh[t] = s;
    s = Zc(s);
    for (let n = 0; n < km.length; n++) {
        const r = km[n] + s;
        if (r in e) return zh[t] = r
    }
    return t
}
const Pm = "http://www.w3.org/1999/xlink";

function lC(e, t, i, s, n) {
    if (s && t.startsWith("xlink:")) i == null ? e.removeAttributeNS(Pm, t.slice(6, t.length)) : e.setAttributeNS(Pm, t, i);
    else {
        const r = aE(t);
        i == null || r && !gv(i) ? e.removeAttribute(t) : e.setAttribute(t, r ? "" : i)
    }
}

function cC(e, t, i, s, n, r, o) {
    if (t === "innerHTML" || t === "textContent") {
        s && o(s, n, r), e[t] = i ?? "";
        return
    }
    if (t === "value" && e.tagName !== "PROGRESS" && !e.tagName.includes("-")) {
        e._value = i;
        const a = i ?? "";
        (e.value !== a || e.tagName === "OPTION") && (e.value = a), i == null && e.removeAttribute(t);
        return
    }
    if (i === "" || i == null) {
        const a = typeof e[t];
        if (a === "boolean") {
            e[t] = gv(i);
            return
        } else if (i == null && a === "string") {
            e[t] = "", e.removeAttribute(t);
            return
        } else if (a === "number") {
            try {
                e[t] = 0
            } catch {}
            e.removeAttribute(t);
            return
        }
    }
    try {
        e[t] = i
    } catch {}
}
let bc = Date.now,
    m_ = !1;
if (typeof window < "u") {
    bc() > document.createEvent("Event").timeStamp && (bc = () => performance.now());
    const e = navigator.userAgent.match(/firefox\/(\d+)/i);
    m_ = !!(e && Number(e[1]) <= 53)
}
let Xu = 0;
const hC = Promise.resolve(),
    uC = () => {
        Xu = 0
    },
    dC = () => Xu || (hC.then(uC), Xu = bc());

function to(e, t, i, s) {
    e.addEventListener(t, i, s)
}

function fC(e, t, i, s) {
    e.removeEventListener(t, i, s)
}

function pC(e, t, i, s, n = null) {
    const r = e._vei || (e._vei = {}),
        o = r[t];
    if (s && o) o.value = s;
    else {
        const [a, l] = mC(t);
        if (s) {
            const c = r[t] = gC(s, n);
            to(e, a, c, l)
        } else o && (fC(e, a, o, l), r[t] = void 0)
    }
}
const Lm = /(?:Once|Passive|Capture)$/;

function mC(e) {
    let t;
    if (Lm.test(e)) {
        t = {};
        let i;
        for (; i = e.match(Lm);) e = e.slice(0, e.length - i[0].length), t[i[0].toLowerCase()] = !0
    }
    return [Vo(e.slice(2)), t]
}

function gC(e, t) {
    const i = s => {
        const n = s.timeStamp || bc();
        (m_ || n >= i.attached - 1) && $i(vC(s, i.value), t, 5, [s])
    };
    return i.value = e, i.attached = dC(), i
}

function vC(e, t) {
    if (Wt(t)) {
        const i = e.stopImmediatePropagation;
        return e.stopImmediatePropagation = () => {
            i.call(e), e._stopped = !0
        }, t.map(s => n => !n._stopped && s(n))
    } else return t
}
const Om = /^on[a-z]/,
    _C = (e, t, i, s, n = !1, r, o, a, l) => {
        t === "class" ? rC(e, s, n) : t === "style" ? oC(e, i, s) : Xc(t) ? df(t) || pC(e, t, i, s, o) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : yC(e, t, s, n)) ? cC(e, t, s, r, o, a, l) : (t === "true-value" ? e._trueValue = s : t === "false-value" && (e._falseValue = s), lC(e, t, s, n))
    };

function yC(e, t, i, s) {
    return s ? !!(t === "innerHTML" || t === "textContent" || t in e && Om.test(t) && Yt(i)) : t === "spellcheck" || t === "draggable" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA" || Om.test(t) && Ye(i) ? !1 : t in e
}
const bC = {
    name: String,
    type: String,
    css: {
        type: Boolean,
        default: !0
    },
    duration: [String, Number, Object],
    enterFromClass: String,
    enterActiveClass: String,
    enterToClass: String,
    appearFromClass: String,
    appearActiveClass: String,
    appearToClass: String,
    leaveFromClass: String,
    leaveActiveClass: String,
    leaveToClass: String
};
lS.props;
const Dm = e => {
    const t = e.props["onUpdate:modelValue"];
    return Wt(t) ? i => Yl(t, i) : t
};

function xC(e) {
    e.target.composing = !0
}

function Nm(e) {
    const t = e.target;
    t.composing && (t.composing = !1, wC(t, "input"))
}

function wC(e, t) {
    const i = document.createEvent("HTMLEvents");
    i.initEvent(t, !0, !0), e.dispatchEvent(i)
}
const nr = {
        created(e, {
            modifiers: {
                lazy: t,
                trim: i,
                number: s
            }
        }, n) {
            e._assign = Dm(n);
            const r = s || n.props && n.props.type === "number";
            to(e, t ? "change" : "input", o => {
                if (o.target.composing) return;
                let a = e.value;
                i ? a = a.trim() : r && (a = ku(a)), e._assign(a)
            }), i && to(e, "change", () => {
                e.value = e.value.trim()
            }), t || (to(e, "compositionstart", xC), to(e, "compositionend", Nm), to(e, "change", Nm))
        },
        mounted(e, {
            value: t
        }) {
            e.value = t ?? ""
        },
        beforeUpdate(e, {
            value: t,
            modifiers: {
                lazy: i,
                trim: s,
                number: n
            }
        }, r) {
            if (e._assign = Dm(r), e.composing || document.activeElement === e && (i || s && e.value.trim() === t || (n || e.type === "number") && ku(e.value) === t)) return;
            const o = t ?? "";
            e.value !== o && (e.value = o)
        }
    },
    ye = {
        beforeMount(e, {
            value: t
        }, {
            transition: i
        }) {
            e._vod = e.style.display === "none" ? "" : e.style.display, i && t ? i.beforeEnter(e) : Zo(e, t)
        },
        mounted(e, {
            value: t
        }, {
            transition: i
        }) {
            i && t && i.enter(e)
        },
        updated(e, {
            value: t,
            oldValue: i
        }, {
            transition: s
        }) {
            !t != !i && (s ? t ? (s.beforeEnter(e), Zo(e, !0), s.enter(e)) : s.leave(e, () => {
                Zo(e, !1)
            }) : Zo(e, t))
        },
        beforeUnmount(e, {
            value: t
        }) {
            Zo(e, t)
        }
    };

function Zo(e, t) {
    e.style.display = t ? e._vod : "none"
}
const TC = Qe({
    patchProp: _C
}, nC);
let Fm;

function EC() {
    return Fm || (Fm = MS(TC))
}
const SC = (...e) => {
    const t = EC().createApp(...e),
        {
            mount: i
        } = t;
    return t.mount = s => {
        const n = CC(s);
        if (!n) return;
        const r = t._component;
        !Yt(r) && !r.render && !r.template && (r.template = n.innerHTML), n.innerHTML = "";
        const o = i(n, !1, n instanceof SVGElement);
        return n instanceof Element && (n.removeAttribute("v-cloak"), n.setAttribute("data-v-app", "")), o
    }, t
};

function CC(e) {
    return Ye(e) ? document.querySelector(e) : e
}
var Lr = (e => (e[e.WEBGL_LEGACY = 0] = "WEBGL_LEGACY", e[e.WEBGL = 1] = "WEBGL", e[e.WEBGL2 = 2] = "WEBGL2", e))(Lr || {}),
    Yu = (e => (e[e.COLOR = 16384] = "COLOR", e[e.DEPTH = 256] = "DEPTH", e[e.STENCIL = 1024] = "STENCIL", e))(Yu || {}),
    j = (e => (e[e.NORMAL = 0] = "NORMAL", e[e.ADD = 1] = "ADD", e[e.MULTIPLY = 2] = "MULTIPLY", e[e.SCREEN = 3] = "SCREEN", e[e.OVERLAY = 4] = "OVERLAY", e[e.DARKEN = 5] = "DARKEN", e[e.LIGHTEN = 6] = "LIGHTEN", e[e.COLOR_DODGE = 7] = "COLOR_DODGE", e[e.COLOR_BURN = 8] = "COLOR_BURN", e[e.HARD_LIGHT = 9] = "HARD_LIGHT", e[e.SOFT_LIGHT = 10] = "SOFT_LIGHT", e[e.DIFFERENCE = 11] = "DIFFERENCE", e[e.EXCLUSION = 12] = "EXCLUSION", e[e.HUE = 13] = "HUE", e[e.SATURATION = 14] = "SATURATION", e[e.COLOR = 15] = "COLOR", e[e.LUMINOSITY = 16] = "LUMINOSITY", e[e.NORMAL_NPM = 17] = "NORMAL_NPM", e[e.ADD_NPM = 18] = "ADD_NPM", e[e.SCREEN_NPM = 19] = "SCREEN_NPM", e[e.NONE = 20] = "NONE", e[e.SRC_OVER = 0] = "SRC_OVER", e[e.SRC_IN = 21] = "SRC_IN", e[e.SRC_OUT = 22] = "SRC_OUT", e[e.SRC_ATOP = 23] = "SRC_ATOP", e[e.DST_OVER = 24] = "DST_OVER", e[e.DST_IN = 25] = "DST_IN", e[e.DST_OUT = 26] = "DST_OUT", e[e.DST_ATOP = 27] = "DST_ATOP", e[e.ERASE = 26] = "ERASE", e[e.SUBTRACT = 28] = "SUBTRACT", e[e.XOR = 29] = "XOR", e))(j || {}),
    rs = (e => (e[e.POINTS = 0] = "POINTS", e[e.LINES = 1] = "LINES", e[e.LINE_LOOP = 2] = "LINE_LOOP", e[e.LINE_STRIP = 3] = "LINE_STRIP", e[e.TRIANGLES = 4] = "TRIANGLES", e[e.TRIANGLE_STRIP = 5] = "TRIANGLE_STRIP", e[e.TRIANGLE_FAN = 6] = "TRIANGLE_FAN", e))(rs || {}),
    ot = (e => (e[e.RGBA = 6408] = "RGBA", e[e.RGB = 6407] = "RGB", e[e.RG = 33319] = "RG", e[e.RED = 6403] = "RED", e[e.RGBA_INTEGER = 36249] = "RGBA_INTEGER", e[e.RGB_INTEGER = 36248] = "RGB_INTEGER", e[e.RG_INTEGER = 33320] = "RG_INTEGER", e[e.RED_INTEGER = 36244] = "RED_INTEGER", e[e.ALPHA = 6406] = "ALPHA", e[e.LUMINANCE = 6409] = "LUMINANCE", e[e.LUMINANCE_ALPHA = 6410] = "LUMINANCE_ALPHA", e[e.DEPTH_COMPONENT = 6402] = "DEPTH_COMPONENT", e[e.DEPTH_STENCIL = 34041] = "DEPTH_STENCIL", e))(ot || {}),
    mo = (e => (e[e.TEXTURE_2D = 3553] = "TEXTURE_2D", e[e.TEXTURE_CUBE_MAP = 34067] = "TEXTURE_CUBE_MAP", e[e.TEXTURE_2D_ARRAY = 35866] = "TEXTURE_2D_ARRAY", e[e.TEXTURE_CUBE_MAP_POSITIVE_X = 34069] = "TEXTURE_CUBE_MAP_POSITIVE_X", e[e.TEXTURE_CUBE_MAP_NEGATIVE_X = 34070] = "TEXTURE_CUBE_MAP_NEGATIVE_X", e[e.TEXTURE_CUBE_MAP_POSITIVE_Y = 34071] = "TEXTURE_CUBE_MAP_POSITIVE_Y", e[e.TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072] = "TEXTURE_CUBE_MAP_NEGATIVE_Y", e[e.TEXTURE_CUBE_MAP_POSITIVE_Z = 34073] = "TEXTURE_CUBE_MAP_POSITIVE_Z", e[e.TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074] = "TEXTURE_CUBE_MAP_NEGATIVE_Z", e))(mo || {}),
    Rt = (e => (e[e.UNSIGNED_BYTE = 5121] = "UNSIGNED_BYTE", e[e.UNSIGNED_SHORT = 5123] = "UNSIGNED_SHORT", e[e.UNSIGNED_SHORT_5_6_5 = 33635] = "UNSIGNED_SHORT_5_6_5", e[e.UNSIGNED_SHORT_4_4_4_4 = 32819] = "UNSIGNED_SHORT_4_4_4_4", e[e.UNSIGNED_SHORT_5_5_5_1 = 32820] = "UNSIGNED_SHORT_5_5_5_1", e[e.UNSIGNED_INT = 5125] = "UNSIGNED_INT", e[e.UNSIGNED_INT_10F_11F_11F_REV = 35899] = "UNSIGNED_INT_10F_11F_11F_REV", e[e.UNSIGNED_INT_2_10_10_10_REV = 33640] = "UNSIGNED_INT_2_10_10_10_REV", e[e.UNSIGNED_INT_24_8 = 34042] = "UNSIGNED_INT_24_8", e[e.UNSIGNED_INT_5_9_9_9_REV = 35902] = "UNSIGNED_INT_5_9_9_9_REV", e[e.BYTE = 5120] = "BYTE", e[e.SHORT = 5122] = "SHORT", e[e.INT = 5124] = "INT", e[e.FLOAT = 5126] = "FLOAT", e[e.FLOAT_32_UNSIGNED_INT_24_8_REV = 36269] = "FLOAT_32_UNSIGNED_INT_24_8_REV", e[e.HALF_FLOAT = 36193] = "HALF_FLOAT", e))(Rt || {}),
    Ku = (e => (e[e.FLOAT = 0] = "FLOAT", e[e.INT = 1] = "INT", e[e.UINT = 2] = "UINT", e))(Ku || {}),
    Hi = (e => (e[e.NEAREST = 0] = "NEAREST", e[e.LINEAR = 1] = "LINEAR", e))(Hi || {}),
    Zs = (e => (e[e.CLAMP = 33071] = "CLAMP", e[e.REPEAT = 10497] = "REPEAT", e[e.MIRRORED_REPEAT = 33648] = "MIRRORED_REPEAT", e))(Zs || {}),
    ds = (e => (e[e.OFF = 0] = "OFF", e[e.POW2 = 1] = "POW2", e[e.ON = 2] = "ON", e[e.ON_MANUAL = 3] = "ON_MANUAL", e))(ds || {}),
    _s = (e => (e[e.NPM = 0] = "NPM", e[e.UNPACK = 1] = "UNPACK", e[e.PMA = 2] = "PMA", e[e.NO_PREMULTIPLIED_ALPHA = 0] = "NO_PREMULTIPLIED_ALPHA", e[e.PREMULTIPLY_ON_UPLOAD = 1] = "PREMULTIPLY_ON_UPLOAD", e[e.PREMULTIPLIED_ALPHA = 2] = "PREMULTIPLIED_ALPHA", e))(_s || {}),
    Ss = (e => (e[e.NO = 0] = "NO", e[e.YES = 1] = "YES", e[e.AUTO = 2] = "AUTO", e[e.BLEND = 0] = "BLEND", e[e.CLEAR = 1] = "CLEAR", e[e.BLIT = 2] = "BLIT", e))(Ss || {}),
    Lf = (e => (e[e.AUTO = 0] = "AUTO", e[e.MANUAL = 1] = "MANUAL", e))(Lf || {}),
    Vi = (e => (e.LOW = "lowp", e.MEDIUM = "mediump", e.HIGH = "highp", e))(Vi || {}),
    Ue = (e => (e[e.NONE = 0] = "NONE", e[e.SCISSOR = 1] = "SCISSOR", e[e.STENCIL = 2] = "STENCIL", e[e.SPRITE = 3] = "SPRITE", e[e.COLOR = 4] = "COLOR", e))(Ue || {}),
    Fe = (e => (e[e.NONE = 0] = "NONE", e[e.LOW = 2] = "LOW", e[e.MEDIUM = 4] = "MEDIUM", e[e.HIGH = 8] = "HIGH", e))(Fe || {}),
    Ps = (e => (e[e.ELEMENT_ARRAY_BUFFER = 34963] = "ELEMENT_ARRAY_BUFFER", e[e.ARRAY_BUFFER = 34962] = "ARRAY_BUFFER", e[e.UNIFORM_BUFFER = 35345] = "UNIFORM_BUFFER", e))(Ps || {});
const AC = {
        createCanvas: (e, t) => {
            const i = document.createElement("canvas");
            return i.width = e, i.height = t, i
        },
        getCanvasRenderingContext2D: () => CanvasRenderingContext2D,
        getWebGLRenderingContext: () => WebGLRenderingContext,
        getNavigator: () => navigator,
        getBaseUrl: () => document.baseURI ?? window.location.href,
        getFontFaceSet: () => document.fonts,
        fetch: (e, t) => fetch(e, t),
        parseXML: e => new DOMParser().parseFromString(e, "text/xml")
    },
    ut = {
        ADAPTER: AC,
        RESOLUTION: 1,
        RENDER_OPTIONS: {
            view: null,
            antialias: !1,
            autoDensity: !1,
            backgroundColor: 0,
            backgroundAlpha: 1,
            premultipliedAlpha: !0,
            clearBeforeRender: !0,
            preserveDrawingBuffer: !1,
            width: 800,
            height: 600,
            legacy: !1,
            hello: !1
        },
        CREATE_IMAGE_BITMAP: !1,
        ROUND_PIXELS: !1
    };
var $h = /iPhone/i,
    Bm = /iPod/i,
    Um = /iPad/i,
    Gm = /\biOS-universal(?:.+)Mac\b/i,
    jh = /\bAndroid(?:.+)Mobile\b/i,
    Hm = /Android/i,
    Ur = /(?:SD4930UR|\bSilk(?:.+)Mobile\b)/i,
    vl = /Silk/i,
    Gs = /Windows Phone/i,
    Vm = /\bWindows(?:.+)ARM\b/i,
    zm = /BlackBerry/i,
    $m = /BB10/i,
    jm = /Opera Mini/i,
    Wm = /\b(CriOS|Chrome)(?:.+)Mobile/i,
    Xm = /Mobile(?:.+)Firefox\b/i,
    Ym = function(e) {
        return typeof e < "u" && e.platform === "MacIntel" && typeof e.maxTouchPoints == "number" && e.maxTouchPoints > 1 && typeof MSStream > "u"
    };

function IC(e) {
    return function(t) {
        return t.test(e)
    }
}

function MC(e) {
    var t = {
        userAgent: "",
        platform: "",
        maxTouchPoints: 0
    };
    !e && typeof navigator < "u" ? t = {
        userAgent: navigator.userAgent,
        platform: navigator.platform,
        maxTouchPoints: navigator.maxTouchPoints || 0
    } : typeof e == "string" ? t.userAgent = e : e && e.userAgent && (t = {
        userAgent: e.userAgent,
        platform: e.platform,
        maxTouchPoints: e.maxTouchPoints || 0
    });
    var i = t.userAgent,
        s = i.split("[FBAN");
    typeof s[1] < "u" && (i = s[0]), s = i.split("Twitter"), typeof s[1] < "u" && (i = s[0]);
    var n = IC(i),
        r = {
            apple: {
                phone: n($h) && !n(Gs),
                ipod: n(Bm),
                tablet: !n($h) && (n(Um) || Ym(t)) && !n(Gs),
                universal: n(Gm),
                device: (n($h) || n(Bm) || n(Um) || n(Gm) || Ym(t)) && !n(Gs)
            },
            amazon: {
                phone: n(Ur),
                tablet: !n(Ur) && n(vl),
                device: n(Ur) || n(vl)
            },
            android: {
                phone: !n(Gs) && n(Ur) || !n(Gs) && n(jh),
                tablet: !n(Gs) && !n(Ur) && !n(jh) && (n(vl) || n(Hm)),
                device: !n(Gs) && (n(Ur) || n(vl) || n(jh) || n(Hm)) || n(/\bokhttp\b/i)
            },
            windows: {
                phone: n(Gs),
                tablet: n(Vm),
                device: n(Gs) || n(Vm)
            },
            other: {
                blackberry: n(zm),
                blackberry10: n($m),
                opera: n(jm),
                firefox: n(Xm),
                chrome: n(Wm),
                device: n(zm) || n($m) || n(jm) || n(Xm) || n(Wm)
            },
            any: !1,
            phone: !1,
            tablet: !1
        };
    return r.any = r.apple.device || r.android.device || r.windows.device || r.other.device, r.phone = r.apple.phone || r.android.phone || r.windows.phone, r.tablet = r.apple.tablet || r.android.tablet || r.windows.tablet, r
}
const Is = MC(globalThis.navigator);
ut.RETINA_PREFIX = /@([0-9\.]+)x/;
ut.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT = !1;
var Wh = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {},
    g_ = {
        exports: {}
    };
(function(e) {
    var t = Object.prototype.hasOwnProperty,
        i = "~";

    function s() {}
    Object.create && (s.prototype = Object.create(null), new s().__proto__ || (i = !1));

    function n(l, c, h) {
        this.fn = l, this.context = c, this.once = h || !1
    }

    function r(l, c, h, u, d) {
        if (typeof h != "function") throw new TypeError("The listener must be a function");
        var f = new n(h, u || l, d),
            p = i ? i + c : c;
        return l._events[p] ? l._events[p].fn ? l._events[p] = [l._events[p], f] : l._events[p].push(f) : (l._events[p] = f, l._eventsCount++), l
    }

    function o(l, c) {
        --l._eventsCount === 0 ? l._events = new s : delete l._events[c]
    }

    function a() {
        this._events = new s, this._eventsCount = 0
    }
    a.prototype.eventNames = function() {
        var c = [],
            h, u;
        if (this._eventsCount === 0) return c;
        for (u in h = this._events) t.call(h, u) && c.push(i ? u.slice(1) : u);
        return Object.getOwnPropertySymbols ? c.concat(Object.getOwnPropertySymbols(h)) : c
    }, a.prototype.listeners = function(c) {
        var h = i ? i + c : c,
            u = this._events[h];
        if (!u) return [];
        if (u.fn) return [u.fn];
        for (var d = 0, f = u.length, p = new Array(f); d < f; d++) p[d] = u[d].fn;
        return p
    }, a.prototype.listenerCount = function(c) {
        var h = i ? i + c : c,
            u = this._events[h];
        return u ? u.fn ? 1 : u.length : 0
    }, a.prototype.emit = function(c, h, u, d, f, p) {
        var m = i ? i + c : c;
        if (!this._events[m]) return !1;
        var g = this._events[m],
            y = arguments.length,
            x, v;
        if (g.fn) {
            switch (g.once && this.removeListener(c, g.fn, void 0, !0), y) {
                case 1:
                    return g.fn.call(g.context), !0;
                case 2:
                    return g.fn.call(g.context, h), !0;
                case 3:
                    return g.fn.call(g.context, h, u), !0;
                case 4:
                    return g.fn.call(g.context, h, u, d), !0;
                case 5:
                    return g.fn.call(g.context, h, u, d, f), !0;
                case 6:
                    return g.fn.call(g.context, h, u, d, f, p), !0
            }
            for (v = 1, x = new Array(y - 1); v < y; v++) x[v - 1] = arguments[v];
            g.fn.apply(g.context, x)
        } else {
            var _ = g.length,
                C;
            for (v = 0; v < _; v++) switch (g[v].once && this.removeListener(c, g[v].fn, void 0, !0), y) {
                case 1:
                    g[v].fn.call(g[v].context);
                    break;
                case 2:
                    g[v].fn.call(g[v].context, h);
                    break;
                case 3:
                    g[v].fn.call(g[v].context, h, u);
                    break;
                case 4:
                    g[v].fn.call(g[v].context, h, u, d);
                    break;
                default:
                    if (!x)
                        for (C = 1, x = new Array(y - 1); C < y; C++) x[C - 1] = arguments[C];
                    g[v].fn.apply(g[v].context, x)
            }
        }
        return !0
    }, a.prototype.on = function(c, h, u) {
        return r(this, c, h, u, !1)
    }, a.prototype.once = function(c, h, u) {
        return r(this, c, h, u, !0)
    }, a.prototype.removeListener = function(c, h, u, d) {
        var f = i ? i + c : c;
        if (!this._events[f]) return this;
        if (!h) return o(this, f), this;
        var p = this._events[f];
        if (p.fn) p.fn === h && (!d || p.once) && (!u || p.context === u) && o(this, f);
        else {
            for (var m = 0, g = [], y = p.length; m < y; m++)(p[m].fn !== h || d && !p[m].once || u && p[m].context !== u) && g.push(p[m]);
            g.length ? this._events[f] = g.length === 1 ? g[0] : g : o(this, f)
        }
        return this
    }, a.prototype.removeAllListeners = function(c) {
        var h;
        return c ? (h = i ? i + c : c, this._events[h] && o(this, h)) : (this._events = new s, this._eventsCount = 0), this
    }, a.prototype.off = a.prototype.removeListener, a.prototype.addListener = a.prototype.on, a.prefixed = i, a.EventEmitter = a, e.exports = a
})(g_);
var $o = g_.exports,
    Of = {
        exports: {}
    };
Of.exports = nh;
Of.exports.default = nh;

function nh(e, t, i) {
    i = i || 2;
    var s = t && t.length,
        n = s ? t[0] * i : e.length,
        r = v_(e, 0, n, i, !0),
        o = [];
    if (!r || r.next === r.prev) return o;
    var a, l, c, h, u, d, f;
    if (s && (r = OC(e, t, r, i)), e.length > 80 * i) {
        a = c = e[0], l = h = e[1];
        for (var p = i; p < n; p += i) u = e[p], d = e[p + 1], u < a && (a = u), d < l && (l = d), u > c && (c = u), d > h && (h = d);
        f = Math.max(c - a, h - l), f = f !== 0 ? 32767 / f : 0
    }
    return Oa(r, o, i, a, l, f, 0), o
}

function v_(e, t, i, s, n) {
    var r, o;
    if (n === Ju(e, t, i, s) > 0)
        for (r = t; r < i; r += s) o = Km(r, e[r], e[r + 1], o);
    else
        for (r = i - s; r >= t; r -= s) o = Km(r, e[r], e[r + 1], o);
    return o && rh(o, o.next) && (Na(o), o = o.next), o
}

function Cr(e, t) {
    if (!e) return e;
    t || (t = e);
    var i = e,
        s;
    do
        if (s = !1, !i.steiner && (rh(i, i.next) || Re(i.prev, i, i.next) === 0)) {
            if (Na(i), i = t = i.prev, i === i.next) break;
            s = !0
        } else i = i.next; while (s || i !== t);
    return t
}

function Oa(e, t, i, s, n, r, o) {
    if (!!e) {
        !o && r && UC(e, s, n, r);
        for (var a = e, l, c; e.prev !== e.next;) {
            if (l = e.prev, c = e.next, r ? kC(e, s, n, r) : RC(e)) {
                t.push(l.i / i | 0), t.push(e.i / i | 0), t.push(c.i / i | 0), Na(e), e = c.next, a = c.next;
                continue
            }
            if (e = c, e === a) {
                o ? o === 1 ? (e = PC(Cr(e), t, i), Oa(e, t, i, s, n, r, 2)) : o === 2 && LC(e, t, i, s, n, r) : Oa(Cr(e), t, i, s, n, r, 1);
                break
            }
        }
    }
}

function RC(e) {
    var t = e.prev,
        i = e,
        s = e.next;
    if (Re(t, i, s) >= 0) return !1;
    for (var n = t.x, r = i.x, o = s.x, a = t.y, l = i.y, c = s.y, h = n < r ? n < o ? n : o : r < o ? r : o, u = a < l ? a < c ? a : c : l < c ? l : c, d = n > r ? n > o ? n : o : r > o ? r : o, f = a > l ? a > c ? a : c : l > c ? l : c, p = s.next; p !== t;) {
        if (p.x >= h && p.x <= d && p.y >= u && p.y <= f && oo(n, a, r, l, o, c, p.x, p.y) && Re(p.prev, p, p.next) >= 0) return !1;
        p = p.next
    }
    return !0
}

function kC(e, t, i, s) {
    var n = e.prev,
        r = e,
        o = e.next;
    if (Re(n, r, o) >= 0) return !1;
    for (var a = n.x, l = r.x, c = o.x, h = n.y, u = r.y, d = o.y, f = a < l ? a < c ? a : c : l < c ? l : c, p = h < u ? h < d ? h : d : u < d ? u : d, m = a > l ? a > c ? a : c : l > c ? l : c, g = h > u ? h > d ? h : d : u > d ? u : d, y = Zu(f, p, t, i, s), x = Zu(m, g, t, i, s), v = e.prevZ, _ = e.nextZ; v && v.z >= y && _ && _.z <= x;) {
        if (v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== n && v !== o && oo(a, h, l, u, c, d, v.x, v.y) && Re(v.prev, v, v.next) >= 0 || (v = v.prevZ, _.x >= f && _.x <= m && _.y >= p && _.y <= g && _ !== n && _ !== o && oo(a, h, l, u, c, d, _.x, _.y) && Re(_.prev, _, _.next) >= 0)) return !1;
        _ = _.nextZ
    }
    for (; v && v.z >= y;) {
        if (v.x >= f && v.x <= m && v.y >= p && v.y <= g && v !== n && v !== o && oo(a, h, l, u, c, d, v.x, v.y) && Re(v.prev, v, v.next) >= 0) return !1;
        v = v.prevZ
    }
    for (; _ && _.z <= x;) {
        if (_.x >= f && _.x <= m && _.y >= p && _.y <= g && _ !== n && _ !== o && oo(a, h, l, u, c, d, _.x, _.y) && Re(_.prev, _, _.next) >= 0) return !1;
        _ = _.nextZ
    }
    return !0
}

function PC(e, t, i) {
    var s = e;
    do {
        var n = s.prev,
            r = s.next.next;
        !rh(n, r) && __(n, s, s.next, r) && Da(n, r) && Da(r, n) && (t.push(n.i / i | 0), t.push(s.i / i | 0), t.push(r.i / i | 0), Na(s), Na(s.next), s = e = r), s = s.next
    } while (s !== e);
    return Cr(s)
}

function LC(e, t, i, s, n, r) {
    var o = e;
    do {
        for (var a = o.next.next; a !== o.prev;) {
            if (o.i !== a.i && VC(o, a)) {
                var l = y_(o, a);
                o = Cr(o, o.next), l = Cr(l, l.next), Oa(o, t, i, s, n, r, 0), Oa(l, t, i, s, n, r, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== e)
}

function OC(e, t, i, s) {
    var n = [],
        r, o, a, l, c;
    for (r = 0, o = t.length; r < o; r++) a = t[r] * s, l = r < o - 1 ? t[r + 1] * s : e.length, c = v_(e, a, l, s, !1), c === c.next && (c.steiner = !0), n.push(HC(c));
    for (n.sort(DC), r = 0; r < n.length; r++) i = NC(n[r], i);
    return i
}

function DC(e, t) {
    return e.x - t.x
}

function NC(e, t) {
    var i = FC(e, t);
    if (!i) return t;
    var s = y_(i, e);
    return Cr(s, s.next), Cr(i, i.next)
}

function FC(e, t) {
    var i = t,
        s = e.x,
        n = e.y,
        r = -1 / 0,
        o;
    do {
        if (n <= i.y && n >= i.next.y && i.next.y !== i.y) {
            var a = i.x + (n - i.y) * (i.next.x - i.x) / (i.next.y - i.y);
            if (a <= s && a > r && (r = a, o = i.x < i.next.x ? i : i.next, a === s)) return o
        }
        i = i.next
    } while (i !== t);
    if (!o) return null;
    var l = o,
        c = o.x,
        h = o.y,
        u = 1 / 0,
        d;
    i = o;
    do s >= i.x && i.x >= c && s !== i.x && oo(n < h ? s : r, n, c, h, n < h ? r : s, n, i.x, i.y) && (d = Math.abs(n - i.y) / (s - i.x), Da(i, e) && (d < u || d === u && (i.x > o.x || i.x === o.x && BC(o, i))) && (o = i, u = d)), i = i.next; while (i !== l);
    return o
}

function BC(e, t) {
    return Re(e.prev, e, t.prev) < 0 && Re(t.next, e, e.next) < 0
}

function UC(e, t, i, s) {
    var n = e;
    do n.z === 0 && (n.z = Zu(n.x, n.y, t, i, s)), n.prevZ = n.prev, n.nextZ = n.next, n = n.next; while (n !== e);
    n.prevZ.nextZ = null, n.prevZ = null, GC(n)
}

function GC(e) {
    var t, i, s, n, r, o, a, l, c = 1;
    do {
        for (i = e, e = null, r = null, o = 0; i;) {
            for (o++, s = i, a = 0, t = 0; t < c && (a++, s = s.nextZ, !!s); t++);
            for (l = c; a > 0 || l > 0 && s;) a !== 0 && (l === 0 || !s || i.z <= s.z) ? (n = i, i = i.nextZ, a--) : (n = s, s = s.nextZ, l--), r ? r.nextZ = n : e = n, n.prevZ = r, r = n;
            i = s
        }
        r.nextZ = null, c *= 2
    } while (o > 1);
    return e
}

function Zu(e, t, i, s, n) {
    return e = (e - i) * n | 0, t = (t - s) * n | 0, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, t = (t | t << 8) & 16711935, t = (t | t << 4) & 252645135, t = (t | t << 2) & 858993459, t = (t | t << 1) & 1431655765, e | t << 1
}

function HC(e) {
    var t = e,
        i = e;
    do(t.x < i.x || t.x === i.x && t.y < i.y) && (i = t), t = t.next; while (t !== e);
    return i
}

function oo(e, t, i, s, n, r, o, a) {
    return (n - o) * (t - a) >= (e - o) * (r - a) && (e - o) * (s - a) >= (i - o) * (t - a) && (i - o) * (r - a) >= (n - o) * (s - a)
}

function VC(e, t) {
    return e.next.i !== t.i && e.prev.i !== t.i && !zC(e, t) && (Da(e, t) && Da(t, e) && $C(e, t) && (Re(e.prev, e, t.prev) || Re(e, t.prev, t)) || rh(e, t) && Re(e.prev, e, e.next) > 0 && Re(t.prev, t, t.next) > 0)
}

function Re(e, t, i) {
    return (t.y - e.y) * (i.x - t.x) - (t.x - e.x) * (i.y - t.y)
}

function rh(e, t) {
    return e.x === t.x && e.y === t.y
}

function __(e, t, i, s) {
    var n = yl(Re(e, t, i)),
        r = yl(Re(e, t, s)),
        o = yl(Re(i, s, e)),
        a = yl(Re(i, s, t));
    return !!(n !== r && o !== a || n === 0 && _l(e, i, t) || r === 0 && _l(e, s, t) || o === 0 && _l(i, e, s) || a === 0 && _l(i, t, s))
}

function _l(e, t, i) {
    return t.x <= Math.max(e.x, i.x) && t.x >= Math.min(e.x, i.x) && t.y <= Math.max(e.y, i.y) && t.y >= Math.min(e.y, i.y)
}

function yl(e) {
    return e > 0 ? 1 : e < 0 ? -1 : 0
}

function zC(e, t) {
    var i = e;
    do {
        if (i.i !== e.i && i.next.i !== e.i && i.i !== t.i && i.next.i !== t.i && __(i, i.next, e, t)) return !0;
        i = i.next
    } while (i !== e);
    return !1
}

function Da(e, t) {
    return Re(e.prev, e, e.next) < 0 ? Re(e, t, e.next) >= 0 && Re(e, e.prev, t) >= 0 : Re(e, t, e.prev) < 0 || Re(e, e.next, t) < 0
}

function $C(e, t) {
    var i = e,
        s = !1,
        n = (e.x + t.x) / 2,
        r = (e.y + t.y) / 2;
    do i.y > r != i.next.y > r && i.next.y !== i.y && n < (i.next.x - i.x) * (r - i.y) / (i.next.y - i.y) + i.x && (s = !s), i = i.next; while (i !== e);
    return s
}

function y_(e, t) {
    var i = new qu(e.i, e.x, e.y),
        s = new qu(t.i, t.x, t.y),
        n = e.next,
        r = t.prev;
    return e.next = t, t.prev = e, i.next = n, n.prev = i, s.next = i, i.prev = s, r.next = s, s.prev = r, s
}

function Km(e, t, i, s) {
    var n = new qu(e, t, i);
    return s ? (n.next = s.next, n.prev = s, s.next.prev = n, s.next = n) : (n.prev = n, n.next = n), n
}

function Na(e) {
    e.next.prev = e.prev, e.prev.next = e.next, e.prevZ && (e.prevZ.nextZ = e.nextZ), e.nextZ && (e.nextZ.prevZ = e.prevZ)
}

function qu(e, t, i) {
    this.i = e, this.x = t, this.y = i, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
}
nh.deviation = function(e, t, i, s) {
    var n = t && t.length,
        r = n ? t[0] * i : e.length,
        o = Math.abs(Ju(e, 0, r, i));
    if (n)
        for (var a = 0, l = t.length; a < l; a++) {
            var c = t[a] * i,
                h = a < l - 1 ? t[a + 1] * i : e.length;
            o -= Math.abs(Ju(e, c, h, i))
        }
    var u = 0;
    for (a = 0; a < s.length; a += 3) {
        var d = s[a] * i,
            f = s[a + 1] * i,
            p = s[a + 2] * i;
        u += Math.abs((e[d] - e[p]) * (e[f + 1] - e[d + 1]) - (e[d] - e[f]) * (e[p + 1] - e[d + 1]))
    }
    return o === 0 && u === 0 ? 0 : Math.abs((u - o) / o)
};

function Ju(e, t, i, s) {
    for (var n = 0, r = t, o = i - s; r < i; r += s) n += (e[o] - e[r]) * (e[r + 1] + e[o + 1]), o = r;
    return n
}
nh.flatten = function(e) {
    for (var t = e[0][0].length, i = {
            vertices: [],
            holes: [],
            dimensions: t
        }, s = 0, n = 0; n < e.length; n++) {
        for (var r = 0; r < e[n].length; r++)
            for (var o = 0; o < t; o++) i.vertices.push(e[n][r][o]);
        n > 0 && (s += e[n - 1].length, i.holes.push(s))
    }
    return i
};
var b_ = Of.exports,
    Qu = {
        exports: {}
    }; /*! https://mths.be/punycode v1.3.2 by @mathias */
(function(e, t) {
    (function(i) {
        var s = t && !t.nodeType && t,
            n = e && !e.nodeType && e,
            r = typeof Wh == "object" && Wh;
        (r.global === r || r.window === r || r.self === r) && (i = r);
        var o, a = 2147483647,
            l = 36,
            c = 1,
            h = 26,
            u = 38,
            d = 700,
            f = 72,
            p = 128,
            m = "-",
            g = /^xn--/,
            y = /[^\x20-\x7E]/,
            x = /[\x2E\u3002\uFF0E\uFF61]/g,
            v = {
                overflow: "Overflow: input needs wider integers to process",
                "not-basic": "Illegal input >= 0x80 (not a basic code point)",
                "invalid-input": "Invalid input"
            },
            _ = l - c,
            C = Math.floor,
            k = String.fromCharCode,
            S;

        function T(ct) {
            throw RangeError(v[ct])
        }

        function L(ct, gt) {
            for (var xt = ct.length, It = []; xt--;) It[xt] = gt(ct[xt]);
            return It
        }

        function D(ct, gt) {
            var xt = ct.split("@"),
                It = "";
            xt.length > 1 && (It = xt[0] + "@", ct = xt[1]), ct = ct.replace(x, ".");
            var St = ct.split("."),
                J = L(St, gt).join(".");
            return It + J
        }

        function O(ct) {
            for (var gt = [], xt = 0, It = ct.length, St, J; xt < It;) St = ct.charCodeAt(xt++), St >= 55296 && St <= 56319 && xt < It ? (J = ct.charCodeAt(xt++), (J & 64512) == 56320 ? gt.push(((St & 1023) << 10) + (J & 1023) + 65536) : (gt.push(St), xt--)) : gt.push(St);
            return gt
        }

        function K(ct) {
            return L(ct, function(gt) {
                var xt = "";
                return gt > 65535 && (gt -= 65536, xt += k(gt >>> 10 & 1023 | 55296), gt = 56320 | gt & 1023), xt += k(gt), xt
            }).join("")
        }

        function P(ct) {
            return ct - 48 < 10 ? ct - 22 : ct - 65 < 26 ? ct - 65 : ct - 97 < 26 ? ct - 97 : l
        }

        function N(ct, gt) {
            return ct + 22 + 75 * (ct < 26) - ((gt != 0) << 5)
        }

        function W(ct, gt, xt) {
            var It = 0;
            for (ct = xt ? C(ct / d) : ct >> 1, ct += C(ct / gt); ct > _ * h >> 1; It += l) ct = C(ct / _);
            return C(It + (_ + 1) * ct / (ct + u))
        }

        function V(ct) {
            var gt = [],
                xt = ct.length,
                It, St = 0,
                J = p,
                wt = f,
                Tt, Bt, kt, re, Xt, ce, E, M, F;
            for (Tt = ct.lastIndexOf(m), Tt < 0 && (Tt = 0), Bt = 0; Bt < Tt; ++Bt) ct.charCodeAt(Bt) >= 128 && T("not-basic"), gt.push(ct.charCodeAt(Bt));
            for (kt = Tt > 0 ? Tt + 1 : 0; kt < xt;) {
                for (re = St, Xt = 1, ce = l; kt >= xt && T("invalid-input"), E = P(ct.charCodeAt(kt++)), (E >= l || E > C((a - St) / Xt)) && T("overflow"), St += E * Xt, M = ce <= wt ? c : ce >= wt + h ? h : ce - wt, !(E < M); ce += l) F = l - M, Xt > C(a / F) && T("overflow"), Xt *= F;
                It = gt.length + 1, wt = W(St - re, It, re == 0), C(St / It) > a - J && T("overflow"), J += C(St / It), St %= It, gt.splice(St++, 0, J)
            }
            return K(gt)
        }

        function Q(ct) {
            var gt, xt, It, St, J, wt, Tt, Bt, kt, re, Xt, ce = [],
                E, M, F, $;
            for (ct = O(ct), E = ct.length, gt = p, xt = 0, J = f, wt = 0; wt < E; ++wt) Xt = ct[wt], Xt < 128 && ce.push(k(Xt));
            for (It = St = ce.length, St && ce.push(m); It < E;) {
                for (Tt = a, wt = 0; wt < E; ++wt) Xt = ct[wt], Xt >= gt && Xt < Tt && (Tt = Xt);
                for (M = It + 1, Tt - gt > C((a - xt) / M) && T("overflow"), xt += (Tt - gt) * M, gt = Tt, wt = 0; wt < E; ++wt)
                    if (Xt = ct[wt], Xt < gt && ++xt > a && T("overflow"), Xt == gt) {
                        for (Bt = xt, kt = l; re = kt <= J ? c : kt >= J + h ? h : kt - J, !(Bt < re); kt += l) $ = Bt - re, F = l - re, ce.push(k(N(re + $ % F, 0))), Bt = C($ / F);
                        ce.push(k(N(Bt, 0))), J = W(xt, M, It == St), xt = 0, ++It
                    }++ xt, ++gt
            }
            return ce.join("")
        }

        function pt(ct) {
            return D(ct, function(gt) {
                return g.test(gt) ? V(gt.slice(4).toLowerCase()) : gt
            })
        }

        function bt(ct) {
            return D(ct, function(gt) {
                return y.test(gt) ? "xn--" + Q(gt) : gt
            })
        }
        if (o = {
                version: "1.3.2",
                ucs2: {
                    decode: O,
                    encode: K
                },
                decode: V,
                encode: Q,
                toASCII: bt,
                toUnicode: pt
            }, s && n)
            if (e.exports == s) n.exports = o;
            else
                for (S in o) o.hasOwnProperty(S) && (s[S] = o[S]);
        else i.punycode = o
    })(Wh)
})(Qu, Qu.exports);
var jC = {
        isString: function(e) {
            return typeof e == "string"
        },
        isObject: function(e) {
            return typeof e == "object" && e !== null
        },
        isNull: function(e) {
            return e === null
        },
        isNullOrUndefined: function(e) {
            return e == null
        }
    },
    Fa = {};

function WC(e, t) {
    return Object.prototype.hasOwnProperty.call(e, t)
}
var XC = function(e, t, i, s) {
        t = t || "&", i = i || "=";
        var n = {};
        if (typeof e != "string" || e.length === 0) return n;
        var r = /\+/g;
        e = e.split(t);
        var o = 1e3;
        s && typeof s.maxKeys == "number" && (o = s.maxKeys);
        var a = e.length;
        o > 0 && a > o && (a = o);
        for (var l = 0; l < a; ++l) {
            var c = e[l].replace(r, "%20"),
                h = c.indexOf(i),
                u, d, f, p;
            h >= 0 ? (u = c.substr(0, h), d = c.substr(h + 1)) : (u = c, d = ""), f = decodeURIComponent(u), p = decodeURIComponent(d), WC(n, f) ? Array.isArray(n[f]) ? n[f].push(p) : n[f] = [n[f], p] : n[f] = p
        }
        return n
    },
    qo = function(e) {
        switch (typeof e) {
            case "string":
                return e;
            case "boolean":
                return e ? "true" : "false";
            case "number":
                return isFinite(e) ? e : "";
            default:
                return ""
        }
    },
    YC = function(e, t, i, s) {
        return t = t || "&", i = i || "=", e === null && (e = void 0), typeof e == "object" ? Object.keys(e).map(function(n) {
            var r = encodeURIComponent(qo(n)) + i;
            return Array.isArray(e[n]) ? e[n].map(function(o) {
                return r + encodeURIComponent(qo(o))
            }).join(t) : r + encodeURIComponent(qo(e[n]))
        }).join(t) : s ? encodeURIComponent(qo(s)) + i + encodeURIComponent(qo(e)) : ""
    };
Fa.decode = Fa.parse = XC;
Fa.encode = Fa.stringify = YC;
var KC = Qu.exports,
    Cs = jC,
    ZC = oh,
    qC = l3,
    JC = a3;

function ls() {
    this.protocol = null, this.slashes = null, this.auth = null, this.host = null, this.port = null, this.hostname = null, this.hash = null, this.search = null, this.query = null, this.pathname = null, this.path = null, this.href = null
}
var QC = /^([a-z0-9.+-]+:)/i,
    t3 = /:[0-9]*$/,
    e3 = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,
    i3 = ["<", ">", '"', "`", " ", "\r", `
`, "	"],
    s3 = ["{", "}", "|", "\\", "^", "`"].concat(i3),
    td = ["'"].concat(s3),
    Zm = ["%", "/", "?", ";", "#"].concat(td),
    qm = ["/", "?", "#"],
    n3 = 255,
    Jm = /^[+a-z0-9A-Z_-]{0,63}$/,
    r3 = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    o3 = {
        javascript: !0,
        "javascript:": !0
    },
    ed = {
        javascript: !0,
        "javascript:": !0
    },
    go = {
        http: !0,
        https: !0,
        ftp: !0,
        gopher: !0,
        file: !0,
        "http:": !0,
        "https:": !0,
        "ftp:": !0,
        "gopher:": !0,
        "file:": !0
    },
    id = Fa;

function oh(e, t, i) {
    if (e && Cs.isObject(e) && e instanceof ls) return e;
    var s = new ls;
    return s.parse(e, t, i), s
}
ls.prototype.parse = function(e, t, i) {
    if (!Cs.isString(e)) throw new TypeError("Parameter 'url' must be a string, not " + typeof e);
    var s = e.indexOf("?"),
        n = s !== -1 && s < e.indexOf("#") ? "?" : "#",
        r = e.split(n),
        o = /\\/g;
    r[0] = r[0].replace(o, "/"), e = r.join(n);
    var a = e;
    if (a = a.trim(), !i && e.split("#").length === 1) {
        var l = e3.exec(a);
        if (l) return this.path = a, this.href = a, this.pathname = l[1], l[2] ? (this.search = l[2], t ? this.query = id.parse(this.search.substr(1)) : this.query = this.search.substr(1)) : t && (this.search = "", this.query = {}), this
    }
    var c = QC.exec(a);
    if (c) {
        c = c[0];
        var h = c.toLowerCase();
        this.protocol = h, a = a.substr(c.length)
    }
    if (i || c || a.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var u = a.substr(0, 2) === "//";
        u && !(c && ed[c]) && (a = a.substr(2), this.slashes = !0)
    }
    if (!ed[c] && (u || c && !go[c])) {
        for (var d = -1, f = 0; f < qm.length; f++) {
            var p = a.indexOf(qm[f]);
            p !== -1 && (d === -1 || p < d) && (d = p)
        }
        var m, g;
        d === -1 ? g = a.lastIndexOf("@") : g = a.lastIndexOf("@", d), g !== -1 && (m = a.slice(0, g), a = a.slice(g + 1), this.auth = decodeURIComponent(m)), d = -1;
        for (var f = 0; f < Zm.length; f++) {
            var p = a.indexOf(Zm[f]);
            p !== -1 && (d === -1 || p < d) && (d = p)
        }
        d === -1 && (d = a.length), this.host = a.slice(0, d), a = a.slice(d), this.parseHost(), this.hostname = this.hostname || "";
        var y = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
        if (!y)
            for (var x = this.hostname.split(/\./), f = 0, v = x.length; f < v; f++) {
                var _ = x[f];
                if (!!_ && !_.match(Jm)) {
                    for (var C = "", k = 0, S = _.length; k < S; k++) _.charCodeAt(k) > 127 ? C += "x" : C += _[k];
                    if (!C.match(Jm)) {
                        var T = x.slice(0, f),
                            L = x.slice(f + 1),
                            D = _.match(r3);
                        D && (T.push(D[1]), L.unshift(D[2])), L.length && (a = "/" + L.join(".") + a), this.hostname = T.join(".");
                        break
                    }
                }
            }
        this.hostname.length > n3 ? this.hostname = "" : this.hostname = this.hostname.toLowerCase(), y || (this.hostname = KC.toASCII(this.hostname));
        var O = this.port ? ":" + this.port : "",
            K = this.hostname || "";
        this.host = K + O, this.href += this.host, y && (this.hostname = this.hostname.substr(1, this.hostname.length - 2), a[0] !== "/" && (a = "/" + a))
    }
    if (!o3[h])
        for (var f = 0, v = td.length; f < v; f++) {
            var P = td[f];
            if (a.indexOf(P) !== -1) {
                var N = encodeURIComponent(P);
                N === P && (N = escape(P)), a = a.split(P).join(N)
            }
        }
    var W = a.indexOf("#");
    W !== -1 && (this.hash = a.substr(W), a = a.slice(0, W));
    var V = a.indexOf("?");
    if (V !== -1 ? (this.search = a.substr(V), this.query = a.substr(V + 1), t && (this.query = id.parse(this.query)), a = a.slice(0, V)) : t && (this.search = "", this.query = {}), a && (this.pathname = a), go[h] && this.hostname && !this.pathname && (this.pathname = "/"), this.pathname || this.search) {
        var O = this.pathname || "",
            Q = this.search || "";
        this.path = O + Q
    }
    return this.href = this.format(), this
};

function a3(e) {
    return Cs.isString(e) && (e = oh(e)), e instanceof ls ? e.format() : ls.prototype.format.call(e)
}
ls.prototype.format = function() {
    var e = this.auth || "";
    e && (e = encodeURIComponent(e), e = e.replace(/%3A/i, ":"), e += "@");
    var t = this.protocol || "",
        i = this.pathname || "",
        s = this.hash || "",
        n = !1,
        r = "";
    this.host ? n = e + this.host : this.hostname && (n = e + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]"), this.port && (n += ":" + this.port)), this.query && Cs.isObject(this.query) && Object.keys(this.query).length && (r = id.stringify(this.query));
    var o = this.search || r && "?" + r || "";
    return t && t.substr(-1) !== ":" && (t += ":"), this.slashes || (!t || go[t]) && n !== !1 ? (n = "//" + (n || ""), i && i.charAt(0) !== "/" && (i = "/" + i)) : n || (n = ""), s && s.charAt(0) !== "#" && (s = "#" + s), o && o.charAt(0) !== "?" && (o = "?" + o), i = i.replace(/[?#]/g, function(a) {
        return encodeURIComponent(a)
    }), o = o.replace("#", "%23"), t + n + i + o + s
};

function l3(e, t) {
    return oh(e, !1, !0).resolve(t)
}
ls.prototype.resolve = function(e) {
    return this.resolveObject(oh(e, !1, !0)).format()
};
ls.prototype.resolveObject = function(e) {
    if (Cs.isString(e)) {
        var t = new ls;
        t.parse(e, !1, !0), e = t
    }
    for (var i = new ls, s = Object.keys(this), n = 0; n < s.length; n++) {
        var r = s[n];
        i[r] = this[r]
    }
    if (i.hash = e.hash, e.href === "") return i.href = i.format(), i;
    if (e.slashes && !e.protocol) {
        for (var o = Object.keys(e), a = 0; a < o.length; a++) {
            var l = o[a];
            l !== "protocol" && (i[l] = e[l])
        }
        return go[i.protocol] && i.hostname && !i.pathname && (i.path = i.pathname = "/"), i.href = i.format(), i
    }
    if (e.protocol && e.protocol !== i.protocol) {
        if (!go[e.protocol]) {
            for (var c = Object.keys(e), h = 0; h < c.length; h++) {
                var u = c[h];
                i[u] = e[u]
            }
            return i.href = i.format(), i
        }
        if (i.protocol = e.protocol, !e.host && !ed[e.protocol]) {
            for (var v = (e.pathname || "").split("/"); v.length && !(e.host = v.shift()););
            e.host || (e.host = ""), e.hostname || (e.hostname = ""), v[0] !== "" && v.unshift(""), v.length < 2 && v.unshift(""), i.pathname = v.join("/")
        } else i.pathname = e.pathname;
        if (i.search = e.search, i.query = e.query, i.host = e.host || "", i.auth = e.auth, i.hostname = e.hostname || e.host, i.port = e.port, i.pathname || i.search) {
            var d = i.pathname || "",
                f = i.search || "";
            i.path = d + f
        }
        return i.slashes = i.slashes || e.slashes, i.href = i.format(), i
    }
    var p = i.pathname && i.pathname.charAt(0) === "/",
        m = e.host || e.pathname && e.pathname.charAt(0) === "/",
        g = m || p || i.host && e.pathname,
        y = g,
        x = i.pathname && i.pathname.split("/") || [],
        v = e.pathname && e.pathname.split("/") || [],
        _ = i.protocol && !go[i.protocol];
    if (_ && (i.hostname = "", i.port = null, i.host && (x[0] === "" ? x[0] = i.host : x.unshift(i.host)), i.host = "", e.protocol && (e.hostname = null, e.port = null, e.host && (v[0] === "" ? v[0] = e.host : v.unshift(e.host)), e.host = null), g = g && (v[0] === "" || x[0] === "")), m) i.host = e.host || e.host === "" ? e.host : i.host, i.hostname = e.hostname || e.hostname === "" ? e.hostname : i.hostname, i.search = e.search, i.query = e.query, x = v;
    else if (v.length) x || (x = []), x.pop(), x = x.concat(v), i.search = e.search, i.query = e.query;
    else if (!Cs.isNullOrUndefined(e.search)) {
        if (_) {
            i.hostname = i.host = x.shift();
            var C = i.host && i.host.indexOf("@") > 0 ? i.host.split("@") : !1;
            C && (i.auth = C.shift(), i.host = i.hostname = C.shift())
        }
        return i.search = e.search, i.query = e.query, (!Cs.isNull(i.pathname) || !Cs.isNull(i.search)) && (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")), i.href = i.format(), i
    }
    if (!x.length) return i.pathname = null, i.search ? i.path = "/" + i.search : i.path = null, i.href = i.format(), i;
    for (var k = x.slice(-1)[0], S = (i.host || e.host || x.length > 1) && (k === "." || k === "..") || k === "", T = 0, L = x.length; L >= 0; L--) k = x[L], k === "." ? x.splice(L, 1) : k === ".." ? (x.splice(L, 1), T++) : T && (x.splice(L, 1), T--);
    if (!g && !y)
        for (; T--; T) x.unshift("..");
    g && x[0] !== "" && (!x[0] || x[0].charAt(0) !== "/") && x.unshift(""), S && x.join("/").substr(-1) !== "/" && x.push("");
    var D = x[0] === "" || x[0] && x[0].charAt(0) === "/";
    if (_) {
        i.hostname = i.host = D ? "" : x.length ? x.shift() : "";
        var C = i.host && i.host.indexOf("@") > 0 ? i.host.split("@") : !1;
        C && (i.auth = C.shift(), i.host = i.hostname = C.shift())
    }
    return g = g || i.host && x.length, g && !D && x.unshift(""), x.length ? i.pathname = x.join("/") : (i.pathname = null, i.path = null), (!Cs.isNull(i.pathname) || !Cs.isNull(i.search)) && (i.path = (i.pathname ? i.pathname : "") + (i.search ? i.search : "")), i.auth = e.auth || i.auth, i.slashes = i.slashes || e.slashes, i.href = i.format(), i
};
ls.prototype.parseHost = function() {
    var e = this.host,
        t = t3.exec(e);
    t && (t = t[0], t !== ":" && (this.port = t.substr(1)), e = e.substr(0, e.length - t.length)), e && (this.hostname = e)
};
const x_ = {
    parse: ZC,
    format: JC,
    resolve: qC
};

function Ki(e) {
    if (typeof e != "string") throw new TypeError(`Path must be a string. Received ${JSON.stringify(e)}`)
}

function Jo(e) {
    return e.split("?")[0].split("#")[0]
}

function c3(e) {
    return e.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")
}

function h3(e, t, i) {
    return e.replace(new RegExp(c3(t), "g"), i)
}

function u3(e, t) {
    let i = "",
        s = 0,
        n = -1,
        r = 0,
        o = -1;
    for (let a = 0; a <= e.length; ++a) {
        if (a < e.length) o = e.charCodeAt(a);
        else {
            if (o === 47) break;
            o = 47
        }
        if (o === 47) {
            if (!(n === a - 1 || r === 1))
                if (n !== a - 1 && r === 2) {
                    if (i.length < 2 || s !== 2 || i.charCodeAt(i.length - 1) !== 46 || i.charCodeAt(i.length - 2) !== 46) {
                        if (i.length > 2) {
                            const l = i.lastIndexOf("/");
                            if (l !== i.length - 1) {
                                l === -1 ? (i = "", s = 0) : (i = i.slice(0, l), s = i.length - 1 - i.lastIndexOf("/")), n = a, r = 0;
                                continue
                            }
                        } else if (i.length === 2 || i.length === 1) {
                            i = "", s = 0, n = a, r = 0;
                            continue
                        }
                    }
                    t && (i.length > 0 ? i += "/.." : i = "..", s = 2)
                } else i.length > 0 ? i += `/${e.slice(n+1,a)}` : i = e.slice(n + 1, a), s = a - n - 1;
            n = a, r = 0
        } else o === 46 && r !== -1 ? ++r : r = -1
    }
    return i
}
const Xe = {
        toPosix(e) {
            return h3(e, "\\", "/")
        },
        isUrl(e) {
            return /^https?:/.test(this.toPosix(e))
        },
        isDataUrl(e) {
            return /^data:([a-z]+\/[a-z0-9-+.]+(;[a-z0-9-.!#$%*+.{}|~`]+=[a-z0-9-.!#$%*+.{}()_|~`]+)*)?(;base64)?,([a-z0-9!$&',()*+;=\-._~:@\/?%\s<>]*?)$/i.test(e)
        },
        hasProtocol(e) {
            return /^[^/:]+:\//.test(this.toPosix(e))
        },
        getProtocol(e) {
            Ki(e), e = this.toPosix(e);
            let t = "";
            const i = /^file:\/\/\//.exec(e),
                s = /^[^/:]+:\/\//.exec(e),
                n = /^[^/:]+:\//.exec(e);
            if (i || s || n) {
                const r = i?.[0] || s?.[0] || n?.[0];
                t = r, e = e.slice(r.length)
            }
            return t
        },
        toAbsolute(e, t, i) {
            if (this.isDataUrl(e)) return e;
            const s = Jo(this.toPosix(t ?? ut.ADAPTER.getBaseUrl())),
                n = Jo(this.toPosix(i ?? this.rootname(s)));
            return Ki(e), e = this.toPosix(e), e.startsWith("/") ? Xe.join(n, e.slice(1)) : this.isAbsolute(e) ? e : this.join(s, e)
        },
        normalize(e) {
            if (e = this.toPosix(e), Ki(e), e.length === 0) return ".";
            let t = "";
            const i = e.startsWith("/");
            this.hasProtocol(e) && (t = this.rootname(e), e = e.slice(t.length));
            const s = e.endsWith("/");
            return e = u3(e, !1), e.length > 0 && s && (e += "/"), i ? `/${e}` : t + e
        },
        isAbsolute(e) {
            return Ki(e), e = this.toPosix(e), this.hasProtocol(e) ? !0 : e.startsWith("/")
        },
        join(...e) {
            if (e.length === 0) return ".";
            let t;
            for (let i = 0; i < e.length; ++i) {
                const s = e[i];
                if (Ki(s), s.length > 0)
                    if (t === void 0) t = s;
                    else {
                        const n = e[i - 1] ?? "";
                        this.extname(n) ? t += `/../${s}` : t += `/${s}`
                    }
            }
            return t === void 0 ? "." : this.normalize(t)
        },
        dirname(e) {
            if (Ki(e), e.length === 0) return ".";
            e = this.toPosix(e);
            let t = e.charCodeAt(0);
            const i = t === 47;
            let s = -1,
                n = !0;
            const r = this.getProtocol(e),
                o = e;
            e = e.slice(r.length);
            for (let a = e.length - 1; a >= 1; --a)
                if (t = e.charCodeAt(a), t === 47) {
                    if (!n) {
                        s = a;
                        break
                    }
                } else n = !1;
            return s === -1 ? i ? "/" : this.isUrl(o) ? r + e : r : i && s === 1 ? "//" : r + e.slice(0, s)
        },
        rootname(e) {
            Ki(e), e = this.toPosix(e);
            let t = "";
            if (e.startsWith("/") ? t = "/" : t = this.getProtocol(e), this.isUrl(e)) {
                const i = e.indexOf("/", t.length);
                i !== -1 ? t = e.slice(0, i) : t = e, t.endsWith("/") || (t += "/")
            }
            return t
        },
        basename(e, t) {
            Ki(e), t && Ki(t), e = Jo(this.toPosix(e));
            let i = 0,
                s = -1,
                n = !0,
                r;
            if (t !== void 0 && t.length > 0 && t.length <= e.length) {
                if (t.length === e.length && t === e) return "";
                let o = t.length - 1,
                    a = -1;
                for (r = e.length - 1; r >= 0; --r) {
                    const l = e.charCodeAt(r);
                    if (l === 47) {
                        if (!n) {
                            i = r + 1;
                            break
                        }
                    } else a === -1 && (n = !1, a = r + 1), o >= 0 && (l === t.charCodeAt(o) ? --o === -1 && (s = r) : (o = -1, s = a))
                }
                return i === s ? s = a : s === -1 && (s = e.length), e.slice(i, s)
            }
            for (r = e.length - 1; r >= 0; --r)
                if (e.charCodeAt(r) === 47) {
                    if (!n) {
                        i = r + 1;
                        break
                    }
                } else s === -1 && (n = !1, s = r + 1);
            return s === -1 ? "" : e.slice(i, s)
        },
        extname(e) {
            Ki(e), e = Jo(this.toPosix(e));
            let t = -1,
                i = 0,
                s = -1,
                n = !0,
                r = 0;
            for (let o = e.length - 1; o >= 0; --o) {
                const a = e.charCodeAt(o);
                if (a === 47) {
                    if (!n) {
                        i = o + 1;
                        break
                    }
                    continue
                }
                s === -1 && (n = !1, s = o + 1), a === 46 ? t === -1 ? t = o : r !== 1 && (r = 1) : t !== -1 && (r = -1)
            }
            return t === -1 || s === -1 || r === 0 || r === 1 && t === s - 1 && t === i + 1 ? "" : e.slice(t, s)
        },
        parse(e) {
            Ki(e);
            const t = {
                root: "",
                dir: "",
                base: "",
                ext: "",
                name: ""
            };
            if (e.length === 0) return t;
            e = Jo(this.toPosix(e));
            let i = e.charCodeAt(0);
            const s = this.isAbsolute(e);
            let n;
            t.root = this.rootname(e), s || this.hasProtocol(e) ? n = 1 : n = 0;
            let r = -1,
                o = 0,
                a = -1,
                l = !0,
                c = e.length - 1,
                h = 0;
            for (; c >= n; --c) {
                if (i = e.charCodeAt(c), i === 47) {
                    if (!l) {
                        o = c + 1;
                        break
                    }
                    continue
                }
                a === -1 && (l = !1, a = c + 1), i === 46 ? r === -1 ? r = c : h !== 1 && (h = 1) : r !== -1 && (h = -1)
            }
            return r === -1 || a === -1 || h === 0 || h === 1 && r === a - 1 && r === o + 1 ? a !== -1 && (o === 0 && s ? t.base = t.name = e.slice(1, a) : t.base = t.name = e.slice(o, a)) : (o === 0 && s ? (t.name = e.slice(1, r), t.base = e.slice(1, a)) : (t.name = e.slice(o, r), t.base = e.slice(o, a)), t.ext = e.slice(r, a)), t.dir = this.dirname(e), t
        },
        sep: "/",
        delimiter: ":"
    },
    Qm = {};

function Qt(e, t, i = 3) {
    if (Qm[t]) return;
    let s = new Error().stack;
    typeof s > "u" ? console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${e}`) : (s = s.split(`
`).splice(i).join(`
`), console.groupCollapsed ? (console.groupCollapsed("%cPixiJS Deprecation Warning: %c%s", "color:#614108;background:#fffbe6", "font-weight:normal;color:#614108;background:#fffbe6", `${t}
Deprecated since v${e}`), console.warn(s), console.groupEnd()) : (console.warn("PixiJS Deprecation Warning: ", `${t}
Deprecated since v${e}`), console.warn(s))), Qm[t] = !0
}

function d3() {
    Qt("7.0.0", "skipHello is deprecated, please use settings.RENDER_OPTIONS.hello")
}

function f3() {
    Qt("7.0.0", `sayHello is deprecated, please use Renderer's "hello" option`)
}
let Xh;

function w_() {
    return typeof Xh > "u" && (Xh = function() {
        const t = {
            stencil: !0,
            failIfMajorPerformanceCaveat: ut.FAIL_IF_MAJOR_PERFORMANCE_CAVEAT
        };
        try {
            if (!ut.ADAPTER.getWebGLRenderingContext()) return !1;
            const i = ut.ADAPTER.createCanvas();
            let s = i.getContext("webgl", t) || i.getContext("experimental-webgl", t);
            const n = !!s?.getContextAttributes()?.stencil;
            if (s) {
                const r = s.getExtension("WEBGL_lose_context");
                r && r.loseContext()
            }
            return s = null, n
        } catch {
            return !1
        }
    }()), Xh
}
var p3 = "#f0f8ff",
    m3 = "#faebd7",
    g3 = "#00ffff",
    v3 = "#7fffd4",
    _3 = "#f0ffff",
    y3 = "#f5f5dc",
    b3 = "#ffe4c4",
    x3 = "#000000",
    w3 = "#ffebcd",
    T3 = "#0000ff",
    E3 = "#8a2be2",
    S3 = "#a52a2a",
    C3 = "#deb887",
    A3 = "#5f9ea0",
    I3 = "#7fff00",
    M3 = "#d2691e",
    R3 = "#ff7f50",
    k3 = "#6495ed",
    P3 = "#fff8dc",
    L3 = "#dc143c",
    O3 = "#00ffff",
    D3 = "#00008b",
    N3 = "#008b8b",
    F3 = "#b8860b",
    B3 = "#a9a9a9",
    U3 = "#006400",
    G3 = "#a9a9a9",
    H3 = "#bdb76b",
    V3 = "#8b008b",
    z3 = "#556b2f",
    $3 = "#ff8c00",
    j3 = "#9932cc",
    W3 = "#8b0000",
    X3 = "#e9967a",
    Y3 = "#8fbc8f",
    K3 = "#483d8b",
    Z3 = "#2f4f4f",
    q3 = "#2f4f4f",
    J3 = "#00ced1",
    Q3 = "#9400d3",
    tA = "#ff1493",
    eA = "#00bfff",
    iA = "#696969",
    sA = "#696969",
    nA = "#1e90ff",
    rA = "#b22222",
    oA = "#fffaf0",
    aA = "#228b22",
    lA = "#ff00ff",
    cA = "#dcdcdc",
    hA = "#f8f8ff",
    uA = "#daa520",
    dA = "#ffd700",
    fA = "#808080",
    pA = "#008000",
    mA = "#adff2f",
    gA = "#808080",
    vA = "#f0fff0",
    _A = "#ff69b4",
    yA = "#cd5c5c",
    bA = "#4b0082",
    xA = "#fffff0",
    wA = "#f0e68c",
    TA = "#fff0f5",
    EA = "#e6e6fa",
    SA = "#7cfc00",
    CA = "#fffacd",
    AA = "#add8e6",
    IA = "#f08080",
    MA = "#e0ffff",
    RA = "#fafad2",
    kA = "#d3d3d3",
    PA = "#90ee90",
    LA = "#d3d3d3",
    OA = "#ffb6c1",
    DA = "#ffa07a",
    NA = "#20b2aa",
    FA = "#87cefa",
    BA = "#778899",
    UA = "#778899",
    GA = "#b0c4de",
    HA = "#ffffe0",
    VA = "#00ff00",
    zA = "#32cd32",
    $A = "#faf0e6",
    jA = "#ff00ff",
    WA = "#800000",
    XA = "#66cdaa",
    YA = "#0000cd",
    KA = "#ba55d3",
    ZA = "#9370db",
    qA = "#3cb371",
    JA = "#7b68ee",
    QA = "#00fa9a",
    t5 = "#48d1cc",
    e5 = "#c71585",
    i5 = "#191970",
    s5 = "#f5fffa",
    n5 = "#ffe4e1",
    r5 = "#ffe4b5",
    o5 = "#ffdead",
    a5 = "#000080",
    l5 = "#fdf5e6",
    c5 = "#808000",
    h5 = "#6b8e23",
    u5 = "#ffa500",
    d5 = "#ff4500",
    f5 = "#da70d6",
    p5 = "#eee8aa",
    m5 = "#98fb98",
    g5 = "#afeeee",
    v5 = "#db7093",
    _5 = "#ffefd5",
    y5 = "#ffdab9",
    b5 = "#cd853f",
    x5 = "#ffc0cb",
    w5 = "#dda0dd",
    T5 = "#b0e0e6",
    E5 = "#800080",
    S5 = "#663399",
    C5 = "#ff0000",
    A5 = "#bc8f8f",
    I5 = "#4169e1",
    M5 = "#8b4513",
    R5 = "#fa8072",
    k5 = "#f4a460",
    P5 = "#2e8b57",
    L5 = "#fff5ee",
    O5 = "#a0522d",
    D5 = "#c0c0c0",
    N5 = "#87ceeb",
    F5 = "#6a5acd",
    B5 = "#708090",
    U5 = "#708090",
    G5 = "#fffafa",
    H5 = "#00ff7f",
    V5 = "#4682b4",
    z5 = "#d2b48c",
    $5 = "#008080",
    j5 = "#d8bfd8",
    W5 = "#ff6347",
    X5 = "#40e0d0",
    Y5 = "#ee82ee",
    K5 = "#f5deb3",
    Z5 = "#ffffff",
    q5 = "#f5f5f5",
    J5 = "#ffff00",
    Q5 = "#9acd32",
    t4 = {
        aliceblue: p3,
        antiquewhite: m3,
        aqua: g3,
        aquamarine: v3,
        azure: _3,
        beige: y3,
        bisque: b3,
        black: x3,
        blanchedalmond: w3,
        blue: T3,
        blueviolet: E3,
        brown: S3,
        burlywood: C3,
        cadetblue: A3,
        chartreuse: I3,
        chocolate: M3,
        coral: R3,
        cornflowerblue: k3,
        cornsilk: P3,
        crimson: L3,
        cyan: O3,
        darkblue: D3,
        darkcyan: N3,
        darkgoldenrod: F3,
        darkgray: B3,
        darkgreen: U3,
        darkgrey: G3,
        darkkhaki: H3,
        darkmagenta: V3,
        darkolivegreen: z3,
        darkorange: $3,
        darkorchid: j3,
        darkred: W3,
        darksalmon: X3,
        darkseagreen: Y3,
        darkslateblue: K3,
        darkslategray: Z3,
        darkslategrey: q3,
        darkturquoise: J3,
        darkviolet: Q3,
        deeppink: tA,
        deepskyblue: eA,
        dimgray: iA,
        dimgrey: sA,
        dodgerblue: nA,
        firebrick: rA,
        floralwhite: oA,
        forestgreen: aA,
        fuchsia: lA,
        gainsboro: cA,
        ghostwhite: hA,
        goldenrod: uA,
        gold: dA,
        gray: fA,
        green: pA,
        greenyellow: mA,
        grey: gA,
        honeydew: vA,
        hotpink: _A,
        indianred: yA,
        indigo: bA,
        ivory: xA,
        khaki: wA,
        lavenderblush: TA,
        lavender: EA,
        lawngreen: SA,
        lemonchiffon: CA,
        lightblue: AA,
        lightcoral: IA,
        lightcyan: MA,
        lightgoldenrodyellow: RA,
        lightgray: kA,
        lightgreen: PA,
        lightgrey: LA,
        lightpink: OA,
        lightsalmon: DA,
        lightseagreen: NA,
        lightskyblue: FA,
        lightslategray: BA,
        lightslategrey: UA,
        lightsteelblue: GA,
        lightyellow: HA,
        lime: VA,
        limegreen: zA,
        linen: $A,
        magenta: jA,
        maroon: WA,
        mediumaquamarine: XA,
        mediumblue: YA,
        mediumorchid: KA,
        mediumpurple: ZA,
        mediumseagreen: qA,
        mediumslateblue: JA,
        mediumspringgreen: QA,
        mediumturquoise: t5,
        mediumvioletred: e5,
        midnightblue: i5,
        mintcream: s5,
        mistyrose: n5,
        moccasin: r5,
        navajowhite: o5,
        navy: a5,
        oldlace: l5,
        olive: c5,
        olivedrab: h5,
        orange: u5,
        orangered: d5,
        orchid: f5,
        palegoldenrod: p5,
        palegreen: m5,
        paleturquoise: g5,
        palevioletred: v5,
        papayawhip: _5,
        peachpuff: y5,
        peru: b5,
        pink: x5,
        plum: w5,
        powderblue: T5,
        purple: E5,
        rebeccapurple: S5,
        red: C5,
        rosybrown: A5,
        royalblue: I5,
        saddlebrown: M5,
        salmon: R5,
        sandybrown: k5,
        seagreen: P5,
        seashell: L5,
        sienna: O5,
        silver: D5,
        skyblue: N5,
        slateblue: F5,
        slategray: B5,
        slategrey: U5,
        snow: G5,
        springgreen: H5,
        steelblue: V5,
        tan: z5,
        teal: $5,
        thistle: j5,
        tomato: W5,
        turquoise: X5,
        violet: Y5,
        wheat: K5,
        white: Z5,
        whitesmoke: q5,
        yellow: J5,
        yellowgreen: Q5
    };

function tn(e, t = []) {
    return t[0] = (e >> 16 & 255) / 255, t[1] = (e >> 8 & 255) / 255, t[2] = (e & 255) / 255, t
}

function ah(e) {
    let t = e.toString(16);
    return t = "000000".substring(0, 6 - t.length) + t, `#${t}`
}

function lh(e) {
    if (typeof e == "string" && (e = t4[e.toLowerCase()] || e, e[0] === "#" && (e = e.slice(1)), e.length === 3)) {
        const [t, i, s] = e;
        e = t + t + i + i + s + s
    }
    return parseInt(e, 16)
}

function Df(e) {
    return (e[0] * 255 << 16) + (e[1] * 255 << 8) + (e[2] * 255 | 0)
}

function e4() {
    const e = [],
        t = [];
    for (let s = 0; s < 32; s++) e[s] = s, t[s] = s;
    e[j.NORMAL_NPM] = j.NORMAL, e[j.ADD_NPM] = j.ADD, e[j.SCREEN_NPM] = j.SCREEN, t[j.NORMAL] = j.NORMAL_NPM, t[j.ADD] = j.ADD_NPM, t[j.SCREEN] = j.SCREEN_NPM;
    const i = [];
    return i.push(t), i.push(e), i
}
const Nf = e4();

function Ff(e, t) {
    return Nf[t ? 1 : 0][e]
}

function T_(e, t, i, s) {
    return i = i || new Float32Array(4), s || s === void 0 ? (i[0] = e[0] * t, i[1] = e[1] * t, i[2] = e[2] * t) : (i[0] = e[0], i[1] = e[1], i[2] = e[2]), i[3] = t, i
}

function ch(e, t) {
    if (t === 1) return (t * 255 << 24) + e;
    if (t === 0) return 0;
    let i = e >> 16 & 255,
        s = e >> 8 & 255,
        n = e & 255;
    return i = i * t + .5 | 0, s = s * t + .5 | 0, n = n * t + .5 | 0, (t * 255 << 24) + (i << 16) + (s << 8) + n
}

function Bf(e, t, i, s) {
    return i = i || new Float32Array(4), i[0] = (e >> 16 & 255) / 255, i[1] = (e >> 8 & 255) / 255, i[2] = (e & 255) / 255, (s || s === void 0) && (i[0] *= t, i[1] *= t, i[2] *= t), i[3] = t, i
}
const E_ = /^\s*data:(?:([\w-]+)\/([\w+.-]+))?(?:;charset=([\w-]+))?(?:;(base64))?,(.*)/i;

function S_(e, t = null) {
    const i = e * 6;
    if (t = t || new Uint16Array(i), t.length !== i) throw new Error(`Out buffer length is incorrect, got ${t.length} and expected ${i}`);
    for (let s = 0, n = 0; s < i; s += 6, n += 4) t[s + 0] = n + 0, t[s + 1] = n + 1, t[s + 2] = n + 2, t[s + 3] = n + 0, t[s + 4] = n + 2, t[s + 5] = n + 3;
    return t
}

function hh(e) {
    if (e.BYTES_PER_ELEMENT === 4) return e instanceof Float32Array ? "Float32Array" : e instanceof Uint32Array ? "Uint32Array" : "Int32Array";
    if (e.BYTES_PER_ELEMENT === 2) {
        if (e instanceof Uint16Array) return "Uint16Array"
    } else if (e.BYTES_PER_ELEMENT === 1 && e instanceof Uint8Array) return "Uint8Array";
    return null
}
const i4 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
};

function s4(e, t) {
    let i = 0,
        s = 0;
    const n = {};
    for (let l = 0; l < e.length; l++) s += t[l], i += e[l].length;
    const r = new ArrayBuffer(i * 4);
    let o = null,
        a = 0;
    for (let l = 0; l < e.length; l++) {
        const c = t[l],
            h = e[l],
            u = hh(h);
        n[u] || (n[u] = new i4[u](r)), o = n[u];
        for (let d = 0; d < h.length; d++) {
            const f = (d / c | 0) * s + a,
                p = d % c;
            o[f + p] = h[d]
        }
        a += c
    }
    return new Float32Array(r)
}

function Ba(e) {
    return e += e === 0 ? 1 : 0, --e, e |= e >>> 1, e |= e >>> 2, e |= e >>> 4, e |= e >>> 8, e |= e >>> 16, e + 1
}

function sd(e) {
    return !(e & e - 1) && !!e
}

function nd(e) {
    let t = (e > 65535 ? 1 : 0) << 4;
    e >>>= t;
    let i = (e > 255 ? 1 : 0) << 3;
    return e >>>= i, t |= i, i = (e > 15 ? 1 : 0) << 2, e >>>= i, t |= i, i = (e > 3 ? 1 : 0) << 1, e >>>= i, t |= i, t | e >> 1
}

function wr(e, t, i) {
    const s = e.length;
    let n;
    if (t >= s || i === 0) return;
    i = t + i > s ? s - t : i;
    const r = s - i;
    for (n = t; n < r; ++n) e[n] = e[n + i];
    e.length = r
}

function rr(e) {
    return e === 0 ? 0 : e < 0 ? -1 : 1
}
let n4 = 0;

function Ln() {
    return ++n4
}
const C_ = class {
    constructor(e, t, i, s) {
        this.left = e, this.top = t, this.right = i, this.bottom = s
    }
    get width() {
        return this.right - this.left
    }
    get height() {
        return this.bottom - this.top
    }
    isEmpty() {
        return this.left === this.right || this.top === this.bottom
    }
};
let xc = C_;
xc.EMPTY = new C_(0, 0, 0, 0);
const rd = {},
    ri = Object.create(null),
    mi = Object.create(null);

function r4() {
    let e;
    for (e in ri) ri[e].destroy();
    for (e in mi) mi[e].destroy()
}

function o4() {
    let e;
    for (e in ri) delete ri[e];
    for (e in mi) delete mi[e]
}
class Po {
    constructor(t, i, s) {
        this._canvas = ut.ADAPTER.createCanvas(), this._context = this._canvas.getContext("2d"), this.resolution = s || ut.RESOLUTION, this.resize(t, i)
    }
    clear() {
        this._checkDestroyed(), this._context.setTransform(1, 0, 0, 1, 0, 0), this._context.clearRect(0, 0, this._canvas.width, this._canvas.height)
    }
    resize(t, i) {
        this._checkDestroyed(), this._canvas.width = Math.round(t * this.resolution), this._canvas.height = Math.round(i * this.resolution)
    }
    destroy() {
        this._context = null, this._canvas = null
    }
    get width() {
        return this._checkDestroyed(), this._canvas.width
    }
    set width(t) {
        this._checkDestroyed(), this._canvas.width = Math.round(t)
    }
    get height() {
        return this._checkDestroyed(), this._canvas.height
    }
    set height(t) {
        this._checkDestroyed(), this._canvas.height = Math.round(t)
    }
    get canvas() {
        return this._checkDestroyed(), this._canvas
    }
    get context() {
        return this._checkDestroyed(), this._context
    }
    _checkDestroyed() {
        if (this._canvas === null) throw new TypeError("The CanvasRenderTarget has already been destroyed")
    }
}

function tg(e, t, i) {
    for (let s = 0, n = 4 * i * t; s < t; ++s, n += 4)
        if (e[n + 3] !== 0) return !1;
    return !0
}

function eg(e, t, i, s, n) {
    const r = 4 * t;
    for (let o = s, a = s * r + 4 * i; o <= n; ++o, a += r)
        if (e[a + 3] !== 0) return !1;
    return !0
}

function A_(e) {
    const {
        width: t,
        height: i
    } = e, s = e.getContext("2d", {
        willReadFrequently: !0
    });
    if (s === null) throw new TypeError("Failed to get canvas 2D context");
    const r = s.getImageData(0, 0, t, i).data;
    let o = 0,
        a = 0,
        l = t - 1,
        c = i - 1;
    for (; a < i && tg(r, t, a);) ++a;
    if (a === i) return xc.EMPTY;
    for (; tg(r, t, c);) --c;
    for (; eg(r, t, o, a, c);) ++o;
    for (; eg(r, t, l, a, c);) --l;
    return ++l, ++c, new xc(o, a, l, c)
}

function I_(e) {
    const t = A_(e),
        {
            width: i,
            height: s
        } = t;
    let n = null;
    if (!t.isEmpty()) {
        const r = e.getContext("2d");
        if (r === null) throw new TypeError("Failed to get canvas 2D context");
        n = r.getImageData(t.left, t.top, i, s)
    }
    return {
        width: i,
        height: s,
        data: n
    }
}

function a4(e) {
    const t = E_.exec(e);
    if (t) return {
        mediaType: t[1] ? t[1].toLowerCase() : void 0,
        subType: t[2] ? t[2].toLowerCase() : void 0,
        charset: t[3] ? t[3].toLowerCase() : void 0,
        encoding: t[4] ? t[4].toLowerCase() : void 0,
        data: t[5]
    }
}
let bl;

function M_(e, t = globalThis.location) {
    if (e.startsWith("data:")) return "";
    t = t || globalThis.location, bl || (bl = document.createElement("a")), bl.href = e;
    const i = x_.parse(bl.href),
        s = !i.port && t.port === "" || i.port === t.port;
    return i.hostname !== t.hostname || !s || i.protocol !== t.protocol ? "anonymous" : ""
}

function en(e, t = 1) {
    const i = ut.RETINA_PREFIX?.exec(e);
    return i ? parseFloat(i[1]) : t
}
var l4 = Object.freeze(Object.defineProperty({
        __proto__: null,
        isMobile: Is,
        EventEmitter: $o,
        earcut: b_,
        url: x_,
        path: Xe,
        sayHello: f3,
        skipHello: d3,
        isWebGLSupported: w_,
        hex2rgb: tn,
        hex2string: ah,
        rgb2hex: Df,
        string2hex: lh,
        correctBlendMode: Ff,
        premultiplyBlendMode: Nf,
        premultiplyRgba: T_,
        premultiplyTint: ch,
        premultiplyTintToRgba: Bf,
        DATA_URI: E_,
        createIndicesForQuads: S_,
        getBufferType: hh,
        interleaveTypedArrays: s4,
        isPow2: sd,
        log2: nd,
        nextPow2: Ba,
        removeItems: wr,
        sign: rr,
        uid: Ln,
        deprecation: Qt,
        BoundingBox: xc,
        BaseTextureCache: mi,
        ProgramCache: rd,
        TextureCache: ri,
        clearTextureCache: o4,
        destroyTextureCache: r4,
        CanvasRenderTarget: Po,
        getCanvasBoundingBox: A_,
        trimCanvas: I_,
        decomposeDataUri: a4,
        determineCrossOrigin: M_,
        getResolutionOfUrl: en
    }, Symbol.toStringTag, {
        value: "Module"
    })),
    lt = (e => (e.Renderer = "renderer", e.Application = "application", e.RendererSystem = "renderer-webgl-system", e.RendererPlugin = "renderer-webgl-plugin", e.CanvasRendererSystem = "renderer-canvas-system", e.CanvasRendererPlugin = "renderer-canvas-plugin", e.Asset = "asset", e.LoadParser = "load-parser", e.ResolveParser = "resolve-parser", e.CacheParser = "cache-parser", e.DetectionParser = "detection-parser", e))(lt || {});
const od = e => {
        if (typeof e == "function" || typeof e == "object" && e.extension) {
            if (!e.extension) throw new Error("Extension class must have an extension object");
            e = {
                ...typeof e.extension != "object" ? {
                    type: e.extension
                } : e.extension,
                ref: e
            }
        }
        if (typeof e == "object") e = {
            ...e
        };
        else throw new Error("Invalid extension type");
        return typeof e.type == "string" && (e.type = [e.type]), e
    },
    ig = (e, t) => od(e).priority ?? t,
    vt = {
        _addHandlers: {},
        _removeHandlers: {},
        _queue: {},
        remove(...e) {
            return e.map(od).forEach(t => {
                t.type.forEach(i => this._removeHandlers[i]?.(t))
            }), this
        },
        add(...e) {
            return e.map(od).forEach(t => {
                t.type.forEach(i => {
                    const s = this._addHandlers,
                        n = this._queue;
                    s[i] ? s[i](t) : (n[i] = n[i] || [], n[i].push(t))
                })
            }), this
        },
        handle(e, t, i) {
            const s = this._addHandlers,
                n = this._removeHandlers;
            if (s[e] || n[e]) throw new Error(`Extension type ${e} already has a handler`);
            s[e] = t, n[e] = i;
            const r = this._queue;
            return r[e] && (r[e].forEach(o => t(o)), delete r[e]), this
        },
        handleByMap(e, t) {
            return this.handle(e, i => {
                t[i.name] = i.ref
            }, i => {
                delete t[i.name]
            })
        },
        handleByList(e, t, i = -1) {
            return this.handle(e, s => {
                t.includes(s.ref) || (t.push(s.ref), t.sort((n, r) => ig(r, i) - ig(n, i)))
            }, s => {
                const n = t.indexOf(s.ref);
                n !== -1 && t.splice(n, 1)
            })
        }
    };
class ad {
    constructor(t) {
        typeof t == "number" ? this.rawBinaryData = new ArrayBuffer(t) : t instanceof Uint8Array ? this.rawBinaryData = t.buffer : this.rawBinaryData = t, this.uint32View = new Uint32Array(this.rawBinaryData), this.float32View = new Float32Array(this.rawBinaryData)
    }
    get int8View() {
        return this._int8View || (this._int8View = new Int8Array(this.rawBinaryData)), this._int8View
    }
    get uint8View() {
        return this._uint8View || (this._uint8View = new Uint8Array(this.rawBinaryData)), this._uint8View
    }
    get int16View() {
        return this._int16View || (this._int16View = new Int16Array(this.rawBinaryData)), this._int16View
    }
    get uint16View() {
        return this._uint16View || (this._uint16View = new Uint16Array(this.rawBinaryData)), this._uint16View
    }
    get int32View() {
        return this._int32View || (this._int32View = new Int32Array(this.rawBinaryData)), this._int32View
    }
    view(t) {
        return this[`${t}View`]
    }
    destroy() {
        this.rawBinaryData = null, this._int8View = null, this._uint8View = null, this._int16View = null, this._uint16View = null, this._int32View = null, this.uint32View = null, this.float32View = null
    }
    static sizeOf(t) {
        switch (t) {
            case "int8":
            case "uint8":
                return 1;
            case "int16":
            case "uint16":
                return 2;
            case "int32":
            case "uint32":
            case "float32":
                return 4;
            default:
                throw new Error(`${t} isn't a valid view type`)
        }
    }
}
const c4 = ["precision mediump float;", "void main(void){", "float test = 0.1;", "%forloop%", "gl_FragColor = vec4(0.0);", "}"].join(`
`);

function h4(e) {
    let t = "";
    for (let i = 0; i < e; ++i) i > 0 && (t += `
else `), i < e - 1 && (t += `if(test == ${i}.0){}`);
    return t
}

function u4(e, t) {
    if (e === 0) throw new Error("Invalid value of `0` passed to `checkMaxIfStatementsInShader`");
    const i = t.createShader(t.FRAGMENT_SHADER);
    for (;;) {
        const s = c4.replace(/%forloop%/gi, h4(e));
        if (t.shaderSource(i, s), t.compileShader(i), !t.getShaderParameter(i, t.COMPILE_STATUS)) e = e / 2 | 0;
        else break
    }
    return e
}
const Yh = 0,
    Kh = 1,
    Zh = 2,
    qh = 3,
    Jh = 4,
    Qh = 5;
class rn {
    constructor() {
        this.data = 0, this.blendMode = j.NORMAL, this.polygonOffset = 0, this.blend = !0, this.depthMask = !0
    }
    get blend() {
        return !!(this.data & 1 << Yh)
    }
    set blend(t) {
        !!(this.data & 1 << Yh) !== t && (this.data ^= 1 << Yh)
    }
    get offsets() {
        return !!(this.data & 1 << Kh)
    }
    set offsets(t) {
        !!(this.data & 1 << Kh) !== t && (this.data ^= 1 << Kh)
    }
    get culling() {
        return !!(this.data & 1 << Zh)
    }
    set culling(t) {
        !!(this.data & 1 << Zh) !== t && (this.data ^= 1 << Zh)
    }
    get depthTest() {
        return !!(this.data & 1 << qh)
    }
    set depthTest(t) {
        !!(this.data & 1 << qh) !== t && (this.data ^= 1 << qh)
    }
    get depthMask() {
        return !!(this.data & 1 << Qh)
    }
    set depthMask(t) {
        !!(this.data & 1 << Qh) !== t && (this.data ^= 1 << Qh)
    }
    get clockwiseFrontFace() {
        return !!(this.data & 1 << Jh)
    }
    set clockwiseFrontFace(t) {
        !!(this.data & 1 << Jh) !== t && (this.data ^= 1 << Jh)
    }
    get blendMode() {
        return this._blendMode
    }
    set blendMode(t) {
        this.blend = t !== j.NONE, this._blendMode = t
    }
    get polygonOffset() {
        return this._polygonOffset
    }
    set polygonOffset(t) {
        this.offsets = !!t, this._polygonOffset = t
    }
    toString() {
        return `[@pixi/core:State blendMode=${this.blendMode} clockwiseFrontFace=${this.clockwiseFrontFace} culling=${this.culling} depthMask=${this.depthMask} polygonOffset=${this.polygonOffset}]`
    }
    static for2d() {
        const t = new rn;
        return t.depthTest = !1, t.blend = !0, t
    }
}
const ld = [];

function R_(e, t) {
    if (!e) return null;
    let i = "";
    if (typeof e == "string") {
        const s = /\.(\w{3,4})(?:$|\?|#)/i.exec(e);
        s && (i = s[1].toLowerCase())
    }
    for (let s = ld.length - 1; s >= 0; --s) {
        const n = ld[s];
        if (n.test && n.test(e, i)) return new n(e, t)
    }
    throw new Error("Unrecognized source type to auto-detect Resource")
}
class cs {
    constructor(t) {
        this.items = [], this._name = t, this._aliasCount = 0
    }
    emit(t, i, s, n, r, o, a, l) {
        if (arguments.length > 8) throw new Error("max arguments reached");
        const {
            name: c,
            items: h
        } = this;
        this._aliasCount++;
        for (let u = 0, d = h.length; u < d; u++) h[u][c](t, i, s, n, r, o, a, l);
        return h === this.items && this._aliasCount--, this
    }
    ensureNonAliasedItems() {
        this._aliasCount > 0 && this.items.length > 1 && (this._aliasCount = 0, this.items = this.items.slice(0))
    }
    add(t) {
        return t[this._name] && (this.ensureNonAliasedItems(), this.remove(t), this.items.push(t)), this
    }
    remove(t) {
        const i = this.items.indexOf(t);
        return i !== -1 && (this.ensureNonAliasedItems(), this.items.splice(i, 1)), this
    }
    contains(t) {
        return this.items.includes(t)
    }
    removeAll() {
        return this.ensureNonAliasedItems(), this.items.length = 0, this
    }
    destroy() {
        this.removeAll(), this.items = null, this._name = null
    }
    get empty() {
        return this.items.length === 0
    }
    get name() {
        return this._name
    }
}
Object.defineProperties(cs.prototype, {
    dispatch: {
        value: cs.prototype.emit
    },
    run: {
        value: cs.prototype.emit
    }
});
class Ua {
    constructor(t = 0, i = 0) {
        this._width = t, this._height = i, this.destroyed = !1, this.internal = !1, this.onResize = new cs("setRealSize"), this.onUpdate = new cs("update"), this.onError = new cs("onError")
    }
    bind(t) {
        this.onResize.add(t), this.onUpdate.add(t), this.onError.add(t), (this._width || this._height) && this.onResize.emit(this._width, this._height)
    }
    unbind(t) {
        this.onResize.remove(t), this.onUpdate.remove(t), this.onError.remove(t)
    }
    resize(t, i) {
        (t !== this._width || i !== this._height) && (this._width = t, this._height = i, this.onResize.emit(t, i))
    }
    get valid() {
        return !!this._width && !!this._height
    }
    update() {
        this.destroyed || this.onUpdate.emit()
    }
    load() {
        return Promise.resolve(this)
    }
    get width() {
        return this._width
    }
    get height() {
        return this._height
    }
    style(t, i, s) {
        return !1
    }
    dispose() {}
    destroy() {
        this.destroyed || (this.destroyed = !0, this.dispose(), this.onError.removeAll(), this.onError = null, this.onResize.removeAll(), this.onResize = null, this.onUpdate.removeAll(), this.onUpdate = null)
    }
    static test(t, i) {
        return !1
    }
}
class qa extends Ua {
    constructor(t, i) {
        const {
            width: s,
            height: n
        } = i || {};
        if (!s || !n) throw new Error("BufferResource width or height invalid");
        super(s, n), this.data = t
    }
    upload(t, i, s) {
        const n = t.gl;
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === _s.UNPACK);
        const r = i.realWidth,
            o = i.realHeight;
        return s.width === r && s.height === o ? n.texSubImage2D(i.target, 0, 0, 0, r, o, i.format, s.type, this.data) : (s.width = r, s.height = o, n.texImage2D(i.target, 0, s.internalFormat, r, o, 0, i.format, s.type, this.data)), !0
    }
    dispose() {
        this.data = null
    }
    static test(t) {
        return t instanceof Float32Array || t instanceof Uint8Array || t instanceof Uint32Array
    }
}
const d4 = {
        scaleMode: Hi.NEAREST,
        format: ot.RGBA,
        alphaMode: _s.NPM
    },
    eo = class extends $o {
        constructor(e = null, t = null) {
            super(), t = Object.assign({}, eo.defaultOptions, t);
            const {
                alphaMode: i,
                mipmap: s,
                anisotropicLevel: n,
                scaleMode: r,
                width: o,
                height: a,
                wrapMode: l,
                format: c,
                type: h,
                target: u,
                resolution: d,
                resourceOptions: f
            } = t;
            e && !(e instanceof Ua) && (e = R_(e, f), e.internal = !0), this.resolution = d || ut.RESOLUTION, this.width = Math.round((o || 0) * this.resolution) / this.resolution, this.height = Math.round((a || 0) * this.resolution) / this.resolution, this._mipmap = s, this.anisotropicLevel = n, this._wrapMode = l, this._scaleMode = r, this.format = c, this.type = h, this.target = u, this.alphaMode = i, this.uid = Ln(), this.touched = 0, this.isPowerOfTwo = !1, this._refreshPOT(), this._glTextures = {}, this.dirtyId = 0, this.dirtyStyleId = 0, this.cacheId = null, this.valid = o > 0 && a > 0, this.textureCacheIds = [], this.destroyed = !1, this.resource = null, this._batchEnabled = 0, this._batchLocation = 0, this.parentTextureArray = null, this.setResource(e)
        }
        get realWidth() {
            return Math.round(this.width * this.resolution)
        }
        get realHeight() {
            return Math.round(this.height * this.resolution)
        }
        get mipmap() {
            return this._mipmap
        }
        set mipmap(e) {
            this._mipmap !== e && (this._mipmap = e, this.dirtyStyleId++)
        }
        get scaleMode() {
            return this._scaleMode
        }
        set scaleMode(e) {
            this._scaleMode !== e && (this._scaleMode = e, this.dirtyStyleId++)
        }
        get wrapMode() {
            return this._wrapMode
        }
        set wrapMode(e) {
            this._wrapMode !== e && (this._wrapMode = e, this.dirtyStyleId++)
        }
        setStyle(e, t) {
            let i;
            return e !== void 0 && e !== this.scaleMode && (this.scaleMode = e, i = !0), t !== void 0 && t !== this.mipmap && (this.mipmap = t, i = !0), i && this.dirtyStyleId++, this
        }
        setSize(e, t, i) {
            return i = i || this.resolution, this.setRealSize(e * i, t * i, i)
        }
        setRealSize(e, t, i) {
            return this.resolution = i || this.resolution, this.width = Math.round(e) / this.resolution, this.height = Math.round(t) / this.resolution, this._refreshPOT(), this.update(), this
        }
        _refreshPOT() {
            this.isPowerOfTwo = sd(this.realWidth) && sd(this.realHeight)
        }
        setResolution(e) {
            const t = this.resolution;
            return t === e ? this : (this.resolution = e, this.valid && (this.width = Math.round(this.width * t) / e, this.height = Math.round(this.height * t) / e, this.emit("update", this)), this._refreshPOT(), this)
        }
        setResource(e) {
            if (this.resource === e) return this;
            if (this.resource) throw new Error("Resource can be set only once");
            return e.bind(this), this.resource = e, this
        }
        update() {
            this.valid ? (this.dirtyId++, this.dirtyStyleId++, this.emit("update", this)) : this.width > 0 && this.height > 0 && (this.valid = !0, this.emit("loaded", this), this.emit("update", this))
        }
        onError(e) {
            this.emit("error", this, e)
        }
        destroy() {
            this.resource && (this.resource.unbind(this), this.resource.internal && this.resource.destroy(), this.resource = null), this.cacheId && (delete mi[this.cacheId], delete ri[this.cacheId], this.cacheId = null), this.dispose(), eo.removeFromCache(this), this.textureCacheIds = null, this.destroyed = !0
        }
        dispose() {
            this.emit("dispose", this)
        }
        castToBaseTexture() {
            return this
        }
        static from(e, t, i = ut.STRICT_TEXTURE_CACHE) {
            const s = typeof e == "string";
            let n = null;
            if (s) n = e;
            else {
                if (!e._pixiId) {
                    const o = t?.pixiIdPrefix || "pixiid";
                    e._pixiId = `${o}_${Ln()}`
                }
                n = e._pixiId
            }
            let r = mi[n];
            if (s && i && !r) throw new Error(`The cacheId "${n}" does not exist in BaseTextureCache.`);
            return r || (r = new eo(e, t), r.cacheId = n, eo.addToCache(r, n)), r
        }
        static fromBuffer(e, t, i, s) {
            e = e || new Float32Array(t * i * 4);
            const n = new qa(e, {
                    width: t,
                    height: i
                }),
                r = e instanceof Float32Array ? Rt.FLOAT : Rt.UNSIGNED_BYTE;
            return new eo(n, Object.assign({}, d4, s || {
                width: t,
                height: i,
                type: r
            }))
        }
        static addToCache(e, t) {
            t && (e.textureCacheIds.includes(t) || e.textureCacheIds.push(t), mi[t] && mi[t] !== e && console.warn(`BaseTexture added to the cache with an id [${t}] that already had an entry`), mi[t] = e)
        }
        static removeFromCache(e) {
            if (typeof e == "string") {
                const t = mi[e];
                if (t) {
                    const i = t.textureCacheIds.indexOf(e);
                    return i > -1 && t.textureCacheIds.splice(i, 1), delete mi[e], t
                }
            } else if (e?.textureCacheIds) {
                for (let t = 0; t < e.textureCacheIds.length; ++t) delete mi[e.textureCacheIds[t]];
                return e.textureCacheIds.length = 0, e
            }
            return null
        }
    };
let Nt = eo;
Nt.defaultOptions = {
    mipmap: ds.POW2,
    anisotropicLevel: 0,
    scaleMode: Hi.LINEAR,
    wrapMode: Zs.CLAMP,
    alphaMode: _s.UNPACK,
    target: mo.TEXTURE_2D,
    format: ot.RGBA,
    type: Rt.UNSIGNED_BYTE
};
Nt._globalBatch = 0;
class cd {
    constructor() {
        this.texArray = null, this.blend = 0, this.type = rs.TRIANGLES, this.start = 0, this.size = 0, this.data = null
    }
}
let f4 = 0;
class Ne {
    constructor(t, i = !0, s = !1) {
        this.data = t || new Float32Array(1), this._glBuffers = {}, this._updateID = 0, this.index = s, this.static = i, this.id = f4++, this.disposeRunner = new cs("disposeBuffer")
    }
    update(t) {
        t instanceof Array && (t = new Float32Array(t)), this.data = t || this.data, this._updateID++
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(), this.data = null
    }
    set index(t) {
        this.type = t ? Ps.ELEMENT_ARRAY_BUFFER : Ps.ARRAY_BUFFER
    }
    get index() {
        return this.type === Ps.ELEMENT_ARRAY_BUFFER
    }
    static from(t) {
        return t instanceof Array && (t = new Float32Array(t)), new Ne(t)
    }
}
class wc {
    constructor(t, i = 0, s = !1, n = Rt.FLOAT, r, o, a, l = 1) {
        this.buffer = t, this.size = i, this.normalized = s, this.type = n, this.stride = r, this.start = o, this.instance = a, this.divisor = l
    }
    destroy() {
        this.buffer = null
    }
    static from(t, i, s, n, r) {
        return new wc(t, i, s, n, r)
    }
}
const p4 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array
};

function m4(e, t) {
    let i = 0,
        s = 0;
    const n = {};
    for (let l = 0; l < e.length; l++) s += t[l], i += e[l].length;
    const r = new ArrayBuffer(i * 4);
    let o = null,
        a = 0;
    for (let l = 0; l < e.length; l++) {
        const c = t[l],
            h = e[l],
            u = hh(h);
        n[u] || (n[u] = new p4[u](r)), o = n[u];
        for (let d = 0; d < h.length; d++) {
            const f = (d / c | 0) * s + a,
                p = d % c;
            o[f + p] = h[d]
        }
        a += c
    }
    return new Float32Array(r)
}
const sg = {
    5126: 4,
    5123: 2,
    5121: 1
};
let g4 = 0;
const v4 = {
    Float32Array,
    Uint32Array,
    Int32Array,
    Uint8Array,
    Uint16Array
};
class On {
    constructor(t = [], i = {}) {
        this.buffers = t, this.indexBuffer = null, this.attributes = i, this.glVertexArrayObjects = {}, this.id = g4++, this.instanced = !1, this.instanceCount = 1, this.disposeRunner = new cs("disposeGeometry"), this.refCount = 0
    }
    addAttribute(t, i, s = 0, n = !1, r, o, a, l = !1) {
        if (!i) throw new Error("You must pass a buffer when creating an attribute");
        i instanceof Ne || (i instanceof Array && (i = new Float32Array(i)), i = new Ne(i));
        const c = t.split("|");
        if (c.length > 1) {
            for (let u = 0; u < c.length; u++) this.addAttribute(c[u], i, s, n, r);
            return this
        }
        let h = this.buffers.indexOf(i);
        return h === -1 && (this.buffers.push(i), h = this.buffers.length - 1), this.attributes[t] = new wc(h, s, n, r, o, a, l), this.instanced = this.instanced || l, this
    }
    getAttribute(t) {
        return this.attributes[t]
    }
    getBuffer(t) {
        return this.buffers[this.getAttribute(t).buffer]
    }
    addIndex(t) {
        return t instanceof Ne || (t instanceof Array && (t = new Uint16Array(t)), t = new Ne(t)), t.type = Ps.ELEMENT_ARRAY_BUFFER, this.indexBuffer = t, this.buffers.includes(t) || this.buffers.push(t), this
    }
    getIndex() {
        return this.indexBuffer
    }
    interleave() {
        if (this.buffers.length === 1 || this.buffers.length === 2 && this.indexBuffer) return this;
        const t = [],
            i = [],
            s = new Ne;
        let n;
        for (n in this.attributes) {
            const r = this.attributes[n],
                o = this.buffers[r.buffer];
            t.push(o.data), i.push(r.size * sg[r.type] / 4), r.buffer = 0
        }
        for (s.data = m4(t, i), n = 0; n < this.buffers.length; n++) this.buffers[n] !== this.indexBuffer && this.buffers[n].destroy();
        return this.buffers = [s], this.indexBuffer && this.buffers.push(this.indexBuffer), this
    }
    getSize() {
        for (const t in this.attributes) {
            const i = this.attributes[t];
            return this.buffers[i.buffer].data.length / (i.stride / 4 || i.size)
        }
        return 0
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroy() {
        this.dispose(), this.buffers = null, this.indexBuffer = null, this.attributes = null
    }
    clone() {
        const t = new On;
        for (let i = 0; i < this.buffers.length; i++) t.buffers[i] = new Ne(this.buffers[i].data.slice(0));
        for (const i in this.attributes) {
            const s = this.attributes[i];
            t.attributes[i] = new wc(s.buffer, s.size, s.normalized, s.type, s.stride, s.start, s.instance)
        }
        return this.indexBuffer && (t.indexBuffer = t.buffers[this.buffers.indexOf(this.indexBuffer)], t.indexBuffer.type = Ps.ELEMENT_ARRAY_BUFFER), t
    }
    static merge(t) {
        const i = new On,
            s = [],
            n = [],
            r = [];
        let o;
        for (let a = 0; a < t.length; a++) {
            o = t[a];
            for (let l = 0; l < o.buffers.length; l++) n[l] = n[l] || 0, n[l] += o.buffers[l].data.length, r[l] = 0
        }
        for (let a = 0; a < o.buffers.length; a++) s[a] = new v4[hh(o.buffers[a].data)](n[a]), i.buffers[a] = new Ne(s[a]);
        for (let a = 0; a < t.length; a++) {
            o = t[a];
            for (let l = 0; l < o.buffers.length; l++) s[l].set(o.buffers[l].data, r[l]), r[l] += o.buffers[l].data.length
        }
        if (i.attributes = o.attributes, o.indexBuffer) {
            i.indexBuffer = i.buffers[o.buffers.indexOf(o.indexBuffer)], i.indexBuffer.type = Ps.ELEMENT_ARRAY_BUFFER;
            let a = 0,
                l = 0,
                c = 0,
                h = 0;
            for (let u = 0; u < o.buffers.length; u++)
                if (o.buffers[u] !== o.indexBuffer) {
                    h = u;
                    break
                } for (const u in o.attributes) {
                const d = o.attributes[u];
                (d.buffer | 0) === h && (l += d.size * sg[d.type] / 4)
            }
            for (let u = 0; u < t.length; u++) {
                const d = t[u].indexBuffer.data;
                for (let f = 0; f < d.length; f++) i.indexBuffer.data[f + c] += a;
                a += t[u].buffers[h].data.length / l, c += d.length
            }
        }
        return i
    }
}
class k_ extends On {
    constructor(t = !1) {
        super(), this._buffer = new Ne(null, t, !1), this._indexBuffer = new Ne(null, t, !0), this.addAttribute("aVertexPosition", this._buffer, 2, !1, Rt.FLOAT).addAttribute("aTextureCoord", this._buffer, 2, !1, Rt.FLOAT).addAttribute("aColor", this._buffer, 4, !0, Rt.UNSIGNED_BYTE).addAttribute("aTextureId", this._buffer, 1, !0, Rt.FLOAT).addIndex(this._indexBuffer)
    }
}
const Tc = Math.PI * 2,
    _4 = 180 / Math.PI,
    y4 = Math.PI / 180;
var we = (e => (e[e.POLY = 0] = "POLY", e[e.RECT = 1] = "RECT", e[e.CIRC = 2] = "CIRC", e[e.ELIP = 3] = "ELIP", e[e.RREC = 4] = "RREC", e))(we || {});
class Zt {
    constructor(t = 0, i = 0) {
        this.x = 0, this.y = 0, this.x = t, this.y = i
    }
    clone() {
        return new Zt(this.x, this.y)
    }
    copyFrom(t) {
        return this.set(t.x, t.y), this
    }
    copyTo(t) {
        return t.set(this.x, this.y), t
    }
    equals(t) {
        return t.x === this.x && t.y === this.y
    }
    set(t = 0, i = t) {
        return this.x = t, this.y = i, this
    }
    toString() {
        return `[@pixi/math:Point x=${this.x} y=${this.y}]`
    }
}
const xl = [new Zt, new Zt, new Zt, new Zt];
class qt {
    constructor(t = 0, i = 0, s = 0, n = 0) {
        this.x = Number(t), this.y = Number(i), this.width = Number(s), this.height = Number(n), this.type = we.RECT
    }
    get left() {
        return this.x
    }
    get right() {
        return this.x + this.width
    }
    get top() {
        return this.y
    }
    get bottom() {
        return this.y + this.height
    }
    static get EMPTY() {
        return new qt(0, 0, 0, 0)
    }
    clone() {
        return new qt(this.x, this.y, this.width, this.height)
    }
    copyFrom(t) {
        return this.x = t.x, this.y = t.y, this.width = t.width, this.height = t.height, this
    }
    copyTo(t) {
        return t.x = this.x, t.y = this.y, t.width = this.width, t.height = this.height, t
    }
    contains(t, i) {
        return this.width <= 0 || this.height <= 0 ? !1 : t >= this.x && t < this.x + this.width && i >= this.y && i < this.y + this.height
    }
    intersects(t, i) {
        if (!i) {
            const T = this.x < t.x ? t.x : this.x;
            if ((this.right > t.right ? t.right : this.right) <= T) return !1;
            const D = this.y < t.y ? t.y : this.y;
            return (this.bottom > t.bottom ? t.bottom : this.bottom) > D
        }
        const s = this.left,
            n = this.right,
            r = this.top,
            o = this.bottom;
        if (n <= s || o <= r) return !1;
        const a = xl[0].set(t.left, t.top),
            l = xl[1].set(t.left, t.bottom),
            c = xl[2].set(t.right, t.top),
            h = xl[3].set(t.right, t.bottom);
        if (c.x <= a.x || l.y <= a.y) return !1;
        const u = Math.sign(i.a * i.d - i.b * i.c);
        if (u === 0 || (i.apply(a, a), i.apply(l, l), i.apply(c, c), i.apply(h, h), Math.max(a.x, l.x, c.x, h.x) <= s || Math.min(a.x, l.x, c.x, h.x) >= n || Math.max(a.y, l.y, c.y, h.y) <= r || Math.min(a.y, l.y, c.y, h.y) >= o)) return !1;
        const d = u * (l.y - a.y),
            f = u * (a.x - l.x),
            p = d * s + f * r,
            m = d * n + f * r,
            g = d * s + f * o,
            y = d * n + f * o;
        if (Math.max(p, m, g, y) <= d * a.x + f * a.y || Math.min(p, m, g, y) >= d * h.x + f * h.y) return !1;
        const x = u * (a.y - c.y),
            v = u * (c.x - a.x),
            _ = x * s + v * r,
            C = x * n + v * r,
            k = x * s + v * o,
            S = x * n + v * o;
        return !(Math.max(_, C, k, S) <= x * a.x + v * a.y || Math.min(_, C, k, S) >= x * h.x + v * h.y)
    }
    pad(t = 0, i = t) {
        return this.x -= t, this.y -= i, this.width += t * 2, this.height += i * 2, this
    }
    fit(t) {
        const i = Math.max(this.x, t.x),
            s = Math.min(this.x + this.width, t.x + t.width),
            n = Math.max(this.y, t.y),
            r = Math.min(this.y + this.height, t.y + t.height);
        return this.x = i, this.width = Math.max(s - i, 0), this.y = n, this.height = Math.max(r - n, 0), this
    }
    ceil(t = 1, i = .001) {
        const s = Math.ceil((this.x + this.width - i) * t) / t,
            n = Math.ceil((this.y + this.height - i) * t) / t;
        return this.x = Math.floor((this.x + i) * t) / t, this.y = Math.floor((this.y + i) * t) / t, this.width = s - this.x, this.height = n - this.y, this
    }
    enlarge(t) {
        const i = Math.min(this.x, t.x),
            s = Math.max(this.x + this.width, t.x + t.width),
            n = Math.min(this.y, t.y),
            r = Math.max(this.y + this.height, t.y + t.height);
        return this.x = i, this.width = s - i, this.y = n, this.height = r - n, this
    }
    toString() {
        return `[@pixi/math:Rectangle x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
    }
}
class Uf {
    constructor(t = 0, i = 0, s = 0) {
        this.x = t, this.y = i, this.radius = s, this.type = we.CIRC
    }
    clone() {
        return new Uf(this.x, this.y, this.radius)
    }
    contains(t, i) {
        if (this.radius <= 0) return !1;
        const s = this.radius * this.radius;
        let n = this.x - t,
            r = this.y - i;
        return n *= n, r *= r, n + r <= s
    }
    getBounds() {
        return new qt(this.x - this.radius, this.y - this.radius, this.radius * 2, this.radius * 2)
    }
    toString() {
        return `[@pixi/math:Circle x=${this.x} y=${this.y} radius=${this.radius}]`
    }
}
class Gf {
    constructor(t = 0, i = 0, s = 0, n = 0) {
        this.x = t, this.y = i, this.width = s, this.height = n, this.type = we.ELIP
    }
    clone() {
        return new Gf(this.x, this.y, this.width, this.height)
    }
    contains(t, i) {
        if (this.width <= 0 || this.height <= 0) return !1;
        let s = (t - this.x) / this.width,
            n = (i - this.y) / this.height;
        return s *= s, n *= n, s + n <= 1
    }
    getBounds() {
        return new qt(this.x - this.width, this.y - this.height, this.width, this.height)
    }
    toString() {
        return `[@pixi/math:Ellipse x=${this.x} y=${this.y} width=${this.width} height=${this.height}]`
    }
}
class vo {
    constructor(...t) {
        let i = Array.isArray(t[0]) ? t[0] : t;
        if (typeof i[0] != "number") {
            const s = [];
            for (let n = 0, r = i.length; n < r; n++) s.push(i[n].x, i[n].y);
            i = s
        }
        this.points = i, this.type = we.POLY, this.closeStroke = !0
    }
    clone() {
        const t = this.points.slice(),
            i = new vo(t);
        return i.closeStroke = this.closeStroke, i
    }
    contains(t, i) {
        let s = !1;
        const n = this.points.length / 2;
        for (let r = 0, o = n - 1; r < n; o = r++) {
            const a = this.points[r * 2],
                l = this.points[r * 2 + 1],
                c = this.points[o * 2],
                h = this.points[o * 2 + 1];
            l > i != h > i && t < (c - a) * ((i - l) / (h - l)) + a && (s = !s)
        }
        return s
    }
    toString() {
        return `[@pixi/math:PolygoncloseStroke=${this.closeStroke}points=${this.points.reduce((t,i)=>`${t}, ${i}`,"")}]`
    }
}
class Hf {
    constructor(t = 0, i = 0, s = 0, n = 0, r = 20) {
        this.x = t, this.y = i, this.width = s, this.height = n, this.radius = r, this.type = we.RREC
    }
    clone() {
        return new Hf(this.x, this.y, this.width, this.height, this.radius)
    }
    contains(t, i) {
        if (this.width <= 0 || this.height <= 0) return !1;
        if (t >= this.x && t <= this.x + this.width && i >= this.y && i <= this.y + this.height) {
            const s = Math.max(0, Math.min(this.radius, Math.min(this.width, this.height) / 2));
            if (i >= this.y + s && i <= this.y + this.height - s || t >= this.x + s && t <= this.x + this.width - s) return !0;
            let n = t - (this.x + s),
                r = i - (this.y + s);
            const o = s * s;
            if (n * n + r * r <= o || (n = t - (this.x + this.width - s), n * n + r * r <= o) || (r = i - (this.y + this.height - s), n * n + r * r <= o) || (n = t - (this.x + s), n * n + r * r <= o)) return !0
        }
        return !1
    }
    toString() {
        return `[@pixi/math:RoundedRectangle x=${this.x} y=${this.y}width=${this.width} height=${this.height} radius=${this.radius}]`
    }
}
class pe {
    constructor(t = 1, i = 0, s = 0, n = 1, r = 0, o = 0) {
        this.array = null, this.a = t, this.b = i, this.c = s, this.d = n, this.tx = r, this.ty = o
    }
    fromArray(t) {
        this.a = t[0], this.b = t[1], this.c = t[3], this.d = t[4], this.tx = t[2], this.ty = t[5]
    }
    set(t, i, s, n, r, o) {
        return this.a = t, this.b = i, this.c = s, this.d = n, this.tx = r, this.ty = o, this
    }
    toArray(t, i) {
        this.array || (this.array = new Float32Array(9));
        const s = i || this.array;
        return t ? (s[0] = this.a, s[1] = this.b, s[2] = 0, s[3] = this.c, s[4] = this.d, s[5] = 0, s[6] = this.tx, s[7] = this.ty, s[8] = 1) : (s[0] = this.a, s[1] = this.c, s[2] = this.tx, s[3] = this.b, s[4] = this.d, s[5] = this.ty, s[6] = 0, s[7] = 0, s[8] = 1), s
    }
    apply(t, i) {
        i = i || new Zt;
        const s = t.x,
            n = t.y;
        return i.x = this.a * s + this.c * n + this.tx, i.y = this.b * s + this.d * n + this.ty, i
    }
    applyInverse(t, i) {
        i = i || new Zt;
        const s = 1 / (this.a * this.d + this.c * -this.b),
            n = t.x,
            r = t.y;
        return i.x = this.d * s * n + -this.c * s * r + (this.ty * this.c - this.tx * this.d) * s, i.y = this.a * s * r + -this.b * s * n + (-this.ty * this.a + this.tx * this.b) * s, i
    }
    translate(t, i) {
        return this.tx += t, this.ty += i, this
    }
    scale(t, i) {
        return this.a *= t, this.d *= i, this.c *= t, this.b *= i, this.tx *= t, this.ty *= i, this
    }
    rotate(t) {
        const i = Math.cos(t),
            s = Math.sin(t),
            n = this.a,
            r = this.c,
            o = this.tx;
        return this.a = n * i - this.b * s, this.b = n * s + this.b * i, this.c = r * i - this.d * s, this.d = r * s + this.d * i, this.tx = o * i - this.ty * s, this.ty = o * s + this.ty * i, this
    }
    append(t) {
        const i = this.a,
            s = this.b,
            n = this.c,
            r = this.d;
        return this.a = t.a * i + t.b * n, this.b = t.a * s + t.b * r, this.c = t.c * i + t.d * n, this.d = t.c * s + t.d * r, this.tx = t.tx * i + t.ty * n + this.tx, this.ty = t.tx * s + t.ty * r + this.ty, this
    }
    setTransform(t, i, s, n, r, o, a, l, c) {
        return this.a = Math.cos(a + c) * r, this.b = Math.sin(a + c) * r, this.c = -Math.sin(a - l) * o, this.d = Math.cos(a - l) * o, this.tx = t - (s * this.a + n * this.c), this.ty = i - (s * this.b + n * this.d), this
    }
    prepend(t) {
        const i = this.tx;
        if (t.a !== 1 || t.b !== 0 || t.c !== 0 || t.d !== 1) {
            const s = this.a,
                n = this.c;
            this.a = s * t.a + this.b * t.c, this.b = s * t.b + this.b * t.d, this.c = n * t.a + this.d * t.c, this.d = n * t.b + this.d * t.d
        }
        return this.tx = i * t.a + this.ty * t.c + t.tx, this.ty = i * t.b + this.ty * t.d + t.ty, this
    }
    decompose(t) {
        const i = this.a,
            s = this.b,
            n = this.c,
            r = this.d,
            o = t.pivot,
            a = -Math.atan2(-n, r),
            l = Math.atan2(s, i),
            c = Math.abs(a + l);
        return c < 1e-5 || Math.abs(Tc - c) < 1e-5 ? (t.rotation = l, t.skew.x = t.skew.y = 0) : (t.rotation = 0, t.skew.x = a, t.skew.y = l), t.scale.x = Math.sqrt(i * i + s * s), t.scale.y = Math.sqrt(n * n + r * r), t.position.x = this.tx + (o.x * i + o.y * n), t.position.y = this.ty + (o.x * s + o.y * r), t
    }
    invert() {
        const t = this.a,
            i = this.b,
            s = this.c,
            n = this.d,
            r = this.tx,
            o = t * n - i * s;
        return this.a = n / o, this.b = -i / o, this.c = -s / o, this.d = t / o, this.tx = (s * this.ty - n * r) / o, this.ty = -(t * this.ty - i * r) / o, this
    }
    identity() {
        return this.a = 1, this.b = 0, this.c = 0, this.d = 1, this.tx = 0, this.ty = 0, this
    }
    clone() {
        const t = new pe;
        return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
    }
    copyTo(t) {
        return t.a = this.a, t.b = this.b, t.c = this.c, t.d = this.d, t.tx = this.tx, t.ty = this.ty, t
    }
    copyFrom(t) {
        return this.a = t.a, this.b = t.b, this.c = t.c, this.d = t.d, this.tx = t.tx, this.ty = t.ty, this
    }
    toString() {
        return `[@pixi/math:Matrix a=${this.a} b=${this.b} c=${this.c} d=${this.d} tx=${this.tx} ty=${this.ty}]`
    }
    static get IDENTITY() {
        return new pe
    }
    static get TEMP_MATRIX() {
        return new pe
    }
}
const Xn = [1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1, 0, 1],
    Yn = [0, 1, 1, 1, 0, -1, -1, -1, 0, 1, 1, 1, 0, -1, -1, -1],
    Kn = [0, -1, -1, -1, 0, 1, 1, 1, 0, 1, 1, 1, 0, -1, -1, -1],
    Zn = [1, 1, 0, -1, -1, -1, 0, 1, -1, -1, 0, 1, 1, 1, 0, -1],
    hd = [],
    P_ = [],
    wl = Math.sign;

function b4() {
    for (let e = 0; e < 16; e++) {
        const t = [];
        hd.push(t);
        for (let i = 0; i < 16; i++) {
            const s = wl(Xn[e] * Xn[i] + Kn[e] * Yn[i]),
                n = wl(Yn[e] * Xn[i] + Zn[e] * Yn[i]),
                r = wl(Xn[e] * Kn[i] + Kn[e] * Zn[i]),
                o = wl(Yn[e] * Kn[i] + Zn[e] * Zn[i]);
            for (let a = 0; a < 16; a++)
                if (Xn[a] === s && Yn[a] === n && Kn[a] === r && Zn[a] === o) {
                    t.push(a);
                    break
                }
        }
    }
    for (let e = 0; e < 16; e++) {
        const t = new pe;
        t.set(Xn[e], Yn[e], Kn[e], Zn[e], 0, 0), P_.push(t)
    }
}
b4();
const Se = {
    E: 0,
    SE: 1,
    S: 2,
    SW: 3,
    W: 4,
    NW: 5,
    N: 6,
    NE: 7,
    MIRROR_VERTICAL: 8,
    MAIN_DIAGONAL: 10,
    MIRROR_HORIZONTAL: 12,
    REVERSE_DIAGONAL: 14,
    uX: e => Xn[e],
    uY: e => Yn[e],
    vX: e => Kn[e],
    vY: e => Zn[e],
    inv: e => e & 8 ? e & 15 : -e & 7,
    add: (e, t) => hd[e][t],
    sub: (e, t) => hd[e][Se.inv(t)],
    rotate180: e => e ^ 4,
    isVertical: e => (e & 3) === 2,
    byDirection: (e, t) => Math.abs(e) * 2 <= Math.abs(t) ? t >= 0 ? Se.S : Se.N : Math.abs(t) * 2 <= Math.abs(e) ? e > 0 ? Se.E : Se.W : t > 0 ? e > 0 ? Se.SE : Se.SW : e > 0 ? Se.NE : Se.NW,
    matrixAppendRotationInv: (e, t, i = 0, s = 0) => {
        const n = P_[Se.inv(t)];
        n.tx = i, n.ty = s, e.append(n)
    }
};
class wn {
    constructor(t, i, s = 0, n = 0) {
        this._x = s, this._y = n, this.cb = t, this.scope = i
    }
    clone(t = this.cb, i = this.scope) {
        return new wn(t, i, this._x, this._y)
    }
    set(t = 0, i = t) {
        return (this._x !== t || this._y !== i) && (this._x = t, this._y = i, this.cb.call(this.scope)), this
    }
    copyFrom(t) {
        return (this._x !== t.x || this._y !== t.y) && (this._x = t.x, this._y = t.y, this.cb.call(this.scope)), this
    }
    copyTo(t) {
        return t.set(this._x, this._y), t
    }
    equals(t) {
        return t.x === this._x && t.y === this._y
    }
    toString() {
        return `[@pixi/math:ObservablePoint x=${0} y=${0} scope=${this.scope}]`
    }
    get x() {
        return this._x
    }
    set x(t) {
        this._x !== t && (this._x = t, this.cb.call(this.scope))
    }
    get y() {
        return this._y
    }
    set y(t) {
        this._y !== t && (this._y = t, this.cb.call(this.scope))
    }
}
const L_ = class {
    constructor() {
        this.worldTransform = new pe, this.localTransform = new pe, this.position = new wn(this.onChange, this, 0, 0), this.scale = new wn(this.onChange, this, 1, 1), this.pivot = new wn(this.onChange, this, 0, 0), this.skew = new wn(this.updateSkew, this, 0, 0), this._rotation = 0, this._cx = 1, this._sx = 0, this._cy = 0, this._sy = 1, this._localID = 0, this._currentLocalID = 0, this._worldID = 0, this._parentID = 0
    }
    onChange() {
        this._localID++
    }
    updateSkew() {
        this._cx = Math.cos(this._rotation + this.skew.y), this._sx = Math.sin(this._rotation + this.skew.y), this._cy = -Math.sin(this._rotation - this.skew.x), this._sy = Math.cos(this._rotation - this.skew.x), this._localID++
    }
    toString() {
        return `[@pixi/math:Transform position=(${this.position.x}, ${this.position.y}) rotation=${this.rotation} scale=(${this.scale.x}, ${this.scale.y}) skew=(${this.skew.x}, ${this.skew.y}) ]`
    }
    updateLocalTransform() {
        const e = this.localTransform;
        this._localID !== this._currentLocalID && (e.a = this._cx * this.scale.x, e.b = this._sx * this.scale.x, e.c = this._cy * this.scale.y, e.d = this._sy * this.scale.y, e.tx = this.position.x - (this.pivot.x * e.a + this.pivot.y * e.c), e.ty = this.position.y - (this.pivot.x * e.b + this.pivot.y * e.d), this._currentLocalID = this._localID, this._parentID = -1)
    }
    updateTransform(e) {
        const t = this.localTransform;
        if (this._localID !== this._currentLocalID && (t.a = this._cx * this.scale.x, t.b = this._sx * this.scale.x, t.c = this._cy * this.scale.y, t.d = this._sy * this.scale.y, t.tx = this.position.x - (this.pivot.x * t.a + this.pivot.y * t.c), t.ty = this.position.y - (this.pivot.x * t.b + this.pivot.y * t.d), this._currentLocalID = this._localID, this._parentID = -1), this._parentID !== e._worldID) {
            const i = e.worldTransform,
                s = this.worldTransform;
            s.a = t.a * i.a + t.b * i.c, s.b = t.a * i.b + t.b * i.d, s.c = t.c * i.a + t.d * i.c, s.d = t.c * i.b + t.d * i.d, s.tx = t.tx * i.a + t.ty * i.c + i.tx, s.ty = t.tx * i.b + t.ty * i.d + i.ty, this._parentID = e._worldID, this._worldID++
        }
    }
    setFromMatrix(e) {
        e.decompose(this), this._localID++
    }
    get rotation() {
        return this._rotation
    }
    set rotation(e) {
        this._rotation !== e && (this._rotation = e, this.updateSkew())
    }
};
let uh = L_;
uh.IDENTITY = new L_;
var x4 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor *= texture2D(uSampler, vTextureCoord);
}`,
    w4 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void){
   gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
   vTextureCoord = aTextureCoord;
}
`;

function ng(e, t, i) {
    const s = e.createShader(t);
    return e.shaderSource(s, i), e.compileShader(s), s
}

function tu(e) {
    const t = new Array(e);
    for (let i = 0; i < t.length; i++) t[i] = !1;
    return t
}

function O_(e, t) {
    switch (e) {
        case "float":
            return 0;
        case "vec2":
            return new Float32Array(2 * t);
        case "vec3":
            return new Float32Array(3 * t);
        case "vec4":
            return new Float32Array(4 * t);
        case "int":
        case "uint":
        case "sampler2D":
        case "sampler2DArray":
            return 0;
        case "ivec2":
            return new Int32Array(2 * t);
        case "ivec3":
            return new Int32Array(3 * t);
        case "ivec4":
            return new Int32Array(4 * t);
        case "uvec2":
            return new Uint32Array(2 * t);
        case "uvec3":
            return new Uint32Array(3 * t);
        case "uvec4":
            return new Uint32Array(4 * t);
        case "bool":
            return !1;
        case "bvec2":
            return tu(2 * t);
        case "bvec3":
            return tu(3 * t);
        case "bvec4":
            return tu(4 * t);
        case "mat2":
            return new Float32Array([1, 0, 0, 1]);
        case "mat3":
            return new Float32Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
        case "mat4":
            return new Float32Array([1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1])
    }
    return null
}
const _o = [{
        test: e => e.type === "float" && e.size === 1 && !e.isArray,
        code: e => `
            if(uv["${e}"] !== ud["${e}"].value)
            {
                ud["${e}"].value = uv["${e}"]
                gl.uniform1f(ud["${e}"].location, uv["${e}"])
            }
            `
    }, {
        test: (e, t) => (e.type === "sampler2D" || e.type === "samplerCube" || e.type === "sampler2DArray") && e.size === 1 && !e.isArray && (t == null || t.castToBaseTexture !== void 0),
        code: e => `t = syncData.textureCount++;

            renderer.texture.bind(uv["${e}"], t);

            if(ud["${e}"].value !== t)
            {
                ud["${e}"].value = t;
                gl.uniform1i(ud["${e}"].location, t);
; // eslint-disable-line max-len
            }`
    }, {
        test: (e, t) => e.type === "mat3" && e.size === 1 && !e.isArray && t.a !== void 0,
        code: e => `
            gl.uniformMatrix3fv(ud["${e}"].location, false, uv["${e}"].toArray(true));
            `,
        codeUbo: e => `
                var ${e}_matrix = uv.${e}.toArray(true);

                data[offset] = ${e}_matrix[0];
                data[offset+1] = ${e}_matrix[1];
                data[offset+2] = ${e}_matrix[2];
        
                data[offset + 4] = ${e}_matrix[3];
                data[offset + 5] = ${e}_matrix[4];
                data[offset + 6] = ${e}_matrix[5];
        
                data[offset + 8] = ${e}_matrix[6];
                data[offset + 9] = ${e}_matrix[7];
                data[offset + 10] = ${e}_matrix[8];
            `
    }, {
        test: (e, t) => e.type === "vec2" && e.size === 1 && !e.isArray && t.x !== void 0,
        code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.x || cv[1] !== v.y)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    gl.uniform2f(ud["${e}"].location, v.x, v.y);
                }`,
        codeUbo: e => `
                v = uv.${e};

                data[offset] = v.x;
                data[offset+1] = v.y;
            `
    }, {
        test: e => e.type === "vec2" && e.size === 1 && !e.isArray,
        code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v[0] || cv[1] !== v[1])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    gl.uniform2f(ud["${e}"].location, v[0], v[1]);
                }
            `
    }, {
        test: (e, t) => e.type === "vec4" && e.size === 1 && !e.isArray && t.width !== void 0,
        code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v.x || cv[1] !== v.y || cv[2] !== v.width || cv[3] !== v.height)
                {
                    cv[0] = v.x;
                    cv[1] = v.y;
                    cv[2] = v.width;
                    cv[3] = v.height;
                    gl.uniform4f(ud["${e}"].location, v.x, v.y, v.width, v.height)
                }`,
        codeUbo: e => `
                    v = uv.${e};

                    data[offset] = v.x;
                    data[offset+1] = v.y;
                    data[offset+2] = v.width;
                    data[offset+3] = v.height;
                `
    }, {
        test: e => e.type === "vec4" && e.size === 1 && !e.isArray,
        code: e => `
                cv = ud["${e}"].value;
                v = uv["${e}"];

                if(cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
                {
                    cv[0] = v[0];
                    cv[1] = v[1];
                    cv[2] = v[2];
                    cv[3] = v[3];

                    gl.uniform4f(ud["${e}"].location, v[0], v[1], v[2], v[3])
                }`
    }],
    T4 = {
        float: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1f(location, v);
    }`,
        vec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2f(location, v[0], v[1])
    }`,
        vec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3f(location, v[0], v[1], v[2])
    }`,
        vec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4f(location, v[0], v[1], v[2], v[3]);
    }`,
        int: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        ivec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        ivec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        ivec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        uint: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1ui(location, v);
    }`,
        uvec2: `
    if (cv[0] !== v[0] || cv[1] !== v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2ui(location, v[0], v[1]);
    }`,
        uvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3ui(location, v[0], v[1], v[2]);
    }`,
        uvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4ui(location, v[0], v[1], v[2], v[3]);
    }`,
        bool: `
    if (cv !== v)
    {
        cu.value = v;
        gl.uniform1i(location, v);
    }`,
        bvec2: `
    if (cv[0] != v[0] || cv[1] != v[1])
    {
        cv[0] = v[0];
        cv[1] = v[1];

        gl.uniform2i(location, v[0], v[1]);
    }`,
        bvec3: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];

        gl.uniform3i(location, v[0], v[1], v[2]);
    }`,
        bvec4: `
    if (cv[0] !== v[0] || cv[1] !== v[1] || cv[2] !== v[2] || cv[3] !== v[3])
    {
        cv[0] = v[0];
        cv[1] = v[1];
        cv[2] = v[2];
        cv[3] = v[3];

        gl.uniform4i(location, v[0], v[1], v[2], v[3]);
    }`,
        mat2: "gl.uniformMatrix2fv(location, false, v)",
        mat3: "gl.uniformMatrix3fv(location, false, v)",
        mat4: "gl.uniformMatrix4fv(location, false, v)",
        sampler2D: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        samplerCube: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`,
        sampler2DArray: `
    if (cv !== v)
    {
        cu.value = v;

        gl.uniform1i(location, v);
    }`
    },
    E4 = {
        float: "gl.uniform1fv(location, v)",
        vec2: "gl.uniform2fv(location, v)",
        vec3: "gl.uniform3fv(location, v)",
        vec4: "gl.uniform4fv(location, v)",
        mat4: "gl.uniformMatrix4fv(location, false, v)",
        mat3: "gl.uniformMatrix3fv(location, false, v)",
        mat2: "gl.uniformMatrix2fv(location, false, v)",
        int: "gl.uniform1iv(location, v)",
        ivec2: "gl.uniform2iv(location, v)",
        ivec3: "gl.uniform3iv(location, v)",
        ivec4: "gl.uniform4iv(location, v)",
        uint: "gl.uniform1uiv(location, v)",
        uvec2: "gl.uniform2uiv(location, v)",
        uvec3: "gl.uniform3uiv(location, v)",
        uvec4: "gl.uniform4uiv(location, v)",
        bool: "gl.uniform1iv(location, v)",
        bvec2: "gl.uniform2iv(location, v)",
        bvec3: "gl.uniform3iv(location, v)",
        bvec4: "gl.uniform4iv(location, v)",
        sampler2D: "gl.uniform1iv(location, v)",
        samplerCube: "gl.uniform1iv(location, v)",
        sampler2DArray: "gl.uniform1iv(location, v)"
    };

function S4(e, t) {
    const i = [`
        var v = null;
        var cv = null;
        var cu = null;
        var t = 0;
        var gl = renderer.gl;
    `];
    for (const s in e.uniforms) {
        const n = t[s];
        if (!n) {
            e.uniforms[s]?.group && (e.uniforms[s].ubo ? i.push(`
                        renderer.shader.syncUniformBufferGroup(uv.${s}, '${s}');
                    `) : i.push(`
                        renderer.shader.syncUniformGroup(uv.${s}, syncData);
                    `));
            continue
        }
        const r = e.uniforms[s];
        let o = !1;
        for (let a = 0; a < _o.length; a++)
            if (_o[a].test(n, r)) {
                i.push(_o[a].code(s, r)), o = !0;
                break
            } if (!o) {
            const l = (n.size === 1 && !n.isArray ? T4 : E4)[n.type].replace("location", `ud["${s}"].location`);
            i.push(`
            cu = ud["${s}"];
            cv = cu.value;
            v = uv["${s}"];
            ${l};`)
        }
    }
    return new Function("ud", "uv", "renderer", "syncData", i.join(`
`))
}
const D_ = {};
let Tl = D_;

function C4() {
    if (Tl === D_ || Tl?.isContextLost()) {
        const e = ut.ADAPTER.createCanvas();
        let t;
        ut.PREFER_ENV >= Lr.WEBGL2 && (t = e.getContext("webgl2", {})), t || (t = e.getContext("webgl", {}) || e.getContext("experimental-webgl", {}), t ? t.getExtension("WEBGL_draw_buffers") : t = null), Tl = t
    }
    return Tl
}
let El;

function A4() {
    if (!El) {
        El = Vi.MEDIUM;
        const e = C4();
        e && e.getShaderPrecisionFormat && (El = e.getShaderPrecisionFormat(e.FRAGMENT_SHADER, e.HIGH_FLOAT).precision ? Vi.HIGH : Vi.MEDIUM)
    }
    return El
}

function rg(e, t) {
    const i = e.getShaderSource(t).split(`
`).map((c, h) => `${h}: ${c}`),
        s = e.getShaderInfoLog(t),
        n = s.split(`
`),
        r = {},
        o = n.map(c => parseFloat(c.replace(/^ERROR\: 0\:([\d]+)\:.*$/, "$1"))).filter(c => c && !r[c] ? (r[c] = !0, !0) : !1),
        a = [""];
    o.forEach(c => {
        i[c - 1] = `%c${i[c-1]}%c`, a.push("background: #FF0000; color:#FFFFFF; font-size: 10px", "font-size: 10px")
    });
    const l = i.join(`
`);
    a[0] = l, console.error(s), console.groupCollapsed("click to view full shader code"), console.warn(...a), console.groupEnd()
}

function I4(e, t, i, s) {
    e.getProgramParameter(t, e.LINK_STATUS) || (e.getShaderParameter(i, e.COMPILE_STATUS) || rg(e, i), e.getShaderParameter(s, e.COMPILE_STATUS) || rg(e, s), console.error("PixiJS Error: Could not initialize shader."), e.getProgramInfoLog(t) !== "" && console.warn("PixiJS Warning: gl.getProgramInfoLog()", e.getProgramInfoLog(t)))
}
const M4 = {
    float: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    int: 1,
    ivec2: 2,
    ivec3: 3,
    ivec4: 4,
    uint: 1,
    uvec2: 2,
    uvec3: 3,
    uvec4: 4,
    bool: 1,
    bvec2: 2,
    bvec3: 3,
    bvec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16,
    sampler2D: 1
};

function N_(e) {
    return M4[e]
}
let Sl = null;
const og = {
    FLOAT: "float",
    FLOAT_VEC2: "vec2",
    FLOAT_VEC3: "vec3",
    FLOAT_VEC4: "vec4",
    INT: "int",
    INT_VEC2: "ivec2",
    INT_VEC3: "ivec3",
    INT_VEC4: "ivec4",
    UNSIGNED_INT: "uint",
    UNSIGNED_INT_VEC2: "uvec2",
    UNSIGNED_INT_VEC3: "uvec3",
    UNSIGNED_INT_VEC4: "uvec4",
    BOOL: "bool",
    BOOL_VEC2: "bvec2",
    BOOL_VEC3: "bvec3",
    BOOL_VEC4: "bvec4",
    FLOAT_MAT2: "mat2",
    FLOAT_MAT3: "mat3",
    FLOAT_MAT4: "mat4",
    SAMPLER_2D: "sampler2D",
    INT_SAMPLER_2D: "sampler2D",
    UNSIGNED_INT_SAMPLER_2D: "sampler2D",
    SAMPLER_CUBE: "samplerCube",
    INT_SAMPLER_CUBE: "samplerCube",
    UNSIGNED_INT_SAMPLER_CUBE: "samplerCube",
    SAMPLER_2D_ARRAY: "sampler2DArray",
    INT_SAMPLER_2D_ARRAY: "sampler2DArray",
    UNSIGNED_INT_SAMPLER_2D_ARRAY: "sampler2DArray"
};

function F_(e, t) {
    if (!Sl) {
        const i = Object.keys(og);
        Sl = {};
        for (let s = 0; s < i.length; ++s) {
            const n = i[s];
            Sl[e[n]] = og[n]
        }
    }
    return Sl[t]
}

function ag(e, t, i) {
    if (e.substring(0, 9) !== "precision") {
        let s = t;
        return t === Vi.HIGH && i !== Vi.HIGH && (s = Vi.MEDIUM), `precision ${s} float;
${e}`
    } else if (i !== Vi.HIGH && e.substring(0, 15) === "precision highp") return e.replace("precision highp", "precision mediump");
    return e
}
let Qo;

function R4() {
    if (typeof Qo == "boolean") return Qo;
    try {
        Qo = new Function("param1", "param2", "param3", "return param1[param2] === param3;")({
            a: "b"
        }, "a", "b") === !0
    } catch {
        Qo = !1
    }
    return Qo
}
let k4 = 0;
const Cl = {},
    io = class {
        constructor(e, t, i = "pixi-shader", s = {}) {
            this.extra = {}, this.id = k4++, this.vertexSrc = e || io.defaultVertexSrc, this.fragmentSrc = t || io.defaultFragmentSrc, this.vertexSrc = this.vertexSrc.trim(), this.fragmentSrc = this.fragmentSrc.trim(), this.extra = s, this.vertexSrc.substring(0, 8) !== "#version" && (i = i.replace(/\s+/g, "-"), Cl[i] ? (Cl[i]++, i += `-${Cl[i]}`) : Cl[i] = 1, this.vertexSrc = `#define SHADER_NAME ${i}
${this.vertexSrc}`, this.fragmentSrc = `#define SHADER_NAME ${i}
${this.fragmentSrc}`, this.vertexSrc = ag(this.vertexSrc, io.defaultVertexPrecision, Vi.HIGH), this.fragmentSrc = ag(this.fragmentSrc, io.defaultFragmentPrecision, A4())), this.glPrograms = {}, this.syncUniforms = null
        }
        static get defaultVertexSrc() {
            return w4
        }
        static get defaultFragmentSrc() {
            return x4
        }
        static from(e, t, i) {
            const s = e + t;
            let n = rd[s];
            return n || (rd[s] = n = new io(e, t, i)), n
        }
    };
let os = io;
os.defaultVertexPrecision = Vi.HIGH;
os.defaultFragmentPrecision = Is.apple.device ? Vi.HIGH : Vi.MEDIUM;
let P4 = 0;
class hs {
    constructor(t, i, s) {
        this.group = !0, this.syncUniforms = {}, this.dirtyId = 0, this.id = P4++, this.static = !!i, this.ubo = !!s, t instanceof Ne ? (this.buffer = t, this.buffer.type = Ps.UNIFORM_BUFFER, this.autoManage = !1, this.ubo = !0) : (this.uniforms = t, this.ubo && (this.buffer = new Ne(new Float32Array(1)), this.buffer.type = Ps.UNIFORM_BUFFER, this.autoManage = !0))
    }
    update() {
        this.dirtyId++, !this.autoManage && this.buffer && this.buffer.update()
    }
    add(t, i, s) {
        if (!this.ubo) this.uniforms[t] = new hs(i, s);
        else throw new Error("[UniformGroup] uniform groups in ubo mode cannot be modified, or have uniform groups nested in them")
    }
    static from(t, i, s) {
        return new hs(t, i, s)
    }
    static uboFrom(t, i) {
        return new hs(t, i ?? !0, !0)
    }
}
class Ls {
    constructor(t, i) {
        this.uniformBindCount = 0, this.program = t, i ? i instanceof hs ? this.uniformGroup = i : this.uniformGroup = new hs(i) : this.uniformGroup = new hs({}), this.disposeRunner = new cs("disposeShader")
    }
    checkUniformExists(t, i) {
        if (i.uniforms[t]) return !0;
        for (const s in i.uniforms) {
            const n = i.uniforms[s];
            if (n.group && this.checkUniformExists(t, n)) return !0
        }
        return !1
    }
    destroy() {
        this.uniformGroup = null, this.disposeRunner.emit(this), this.disposeRunner.destroy()
    }
    get uniforms() {
        return this.uniformGroup.uniforms
    }
    static from(t, i, s) {
        const n = os.from(t, i);
        return new Ls(n, s)
    }
}
class L4 {
    constructor(t, i) {
        if (this.vertexSrc = t, this.fragTemplate = i, this.programCache = {}, this.defaultGroupCache = {}, !i.includes("%count%")) throw new Error('Fragment template must contain "%count%".');
        if (!i.includes("%forloop%")) throw new Error('Fragment template must contain "%forloop%".')
    }
    generateShader(t) {
        if (!this.programCache[t]) {
            const s = new Int32Array(t);
            for (let r = 0; r < t; r++) s[r] = r;
            this.defaultGroupCache[t] = hs.from({
                uSamplers: s
            }, !0);
            let n = this.fragTemplate;
            n = n.replace(/%count%/gi, `${t}`), n = n.replace(/%forloop%/gi, this.generateSampleSrc(t)), this.programCache[t] = new os(this.vertexSrc, n)
        }
        const i = {
            tint: new Float32Array([1, 1, 1, 1]),
            translationMatrix: new pe,
            default: this.defaultGroupCache[t]
        };
        return new Ls(this.programCache[t], i)
    }
    generateSampleSrc(t) {
        let i = "";
        i += `
`, i += `
`;
        for (let s = 0; s < t; s++) s > 0 && (i += `
else `), s < t - 1 && (i += `if(vTextureId < ${s}.5)`), i += `
{`, i += `
	color = texture2D(uSamplers[${s}], vTextureCoord);`, i += `
}`;
        return i += `
`, i += `
`, i
    }
}
class ud {
    constructor() {
        this.elements = [], this.ids = [], this.count = 0
    }
    clear() {
        for (let t = 0; t < this.count; t++) this.elements[t] = null;
        this.count = 0
    }
}

function O4() {
    return !Is.apple.device
}

function D4(e) {
    let t = !0;
    const i = ut.ADAPTER.getNavigator();
    if (Is.tablet || Is.phone) {
        if (Is.apple.device) {
            const s = i.userAgent.match(/OS (\d+)_(\d+)?/);
            s && parseInt(s[1], 10) < 11 && (t = !1)
        }
        if (Is.android.device) {
            const s = i.userAgent.match(/Android\s([0-9.]*)/);
            s && parseInt(s[1], 10) < 7 && (t = !1)
        }
    }
    return t ? e : 4
}
class dh {
    constructor(t) {
        this.renderer = t
    }
    flush() {}
    destroy() {
        this.renderer = null
    }
    start() {}
    stop() {
        this.flush()
    }
    render(t) {}
}
var N4 = `varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;
uniform sampler2D uSamplers[%count%];

void main(void){
    vec4 color;
    %forloop%
    gl_FragColor = color * vColor;
}
`,
    F4 = `precision highp float;
attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;
attribute float aTextureId;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform vec4 tint;

varying vec2 vTextureCoord;
varying vec4 vColor;
varying float vTextureId;

void main(void){
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vTextureId = aTextureId;
    vColor = aColor * tint;
}
`;
const qi = class extends dh {
    constructor(e) {
        super(e), this.setShaderGenerator(), this.geometryClass = k_, this.vertexSize = 6, this.state = rn.for2d(), this.size = qi.defaultBatchSize * 4, this._vertexCount = 0, this._indexCount = 0, this._bufferedElements = [], this._bufferedTextures = [], this._bufferSize = 0, this._shader = null, this._packedGeometries = [], this._packedGeometryPoolSize = 2, this._flushId = 0, this._aBuffers = {}, this._iBuffers = {}, this.maxTextures = 1, this.renderer.on("prerender", this.onPrerender, this), e.runners.contextChange.add(this), this._dcIndex = 0, this._aIndex = 0, this._iIndex = 0, this._attributeBuffer = null, this._indexBuffer = null, this._tempBoundTextures = []
    }
    static get defaultMaxTextures() {
        return this._defaultMaxTextures = this._defaultMaxTextures ?? D4(32), this._defaultMaxTextures
    }
    static set defaultMaxTextures(e) {
        this._defaultMaxTextures = e
    }
    static get canUploadSameBuffer() {
        return this._canUploadSameBuffer = this._canUploadSameBuffer ?? O4(), this._canUploadSameBuffer
    }
    static set canUploadSameBuffer(e) {
        this._canUploadSameBuffer = e
    }
    get MAX_TEXTURES() {
        return Qt("7.1.0", "BatchRenderer#MAX_TEXTURES renamed to BatchRenderer#maxTextures"), this.maxTextures
    }
    static get defaultVertexSrc() {
        return F4
    }
    static get defaultFragmentTemplate() {
        return N4
    }
    setShaderGenerator({
        vertex: e = qi.defaultVertexSrc,
        fragment: t = qi.defaultFragmentTemplate
    } = {}) {
        this.shaderGenerator = new L4(e, t)
    }
    contextChange() {
        const e = this.renderer.gl;
        ut.PREFER_ENV === Lr.WEBGL_LEGACY ? this.maxTextures = 1 : (this.maxTextures = Math.min(e.getParameter(e.MAX_TEXTURE_IMAGE_UNITS), qi.defaultMaxTextures), this.maxTextures = u4(this.maxTextures, e)), this._shader = this.shaderGenerator.generateShader(this.maxTextures);
        for (let t = 0; t < this._packedGeometryPoolSize; t++) this._packedGeometries[t] = new this.geometryClass;
        this.initFlushBuffers()
    }
    initFlushBuffers() {
        const {
            _drawCallPool: e,
            _textureArrayPool: t
        } = qi, i = this.size / 4, s = Math.floor(i / this.maxTextures) + 1;
        for (; e.length < i;) e.push(new cd);
        for (; t.length < s;) t.push(new ud);
        for (let n = 0; n < this.maxTextures; n++) this._tempBoundTextures[n] = null
    }
    onPrerender() {
        this._flushId = 0
    }
    render(e) {
        !e._texture.valid || (this._vertexCount + e.vertexData.length / 2 > this.size && this.flush(), this._vertexCount += e.vertexData.length / 2, this._indexCount += e.indices.length, this._bufferedTextures[this._bufferSize] = e._texture.baseTexture, this._bufferedElements[this._bufferSize++] = e)
    }
    buildTexturesAndDrawCalls() {
        const {
            _bufferedTextures: e,
            maxTextures: t
        } = this, i = qi._textureArrayPool, s = this.renderer.batch, n = this._tempBoundTextures, r = this.renderer.textureGC.count;
        let o = ++Nt._globalBatch,
            a = 0,
            l = i[0],
            c = 0;
        s.copyBoundTextures(n, t);
        for (let h = 0; h < this._bufferSize; ++h) {
            const u = e[h];
            e[h] = null, u._batchEnabled !== o && (l.count >= t && (s.boundArray(l, n, o, t), this.buildDrawCalls(l, c, h), c = h, l = i[++a], ++o), u._batchEnabled = o, u.touched = r, l.elements[l.count++] = u)
        }
        l.count > 0 && (s.boundArray(l, n, o, t), this.buildDrawCalls(l, c, this._bufferSize), ++a, ++o);
        for (let h = 0; h < n.length; h++) n[h] = null;
        Nt._globalBatch = o
    }
    buildDrawCalls(e, t, i) {
        const {
            _bufferedElements: s,
            _attributeBuffer: n,
            _indexBuffer: r,
            vertexSize: o
        } = this, a = qi._drawCallPool;
        let l = this._dcIndex,
            c = this._aIndex,
            h = this._iIndex,
            u = a[l];
        u.start = this._iIndex, u.texArray = e;
        for (let d = t; d < i; ++d) {
            const f = s[d],
                p = f._texture.baseTexture,
                m = Nf[p.alphaMode ? 1 : 0][f.blendMode];
            s[d] = null, t < d && u.blend !== m && (u.size = h - u.start, t = d, u = a[++l], u.texArray = e, u.start = h), this.packInterleavedGeometry(f, n, r, c, h), c += f.vertexData.length / 2 * o, h += f.indices.length, u.blend = m
        }
        t < i && (u.size = h - u.start, ++l), this._dcIndex = l, this._aIndex = c, this._iIndex = h
    }
    bindAndClearTexArray(e) {
        const t = this.renderer.texture;
        for (let i = 0; i < e.count; i++) t.bind(e.elements[i], e.ids[i]), e.elements[i] = null;
        e.count = 0
    }
    updateGeometry() {
        const {
            _packedGeometries: e,
            _attributeBuffer: t,
            _indexBuffer: i
        } = this;
        qi.canUploadSameBuffer ? (e[this._flushId]._buffer.update(t.rawBinaryData), e[this._flushId]._indexBuffer.update(i), this.renderer.geometry.updateBuffers()) : (this._packedGeometryPoolSize <= this._flushId && (this._packedGeometryPoolSize++, e[this._flushId] = new this.geometryClass), e[this._flushId]._buffer.update(t.rawBinaryData), e[this._flushId]._indexBuffer.update(i), this.renderer.geometry.bind(e[this._flushId]), this.renderer.geometry.updateBuffers(), this._flushId++)
    }
    drawBatches() {
        const e = this._dcIndex,
            {
                gl: t,
                state: i
            } = this.renderer,
            s = qi._drawCallPool;
        let n = null;
        for (let r = 0; r < e; r++) {
            const {
                texArray: o,
                type: a,
                size: l,
                start: c,
                blend: h
            } = s[r];
            n !== o && (n = o, this.bindAndClearTexArray(o)), this.state.blendMode = h, i.set(this.state), t.drawElements(a, l, t.UNSIGNED_SHORT, c * 2)
        }
    }
    flush() {
        this._vertexCount !== 0 && (this._attributeBuffer = this.getAttributeBuffer(this._vertexCount), this._indexBuffer = this.getIndexBuffer(this._indexCount), this._aIndex = 0, this._iIndex = 0, this._dcIndex = 0, this.buildTexturesAndDrawCalls(), this.updateGeometry(), this.drawBatches(), this._bufferSize = 0, this._vertexCount = 0, this._indexCount = 0)
    }
    start() {
        this.renderer.state.set(this.state), this.renderer.texture.ensureSamplerType(this.maxTextures), this.renderer.shader.bind(this._shader), qi.canUploadSameBuffer && this.renderer.geometry.bind(this._packedGeometries[this._flushId])
    }
    stop() {
        this.flush()
    }
    destroy() {
        for (let e = 0; e < this._packedGeometryPoolSize; e++) this._packedGeometries[e] && this._packedGeometries[e].destroy();
        this.renderer.off("prerender", this.onPrerender, this), this._aBuffers = null, this._iBuffers = null, this._packedGeometries = null, this._attributeBuffer = null, this._indexBuffer = null, this._shader && (this._shader.destroy(), this._shader = null), super.destroy()
    }
    getAttributeBuffer(e) {
        const t = Ba(Math.ceil(e / 8)),
            i = nd(t),
            s = t * 8;
        this._aBuffers.length <= i && (this._iBuffers.length = i + 1);
        let n = this._aBuffers[s];
        return n || (this._aBuffers[s] = n = new ad(s * this.vertexSize * 4)), n
    }
    getIndexBuffer(e) {
        const t = Ba(Math.ceil(e / 12)),
            i = nd(t),
            s = t * 12;
        this._iBuffers.length <= i && (this._iBuffers.length = i + 1);
        let n = this._iBuffers[i];
        return n || (this._iBuffers[i] = n = new Uint16Array(s)), n
    }
    packInterleavedGeometry(e, t, i, s, n) {
        const {
            uint32View: r,
            float32View: o
        } = t, a = s / this.vertexSize, l = e.uvs, c = e.indices, h = e.vertexData, u = e._texture.baseTexture._batchLocation, d = Math.min(e.worldAlpha, 1), f = d < 1 && e._texture.baseTexture.alphaMode ? ch(e._tintRGB, d) : e._tintRGB + (d * 255 << 24);
        for (let p = 0; p < h.length; p += 2) o[s++] = h[p], o[s++] = h[p + 1], o[s++] = l[p], o[s++] = l[p + 1], r[s++] = f, o[s++] = u;
        for (let p = 0; p < c.length; p++) i[n++] = a + c[p]
    }
};
let ss = qi;
ss.defaultBatchSize = 4096;
ss.extension = {
    name: "batch",
    type: lt.RendererPlugin
};
ss._drawCallPool = [];
ss._textureArrayPool = [];
vt.add(ss);
var B4 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;

void main(void){
   gl_FragColor = texture2D(uSampler, vTextureCoord);
}
`,
    U4 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const pa = class extends Ls {
    constructor(e, t, i) {
        const s = os.from(e || pa.defaultVertexSrc, t || pa.defaultFragmentSrc);
        super(s, i), this.padding = 0, this.resolution = pa.defaultResolution, this.multisample = pa.defaultMultisample, this.enabled = !0, this.autoFit = !0, this.state = new rn
    }
    apply(e, t, i, s, n) {
        e.applyFilter(this, t, i, s)
    }
    get blendMode() {
        return this.state.blendMode
    }
    set blendMode(e) {
        this.state.blendMode = e
    }
    get resolution() {
        return this._resolution
    }
    set resolution(e) {
        this._resolution = e
    }
    static get defaultVertexSrc() {
        return U4
    }
    static get defaultFragmentSrc() {
        return B4
    }
};
let oi = pa;
oi.defaultResolution = 1;
oi.defaultMultisample = Fe.NONE;
class B_ {
    constructor() {
        this.clearBeforeRender = !0, this._backgroundColor = 0, this._backgroundColorRgba = [0, 0, 0, 1], this._backgroundColorString = "#000000", this.color = this._backgroundColor, this.alpha = 1
    }
    init(t) {
        this.clearBeforeRender = t.clearBeforeRender, t.color && (this.color = typeof t.color == "string" ? lh(t.color) : t.color), this.alpha = t.alpha
    }
    get color() {
        return this._backgroundColor
    }
    set color(t) {
        this._backgroundColor = t, this._backgroundColorString = ah(t), tn(t, this._backgroundColorRgba)
    }
    get alpha() {
        return this._backgroundColorRgba[3]
    }
    set alpha(t) {
        this._backgroundColorRgba[3] = t
    }
    get colorRgba() {
        return this._backgroundColorRgba
    }
    get colorString() {
        return this._backgroundColorString
    }
    destroy() {}
}
B_.extension = {
    type: [lt.RendererSystem, lt.CanvasRendererSystem],
    name: "background"
};
vt.add(B_);
class U_ {
    constructor(t) {
        this.renderer = t, this.emptyRenderer = new dh(t), this.currentRenderer = this.emptyRenderer
    }
    setObjectRenderer(t) {
        this.currentRenderer !== t && (this.currentRenderer.stop(), this.currentRenderer = t, this.currentRenderer.start())
    }
    flush() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    reset() {
        this.setObjectRenderer(this.emptyRenderer)
    }
    copyBoundTextures(t, i) {
        const {
            boundTextures: s
        } = this.renderer.texture;
        for (let n = i - 1; n >= 0; --n) t[n] = s[n] || null, t[n] && (t[n]._batchLocation = n)
    }
    boundArray(t, i, s, n) {
        const {
            elements: r,
            ids: o,
            count: a
        } = t;
        let l = 0;
        for (let c = 0; c < a; c++) {
            const h = r[c],
                u = h._batchLocation;
            if (u >= 0 && u < n && i[u] === h) {
                o[c] = u;
                continue
            }
            for (; l < n;) {
                const d = i[l];
                if (d && d._batchEnabled === s && d._batchLocation === l) {
                    l++;
                    continue
                }
                o[c] = l, h._batchLocation = l, i[l] = h;
                break
            }
        }
    }
    destroy() {
        this.renderer = null
    }
}
U_.extension = {
    type: lt.RendererSystem,
    name: "batch"
};
vt.add(U_);
let lg = 0;
class G_ {
    constructor(t) {
        this.renderer = t, this.webGLVersion = 1, this.extensions = {}, this.supports = {
            uint32Indices: !1
        }, this.handleContextLost = this.handleContextLost.bind(this), this.handleContextRestored = this.handleContextRestored.bind(this)
    }
    get isLost() {
        return !this.gl || this.gl.isContextLost()
    }
    contextChange(t) {
        this.gl = t, this.renderer.gl = t, this.renderer.CONTEXT_UID = lg++
    }
    init(t) {
        if (t.context) this.initFromContext(t.context);
        else {
            const i = this.renderer.background.alpha < 1,
                s = t.premultipliedAlpha;
            this.preserveDrawingBuffer = t.preserveDrawingBuffer, this.useContextAlpha = t.useContextAlpha, this.powerPreference = t.powerPreference, this.initFromOptions({
                alpha: i,
                premultipliedAlpha: s,
                antialias: t.antialias,
                stencil: !0,
                preserveDrawingBuffer: t.preserveDrawingBuffer,
                powerPreference: t.powerPreference
            })
        }
    }
    initFromContext(t) {
        this.gl = t, this.validateContext(t), this.renderer.gl = t, this.renderer.CONTEXT_UID = lg++, this.renderer.runners.contextChange.emit(t);
        const i = this.renderer.view;
        i.addEventListener !== void 0 && (i.addEventListener("webglcontextlost", this.handleContextLost, !1), i.addEventListener("webglcontextrestored", this.handleContextRestored, !1))
    }
    initFromOptions(t) {
        const i = this.createContext(this.renderer.view, t);
        this.initFromContext(i)
    }
    createContext(t, i) {
        let s;
        if (ut.PREFER_ENV >= Lr.WEBGL2 && (s = t.getContext("webgl2", i)), s) this.webGLVersion = 2;
        else if (this.webGLVersion = 1, s = t.getContext("webgl", i) || t.getContext("experimental-webgl", i), !s) throw new Error("This browser does not support WebGL. Try using the canvas renderer");
        return this.gl = s, this.getExtensions(), this.gl
    }
    getExtensions() {
        const {
            gl: t
        } = this, i = {
            loseContext: t.getExtension("WEBGL_lose_context"),
            anisotropicFiltering: t.getExtension("EXT_texture_filter_anisotropic"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            s3tc: t.getExtension("WEBGL_compressed_texture_s3tc"),
            s3tc_sRGB: t.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
            etc: t.getExtension("WEBGL_compressed_texture_etc"),
            etc1: t.getExtension("WEBGL_compressed_texture_etc1"),
            pvrtc: t.getExtension("WEBGL_compressed_texture_pvrtc") || t.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
            atc: t.getExtension("WEBGL_compressed_texture_atc"),
            astc: t.getExtension("WEBGL_compressed_texture_astc")
        };
        this.webGLVersion === 1 ? Object.assign(this.extensions, i, {
            drawBuffers: t.getExtension("WEBGL_draw_buffers"),
            depthTexture: t.getExtension("WEBGL_depth_texture"),
            vertexArrayObject: t.getExtension("OES_vertex_array_object") || t.getExtension("MOZ_OES_vertex_array_object") || t.getExtension("WEBKIT_OES_vertex_array_object"),
            uint32ElementIndex: t.getExtension("OES_element_index_uint"),
            floatTexture: t.getExtension("OES_texture_float"),
            floatTextureLinear: t.getExtension("OES_texture_float_linear"),
            textureHalfFloat: t.getExtension("OES_texture_half_float"),
            textureHalfFloatLinear: t.getExtension("OES_texture_half_float_linear")
        }) : this.webGLVersion === 2 && Object.assign(this.extensions, i, {
            colorBufferFloat: t.getExtension("EXT_color_buffer_float")
        })
    }
    handleContextLost(t) {
        t.preventDefault(), setTimeout(() => {
            this.gl.isContextLost() && this.extensions.loseContext && this.extensions.loseContext.restoreContext()
        }, 0)
    }
    handleContextRestored() {
        this.renderer.runners.contextChange.emit(this.gl)
    }
    destroy() {
        const t = this.renderer.view;
        this.renderer = null, t.removeEventListener !== void 0 && (t.removeEventListener("webglcontextlost", this.handleContextLost), t.removeEventListener("webglcontextrestored", this.handleContextRestored)), this.gl.useProgram(null), this.extensions.loseContext && this.extensions.loseContext.loseContext()
    }
    postrender() {
        this.renderer.objectRenderer.renderingToScreen && this.gl.flush()
    }
    validateContext(t) {
        const i = t.getContextAttributes(),
            s = "WebGL2RenderingContext" in globalThis && t instanceof globalThis.WebGL2RenderingContext;
        s && (this.webGLVersion = 2), i && !i.stencil && console.warn("Provided WebGL context does not have a stencil buffer, masks may not render correctly");
        const n = s || !!t.getExtension("OES_element_index_uint");
        this.supports.uint32Indices = n, n || console.warn("Provided WebGL context does not support 32 index buffer, complex graphics may not render correctly")
    }
}
G_.extension = {
    type: lt.RendererSystem,
    name: "context"
};
vt.add(G_);
class G4 extends qa {
    upload(t, i, s) {
        const n = t.gl;
        n.pixelStorei(n.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === _s.UNPACK);
        const r = i.realWidth,
            o = i.realHeight;
        return s.width === r && s.height === o ? n.texSubImage2D(i.target, 0, 0, 0, r, o, i.format, s.type, this.data) : (s.width = r, s.height = o, n.texImage2D(i.target, 0, s.internalFormat, r, o, 0, i.format, s.type, this.data)), !0
    }
}
class dd {
    constructor(t, i) {
        this.width = Math.round(t || 100), this.height = Math.round(i || 100), this.stencil = !1, this.depth = !1, this.dirtyId = 0, this.dirtyFormat = 0, this.dirtySize = 0, this.depthTexture = null, this.colorTextures = [], this.glFramebuffers = {}, this.disposeRunner = new cs("disposeFramebuffer"), this.multisample = Fe.NONE
    }
    get colorTexture() {
        return this.colorTextures[0]
    }
    addColorTexture(t = 0, i) {
        return this.colorTextures[t] = i || new Nt(null, {
            scaleMode: Hi.NEAREST,
            resolution: 1,
            mipmap: ds.OFF,
            width: this.width,
            height: this.height
        }), this.dirtyId++, this.dirtyFormat++, this
    }
    addDepthTexture(t) {
        return this.depthTexture = t || new Nt(new G4(null, {
            width: this.width,
            height: this.height
        }), {
            scaleMode: Hi.NEAREST,
            resolution: 1,
            width: this.width,
            height: this.height,
            mipmap: ds.OFF,
            format: ot.DEPTH_COMPONENT,
            type: Rt.UNSIGNED_SHORT
        }), this.dirtyId++, this.dirtyFormat++, this
    }
    enableDepth() {
        return this.depth = !0, this.dirtyId++, this.dirtyFormat++, this
    }
    enableStencil() {
        return this.stencil = !0, this.dirtyId++, this.dirtyFormat++, this
    }
    resize(t, i) {
        if (t = Math.round(t), i = Math.round(i), !(t === this.width && i === this.height)) {
            this.width = t, this.height = i, this.dirtyId++, this.dirtySize++;
            for (let s = 0; s < this.colorTextures.length; s++) {
                const n = this.colorTextures[s],
                    r = n.resolution;
                n.setSize(t / r, i / r)
            }
            if (this.depthTexture) {
                const s = this.depthTexture.resolution;
                this.depthTexture.setSize(t / s, i / s)
            }
        }
    }
    dispose() {
        this.disposeRunner.emit(this, !1)
    }
    destroyDepthTexture() {
        this.depthTexture && (this.depthTexture.destroy(), this.depthTexture = null, ++this.dirtyId, ++this.dirtyFormat)
    }
}
class Vf extends Nt {
    constructor(t = {}) {
        if (typeof t == "number") {
            const i = arguments[0],
                s = arguments[1],
                n = arguments[2],
                r = arguments[3];
            t = {
                width: i,
                height: s,
                scaleMode: n,
                resolution: r
            }
        }
        t.width = t.width || 100, t.height = t.height || 100, t.multisample ?? (t.multisample = Fe.NONE), super(null, t), this.mipmap = ds.OFF, this.valid = !0, this.clearColor = [0, 0, 0, 0], this.framebuffer = new dd(this.realWidth, this.realHeight).addColorTexture(0, this), this.framebuffer.multisample = t.multisample, this.maskStack = [], this.filterStack = [{}]
    }
    resize(t, i) {
        this.framebuffer.resize(t * this.resolution, i * this.resolution), this.setRealSize(this.framebuffer.width, this.framebuffer.height)
    }
    dispose() {
        this.framebuffer.dispose(), super.dispose()
    }
    destroy() {
        super.destroy(), this.framebuffer.destroyDepthTexture(), this.framebuffer = null
    }
}
class Dn extends Ua {
    constructor(t) {
        const i = t,
            s = i.naturalWidth || i.videoWidth || i.width,
            n = i.naturalHeight || i.videoHeight || i.height;
        super(s, n), this.source = t, this.noSubImage = !1
    }
    static crossOrigin(t, i, s) {
        s === void 0 && !i.startsWith("data:") ? t.crossOrigin = M_(i) : s !== !1 && (t.crossOrigin = typeof s == "string" ? s : "anonymous")
    }
    upload(t, i, s, n) {
        const r = t.gl,
            o = i.realWidth,
            a = i.realHeight;
        if (n = n || this.source, typeof HTMLImageElement < "u" && n instanceof HTMLImageElement) {
            if (!n.complete || n.naturalWidth === 0) return !1
        } else if (typeof HTMLVideoElement < "u" && n instanceof HTMLVideoElement && n.readyState <= 1 && n.buffered.length === 0) return !1;
        return r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, i.alphaMode === _s.UNPACK), !this.noSubImage && i.target === r.TEXTURE_2D && s.width === o && s.height === a ? r.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, i.format, s.type, n) : (s.width = o, s.height = a, r.texImage2D(i.target, 0, s.internalFormat, i.format, s.type, n)), !0
    }
    update() {
        if (this.destroyed) return;
        const t = this.source,
            i = t.naturalWidth || t.videoWidth || t.width,
            s = t.naturalHeight || t.videoHeight || t.height;
        this.resize(i, s), super.update()
    }
    dispose() {
        this.source = null
    }
}
class H_ extends Dn {
    constructor(t, i) {
        if (i = i || {}, typeof t == "string") {
            const s = new Image;
            Dn.crossOrigin(s, t, i.crossorigin), s.src = t, t = s
        }
        super(t), !t.complete && !!this._width && !!this._height && (this._width = 0, this._height = 0), this.url = t.src, this._process = null, this.preserveBitmap = !1, this.createBitmap = (i.createBitmap ?? ut.CREATE_IMAGE_BITMAP) && !!globalThis.createImageBitmap, this.alphaMode = typeof i.alphaMode == "number" ? i.alphaMode : null, this.bitmap = null, this._load = null, i.autoLoad !== !1 && this.load()
    }
    load(t) {
        return this._load ? this._load : (t !== void 0 && (this.createBitmap = t), this._load = new Promise((i, s) => {
            const n = this.source;
            this.url = n.src;
            const r = () => {
                this.destroyed || (n.onload = null, n.onerror = null, this.resize(n.width, n.height), this._load = null, this.createBitmap ? i(this.process()) : i(this))
            };
            n.complete && n.src ? r() : (n.onload = r, n.onerror = o => {
                s(o), this.onError.emit(o)
            })
        }), this._load)
    }
    process() {
        const t = this.source;
        if (this._process !== null) return this._process;
        if (this.bitmap !== null || !globalThis.createImageBitmap) return Promise.resolve(this);
        const i = globalThis.createImageBitmap,
            s = !t.crossOrigin || t.crossOrigin === "anonymous";
        return this._process = fetch(t.src, {
            mode: s ? "cors" : "no-cors"
        }).then(n => n.blob()).then(n => i(n, 0, 0, t.width, t.height, {
            premultiplyAlpha: this.alphaMode === null || this.alphaMode === _s.UNPACK ? "premultiply" : "none"
        })).then(n => this.destroyed ? Promise.reject() : (this.bitmap = n, this.update(), this._process = null, Promise.resolve(this))), this._process
    }
    upload(t, i, s) {
        if (typeof this.alphaMode == "number" && (i.alphaMode = this.alphaMode), !this.createBitmap) return super.upload(t, i, s);
        if (!this.bitmap && (this.process(), !this.bitmap)) return !1;
        if (super.upload(t, i, s, this.bitmap), !this.preserveBitmap) {
            let n = !0;
            const r = i._glTextures;
            for (const o in r) {
                const a = r[o];
                if (a !== s && a.dirtyId !== i.dirtyId) {
                    n = !1;
                    break
                }
            }
            n && (this.bitmap.close && this.bitmap.close(), this.bitmap = null)
        }
        return !0
    }
    dispose() {
        this.source.onload = null, this.source.onerror = null, super.dispose(), this.bitmap && (this.bitmap.close(), this.bitmap = null), this._process = null, this._load = null
    }
    static test(t) {
        return typeof HTMLImageElement < "u" && (typeof t == "string" || t instanceof HTMLImageElement)
    }
}
class V_ {
    constructor() {
        this.x0 = 0, this.y0 = 0, this.x1 = 1, this.y1 = 0, this.x2 = 1, this.y2 = 1, this.x3 = 0, this.y3 = 1, this.uvsFloat32 = new Float32Array(8)
    }
    set(t, i, s) {
        const n = i.width,
            r = i.height;
        if (s) {
            const o = t.width / 2 / n,
                a = t.height / 2 / r,
                l = t.x / n + o,
                c = t.y / r + a;
            s = Se.add(s, Se.NW), this.x0 = l + o * Se.uX(s), this.y0 = c + a * Se.uY(s), s = Se.add(s, 2), this.x1 = l + o * Se.uX(s), this.y1 = c + a * Se.uY(s), s = Se.add(s, 2), this.x2 = l + o * Se.uX(s), this.y2 = c + a * Se.uY(s), s = Se.add(s, 2), this.x3 = l + o * Se.uX(s), this.y3 = c + a * Se.uY(s)
        } else this.x0 = t.x / n, this.y0 = t.y / r, this.x1 = (t.x + t.width) / n, this.y1 = t.y / r, this.x2 = (t.x + t.width) / n, this.y2 = (t.y + t.height) / r, this.x3 = t.x / n, this.y3 = (t.y + t.height) / r;
        this.uvsFloat32[0] = this.x0, this.uvsFloat32[1] = this.y0, this.uvsFloat32[2] = this.x1, this.uvsFloat32[3] = this.y1, this.uvsFloat32[4] = this.x2, this.uvsFloat32[5] = this.y2, this.uvsFloat32[6] = this.x3, this.uvsFloat32[7] = this.y3
    }
    toString() {
        return `[@pixi/core:TextureUvs x0=${this.x0} y0=${this.y0} x1=${this.x1} y1=${this.y1} x2=${this.x2} y2=${this.y2} x3=${this.x3} y3=${this.y3}]`
    }
}
const cg = new V_;

function Al(e) {
    e.destroy = function() {}, e.on = function() {}, e.once = function() {}, e.emit = function() {}
}
class ht extends $o {
    constructor(t, i, s, n, r, o) {
        if (super(), this.noFrame = !1, i || (this.noFrame = !0, i = new qt(0, 0, 1, 1)), t instanceof ht && (t = t.baseTexture), this.baseTexture = t, this._frame = i, this.trim = n, this.valid = !1, this._uvs = cg, this.uvMatrix = null, this.orig = s || i, this._rotate = Number(r || 0), r === !0) this._rotate = 2;
        else if (this._rotate % 2 !== 0) throw new Error("attempt to use diamond-shaped UVs. If you are sure, set rotation manually");
        this.defaultAnchor = o ? new Zt(o.x, o.y) : new Zt(0, 0), this._updateID = 0, this.textureCacheIds = [], t.valid ? this.noFrame ? t.valid && this.onBaseTextureUpdated(t) : this.frame = i : t.once("loaded", this.onBaseTextureUpdated, this), this.noFrame && t.on("update", this.onBaseTextureUpdated, this)
    }
    update() {
        this.baseTexture.resource && this.baseTexture.resource.update()
    }
    onBaseTextureUpdated(t) {
        if (this.noFrame) {
            if (!this.baseTexture.valid) return;
            this._frame.width = t.width, this._frame.height = t.height, this.valid = !0, this.updateUvs()
        } else this.frame = this._frame;
        this.emit("update", this)
    }
    destroy(t) {
        if (this.baseTexture) {
            if (t) {
                const {
                    resource: i
                } = this.baseTexture;
                i?.url && ri[i.url] && ht.removeFromCache(i.url), this.baseTexture.destroy()
            }
            this.baseTexture.off("loaded", this.onBaseTextureUpdated, this), this.baseTexture.off("update", this.onBaseTextureUpdated, this), this.baseTexture = null
        }
        this._frame = null, this._uvs = null, this.trim = null, this.orig = null, this.valid = !1, ht.removeFromCache(this), this.textureCacheIds = null
    }
    clone() {
        const t = this._frame.clone(),
            i = this._frame === this.orig ? t : this.orig.clone(),
            s = new ht(this.baseTexture, !this.noFrame && t, i, this.trim?.clone(), this.rotate, this.defaultAnchor);
        return this.noFrame && (s._frame = t), s
    }
    updateUvs() {
        this._uvs === cg && (this._uvs = new V_), this._uvs.set(this._frame, this.baseTexture, this.rotate), this._updateID++
    }
    static from(t, i = {}, s = ut.STRICT_TEXTURE_CACHE) {
        const n = typeof t == "string";
        let r = null;
        if (n) r = t;
        else if (t instanceof Nt) {
            if (!t.cacheId) {
                const a = i?.pixiIdPrefix || "pixiid";
                t.cacheId = `${a}-${Ln()}`, Nt.addToCache(t, t.cacheId)
            }
            r = t.cacheId
        } else {
            if (!t._pixiId) {
                const a = i?.pixiIdPrefix || "pixiid";
                t._pixiId = `${a}_${Ln()}`
            }
            r = t._pixiId
        }
        let o = ri[r];
        if (n && s && !o) throw new Error(`The cacheId "${r}" does not exist in TextureCache.`);
        return !o && !(t instanceof Nt) ? (i.resolution || (i.resolution = en(t)), o = new ht(new Nt(t, i)), o.baseTexture.cacheId = r, Nt.addToCache(o.baseTexture, r), ht.addToCache(o, r)) : !o && t instanceof Nt && (o = new ht(t), ht.addToCache(o, r)), o
    }
    static fromURL(t, i) {
        const s = Object.assign({
                autoLoad: !1
            }, i?.resourceOptions),
            n = ht.from(t, Object.assign({
                resourceOptions: s
            }, i), !1),
            r = n.baseTexture.resource;
        return n.baseTexture.valid ? Promise.resolve(n) : r.load().then(() => Promise.resolve(n))
    }
    static fromBuffer(t, i, s, n) {
        return new ht(Nt.fromBuffer(t, i, s, n))
    }
    static fromLoader(t, i, s, n) {
        const r = new Nt(t, Object.assign({
                scaleMode: ut.SCALE_MODE,
                resolution: en(i)
            }, n)),
            {
                resource: o
            } = r;
        o instanceof H_ && (o.url = i);
        const a = new ht(r);
        return s || (s = i), Nt.addToCache(a.baseTexture, s), ht.addToCache(a, s), s !== i && (Nt.addToCache(a.baseTexture, i), ht.addToCache(a, i)), a.baseTexture.valid ? Promise.resolve(a) : new Promise(l => {
            a.baseTexture.once("loaded", () => l(a))
        })
    }
    static addToCache(t, i) {
        i && (t.textureCacheIds.includes(i) || t.textureCacheIds.push(i), ri[i] && ri[i] !== t && console.warn(`Texture added to the cache with an id [${i}] that already had an entry`), ri[i] = t)
    }
    static removeFromCache(t) {
        if (typeof t == "string") {
            const i = ri[t];
            if (i) {
                const s = i.textureCacheIds.indexOf(t);
                return s > -1 && i.textureCacheIds.splice(s, 1), delete ri[t], i
            }
        } else if (t?.textureCacheIds) {
            for (let i = 0; i < t.textureCacheIds.length; ++i) ri[t.textureCacheIds[i]] === t && delete ri[t.textureCacheIds[i]];
            return t.textureCacheIds.length = 0, t
        }
        return null
    }
    get resolution() {
        return this.baseTexture.resolution
    }
    get frame() {
        return this._frame
    }
    set frame(t) {
        this._frame = t, this.noFrame = !1;
        const {
            x: i,
            y: s,
            width: n,
            height: r
        } = t, o = i + n > this.baseTexture.width, a = s + r > this.baseTexture.height;
        if (o || a) {
            const l = o && a ? "and" : "or",
                c = `X: ${i} + ${n} = ${i+n} > ${this.baseTexture.width}`,
                h = `Y: ${s} + ${r} = ${s+r} > ${this.baseTexture.height}`;
            throw new Error(`Texture Error: frame does not fit inside the base Texture dimensions: ${c} ${l} ${h}`)
        }
        this.valid = n && r && this.baseTexture.valid, !this.trim && !this.rotate && (this.orig = t), this.valid && this.updateUvs()
    }
    get rotate() {
        return this._rotate
    }
    set rotate(t) {
        this._rotate = t, this.valid && this.updateUvs()
    }
    get width() {
        return this.orig.width
    }
    get height() {
        return this.orig.height
    }
    castToBaseTexture() {
        return this.baseTexture
    }
    static get EMPTY() {
        return ht._EMPTY || (ht._EMPTY = new ht(new Nt), Al(ht._EMPTY), Al(ht._EMPTY.baseTexture)), ht._EMPTY
    }
    static get WHITE() {
        if (!ht._WHITE) {
            const t = ut.ADAPTER.createCanvas(16, 16),
                i = t.getContext("2d");
            t.width = 16, t.height = 16, i.fillStyle = "white", i.fillRect(0, 0, 16, 16), ht._WHITE = new ht(Nt.from(t)), Al(ht._WHITE), Al(ht._WHITE.baseTexture)
        }
        return ht._WHITE
    }
}
class fs extends ht {
    constructor(t, i) {
        super(t, i), this.valid = !0, this.filterFrame = null, this.filterPoolKey = null, this.updateUvs()
    }
    get framebuffer() {
        return this.baseTexture.framebuffer
    }
    get multisample() {
        return this.framebuffer.multisample
    }
    set multisample(t) {
        this.framebuffer.multisample = t
    }
    resize(t, i, s = !0) {
        const n = this.baseTexture.resolution,
            r = Math.round(t * n) / n,
            o = Math.round(i * n) / n;
        this.valid = r > 0 && o > 0, this._frame.width = this.orig.width = r, this._frame.height = this.orig.height = o, s && this.baseTexture.resize(r, o), this.updateUvs()
    }
    setResolution(t) {
        const {
            baseTexture: i
        } = this;
        i.resolution !== t && (i.setResolution(t), this.resize(i.width, i.height, !1))
    }
    static create(t) {
        return new fs(new Vf(t))
    }
}
class z_ {
    constructor(t) {
        this.texturePool = {}, this.textureOptions = t || {}, this.enableFullScreen = !1, this._pixelsWidth = 0, this._pixelsHeight = 0
    }
    createTexture(t, i, s = Fe.NONE) {
        const n = new Vf(Object.assign({
            width: t,
            height: i,
            resolution: 1,
            multisample: s
        }, this.textureOptions));
        return new fs(n)
    }
    getOptimalTexture(t, i, s = 1, n = Fe.NONE) {
        let r;
        t = Math.ceil(t * s - 1e-6), i = Math.ceil(i * s - 1e-6), !this.enableFullScreen || t !== this._pixelsWidth || i !== this._pixelsHeight ? (t = Ba(t), i = Ba(i), r = ((t & 65535) << 16 | i & 65535) >>> 0, n > 1 && (r += n * 4294967296)) : r = n > 1 ? -n : -1, this.texturePool[r] || (this.texturePool[r] = []);
        let o = this.texturePool[r].pop();
        return o || (o = this.createTexture(t, i, n)), o.filterPoolKey = r, o.setResolution(s), o
    }
    getFilterTexture(t, i, s) {
        const n = this.getOptimalTexture(t.width, t.height, i || t.resolution, s || Fe.NONE);
        return n.filterFrame = t.filterFrame, n
    }
    returnTexture(t) {
        const i = t.filterPoolKey;
        t.filterFrame = null, this.texturePool[i].push(t)
    }
    returnFilterTexture(t) {
        this.returnTexture(t)
    }
    clear(t) {
        if (t = t !== !1, t)
            for (const i in this.texturePool) {
                const s = this.texturePool[i];
                if (s)
                    for (let n = 0; n < s.length; n++) s[n].destroy(!0)
            }
        this.texturePool = {}
    }
    setScreenSize(t) {
        if (!(t.width === this._pixelsWidth && t.height === this._pixelsHeight)) {
            this.enableFullScreen = t.width > 0 && t.height > 0;
            for (const i in this.texturePool) {
                if (!(Number(i) < 0)) continue;
                const s = this.texturePool[i];
                if (s)
                    for (let n = 0; n < s.length; n++) s[n].destroy(!0);
                this.texturePool[i] = []
            }
            this._pixelsWidth = t.width, this._pixelsHeight = t.height
        }
    }
}
z_.SCREEN_KEY = -1;
class H4 extends On {
    constructor() {
        super(), this.addAttribute("aVertexPosition", new Float32Array([0, 0, 1, 0, 1, 1, 0, 1])).addIndex([0, 1, 3, 2])
    }
}
class $_ extends On {
    constructor() {
        super(), this.vertices = new Float32Array([-1, -1, 1, -1, 1, 1, -1, 1]), this.uvs = new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), this.vertexBuffer = new Ne(this.vertices), this.uvBuffer = new Ne(this.uvs), this.addAttribute("aVertexPosition", this.vertexBuffer).addAttribute("aTextureCoord", this.uvBuffer).addIndex([0, 1, 2, 0, 2, 3])
    }
    map(t, i) {
        let s = 0,
            n = 0;
        return this.uvs[0] = s, this.uvs[1] = n, this.uvs[2] = s + i.width / t.width, this.uvs[3] = n, this.uvs[4] = s + i.width / t.width, this.uvs[5] = n + i.height / t.height, this.uvs[6] = s, this.uvs[7] = n + i.height / t.height, s = i.x, n = i.y, this.vertices[0] = s, this.vertices[1] = n, this.vertices[2] = s + i.width, this.vertices[3] = n, this.vertices[4] = s + i.width, this.vertices[5] = n + i.height, this.vertices[6] = s, this.vertices[7] = n + i.height, this.invalidate(), this
    }
    invalidate() {
        return this.vertexBuffer._updateID++, this.uvBuffer._updateID++, this
    }
}
class V4 {
    constructor() {
        this.renderTexture = null, this.target = null, this.legacy = !1, this.resolution = 1, this.multisample = Fe.NONE, this.sourceFrame = new qt, this.destinationFrame = new qt, this.bindingSourceFrame = new qt, this.bindingDestinationFrame = new qt, this.filters = [], this.transform = null
    }
    clear() {
        this.target = null, this.filters = null, this.renderTexture = null
    }
}
const Il = [new Zt, new Zt, new Zt, new Zt],
    eu = new pe;
class j_ {
    constructor(t) {
        this.renderer = t, this.defaultFilterStack = [{}], this.texturePool = new z_, this.statePool = [], this.quad = new H4, this.quadUv = new $_, this.tempRect = new qt, this.activeState = {}, this.globalUniforms = new hs({
            outputFrame: new qt,
            inputSize: new Float32Array(4),
            inputPixel: new Float32Array(4),
            inputClamp: new Float32Array(4),
            resolution: 1,
            filterArea: new Float32Array(4),
            filterClamp: new Float32Array(4)
        }, !0), this.forceClear = !1, this.useMaxPadding = !1
    }
    init() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    push(t, i) {
        const s = this.renderer,
            n = this.defaultFilterStack,
            r = this.statePool.pop() || new V4,
            o = this.renderer.renderTexture;
        let a = i[0].resolution,
            l = i[0].multisample,
            c = i[0].padding,
            h = i[0].autoFit,
            u = i[0].legacy ?? !0;
        for (let p = 1; p < i.length; p++) {
            const m = i[p];
            a = Math.min(a, m.resolution), l = Math.min(l, m.multisample), c = this.useMaxPadding ? Math.max(c, m.padding) : c + m.padding, h = h && m.autoFit, u = u || (m.legacy ?? !0)
        }
        n.length === 1 && (this.defaultFilterStack[0].renderTexture = o.current), n.push(r), r.resolution = a, r.multisample = l, r.legacy = u, r.target = t, r.sourceFrame.copyFrom(t.filterArea || t.getBounds(!0)), r.sourceFrame.pad(c);
        const d = this.tempRect.copyFrom(o.sourceFrame);
        s.projection.transform && this.transformAABB(eu.copyFrom(s.projection.transform).invert(), d), h ? (r.sourceFrame.fit(d), (r.sourceFrame.width <= 0 || r.sourceFrame.height <= 0) && (r.sourceFrame.width = 0, r.sourceFrame.height = 0)) : r.sourceFrame.intersects(d) || (r.sourceFrame.width = 0, r.sourceFrame.height = 0), this.roundFrame(r.sourceFrame, o.current ? o.current.resolution : s.resolution, o.sourceFrame, o.destinationFrame, s.projection.transform), r.renderTexture = this.getOptimalFilterTexture(r.sourceFrame.width, r.sourceFrame.height, a, l), r.filters = i, r.destinationFrame.width = r.renderTexture.width, r.destinationFrame.height = r.renderTexture.height;
        const f = this.tempRect;
        f.x = 0, f.y = 0, f.width = r.sourceFrame.width, f.height = r.sourceFrame.height, r.renderTexture.filterFrame = r.sourceFrame, r.bindingSourceFrame.copyFrom(o.sourceFrame), r.bindingDestinationFrame.copyFrom(o.destinationFrame), r.transform = s.projection.transform, s.projection.transform = null, o.bind(r.renderTexture, r.sourceFrame, f), s.framebuffer.clear(0, 0, 0, 0)
    }
    pop() {
        const t = this.defaultFilterStack,
            i = t.pop(),
            s = i.filters;
        this.activeState = i;
        const n = this.globalUniforms.uniforms;
        n.outputFrame = i.sourceFrame, n.resolution = i.resolution;
        const r = n.inputSize,
            o = n.inputPixel,
            a = n.inputClamp;
        if (r[0] = i.destinationFrame.width, r[1] = i.destinationFrame.height, r[2] = 1 / r[0], r[3] = 1 / r[1], o[0] = Math.round(r[0] * i.resolution), o[1] = Math.round(r[1] * i.resolution), o[2] = 1 / o[0], o[3] = 1 / o[1], a[0] = .5 * o[2], a[1] = .5 * o[3], a[2] = i.sourceFrame.width * r[2] - .5 * o[2], a[3] = i.sourceFrame.height * r[3] - .5 * o[3], i.legacy) {
            const c = n.filterArea;
            c[0] = i.destinationFrame.width, c[1] = i.destinationFrame.height, c[2] = i.sourceFrame.x, c[3] = i.sourceFrame.y, n.filterClamp = n.inputClamp
        }
        this.globalUniforms.update();
        const l = t[t.length - 1];
        if (this.renderer.framebuffer.blit(), s.length === 1) s[0].apply(this, i.renderTexture, l.renderTexture, Ss.BLEND, i), this.returnFilterTexture(i.renderTexture);
        else {
            let c = i.renderTexture,
                h = this.getOptimalFilterTexture(c.width, c.height, i.resolution);
            h.filterFrame = c.filterFrame;
            let u = 0;
            for (u = 0; u < s.length - 1; ++u) {
                u === 1 && i.multisample > 1 && (h = this.getOptimalFilterTexture(c.width, c.height, i.resolution), h.filterFrame = c.filterFrame), s[u].apply(this, c, h, Ss.CLEAR, i);
                const d = c;
                c = h, h = d
            }
            s[u].apply(this, c, l.renderTexture, Ss.BLEND, i), u > 1 && i.multisample > 1 && this.returnFilterTexture(i.renderTexture), this.returnFilterTexture(c), this.returnFilterTexture(h)
        }
        i.clear(), this.statePool.push(i)
    }
    bindAndClear(t, i = Ss.CLEAR) {
        const {
            renderTexture: s,
            state: n
        } = this.renderer;
        if (t === this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? this.renderer.projection.transform = this.activeState.transform : this.renderer.projection.transform = null, t?.filterFrame) {
            const o = this.tempRect;
            o.x = 0, o.y = 0, o.width = t.filterFrame.width, o.height = t.filterFrame.height, s.bind(t, t.filterFrame, o)
        } else t !== this.defaultFilterStack[this.defaultFilterStack.length - 1].renderTexture ? s.bind(t) : this.renderer.renderTexture.bind(t, this.activeState.bindingSourceFrame, this.activeState.bindingDestinationFrame);
        const r = n.stateId & 1 || this.forceClear;
        (i === Ss.CLEAR || i === Ss.BLIT && r) && this.renderer.framebuffer.clear(0, 0, 0, 0)
    }
    applyFilter(t, i, s, n) {
        const r = this.renderer;
        r.state.set(t.state), this.bindAndClear(s, n), t.uniforms.uSampler = i, t.uniforms.filterGlobals = this.globalUniforms, r.shader.bind(t), t.legacy = !!t.program.attributeData.aTextureCoord, t.legacy ? (this.quadUv.map(i._frame, i.filterFrame), r.geometry.bind(this.quadUv), r.geometry.draw(rs.TRIANGLES)) : (r.geometry.bind(this.quad), r.geometry.draw(rs.TRIANGLE_STRIP))
    }
    calculateSpriteMatrix(t, i) {
        const {
            sourceFrame: s,
            destinationFrame: n
        } = this.activeState, {
            orig: r
        } = i._texture, o = t.set(n.width, 0, 0, n.height, s.x, s.y), a = i.worldTransform.copyTo(pe.TEMP_MATRIX);
        return a.invert(), o.prepend(a), o.scale(1 / r.width, 1 / r.height), o.translate(i.anchor.x, i.anchor.y), o
    }
    destroy() {
        this.renderer = null, this.texturePool.clear(!1)
    }
    getOptimalFilterTexture(t, i, s = 1, n = Fe.NONE) {
        return this.texturePool.getOptimalTexture(t, i, s, n)
    }
    getFilterTexture(t, i, s) {
        if (typeof t == "number") {
            const r = t;
            t = i, i = r
        }
        t = t || this.activeState.renderTexture;
        const n = this.texturePool.getOptimalTexture(t.width, t.height, i || t.resolution, s || Fe.NONE);
        return n.filterFrame = t.filterFrame, n
    }
    returnFilterTexture(t) {
        this.texturePool.returnTexture(t)
    }
    emptyPool() {
        this.texturePool.clear(!0)
    }
    resize() {
        this.texturePool.setScreenSize(this.renderer.view)
    }
    transformAABB(t, i) {
        const s = Il[0],
            n = Il[1],
            r = Il[2],
            o = Il[3];
        s.set(i.left, i.top), n.set(i.left, i.bottom), r.set(i.right, i.top), o.set(i.right, i.bottom), t.apply(s, s), t.apply(n, n), t.apply(r, r), t.apply(o, o);
        const a = Math.min(s.x, n.x, r.x, o.x),
            l = Math.min(s.y, n.y, r.y, o.y),
            c = Math.max(s.x, n.x, r.x, o.x),
            h = Math.max(s.y, n.y, r.y, o.y);
        i.x = a, i.y = l, i.width = c - a, i.height = h - l
    }
    roundFrame(t, i, s, n, r) {
        if (!(t.width <= 0 || t.height <= 0 || s.width <= 0 || s.height <= 0)) {
            if (r) {
                const {
                    a: o,
                    b: a,
                    c: l,
                    d: c
                } = r;
                if ((Math.abs(a) > 1e-4 || Math.abs(l) > 1e-4) && (Math.abs(o) > 1e-4 || Math.abs(c) > 1e-4)) return
            }
            r = r ? eu.copyFrom(r) : eu.identity(), r.translate(-s.x, -s.y).scale(n.width / s.width, n.height / s.height).translate(n.x, n.y), this.transformAABB(r, t), t.ceil(i), this.transformAABB(r.invert(), t)
        }
    }
}
j_.extension = {
    type: lt.RendererSystem,
    name: "filter"
};
vt.add(j_);
class z4 {
    constructor(t) {
        this.framebuffer = t, this.stencil = null, this.dirtyId = -1, this.dirtyFormat = -1, this.dirtySize = -1, this.multisample = Fe.NONE, this.msaaBuffer = null, this.blitFramebuffer = null, this.mipLevel = 0
    }
}
const $4 = new qt;
class W_ {
    constructor(t) {
        this.renderer = t, this.managedFramebuffers = [], this.unknownFramebuffer = new dd(10, 10), this.msaaSamples = null
    }
    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.current = this.unknownFramebuffer, this.viewport = new qt, this.hasMRT = !0, this.writeDepthTexture = !0, this.renderer.context.webGLVersion === 1) {
            let i = this.renderer.context.extensions.drawBuffers,
                s = this.renderer.context.extensions.depthTexture;
            ut.PREFER_ENV === Lr.WEBGL_LEGACY && (i = null, s = null), i ? t.drawBuffers = n => i.drawBuffersWEBGL(n) : (this.hasMRT = !1, t.drawBuffers = () => {}), s || (this.writeDepthTexture = !1)
        } else this.msaaSamples = t.getInternalformatParameter(t.RENDERBUFFER, t.RGBA8, t.SAMPLES)
    }
    bind(t, i, s = 0) {
        const {
            gl: n
        } = this;
        if (t) {
            const r = t.glFramebuffers[this.CONTEXT_UID] || this.initFramebuffer(t);
            this.current !== t && (this.current = t, n.bindFramebuffer(n.FRAMEBUFFER, r.framebuffer)), r.mipLevel !== s && (t.dirtyId++, t.dirtyFormat++, r.mipLevel = s), r.dirtyId !== t.dirtyId && (r.dirtyId = t.dirtyId, r.dirtyFormat !== t.dirtyFormat ? (r.dirtyFormat = t.dirtyFormat, r.dirtySize = t.dirtySize, this.updateFramebuffer(t, s)) : r.dirtySize !== t.dirtySize && (r.dirtySize = t.dirtySize, this.resizeFramebuffer(t)));
            for (let o = 0; o < t.colorTextures.length; o++) {
                const a = t.colorTextures[o];
                this.renderer.texture.unbind(a.parentTextureArray || a)
            }
            if (t.depthTexture && this.renderer.texture.unbind(t.depthTexture), i) {
                const o = i.width >> s,
                    a = i.height >> s,
                    l = o / i.width;
                this.setViewport(i.x * l, i.y * l, o, a)
            } else {
                const o = t.width >> s,
                    a = t.height >> s;
                this.setViewport(0, 0, o, a)
            }
        } else this.current && (this.current = null, n.bindFramebuffer(n.FRAMEBUFFER, null)), i ? this.setViewport(i.x, i.y, i.width, i.height) : this.setViewport(0, 0, this.renderer.width, this.renderer.height)
    }
    setViewport(t, i, s, n) {
        const r = this.viewport;
        t = Math.round(t), i = Math.round(i), s = Math.round(s), n = Math.round(n), (r.width !== s || r.height !== n || r.x !== t || r.y !== i) && (r.x = t, r.y = i, r.width = s, r.height = n, this.gl.viewport(t, i, s, n))
    }
    get size() {
        return this.current ? {
            x: 0,
            y: 0,
            width: this.current.width,
            height: this.current.height
        } : {
            x: 0,
            y: 0,
            width: this.renderer.width,
            height: this.renderer.height
        }
    }
    clear(t, i, s, n, r = Yu.COLOR | Yu.DEPTH) {
        const {
            gl: o
        } = this;
        o.clearColor(t, i, s, n), o.clear(r)
    }
    initFramebuffer(t) {
        const {
            gl: i
        } = this, s = new z4(i.createFramebuffer());
        return s.multisample = this.detectSamples(t.multisample), t.glFramebuffers[this.CONTEXT_UID] = s, this.managedFramebuffers.push(t), t.disposeRunner.add(this), s
    }
    resizeFramebuffer(t) {
        const {
            gl: i
        } = this, s = t.glFramebuffers[this.CONTEXT_UID];
        s.stencil && (i.bindRenderbuffer(i.RENDERBUFFER, s.stencil), s.msaaBuffer ? i.renderbufferStorageMultisample(i.RENDERBUFFER, s.multisample, i.DEPTH24_STENCIL8, t.width, t.height) : i.renderbufferStorage(i.RENDERBUFFER, i.DEPTH_STENCIL, t.width, t.height));
        const n = t.colorTextures;
        let r = n.length;
        i.drawBuffers || (r = Math.min(r, 1));
        for (let o = 0; o < r; o++) {
            const a = n[o],
                l = a.parentTextureArray || a;
            this.renderer.texture.bind(l, 0), o === 0 && s.msaaBuffer && (i.bindRenderbuffer(i.RENDERBUFFER, s.msaaBuffer), i.renderbufferStorageMultisample(i.RENDERBUFFER, s.multisample, l._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height))
        }
        t.depthTexture && this.writeDepthTexture && this.renderer.texture.bind(t.depthTexture, 0)
    }
    updateFramebuffer(t, i) {
        const {
            gl: s
        } = this, n = t.glFramebuffers[this.CONTEXT_UID], r = t.colorTextures;
        let o = r.length;
        s.drawBuffers || (o = Math.min(o, 1)), n.multisample > 1 && this.canMultisampleFramebuffer(t) ? n.msaaBuffer = n.msaaBuffer || s.createRenderbuffer() : n.msaaBuffer && (s.deleteRenderbuffer(n.msaaBuffer), n.msaaBuffer = null, n.blitFramebuffer && (n.blitFramebuffer.dispose(), n.blitFramebuffer = null));
        const a = [];
        for (let l = 0; l < o; l++) {
            const c = r[l],
                h = c.parentTextureArray || c;
            this.renderer.texture.bind(h, 0), l === 0 && n.msaaBuffer ? (s.bindRenderbuffer(s.RENDERBUFFER, n.msaaBuffer), s.renderbufferStorageMultisample(s.RENDERBUFFER, n.multisample, h._glTextures[this.CONTEXT_UID].internalFormat, t.width, t.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, n.msaaBuffer)) : (s.framebufferTexture2D(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + l, c.target, h._glTextures[this.CONTEXT_UID].texture, i), a.push(s.COLOR_ATTACHMENT0 + l))
        }
        if (a.length > 1 && s.drawBuffers(a), t.depthTexture && this.writeDepthTexture) {
            const c = t.depthTexture;
            this.renderer.texture.bind(c, 0), s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, c._glTextures[this.CONTEXT_UID].texture, i)
        }(t.stencil || t.depth) && !(t.depthTexture && this.writeDepthTexture) ? (n.stencil = n.stencil || s.createRenderbuffer(), s.bindRenderbuffer(s.RENDERBUFFER, n.stencil), n.msaaBuffer ? s.renderbufferStorageMultisample(s.RENDERBUFFER, n.multisample, s.DEPTH24_STENCIL8, t.width, t.height) : s.renderbufferStorage(s.RENDERBUFFER, s.DEPTH_STENCIL, t.width, t.height), s.framebufferRenderbuffer(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.RENDERBUFFER, n.stencil)) : n.stencil && (s.deleteRenderbuffer(n.stencil), n.stencil = null)
    }
    canMultisampleFramebuffer(t) {
        return this.renderer.context.webGLVersion !== 1 && t.colorTextures.length <= 1 && !t.depthTexture
    }
    detectSamples(t) {
        const {
            msaaSamples: i
        } = this;
        let s = Fe.NONE;
        if (t <= 1 || i === null) return s;
        for (let n = 0; n < i.length; n++)
            if (i[n] <= t) {
                s = i[n];
                break
            } return s === 1 && (s = Fe.NONE), s
    }
    blit(t, i, s) {
        const {
            current: n,
            renderer: r,
            gl: o,
            CONTEXT_UID: a
        } = this;
        if (r.context.webGLVersion !== 2 || !n) return;
        const l = n.glFramebuffers[a];
        if (!l) return;
        if (!t) {
            if (!l.msaaBuffer) return;
            const h = n.colorTextures[0];
            if (!h) return;
            l.blitFramebuffer || (l.blitFramebuffer = new dd(n.width, n.height), l.blitFramebuffer.addColorTexture(0, h)), t = l.blitFramebuffer, t.colorTextures[0] !== h && (t.colorTextures[0] = h, t.dirtyId++, t.dirtyFormat++), (t.width !== n.width || t.height !== n.height) && (t.width = n.width, t.height = n.height, t.dirtyId++, t.dirtySize++)
        }
        i || (i = $4, i.width = n.width, i.height = n.height), s || (s = i);
        const c = i.width === s.width && i.height === s.height;
        this.bind(t), o.bindFramebuffer(o.READ_FRAMEBUFFER, l.framebuffer), o.blitFramebuffer(i.left, i.top, i.right, i.bottom, s.left, s.top, s.right, s.bottom, o.COLOR_BUFFER_BIT, c ? o.NEAREST : o.LINEAR)
    }
    disposeFramebuffer(t, i) {
        const s = t.glFramebuffers[this.CONTEXT_UID],
            n = this.gl;
        if (!s) return;
        delete t.glFramebuffers[this.CONTEXT_UID];
        const r = this.managedFramebuffers.indexOf(t);
        r >= 0 && this.managedFramebuffers.splice(r, 1), t.disposeRunner.remove(this), i || (n.deleteFramebuffer(s.framebuffer), s.msaaBuffer && n.deleteRenderbuffer(s.msaaBuffer), s.stencil && n.deleteRenderbuffer(s.stencil)), s.blitFramebuffer && s.blitFramebuffer.dispose()
    }
    disposeAll(t) {
        const i = this.managedFramebuffers;
        this.managedFramebuffers = [];
        for (let s = 0; s < i.length; s++) this.disposeFramebuffer(i[s], t)
    }
    forceStencil() {
        const t = this.current;
        if (!t) return;
        const i = t.glFramebuffers[this.CONTEXT_UID];
        if (!i || i.stencil) return;
        t.stencil = !0;
        const s = t.width,
            n = t.height,
            r = this.gl,
            o = r.createRenderbuffer();
        r.bindRenderbuffer(r.RENDERBUFFER, o), i.msaaBuffer ? r.renderbufferStorageMultisample(r.RENDERBUFFER, i.multisample, r.DEPTH24_STENCIL8, s, n) : r.renderbufferStorage(r.RENDERBUFFER, r.DEPTH_STENCIL, s, n), i.stencil = o, r.framebufferRenderbuffer(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.RENDERBUFFER, o)
    }
    reset() {
        this.current = this.unknownFramebuffer, this.viewport = new qt
    }
    destroy() {
        this.renderer = null
    }
}
W_.extension = {
    type: lt.RendererSystem,
    name: "framebuffer"
};
vt.add(W_);
const iu = {
    5126: 4,
    5123: 2,
    5121: 1
};
class X_ {
    constructor(t) {
        this.renderer = t, this._activeGeometry = null, this._activeVao = null, this.hasVao = !0, this.hasInstance = !0, this.canUseUInt32ElementIndex = !1, this.managedGeometries = {}
    }
    contextChange() {
        this.disposeAll(!0);
        const t = this.gl = this.renderer.gl,
            i = this.renderer.context;
        if (this.CONTEXT_UID = this.renderer.CONTEXT_UID, i.webGLVersion !== 2) {
            let s = this.renderer.context.extensions.vertexArrayObject;
            ut.PREFER_ENV === Lr.WEBGL_LEGACY && (s = null), s ? (t.createVertexArray = () => s.createVertexArrayOES(), t.bindVertexArray = n => s.bindVertexArrayOES(n), t.deleteVertexArray = n => s.deleteVertexArrayOES(n)) : (this.hasVao = !1, t.createVertexArray = () => null, t.bindVertexArray = () => null, t.deleteVertexArray = () => null)
        }
        if (i.webGLVersion !== 2) {
            const s = t.getExtension("ANGLE_instanced_arrays");
            s ? (t.vertexAttribDivisor = (n, r) => s.vertexAttribDivisorANGLE(n, r), t.drawElementsInstanced = (n, r, o, a, l) => s.drawElementsInstancedANGLE(n, r, o, a, l), t.drawArraysInstanced = (n, r, o, a) => s.drawArraysInstancedANGLE(n, r, o, a)) : this.hasInstance = !1
        }
        this.canUseUInt32ElementIndex = i.webGLVersion === 2 || !!i.extensions.uint32ElementIndex
    }
    bind(t, i) {
        i = i || this.renderer.shader.shader;
        const {
            gl: s
        } = this;
        let n = t.glVertexArrayObjects[this.CONTEXT_UID],
            r = !1;
        n || (this.managedGeometries[t.id] = t, t.disposeRunner.add(this), t.glVertexArrayObjects[this.CONTEXT_UID] = n = {}, r = !0);
        const o = n[i.program.id] || this.initGeometryVao(t, i, r);
        this._activeGeometry = t, this._activeVao !== o && (this._activeVao = o, this.hasVao ? s.bindVertexArray(o) : this.activateVao(t, i.program)), this.updateBuffers()
    }
    reset() {
        this.unbind()
    }
    updateBuffers() {
        const t = this._activeGeometry,
            i = this.renderer.buffer;
        for (let s = 0; s < t.buffers.length; s++) {
            const n = t.buffers[s];
            i.update(n)
        }
    }
    checkCompatibility(t, i) {
        const s = t.attributes,
            n = i.attributeData;
        for (const r in n)
            if (!s[r]) throw new Error(`shader and geometry incompatible, geometry missing the "${r}" attribute`)
    }
    getSignature(t, i) {
        const s = t.attributes,
            n = i.attributeData,
            r = ["g", t.id];
        for (const o in s) n[o] && r.push(o, n[o].location);
        return r.join("-")
    }
    initGeometryVao(t, i, s = !0) {
        const n = this.gl,
            r = this.CONTEXT_UID,
            o = this.renderer.buffer,
            a = i.program;
        a.glPrograms[r] || this.renderer.shader.generateProgram(i), this.checkCompatibility(t, a);
        const l = this.getSignature(t, a),
            c = t.glVertexArrayObjects[this.CONTEXT_UID];
        let h = c[l];
        if (h) return c[a.id] = h, h;
        const u = t.buffers,
            d = t.attributes,
            f = {},
            p = {};
        for (const m in u) f[m] = 0, p[m] = 0;
        for (const m in d) !d[m].size && a.attributeData[m] ? d[m].size = a.attributeData[m].size : d[m].size || console.warn(`PIXI Geometry attribute '${m}' size cannot be determined (likely the bound shader does not have the attribute)`), f[d[m].buffer] += d[m].size * iu[d[m].type];
        for (const m in d) {
            const g = d[m],
                y = g.size;
            g.stride === void 0 && (f[g.buffer] === y * iu[g.type] ? g.stride = 0 : g.stride = f[g.buffer]), g.start === void 0 && (g.start = p[g.buffer], p[g.buffer] += y * iu[g.type])
        }
        h = n.createVertexArray(), n.bindVertexArray(h);
        for (let m = 0; m < u.length; m++) {
            const g = u[m];
            o.bind(g), s && g._glBuffers[r].refCount++
        }
        return this.activateVao(t, a), c[a.id] = h, c[l] = h, n.bindVertexArray(null), o.unbind(Ps.ARRAY_BUFFER), h
    }
    disposeGeometry(t, i) {
        if (!this.managedGeometries[t.id]) return;
        delete this.managedGeometries[t.id];
        const s = t.glVertexArrayObjects[this.CONTEXT_UID],
            n = this.gl,
            r = t.buffers,
            o = this.renderer?.buffer;
        if (t.disposeRunner.remove(this), !!s) {
            if (o)
                for (let a = 0; a < r.length; a++) {
                    const l = r[a]._glBuffers[this.CONTEXT_UID];
                    l && (l.refCount--, l.refCount === 0 && !i && o.dispose(r[a], i))
                }
            if (!i) {
                for (const a in s)
                    if (a[0] === "g") {
                        const l = s[a];
                        this._activeVao === l && this.unbind(), n.deleteVertexArray(l)
                    }
            }
            delete t.glVertexArrayObjects[this.CONTEXT_UID]
        }
    }
    disposeAll(t) {
        const i = Object.keys(this.managedGeometries);
        for (let s = 0; s < i.length; s++) this.disposeGeometry(this.managedGeometries[i[s]], t)
    }
    activateVao(t, i) {
        const s = this.gl,
            n = this.CONTEXT_UID,
            r = this.renderer.buffer,
            o = t.buffers,
            a = t.attributes;
        t.indexBuffer && r.bind(t.indexBuffer);
        let l = null;
        for (const c in a) {
            const h = a[c],
                u = o[h.buffer],
                d = u._glBuffers[n];
            if (i.attributeData[c]) {
                l !== d && (r.bind(u), l = d);
                const f = i.attributeData[c].location;
                if (s.enableVertexAttribArray(f), s.vertexAttribPointer(f, h.size, h.type || s.FLOAT, h.normalized, h.stride, h.start), h.instance)
                    if (this.hasInstance) s.vertexAttribDivisor(f, h.divisor);
                    else throw new Error("geometry error, GPU Instancing is not supported on this device")
            }
        }
    }
    draw(t, i, s, n) {
        const {
            gl: r
        } = this, o = this._activeGeometry;
        if (o.indexBuffer) {
            const a = o.indexBuffer.data.BYTES_PER_ELEMENT,
                l = a === 2 ? r.UNSIGNED_SHORT : r.UNSIGNED_INT;
            a === 2 || a === 4 && this.canUseUInt32ElementIndex ? o.instanced ? r.drawElementsInstanced(t, i || o.indexBuffer.data.length, l, (s || 0) * a, n || 1) : r.drawElements(t, i || o.indexBuffer.data.length, l, (s || 0) * a) : console.warn("unsupported index buffer type: uint32")
        } else o.instanced ? r.drawArraysInstanced(t, s, i || o.getSize(), n || 1) : r.drawArrays(t, s, i || o.getSize());
        return this
    }
    unbind() {
        this.gl.bindVertexArray(null), this._activeVao = null, this._activeGeometry = null
    }
    destroy() {
        this.renderer = null
    }
}
X_.extension = {
    type: lt.RendererSystem,
    name: "geometry"
};
vt.add(X_);
const hg = new pe;
class zf {
    constructor(t, i) {
        this._texture = t, this.mapCoord = new pe, this.uClampFrame = new Float32Array(4), this.uClampOffset = new Float32Array(2), this._textureID = -1, this._updateID = 0, this.clampOffset = 0, this.clampMargin = typeof i > "u" ? .5 : i, this.isSimple = !1
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture = t, this._textureID = -1
    }
    multiplyUvs(t, i) {
        i === void 0 && (i = t);
        const s = this.mapCoord;
        for (let n = 0; n < t.length; n += 2) {
            const r = t[n],
                o = t[n + 1];
            i[n] = r * s.a + o * s.c + s.tx, i[n + 1] = r * s.b + o * s.d + s.ty
        }
        return i
    }
    update(t) {
        const i = this._texture;
        if (!i || !i.valid || !t && this._textureID === i._updateID) return !1;
        this._textureID = i._updateID, this._updateID++;
        const s = i._uvs;
        this.mapCoord.set(s.x1 - s.x0, s.y1 - s.y0, s.x3 - s.x0, s.y3 - s.y0, s.x0, s.y0);
        const n = i.orig,
            r = i.trim;
        r && (hg.set(n.width / r.width, 0, 0, n.height / r.height, -r.x / r.width, -r.y / r.height), this.mapCoord.append(hg));
        const o = i.baseTexture,
            a = this.uClampFrame,
            l = this.clampMargin / o.resolution,
            c = this.clampOffset;
        return a[0] = (i._frame.x + l + c) / o.width, a[1] = (i._frame.y + l + c) / o.height, a[2] = (i._frame.x + i._frame.width - l + c) / o.width, a[3] = (i._frame.y + i._frame.height - l + c) / o.height, this.uClampOffset[0] = c / o.realWidth, this.uClampOffset[1] = c / o.realHeight, this.isSimple = i._frame.width === o.width && i._frame.height === o.height && i.rotate === 0, !0
    }
}
var j4 = `varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform sampler2D mask;
uniform float alpha;
uniform float npmAlpha;
uniform vec4 maskClamp;

void main(void)
{
    float clip = step(3.5,
        step(maskClamp.x, vMaskCoord.x) +
        step(maskClamp.y, vMaskCoord.y) +
        step(vMaskCoord.x, maskClamp.z) +
        step(vMaskCoord.y, maskClamp.w));

    vec4 original = texture2D(uSampler, vTextureCoord);
    vec4 masky = texture2D(mask, vMaskCoord);
    float alphaMul = 1.0 - npmAlpha * (1.0 - masky.a);

    original *= (alphaMul * masky.r * alpha * clip);

    gl_FragColor = original;
}
`,
    W4 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 otherMatrix;

varying vec2 vMaskCoord;
varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vMaskCoord = ( otherMatrix * vec3( aTextureCoord, 1.0)  ).xy;
}
`;
class X4 extends oi {
    constructor(t, i, s) {
        let n = null;
        typeof t != "string" && i === void 0 && s === void 0 && (n = t, t = void 0, i = void 0, s = void 0), super(t || W4, i || j4, s), this.maskSprite = n, this.maskMatrix = new pe
    }
    get maskSprite() {
        return this._maskSprite
    }
    set maskSprite(t) {
        this._maskSprite = t, this._maskSprite && (this._maskSprite.renderable = !1)
    }
    apply(t, i, s, n) {
        const r = this._maskSprite,
            o = r._texture;
        !o.valid || (o.uvMatrix || (o.uvMatrix = new zf(o, 0)), o.uvMatrix.update(), this.uniforms.npmAlpha = o.baseTexture.alphaMode ? 0 : 1, this.uniforms.mask = o, this.uniforms.otherMatrix = t.calculateSpriteMatrix(this.maskMatrix, r).prepend(o.uvMatrix.mapCoord), this.uniforms.alpha = r.worldAlpha, this.uniforms.maskClamp = o.uvMatrix.uClampFrame, t.applyFilter(this, i, s, n))
    }
}
class Y4 {
    constructor(t = null) {
        this.type = Ue.NONE, this.autoDetect = !0, this.maskObject = t || null, this.pooled = !1, this.isMaskData = !0, this.resolution = null, this.multisample = ut.FILTER_MULTISAMPLE, this.enabled = !0, this.colorMask = 15, this._filters = null, this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null, this._scissorRectLocal = null, this._colorMask = 15, this._target = null
    }
    get filter() {
        return this._filters ? this._filters[0] : null
    }
    set filter(t) {
        t ? this._filters ? this._filters[0] = t : this._filters = [t] : this._filters = null
    }
    reset() {
        this.pooled && (this.maskObject = null, this.type = Ue.NONE, this.autoDetect = !0), this._target = null, this._scissorRectLocal = null
    }
    copyCountersOrReset(t) {
        t ? (this._stencilCounter = t._stencilCounter, this._scissorCounter = t._scissorCounter, this._scissorRect = t._scissorRect) : (this._stencilCounter = 0, this._scissorCounter = 0, this._scissorRect = null)
    }
}
class Y_ {
    constructor(t) {
        this.renderer = t, this.enableScissor = !0, this.alphaMaskPool = [], this.maskDataPool = [], this.maskStack = [], this.alphaMaskIndex = 0
    }
    setMaskStack(t) {
        this.maskStack = t, this.renderer.scissor.setMaskStack(t), this.renderer.stencil.setMaskStack(t)
    }
    push(t, i) {
        let s = i;
        if (!s.isMaskData) {
            const r = this.maskDataPool.pop() || new Y4;
            r.pooled = !0, r.maskObject = i, s = r
        }
        const n = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null;
        if (s.copyCountersOrReset(n), s._colorMask = n ? n._colorMask : 15, s.autoDetect && this.detect(s), s._target = t, s.type !== Ue.SPRITE && this.maskStack.push(s), s.enabled) switch (s.type) {
            case Ue.SCISSOR:
                this.renderer.scissor.push(s);
                break;
            case Ue.STENCIL:
                this.renderer.stencil.push(s);
                break;
            case Ue.SPRITE:
                s.copyCountersOrReset(null), this.pushSpriteMask(s);
                break;
            case Ue.COLOR:
                this.pushColorMask(s);
                break
        }
        s.type === Ue.SPRITE && this.maskStack.push(s)
    }
    pop(t) {
        const i = this.maskStack.pop();
        if (!(!i || i._target !== t)) {
            if (i.enabled) switch (i.type) {
                case Ue.SCISSOR:
                    this.renderer.scissor.pop(i);
                    break;
                case Ue.STENCIL:
                    this.renderer.stencil.pop(i.maskObject);
                    break;
                case Ue.SPRITE:
                    this.popSpriteMask(i);
                    break;
                case Ue.COLOR:
                    this.popColorMask(i);
                    break
            }
            if (i.reset(), i.pooled && this.maskDataPool.push(i), this.maskStack.length !== 0) {
                const s = this.maskStack[this.maskStack.length - 1];
                s.type === Ue.SPRITE && s._filters && (s._filters[0].maskSprite = s.maskObject)
            }
        }
    }
    detect(t) {
        const i = t.maskObject;
        i ? i.isSprite ? t.type = Ue.SPRITE : this.enableScissor && this.renderer.scissor.testScissor(t) ? t.type = Ue.SCISSOR : t.type = Ue.STENCIL : t.type = Ue.COLOR
    }
    pushSpriteMask(t) {
        const {
            maskObject: i
        } = t, s = t._target;
        let n = t._filters;
        n || (n = this.alphaMaskPool[this.alphaMaskIndex], n || (n = this.alphaMaskPool[this.alphaMaskIndex] = [new X4]));
        const r = this.renderer,
            o = r.renderTexture;
        let a, l;
        if (o.current) {
            const h = o.current;
            a = t.resolution || h.resolution, l = t.multisample ?? h.multisample
        } else a = t.resolution || r.resolution, l = t.multisample ?? r.multisample;
        n[0].resolution = a, n[0].multisample = l, n[0].maskSprite = i;
        const c = s.filterArea;
        s.filterArea = i.getBounds(!0), r.filter.push(s, n), s.filterArea = c, t._filters || this.alphaMaskIndex++
    }
    popSpriteMask(t) {
        this.renderer.filter.pop(), t._filters ? t._filters[0].maskSprite = null : (this.alphaMaskIndex--, this.alphaMaskPool[this.alphaMaskIndex][0].maskSprite = null)
    }
    pushColorMask(t) {
        const i = t._colorMask,
            s = t._colorMask = i & t.colorMask;
        s !== i && this.renderer.gl.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)
    }
    popColorMask(t) {
        const i = t._colorMask,
            s = this.maskStack.length > 0 ? this.maskStack[this.maskStack.length - 1]._colorMask : 15;
        s !== i && this.renderer.gl.colorMask((s & 1) !== 0, (s & 2) !== 0, (s & 4) !== 0, (s & 8) !== 0)
    }
    destroy() {
        this.renderer = null
    }
}
Y_.extension = {
    type: lt.RendererSystem,
    name: "mask"
};
vt.add(Y_);
class K_ {
    constructor(t) {
        this.renderer = t, this.maskStack = [], this.glConst = 0
    }
    getStackLength() {
        return this.maskStack.length
    }
    setMaskStack(t) {
        const {
            gl: i
        } = this.renderer, s = this.getStackLength();
        this.maskStack = t;
        const n = this.getStackLength();
        n !== s && (n === 0 ? i.disable(this.glConst) : (i.enable(this.glConst), this._useCurrent()))
    }
    _useCurrent() {}
    destroy() {
        this.renderer = null, this.maskStack = null
    }
}
const ug = new pe,
    dg = [],
    ql = class extends K_ {
        constructor(e) {
            super(e), this.glConst = ut.ADAPTER.getWebGLRenderingContext().SCISSOR_TEST
        }
        getStackLength() {
            const e = this.maskStack[this.maskStack.length - 1];
            return e ? e._scissorCounter : 0
        }
        calcScissorRect(e) {
            if (e._scissorRectLocal) return;
            const t = e._scissorRect,
                {
                    maskObject: i
                } = e,
                {
                    renderer: s
                } = this,
                n = s.renderTexture,
                r = i.getBounds(!0, dg.pop() ?? new qt);
            this.roundFrameToPixels(r, n.current ? n.current.resolution : s.resolution, n.sourceFrame, n.destinationFrame, s.projection.transform), t && r.fit(t), e._scissorRectLocal = r
        }
        static isMatrixRotated(e) {
            if (!e) return !1;
            const {
                a: t,
                b: i,
                c: s,
                d: n
            } = e;
            return (Math.abs(i) > 1e-4 || Math.abs(s) > 1e-4) && (Math.abs(t) > 1e-4 || Math.abs(n) > 1e-4)
        }
        testScissor(e) {
            const {
                maskObject: t
            } = e;
            if (!t.isFastRect || !t.isFastRect() || ql.isMatrixRotated(t.worldTransform) || ql.isMatrixRotated(this.renderer.projection.transform)) return !1;
            this.calcScissorRect(e);
            const i = e._scissorRectLocal;
            return i.width > 0 && i.height > 0
        }
        roundFrameToPixels(e, t, i, s, n) {
            ql.isMatrixRotated(n) || (n = n ? ug.copyFrom(n) : ug.identity(), n.translate(-i.x, -i.y).scale(s.width / i.width, s.height / i.height).translate(s.x, s.y), this.renderer.filter.transformAABB(n, e), e.fit(s), e.x = Math.round(e.x * t), e.y = Math.round(e.y * t), e.width = Math.round(e.width * t), e.height = Math.round(e.height * t))
        }
        push(e) {
            e._scissorRectLocal || this.calcScissorRect(e);
            const {
                gl: t
            } = this.renderer;
            e._scissorRect || t.enable(t.SCISSOR_TEST), e._scissorCounter++, e._scissorRect = e._scissorRectLocal, this._useCurrent()
        }
        pop(e) {
            const {
                gl: t
            } = this.renderer;
            e && dg.push(e._scissorRectLocal), this.getStackLength() > 0 ? this._useCurrent() : t.disable(t.SCISSOR_TEST)
        }
        _useCurrent() {
            const e = this.maskStack[this.maskStack.length - 1]._scissorRect;
            let t;
            this.renderer.renderTexture.current ? t = e.y : t = this.renderer.height - e.height - e.y, this.renderer.gl.scissor(e.x, t, e.width, e.height)
        }
    };
let Z_ = ql;
Z_.extension = {
    type: lt.RendererSystem,
    name: "scissor"
};
vt.add(Z_);
class q_ extends K_ {
    constructor(t) {
        super(t), this.glConst = ut.ADAPTER.getWebGLRenderingContext().STENCIL_TEST
    }
    getStackLength() {
        const t = this.maskStack[this.maskStack.length - 1];
        return t ? t._stencilCounter : 0
    }
    push(t) {
        const i = t.maskObject,
            {
                gl: s
            } = this.renderer,
            n = t._stencilCounter;
        n === 0 && (this.renderer.framebuffer.forceStencil(), s.clearStencil(0), s.clear(s.STENCIL_BUFFER_BIT), s.enable(s.STENCIL_TEST)), t._stencilCounter++;
        const r = t._colorMask;
        r !== 0 && (t._colorMask = 0, s.colorMask(!1, !1, !1, !1)), s.stencilFunc(s.EQUAL, n, 4294967295), s.stencilOp(s.KEEP, s.KEEP, s.INCR), i.renderable = !0, i.render(this.renderer), this.renderer.batch.flush(), i.renderable = !1, r !== 0 && (t._colorMask = r, s.colorMask((r & 1) !== 0, (r & 2) !== 0, (r & 4) !== 0, (r & 8) !== 0)), this._useCurrent()
    }
    pop(t) {
        const i = this.renderer.gl;
        if (this.getStackLength() === 0) i.disable(i.STENCIL_TEST);
        else {
            const s = this.maskStack.length !== 0 ? this.maskStack[this.maskStack.length - 1] : null,
                n = s ? s._colorMask : 15;
            n !== 0 && (s._colorMask = 0, i.colorMask(!1, !1, !1, !1)), i.stencilOp(i.KEEP, i.KEEP, i.DECR), t.renderable = !0, t.render(this.renderer), this.renderer.batch.flush(), t.renderable = !1, n !== 0 && (s._colorMask = n, i.colorMask((n & 1) !== 0, (n & 2) !== 0, (n & 4) !== 0, (n & 8) !== 0)), this._useCurrent()
        }
    }
    _useCurrent() {
        const t = this.renderer.gl;
        t.stencilFunc(t.EQUAL, this.getStackLength(), 4294967295), t.stencilOp(t.KEEP, t.KEEP, t.KEEP)
    }
}
q_.extension = {
    type: lt.RendererSystem,
    name: "stencil"
};
vt.add(q_);
class J_ {
    constructor(t) {
        this.renderer = t, this.plugins = {}, Object.defineProperties(this.plugins, {
            extract: {
                enumerable: !1,
                get() {
                    return Qt("7.0.0", "renderer.plugins.extract has moved to renderer.extract"), t.extract
                }
            },
            prepare: {
                enumerable: !1,
                get() {
                    return Qt("7.0.0", "renderer.plugins.prepare has moved to renderer.prepare"), t.prepare
                }
            },
            interaction: {
                enumerable: !1,
                get() {
                    return Qt("7.0.0", "renderer.plugins.interaction has been deprecated, use renderer.events"), t.events
                }
            }
        })
    }
    init(t) {
        for (const i in t) this.plugins[i] = new t[i](this.renderer)
    }
    destroy() {
        for (const t in this.plugins) this.plugins[t].destroy(), this.plugins[t] = null
    }
}
J_.extension = {
    type: [lt.RendererSystem, lt.CanvasRendererSystem],
    name: "_plugin"
};
vt.add(J_);
class Q_ {
    constructor(t) {
        this.renderer = t, this.destinationFrame = null, this.sourceFrame = null, this.defaultFrame = null, this.projectionMatrix = new pe, this.transform = null
    }
    update(t, i, s, n) {
        this.destinationFrame = t || this.destinationFrame || this.defaultFrame, this.sourceFrame = i || this.sourceFrame || t, this.calculateProjection(this.destinationFrame, this.sourceFrame, s, n), this.transform && this.projectionMatrix.append(this.transform);
        const r = this.renderer;
        r.globalUniforms.uniforms.projectionMatrix = this.projectionMatrix, r.globalUniforms.update(), r.shader.shader && r.shader.syncUniformGroup(r.shader.shader.uniforms.globals)
    }
    calculateProjection(t, i, s, n) {
        const r = this.projectionMatrix,
            o = n ? -1 : 1;
        r.identity(), r.a = 1 / i.width * 2, r.d = o * (1 / i.height * 2), r.tx = -1 - i.x * r.a, r.ty = -o - i.y * r.d
    }
    setTransform(t) {}
    destroy() {
        this.renderer = null
    }
}
Q_.extension = {
    type: lt.RendererSystem,
    name: "projection"
};
vt.add(Q_);
const K4 = new uh;
class t1 {
    constructor(t) {
        this.renderer = t, this._tempMatrix = new pe
    }
    generateTexture(t, i) {
        const {
            region: s,
            ...n
        } = i || {}, r = s || t.getLocalBounds(null, !0);
        r.width === 0 && (r.width = 1), r.height === 0 && (r.height = 1);
        const o = fs.create({
            width: r.width,
            height: r.height,
            ...n
        });
        this._tempMatrix.tx = -r.x, this._tempMatrix.ty = -r.y;
        const a = t.transform;
        return t.transform = K4, this.renderer.render(t, {
            renderTexture: o,
            transform: this._tempMatrix,
            skipUpdateTransform: !!t.parent,
            blit: !0
        }), t.transform = a, o
    }
    destroy() {}
}
t1.extension = {
    type: [lt.RendererSystem, lt.CanvasRendererSystem],
    name: "textureGenerator"
};
vt.add(t1);
const Hn = new qt,
    ta = new qt;
class e1 {
    constructor(t) {
        this.renderer = t, this.defaultMaskStack = [], this.current = null, this.sourceFrame = new qt, this.destinationFrame = new qt, this.viewportFrame = new qt
    }
    bind(t = null, i, s) {
        const n = this.renderer;
        this.current = t;
        let r, o, a;
        t ? (r = t.baseTexture, a = r.resolution, i || (Hn.width = t.frame.width, Hn.height = t.frame.height, i = Hn), s || (ta.x = t.frame.x, ta.y = t.frame.y, ta.width = i.width, ta.height = i.height, s = ta), o = r.framebuffer) : (a = n.resolution, i || (Hn.width = n._view.screen.width, Hn.height = n._view.screen.height, i = Hn), s || (s = Hn, s.width = i.width, s.height = i.height));
        const l = this.viewportFrame;
        l.x = s.x * a, l.y = s.y * a, l.width = s.width * a, l.height = s.height * a, t || (l.y = n.view.height - (l.y + l.height)), l.ceil(), this.renderer.framebuffer.bind(o, l), this.renderer.projection.update(s, i, a, !o), t ? this.renderer.mask.setMaskStack(r.maskStack) : this.renderer.mask.setMaskStack(this.defaultMaskStack), this.sourceFrame.copyFrom(i), this.destinationFrame.copyFrom(s)
    }
    clear(t, i) {
        this.current ? t = t || this.current.baseTexture.clearColor : t = t || this.renderer.background.colorRgba;
        const s = this.destinationFrame,
            n = this.current ? this.current.baseTexture : this.renderer._view.screen,
            r = s.width !== n.width || s.height !== n.height;
        if (r) {
            let {
                x: o,
                y: a,
                width: l,
                height: c
            } = this.viewportFrame;
            o = Math.round(o), a = Math.round(a), l = Math.round(l), c = Math.round(c), this.renderer.gl.enable(this.renderer.gl.SCISSOR_TEST), this.renderer.gl.scissor(o, a, l, c)
        }
        this.renderer.framebuffer.clear(t[0], t[1], t[2], t[3], i), r && this.renderer.scissor.pop()
    }
    resize() {
        this.bind(null)
    }
    reset() {
        this.bind(null)
    }
    destroy() {
        this.renderer = null
    }
}
e1.extension = {
    type: lt.RendererSystem,
    name: "renderTexture"
};
vt.add(e1);
class Z4 {
    constructor(t, i) {
        this.program = t, this.uniformData = i, this.uniformGroups = {}, this.uniformDirtyGroups = {}, this.uniformBufferBindings = {}
    }
    destroy() {
        this.uniformData = null, this.uniformGroups = null, this.uniformDirtyGroups = null, this.uniformBufferBindings = null, this.program = null
    }
}

function q4(e, t) {
    const i = {},
        s = t.getProgramParameter(e, t.ACTIVE_ATTRIBUTES);
    for (let n = 0; n < s; n++) {
        const r = t.getActiveAttrib(e, n);
        if (r.name.startsWith("gl_")) continue;
        const o = F_(t, r.type),
            a = {
                type: o,
                name: r.name,
                size: N_(o),
                location: t.getAttribLocation(e, r.name)
            };
        i[r.name] = a
    }
    return i
}

function J4(e, t) {
    const i = {},
        s = t.getProgramParameter(e, t.ACTIVE_UNIFORMS);
    for (let n = 0; n < s; n++) {
        const r = t.getActiveUniform(e, n),
            o = r.name.replace(/\[.*?\]$/, ""),
            a = !!r.name.match(/\[.*?\]$/),
            l = F_(t, r.type);
        i[o] = {
            name: o,
            index: n,
            type: l,
            size: r.size,
            isArray: a,
            value: O_(l, r.size)
        }
    }
    return i
}

function Q4(e, t) {
    const i = ng(e, e.VERTEX_SHADER, t.vertexSrc),
        s = ng(e, e.FRAGMENT_SHADER, t.fragmentSrc),
        n = e.createProgram();
    e.attachShader(n, i), e.attachShader(n, s);
    const r = t.extra?.transformFeedbackVaryings;
    if (r && (typeof e.transformFeedbackVaryings != "function" ? console.warn("TransformFeedback is not supported but TransformFeedbackVaryings are given.") : e.transformFeedbackVaryings(n, r.names, r.bufferMode === "separate" ? e.SEPARATE_ATTRIBS : e.INTERLEAVED_ATTRIBS)), e.linkProgram(n), e.getProgramParameter(n, e.LINK_STATUS) || I4(e, n, i, s), t.attributeData = q4(n, e), t.uniformData = J4(n, e), !/^[ \t]*#[ \t]*version[ \t]+300[ \t]+es[ \t]*$/m.test(t.vertexSrc)) {
        const l = Object.keys(t.attributeData);
        l.sort((c, h) => c > h ? 1 : -1);
        for (let c = 0; c < l.length; c++) t.attributeData[l[c]].location = c, e.bindAttribLocation(n, c, l[c]);
        e.linkProgram(n)
    }
    e.deleteShader(i), e.deleteShader(s);
    const o = {};
    for (const l in t.uniformData) {
        const c = t.uniformData[l];
        o[l] = {
            location: e.getUniformLocation(n, l),
            value: O_(c.type, c.size)
        }
    }
    return new Z4(n, o)
}

function t6(e, t, i, s, n) {
    i.buffer.update(n)
}
const e6 = {
        float: `
        data[offset] = v;
    `,
        vec2: `
        data[offset] = v[0];
        data[offset+1] = v[1];
    `,
        vec3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

    `,
        vec4: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];
        data[offset+3] = v[3];
    `,
        mat2: `
        data[offset] = v[0];
        data[offset+1] = v[1];

        data[offset+4] = v[2];
        data[offset+5] = v[3];
    `,
        mat3: `
        data[offset] = v[0];
        data[offset+1] = v[1];
        data[offset+2] = v[2];

        data[offset + 4] = v[3];
        data[offset + 5] = v[4];
        data[offset + 6] = v[5];

        data[offset + 8] = v[6];
        data[offset + 9] = v[7];
        data[offset + 10] = v[8];
    `,
        mat4: `
        for(var i = 0; i < 16; i++)
        {
            data[offset + i] = v[i];
        }
    `
    },
    i1 = {
        float: 4,
        vec2: 8,
        vec3: 12,
        vec4: 16,
        int: 4,
        ivec2: 8,
        ivec3: 12,
        ivec4: 16,
        uint: 4,
        uvec2: 8,
        uvec3: 12,
        uvec4: 16,
        bool: 4,
        bvec2: 8,
        bvec3: 12,
        bvec4: 16,
        mat2: 16 * 2,
        mat3: 16 * 3,
        mat4: 16 * 4
    };

function i6(e) {
    const t = e.map(r => ({
        data: r,
        offset: 0,
        dataLen: 0,
        dirty: 0
    }));
    let i = 0,
        s = 0,
        n = 0;
    for (let r = 0; r < t.length; r++) {
        const o = t[r];
        if (i = i1[o.data.type], o.data.size > 1 && (i = Math.max(i, 16) * o.data.size), o.dataLen = i, s % i !== 0 && s < 16) {
            const a = s % i % 16;
            s += a, n += a
        }
        s + i > 16 ? (n = Math.ceil(n / 16) * 16, o.offset = n, n += i, s = i) : (o.offset = n, s += i, n += i)
    }
    return n = Math.ceil(n / 16) * 16, {
        uboElements: t,
        size: n
    }
}

function s6(e, t) {
    const i = [];
    for (const s in e) t[s] && i.push(t[s]);
    return i.sort((s, n) => s.index - n.index), i
}

function n6(e, t) {
    if (!e.autoManage) return {
        size: 0,
        syncFunc: t6
    };
    const i = s6(e.uniforms, t),
        {
            uboElements: s,
            size: n
        } = i6(i),
        r = [`
    var v = null;
    var v2 = null;
    var cv = null;
    var t = 0;
    var gl = renderer.gl
    var index = 0;
    var data = buffer.data;
    `];
    for (let o = 0; o < s.length; o++) {
        const a = s[o],
            l = e.uniforms[a.data.name],
            c = a.data.name;
        let h = !1;
        for (let u = 0; u < _o.length; u++) {
            const d = _o[u];
            if (d.codeUbo && d.test(a.data, l)) {
                r.push(`offset = ${a.offset/4};`, _o[u].codeUbo(a.data.name, l)), h = !0;
                break
            }
        }
        if (!h)
            if (a.data.size > 1) {
                const u = N_(a.data.type),
                    d = Math.max(i1[a.data.type] / 16, 1),
                    f = u / d,
                    p = (4 - f % 4) % 4;
                r.push(`
                cv = ud.${c}.value;
                v = uv.${c};
                offset = ${a.offset/4};

                t = 0;

                for(var i=0; i < ${a.data.size*d}; i++)
                {
                    for(var j = 0; j < ${f}; j++)
                    {
                        data[offset++] = v[t++];
                    }
                    offset += ${p};
                }

                `)
            } else {
                const u = e6[a.data.type];
                r.push(`
                cv = ud.${c}.value;
                v = uv.${c};
                offset = ${a.offset/4};
                ${u};
                `)
            }
    }
    return r.push(`
       renderer.buffer.update(buffer);
    `), {
        size: n,
        syncFunc: new Function("ud", "uv", "renderer", "syncData", "buffer", r.join(`
`))
    }
}
let r6 = 0;
const Ml = {
    textureCount: 0,
    uboCount: 0
};
class s1 {
    constructor(t) {
        this.destroyed = !1, this.renderer = t, this.systemCheck(), this.gl = null, this.shader = null, this.program = null, this.cache = {}, this._uboCache = {}, this.id = r6++
    }
    systemCheck() {
        if (!R4()) throw new Error("Current environment does not allow unsafe-eval, please use @pixi/unsafe-eval module to enable support.")
    }
    contextChange(t) {
        this.gl = t, this.reset()
    }
    bind(t, i) {
        t.disposeRunner.add(this), t.uniforms.globals = this.renderer.globalUniforms;
        const s = t.program,
            n = s.glPrograms[this.renderer.CONTEXT_UID] || this.generateProgram(t);
        return this.shader = t, this.program !== s && (this.program = s, this.gl.useProgram(n.program)), i || (Ml.textureCount = 0, Ml.uboCount = 0, this.syncUniformGroup(t.uniformGroup, Ml)), n
    }
    setUniforms(t) {
        const i = this.shader.program,
            s = i.glPrograms[this.renderer.CONTEXT_UID];
        i.syncUniforms(s.uniformData, t, this.renderer)
    }
    syncUniformGroup(t, i) {
        const s = this.getGlProgram();
        (!t.static || t.dirtyId !== s.uniformDirtyGroups[t.id]) && (s.uniformDirtyGroups[t.id] = t.dirtyId, this.syncUniforms(t, s, i))
    }
    syncUniforms(t, i, s) {
        (t.syncUniforms[this.shader.program.id] || this.createSyncGroups(t))(i.uniformData, t.uniforms, this.renderer, s)
    }
    createSyncGroups(t) {
        const i = this.getSignature(t, this.shader.program.uniformData, "u");
        return this.cache[i] || (this.cache[i] = S4(t, this.shader.program.uniformData)), t.syncUniforms[this.shader.program.id] = this.cache[i], t.syncUniforms[this.shader.program.id]
    }
    syncUniformBufferGroup(t, i) {
        const s = this.getGlProgram();
        if (!t.static || t.dirtyId !== 0 || !s.uniformGroups[t.id]) {
            t.dirtyId = 0;
            const n = s.uniformGroups[t.id] || this.createSyncBufferGroup(t, s, i);
            t.buffer.update(), n(s.uniformData, t.uniforms, this.renderer, Ml, t.buffer)
        }
        this.renderer.buffer.bindBufferBase(t.buffer, s.uniformBufferBindings[i])
    }
    createSyncBufferGroup(t, i, s) {
        const {
            gl: n
        } = this.renderer;
        this.renderer.buffer.bind(t.buffer);
        const r = this.gl.getUniformBlockIndex(i.program, s);
        i.uniformBufferBindings[s] = this.shader.uniformBindCount, n.uniformBlockBinding(i.program, r, this.shader.uniformBindCount), this.shader.uniformBindCount++;
        const o = this.getSignature(t, this.shader.program.uniformData, "ubo");
        let a = this._uboCache[o];
        if (a || (a = this._uboCache[o] = n6(t, this.shader.program.uniformData)), t.autoManage) {
            const l = new Float32Array(a.size / 4);
            t.buffer.update(l)
        }
        return i.uniformGroups[t.id] = a.syncFunc, i.uniformGroups[t.id]
    }
    getSignature(t, i, s) {
        const n = t.uniforms,
            r = [`${s}-`];
        for (const o in n) r.push(o), i[o] && r.push(i[o].type);
        return r.join("-")
    }
    getGlProgram() {
        return this.shader ? this.shader.program.glPrograms[this.renderer.CONTEXT_UID] : null
    }
    generateProgram(t) {
        const i = this.gl,
            s = t.program,
            n = Q4(i, s);
        return s.glPrograms[this.renderer.CONTEXT_UID] = n, n
    }
    reset() {
        this.program = null, this.shader = null
    }
    disposeShader(t) {
        this.shader === t && (this.shader = null)
    }
    destroy() {
        this.renderer = null, this.destroyed = !0
    }
}
s1.extension = {
    type: lt.RendererSystem,
    name: "shader"
};
vt.add(s1);
class n1 {
    constructor(t) {
        this.renderer = t
    }
    run(t) {
        const i = this.renderer;
        i.emitWithCustomOptions(i.runners.init, t), t.hello && console.log(`PixiJS 7.1.0 - ${i.rendererLogId} - https://pixijs.com`), i.resize(this.renderer.screen.width, this.renderer.screen.height)
    }
    destroy() {}
}
n1.extension = {
    type: [lt.RendererSystem, lt.CanvasRendererSystem],
    name: "startup"
};
vt.add(n1);

function o6(e, t = []) {
    return t[j.NORMAL] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.ADD] = [e.ONE, e.ONE], t[j.MULTIPLY] = [e.DST_COLOR, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.SCREEN] = [e.ONE, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.OVERLAY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.DARKEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.LIGHTEN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.COLOR_DODGE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.COLOR_BURN] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.HARD_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.SOFT_LIGHT] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.DIFFERENCE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.EXCLUSION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.HUE] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.SATURATION] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.COLOR] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.LUMINOSITY] = [e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.NONE] = [0, 0], t[j.NORMAL_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_ALPHA, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.ADD_NPM] = [e.SRC_ALPHA, e.ONE, e.ONE, e.ONE], t[j.SCREEN_NPM] = [e.SRC_ALPHA, e.ONE_MINUS_SRC_COLOR, e.ONE, e.ONE_MINUS_SRC_ALPHA], t[j.SRC_IN] = [e.DST_ALPHA, e.ZERO], t[j.SRC_OUT] = [e.ONE_MINUS_DST_ALPHA, e.ZERO], t[j.SRC_ATOP] = [e.DST_ALPHA, e.ONE_MINUS_SRC_ALPHA], t[j.DST_OVER] = [e.ONE_MINUS_DST_ALPHA, e.ONE], t[j.DST_IN] = [e.ZERO, e.SRC_ALPHA], t[j.DST_OUT] = [e.ZERO, e.ONE_MINUS_SRC_ALPHA], t[j.DST_ATOP] = [e.ONE_MINUS_DST_ALPHA, e.SRC_ALPHA], t[j.XOR] = [e.ONE_MINUS_DST_ALPHA, e.ONE_MINUS_SRC_ALPHA], t[j.SUBTRACT] = [e.ONE, e.ONE, e.ONE, e.ONE, e.FUNC_REVERSE_SUBTRACT, e.FUNC_ADD], t
}
const a6 = 0,
    l6 = 1,
    c6 = 2,
    h6 = 3,
    u6 = 4,
    d6 = 5,
    fd = class {
        constructor() {
            this.gl = null, this.stateId = 0, this.polygonOffset = 0, this.blendMode = j.NONE, this._blendEq = !1, this.map = [], this.map[a6] = this.setBlend, this.map[l6] = this.setOffset, this.map[c6] = this.setCullFace, this.map[h6] = this.setDepthTest, this.map[u6] = this.setFrontFace, this.map[d6] = this.setDepthMask, this.checks = [], this.defaultState = new rn, this.defaultState.blend = !0
        }
        contextChange(e) {
            this.gl = e, this.blendModes = o6(e), this.set(this.defaultState), this.reset()
        }
        set(e) {
            if (e = e || this.defaultState, this.stateId !== e.data) {
                let t = this.stateId ^ e.data,
                    i = 0;
                for (; t;) t & 1 && this.map[i].call(this, !!(e.data & 1 << i)), t = t >> 1, i++;
                this.stateId = e.data
            }
            for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e)
        }
        forceState(e) {
            e = e || this.defaultState;
            for (let t = 0; t < this.map.length; t++) this.map[t].call(this, !!(e.data & 1 << t));
            for (let t = 0; t < this.checks.length; t++) this.checks[t](this, e);
            this.stateId = e.data
        }
        setBlend(e) {
            this.updateCheck(fd.checkBlendMode, e), this.gl[e ? "enable" : "disable"](this.gl.BLEND)
        }
        setOffset(e) {
            this.updateCheck(fd.checkPolygonOffset, e), this.gl[e ? "enable" : "disable"](this.gl.POLYGON_OFFSET_FILL)
        }
        setDepthTest(e) {
            this.gl[e ? "enable" : "disable"](this.gl.DEPTH_TEST)
        }
        setDepthMask(e) {
            this.gl.depthMask(e)
        }
        setCullFace(e) {
            this.gl[e ? "enable" : "disable"](this.gl.CULL_FACE)
        }
        setFrontFace(e) {
            this.gl.frontFace(this.gl[e ? "CW" : "CCW"])
        }
        setBlendMode(e) {
            if (e === this.blendMode) return;
            this.blendMode = e;
            const t = this.blendModes[e],
                i = this.gl;
            t.length === 2 ? i.blendFunc(t[0], t[1]) : i.blendFuncSeparate(t[0], t[1], t[2], t[3]), t.length === 6 ? (this._blendEq = !0, i.blendEquationSeparate(t[4], t[5])) : this._blendEq && (this._blendEq = !1, i.blendEquationSeparate(i.FUNC_ADD, i.FUNC_ADD))
        }
        setPolygonOffset(e, t) {
            this.gl.polygonOffset(e, t)
        }
        reset() {
            this.gl.pixelStorei(this.gl.UNPACK_FLIP_Y_WEBGL, !1), this.forceState(this.defaultState), this._blendEq = !0, this.blendMode = -1, this.setBlendMode(0)
        }
        updateCheck(e, t) {
            const i = this.checks.indexOf(e);
            t && i === -1 ? this.checks.push(e) : !t && i !== -1 && this.checks.splice(i, 1)
        }
        static checkBlendMode(e, t) {
            e.setBlendMode(t.blendMode)
        }
        static checkPolygonOffset(e, t) {
            e.setPolygonOffset(1, t.polygonOffset)
        }
        destroy() {
            this.gl = null
        }
    };
let r1 = fd;
r1.extension = {
    type: lt.RendererSystem,
    name: "state"
};
vt.add(r1);
class o1 extends $o {
    constructor() {
        super(...arguments), this.runners = {}, this._systemsHash = {}
    }
    setup(t) {
        this.addRunners(...t.runners);
        const i = (t.priority ?? []).filter(n => t.systems[n]),
            s = [...i, ...Object.keys(t.systems).filter(n => !i.includes(n))];
        for (const n of s) this.addSystem(t.systems[n], n)
    }
    addRunners(...t) {
        t.forEach(i => {
            this.runners[i] = new cs(i)
        })
    }
    addSystem(t, i) {
        const s = new t(this);
        if (this[i]) throw new Error(`Whoops! The name "${i}" is already in use`);
        this[i] = s, this._systemsHash[i] = s;
        for (const n in this.runners) this.runners[n].add(s);
        return this
    }
    emitWithCustomOptions(t, i) {
        const s = Object.keys(this._systemsHash);
        t.items.forEach(n => {
            const r = s.find(o => this._systemsHash[o] === n);
            n[t.name](i[r])
        })
    }
    destroy() {
        Object.values(this.runners).forEach(t => {
            t.destroy()
        }), this._systemsHash = {}
    }
}
const Jl = class {
    constructor(e) {
        this.renderer = e, this.count = 0, this.checkCount = 0, this.maxIdle = Jl.defaultMaxIdle, this.checkCountMax = Jl.defaultCheckCountMax, this.mode = Jl.defaultMode
    }
    postrender() {
        !this.renderer.objectRenderer.renderingToScreen || (this.count++, this.mode !== Lf.MANUAL && (this.checkCount++, this.checkCount > this.checkCountMax && (this.checkCount = 0, this.run())))
    }
    run() {
        const e = this.renderer.texture,
            t = e.managedTextures;
        let i = !1;
        for (let s = 0; s < t.length; s++) {
            const n = t[s];
            !n.framebuffer && this.count - n.touched > this.maxIdle && (e.destroyTexture(n, !0), t[s] = null, i = !0)
        }
        if (i) {
            let s = 0;
            for (let n = 0; n < t.length; n++) t[n] !== null && (t[s++] = t[n]);
            t.length = s
        }
    }
    unload(e) {
        const t = this.renderer.texture,
            i = e._texture;
        i && !i.framebuffer && t.destroyTexture(i);
        for (let s = e.children.length - 1; s >= 0; s--) this.unload(e.children[s])
    }
    destroy() {
        this.renderer = null
    }
};
let ns = Jl;
ns.defaultMode = Lf.AUTO;
ns.defaultMaxIdle = 60 * 60;
ns.defaultCheckCountMax = 60 * 10;
ns.extension = {
    type: lt.RendererSystem,
    name: "textureGC"
};
vt.add(ns);
class su {
    constructor(t) {
        this.texture = t, this.width = -1, this.height = -1, this.dirtyId = -1, this.dirtyStyleId = -1, this.mipmap = !1, this.wrapMode = 33071, this.type = Rt.UNSIGNED_BYTE, this.internalFormat = ot.RGBA, this.samplerType = 0
    }
}

function f6(e) {
    let t;
    return "WebGL2RenderingContext" in globalThis && e instanceof globalThis.WebGL2RenderingContext ? t = {
        [Rt.UNSIGNED_BYTE]: {
            [ot.RGBA]: e.RGBA8,
            [ot.RGB]: e.RGB8,
            [ot.RG]: e.RG8,
            [ot.RED]: e.R8,
            [ot.RGBA_INTEGER]: e.RGBA8UI,
            [ot.RGB_INTEGER]: e.RGB8UI,
            [ot.RG_INTEGER]: e.RG8UI,
            [ot.RED_INTEGER]: e.R8UI,
            [ot.ALPHA]: e.ALPHA,
            [ot.LUMINANCE]: e.LUMINANCE,
            [ot.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
        },
        [Rt.BYTE]: {
            [ot.RGBA]: e.RGBA8_SNORM,
            [ot.RGB]: e.RGB8_SNORM,
            [ot.RG]: e.RG8_SNORM,
            [ot.RED]: e.R8_SNORM,
            [ot.RGBA_INTEGER]: e.RGBA8I,
            [ot.RGB_INTEGER]: e.RGB8I,
            [ot.RG_INTEGER]: e.RG8I,
            [ot.RED_INTEGER]: e.R8I
        },
        [Rt.UNSIGNED_SHORT]: {
            [ot.RGBA_INTEGER]: e.RGBA16UI,
            [ot.RGB_INTEGER]: e.RGB16UI,
            [ot.RG_INTEGER]: e.RG16UI,
            [ot.RED_INTEGER]: e.R16UI,
            [ot.DEPTH_COMPONENT]: e.DEPTH_COMPONENT16
        },
        [Rt.SHORT]: {
            [ot.RGBA_INTEGER]: e.RGBA16I,
            [ot.RGB_INTEGER]: e.RGB16I,
            [ot.RG_INTEGER]: e.RG16I,
            [ot.RED_INTEGER]: e.R16I
        },
        [Rt.UNSIGNED_INT]: {
            [ot.RGBA_INTEGER]: e.RGBA32UI,
            [ot.RGB_INTEGER]: e.RGB32UI,
            [ot.RG_INTEGER]: e.RG32UI,
            [ot.RED_INTEGER]: e.R32UI,
            [ot.DEPTH_COMPONENT]: e.DEPTH_COMPONENT24
        },
        [Rt.INT]: {
            [ot.RGBA_INTEGER]: e.RGBA32I,
            [ot.RGB_INTEGER]: e.RGB32I,
            [ot.RG_INTEGER]: e.RG32I,
            [ot.RED_INTEGER]: e.R32I
        },
        [Rt.FLOAT]: {
            [ot.RGBA]: e.RGBA32F,
            [ot.RGB]: e.RGB32F,
            [ot.RG]: e.RG32F,
            [ot.RED]: e.R32F,
            [ot.DEPTH_COMPONENT]: e.DEPTH_COMPONENT32F
        },
        [Rt.HALF_FLOAT]: {
            [ot.RGBA]: e.RGBA16F,
            [ot.RGB]: e.RGB16F,
            [ot.RG]: e.RG16F,
            [ot.RED]: e.R16F
        },
        [Rt.UNSIGNED_SHORT_5_6_5]: {
            [ot.RGB]: e.RGB565
        },
        [Rt.UNSIGNED_SHORT_4_4_4_4]: {
            [ot.RGBA]: e.RGBA4
        },
        [Rt.UNSIGNED_SHORT_5_5_5_1]: {
            [ot.RGBA]: e.RGB5_A1
        },
        [Rt.UNSIGNED_INT_2_10_10_10_REV]: {
            [ot.RGBA]: e.RGB10_A2,
            [ot.RGBA_INTEGER]: e.RGB10_A2UI
        },
        [Rt.UNSIGNED_INT_10F_11F_11F_REV]: {
            [ot.RGB]: e.R11F_G11F_B10F
        },
        [Rt.UNSIGNED_INT_5_9_9_9_REV]: {
            [ot.RGB]: e.RGB9_E5
        },
        [Rt.UNSIGNED_INT_24_8]: {
            [ot.DEPTH_STENCIL]: e.DEPTH24_STENCIL8
        },
        [Rt.FLOAT_32_UNSIGNED_INT_24_8_REV]: {
            [ot.DEPTH_STENCIL]: e.DEPTH32F_STENCIL8
        }
    } : t = {
        [Rt.UNSIGNED_BYTE]: {
            [ot.RGBA]: e.RGBA,
            [ot.RGB]: e.RGB,
            [ot.ALPHA]: e.ALPHA,
            [ot.LUMINANCE]: e.LUMINANCE,
            [ot.LUMINANCE_ALPHA]: e.LUMINANCE_ALPHA
        },
        [Rt.UNSIGNED_SHORT_5_6_5]: {
            [ot.RGB]: e.RGB
        },
        [Rt.UNSIGNED_SHORT_4_4_4_4]: {
            [ot.RGBA]: e.RGBA
        },
        [Rt.UNSIGNED_SHORT_5_5_5_1]: {
            [ot.RGBA]: e.RGBA
        }
    }, t
}
class a1 {
    constructor(t) {
        this.renderer = t, this.boundTextures = [], this.currentLocation = -1, this.managedTextures = [], this._unknownBoundTextures = !1, this.unknownTexture = new Nt, this.hasIntegerTextures = !1
    }
    contextChange() {
        const t = this.gl = this.renderer.gl;
        this.CONTEXT_UID = this.renderer.CONTEXT_UID, this.webGLVersion = this.renderer.context.webGLVersion, this.internalFormats = f6(t);
        const i = t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS);
        this.boundTextures.length = i;
        for (let n = 0; n < i; n++) this.boundTextures[n] = null;
        this.emptyTextures = {};
        const s = new su(t.createTexture());
        t.bindTexture(t.TEXTURE_2D, s.texture), t.texImage2D(t.TEXTURE_2D, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, new Uint8Array(4)), this.emptyTextures[t.TEXTURE_2D] = s, this.emptyTextures[t.TEXTURE_CUBE_MAP] = new su(t.createTexture()), t.bindTexture(t.TEXTURE_CUBE_MAP, this.emptyTextures[t.TEXTURE_CUBE_MAP].texture);
        for (let n = 0; n < 6; n++) t.texImage2D(t.TEXTURE_CUBE_MAP_POSITIVE_X + n, 0, t.RGBA, 1, 1, 0, t.RGBA, t.UNSIGNED_BYTE, null);
        t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MAG_FILTER, t.LINEAR), t.texParameteri(t.TEXTURE_CUBE_MAP, t.TEXTURE_MIN_FILTER, t.LINEAR);
        for (let n = 0; n < this.boundTextures.length; n++) this.bind(null, n)
    }
    bind(t, i = 0) {
        const {
            gl: s
        } = this;
        if (t = t?.castToBaseTexture(), t?.valid && !t.parentTextureArray) {
            t.touched = this.renderer.textureGC.count;
            const n = t._glTextures[this.CONTEXT_UID] || this.initTexture(t);
            this.boundTextures[i] !== t && (this.currentLocation !== i && (this.currentLocation = i, s.activeTexture(s.TEXTURE0 + i)), s.bindTexture(t.target, n.texture)), n.dirtyId !== t.dirtyId ? (this.currentLocation !== i && (this.currentLocation = i, s.activeTexture(s.TEXTURE0 + i)), this.updateTexture(t)) : n.dirtyStyleId !== t.dirtyStyleId && this.updateTextureStyle(t), this.boundTextures[i] = t
        } else this.currentLocation !== i && (this.currentLocation = i, s.activeTexture(s.TEXTURE0 + i)), s.bindTexture(s.TEXTURE_2D, this.emptyTextures[s.TEXTURE_2D].texture), this.boundTextures[i] = null
    }
    reset() {
        this._unknownBoundTextures = !0, this.hasIntegerTextures = !1, this.currentLocation = -1;
        for (let t = 0; t < this.boundTextures.length; t++) this.boundTextures[t] = this.unknownTexture
    }
    unbind(t) {
        const {
            gl: i,
            boundTextures: s
        } = this;
        if (this._unknownBoundTextures) {
            this._unknownBoundTextures = !1;
            for (let n = 0; n < s.length; n++) s[n] === this.unknownTexture && this.bind(null, n)
        }
        for (let n = 0; n < s.length; n++) s[n] === t && (this.currentLocation !== n && (i.activeTexture(i.TEXTURE0 + n), this.currentLocation = n), i.bindTexture(t.target, this.emptyTextures[t.target].texture), s[n] = null)
    }
    ensureSamplerType(t) {
        const {
            boundTextures: i,
            hasIntegerTextures: s,
            CONTEXT_UID: n
        } = this;
        if (!!s)
            for (let r = t - 1; r >= 0; --r) {
                const o = i[r];
                o && o._glTextures[n].samplerType !== Ku.FLOAT && this.renderer.texture.unbind(o)
            }
    }
    initTexture(t) {
        const i = new su(this.gl.createTexture());
        return i.dirtyId = -1, t._glTextures[this.CONTEXT_UID] = i, this.managedTextures.push(t), t.on("dispose", this.destroyTexture, this), i
    }
    initTextureType(t, i) {
        i.internalFormat = this.internalFormats[t.type]?.[t.format] ?? t.format, this.webGLVersion === 2 && t.type === Rt.HALF_FLOAT ? i.type = this.gl.HALF_FLOAT : i.type = t.type
    }
    updateTexture(t) {
        const i = t._glTextures[this.CONTEXT_UID];
        if (!i) return;
        const s = this.renderer;
        if (this.initTextureType(t, i), t.resource?.upload(s, t, i)) i.samplerType !== Ku.FLOAT && (this.hasIntegerTextures = !0);
        else {
            const n = t.realWidth,
                r = t.realHeight,
                o = s.gl;
            (i.width !== n || i.height !== r || i.dirtyId < 0) && (i.width = n, i.height = r, o.texImage2D(t.target, 0, i.internalFormat, n, r, 0, t.format, i.type, null))
        }
        t.dirtyStyleId !== i.dirtyStyleId && this.updateTextureStyle(t), i.dirtyId = t.dirtyId
    }
    destroyTexture(t, i) {
        const {
            gl: s
        } = this;
        if (t = t.castToBaseTexture(), t._glTextures[this.CONTEXT_UID] && (this.unbind(t), s.deleteTexture(t._glTextures[this.CONTEXT_UID].texture), t.off("dispose", this.destroyTexture, this), delete t._glTextures[this.CONTEXT_UID], !i)) {
            const n = this.managedTextures.indexOf(t);
            n !== -1 && wr(this.managedTextures, n, 1)
        }
    }
    updateTextureStyle(t) {
        const i = t._glTextures[this.CONTEXT_UID];
        !i || ((t.mipmap === ds.POW2 || this.webGLVersion !== 2) && !t.isPowerOfTwo ? i.mipmap = !1 : i.mipmap = t.mipmap >= 1, this.webGLVersion !== 2 && !t.isPowerOfTwo ? i.wrapMode = Zs.CLAMP : i.wrapMode = t.wrapMode, t.resource?.style(this.renderer, t, i) || this.setStyle(t, i), i.dirtyStyleId = t.dirtyStyleId)
    }
    setStyle(t, i) {
        const s = this.gl;
        if (i.mipmap && t.mipmap !== ds.ON_MANUAL && s.generateMipmap(t.target), s.texParameteri(t.target, s.TEXTURE_WRAP_S, i.wrapMode), s.texParameteri(t.target, s.TEXTURE_WRAP_T, i.wrapMode), i.mipmap) {
            s.texParameteri(t.target, s.TEXTURE_MIN_FILTER, t.scaleMode === Hi.LINEAR ? s.LINEAR_MIPMAP_LINEAR : s.NEAREST_MIPMAP_NEAREST);
            const n = this.renderer.context.extensions.anisotropicFiltering;
            if (n && t.anisotropicLevel > 0 && t.scaleMode === Hi.LINEAR) {
                const r = Math.min(t.anisotropicLevel, s.getParameter(n.MAX_TEXTURE_MAX_ANISOTROPY_EXT));
                s.texParameterf(t.target, n.TEXTURE_MAX_ANISOTROPY_EXT, r)
            }
        } else s.texParameteri(t.target, s.TEXTURE_MIN_FILTER, t.scaleMode === Hi.LINEAR ? s.LINEAR : s.NEAREST);
        s.texParameteri(t.target, s.TEXTURE_MAG_FILTER, t.scaleMode === Hi.LINEAR ? s.LINEAR : s.NEAREST)
    }
    destroy() {
        this.renderer = null
    }
}
a1.extension = {
    type: lt.RendererSystem,
    name: "texture"
};
vt.add(a1);
class l1 {
    constructor(t) {
        this.renderer = t
    }
    contextChange() {
        this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(t) {
        const {
            gl: i,
            CONTEXT_UID: s
        } = this, n = t._glTransformFeedbacks[s] || this.createGLTransformFeedback(t);
        i.bindTransformFeedback(i.TRANSFORM_FEEDBACK, n)
    }
    unbind() {
        const {
            gl: t
        } = this;
        t.bindTransformFeedback(t.TRANSFORM_FEEDBACK, null)
    }
    beginTransformFeedback(t, i) {
        const {
            gl: s,
            renderer: n
        } = this;
        i && n.shader.bind(i), s.beginTransformFeedback(t)
    }
    endTransformFeedback() {
        const {
            gl: t
        } = this;
        t.endTransformFeedback()
    }
    createGLTransformFeedback(t) {
        const {
            gl: i,
            renderer: s,
            CONTEXT_UID: n
        } = this, r = i.createTransformFeedback();
        t._glTransformFeedbacks[n] = r, i.bindTransformFeedback(i.TRANSFORM_FEEDBACK, r);
        for (let o = 0; o < t.buffers.length; o++) {
            const a = t.buffers[o];
            !a || (s.buffer.update(a), a._glBuffers[n].refCount++, i.bindBufferBase(i.TRANSFORM_FEEDBACK_BUFFER, o, a._glBuffers[n].buffer || null))
        }
        return i.bindTransformFeedback(i.TRANSFORM_FEEDBACK, null), t.disposeRunner.add(this), r
    }
    disposeTransformFeedback(t, i) {
        const s = t._glTransformFeedbacks[this.CONTEXT_UID],
            n = this.gl;
        t.disposeRunner.remove(this);
        const r = this.renderer.buffer;
        if (r)
            for (let o = 0; o < t.buffers.length; o++) {
                const a = t.buffers[o];
                if (!a) continue;
                const l = a._glBuffers[this.CONTEXT_UID];
                l && (l.refCount--, l.refCount === 0 && !i && r.dispose(a, i))
            }!s || (i || n.deleteTransformFeedback(s), delete t._glTransformFeedbacks[this.CONTEXT_UID])
    }
    destroy() {
        this.renderer = null
    }
}
l1.extension = {
    type: lt.RendererSystem,
    name: "transformFeedback"
};
vt.add(l1);
class c1 {
    constructor(t) {
        this.renderer = t
    }
    init(t) {
        this.screen = new qt(0, 0, t.width, t.height), this.element = t.view || ut.ADAPTER.createCanvas(), this.resolution = t.resolution || ut.RESOLUTION, this.autoDensity = !!t.autoDensity
    }
    resizeView(t, i) {
        this.element.width = Math.round(t * this.resolution), this.element.height = Math.round(i * this.resolution);
        const s = this.element.width / this.resolution,
            n = this.element.height / this.resolution;
        this.screen.width = s, this.screen.height = n, this.autoDensity && (this.element.style.width = `${s}px`, this.element.style.height = `${n}px`), this.renderer.emit("resize", s, n), this.renderer.runners.resize.emit(this.screen.width, this.screen.height)
    }
    destroy(t) {
        t && this.element.parentNode?.removeChild(this.element), this.renderer = null, this.element = null, this.screen = null
    }
}
c1.extension = {
    type: [lt.RendererSystem, lt.CanvasRendererSystem],
    name: "_view"
};
vt.add(c1);
ut.PREFER_ENV = Lr.WEBGL2;
ut.STRICT_TEXTURE_CACHE = !1;
Object.defineProperties(ut, {
    WRAP_MODE: {
        get() {
            return Nt.defaultOptions.wrapMode
        },
        set(e) {
            Qt("7.1.0", "settings.WRAP_MODE is deprecated, use BaseTeture.defaultOptions.wrapMode"), Nt.defaultOptions.wrapMode = e
        }
    },
    SCALE_MODE: {
        get() {
            return Nt.defaultOptions.scaleMode
        },
        set(e) {
            Qt("7.1.0", "settings.SCALE_MODE is deprecated, use BaseTeture.defaultOptions.scaleMode"), Nt.defaultOptions.scaleMode = e
        }
    },
    MIPMAP_TEXTURES: {
        get() {
            return Nt.defaultOptions.mipmap
        },
        set(e) {
            Qt("7.1.0", "settings.MIPMAP_TEXTURES is deprecated, use BaseTeture.defaultOptions.mipmap"), Nt.defaultOptions.mipmap = e
        }
    },
    ANISOTROPIC_LEVEL: {
        get() {
            return Nt.defaultOptions.anisotropicLevel
        },
        set(e) {
            Qt("7.1.0", "settings.ANISOTROPIC_LEVEL is deprecated, use BaseTeture.defaultOptions.anisotropicLevel"), Nt.defaultOptions.anisotropicLevel = e
        }
    },
    FILTER_RESOLUTION: {
        get() {
            return Qt("7.1.0", "settings.FILTER_RESOLUTION is deprecated, use Filter.defaultResolution"), oi.defaultResolution
        },
        set(e) {
            oi.defaultResolution = e
        }
    },
    FILTER_MULTISAMPLE: {
        get() {
            return Qt("7.1.0", "settings.FILTER_MULTISAMPLE is deprecated, use Filter.defaultMultisample"), oi.defaultMultisample
        },
        set(e) {
            oi.defaultMultisample = e
        }
    },
    SPRITE_MAX_TEXTURES: {
        get() {
            return ss.defaultMaxTextures
        },
        set(e) {
            Qt("7.1.0", "settings.SPRITE_MAX_TEXTURES is deprecated, use BatchRenderer.defaultMaxTextures"), ss.defaultMaxTextures = e
        }
    },
    SPRITE_BATCH_SIZE: {
        get() {
            return ss.defaultBatchSize
        },
        set(e) {
            Qt("7.1.0", "settings.SPRITE_BATCH_SIZE is deprecated, use BatchRenderer.defaultBatchSize"), ss.defaultBatchSize = e
        }
    },
    CAN_UPLOAD_SAME_BUFFER: {
        get() {
            return ss.canUploadSameBuffer
        },
        set(e) {
            Qt("7.1.0", "settings.CAN_UPLOAD_SAME_BUFFER is deprecated, use BatchRenderer.canUploadSameBuffer"), ss.canUploadSameBuffer = e
        }
    },
    GC_MODE: {
        get() {
            return ns.defaultMode
        },
        set(e) {
            Qt("7.1.0", "settings.GC_MODE is deprecated, use TextureGCSystem.defaultMode"), ns.defaultMode = e
        }
    },
    GC_MAX_IDLE: {
        get() {
            return ns.defaultMaxIdle
        },
        set(e) {
            Qt("7.1.0", "settings.GC_MAX_IDLE is deprecated, use TextureGCSystem.defaultMaxIdle"), ns.defaultMaxIdle = e
        }
    },
    GC_MAX_CHECK_COUNT: {
        get() {
            return ns.defaultCheckCountMax
        },
        set(e) {
            Qt("7.1.0", "settings.GC_MAX_CHECK_COUNT is deprecated, use TextureGCSystem.defaultCheckCountMax"), ns.defaultCheckCountMax = e
        }
    },
    PRECISION_VERTEX: {
        get() {
            return os.defaultVertexPrecision
        },
        set(e) {
            Qt("7.1.0", "settings.PRECISION_VERTEX is deprecated, use Program.defaultVertexPrecision"), os.defaultVertexPrecision = e
        }
    },
    PRECISION_FRAGMENT: {
        get() {
            return os.defaultFragmentPrecision
        },
        set(e) {
            Qt("7.1.0", "settings.PRECISION_FRAGMENT is deprecated, use Program.defaultFragmentPrecision"), os.defaultFragmentPrecision = e
        }
    }
});
var Lo = (e => (e[e.HIGH = 25] = "HIGH", e[e.NORMAL = 0] = "NORMAL", e[e.LOW = -25] = "LOW", e[e.UTILITY = -50] = "UTILITY", e))(Lo || {});
class nu {
    constructor(t, i = null, s = 0, n = !1) {
        this.next = null, this.previous = null, this._destroyed = !1, this.fn = t, this.context = i, this.priority = s, this.once = n
    }
    match(t, i = null) {
        return this.fn === t && this.context === i
    }
    emit(t) {
        this.fn && (this.context ? this.fn.call(this.context, t) : this.fn(t));
        const i = this.next;
        return this.once && this.destroy(!0), this._destroyed && (this.next = null), i
    }
    connect(t) {
        this.previous = t, t.next && (t.next.previous = this), this.next = t.next, t.next = this
    }
    destroy(t = !1) {
        this._destroyed = !0, this.fn = null, this.context = null, this.previous && (this.previous.next = this.next), this.next && (this.next.previous = this.previous);
        const i = this.next;
        return this.next = t ? null : i, this.previous = null, i
    }
}
const Ei = class {
    constructor() {
        this.autoStart = !1, this.deltaTime = 1, this.lastTime = -1, this.speed = 1, this.started = !1, this._requestId = null, this._maxElapsedMS = 100, this._minElapsedMS = 0, this._protected = !1, this._lastFrame = -1, this._head = new nu(null, null, 1 / 0), this.deltaMS = 1 / Ei.targetFPMS, this.elapsedMS = 1 / Ei.targetFPMS, this._tick = e => {
            this._requestId = null, this.started && (this.update(e), this.started && this._requestId === null && this._head.next && (this._requestId = requestAnimationFrame(this._tick)))
        }
    }
    _requestIfNeeded() {
        this._requestId === null && this._head.next && (this.lastTime = performance.now(), this._lastFrame = this.lastTime, this._requestId = requestAnimationFrame(this._tick))
    }
    _cancelIfNeeded() {
        this._requestId !== null && (cancelAnimationFrame(this._requestId), this._requestId = null)
    }
    _startIfPossible() {
        this.started ? this._requestIfNeeded() : this.autoStart && this.start()
    }
    add(e, t, i = Lo.NORMAL) {
        return this._addListener(new nu(e, t, i))
    }
    addOnce(e, t, i = Lo.NORMAL) {
        return this._addListener(new nu(e, t, i, !0))
    }
    _addListener(e) {
        let t = this._head.next,
            i = this._head;
        if (!t) e.connect(i);
        else {
            for (; t;) {
                if (e.priority > t.priority) {
                    e.connect(i);
                    break
                }
                i = t, t = t.next
            }
            e.previous || e.connect(i)
        }
        return this._startIfPossible(), this
    }
    remove(e, t) {
        let i = this._head.next;
        for (; i;) i.match(e, t) ? i = i.destroy() : i = i.next;
        return this._head.next || this._cancelIfNeeded(), this
    }
    get count() {
        if (!this._head) return 0;
        let e = 0,
            t = this._head;
        for (; t = t.next;) e++;
        return e
    }
    start() {
        this.started || (this.started = !0, this._requestIfNeeded())
    }
    stop() {
        this.started && (this.started = !1, this._cancelIfNeeded())
    }
    destroy() {
        if (!this._protected) {
            this.stop();
            let e = this._head.next;
            for (; e;) e = e.destroy(!0);
            this._head.destroy(), this._head = null
        }
    }
    update(e = performance.now()) {
        let t;
        if (e > this.lastTime) {
            if (t = this.elapsedMS = e - this.lastTime, t > this._maxElapsedMS && (t = this._maxElapsedMS), t *= this.speed, this._minElapsedMS) {
                const n = e - this._lastFrame | 0;
                if (n < this._minElapsedMS) return;
                this._lastFrame = e - n % this._minElapsedMS
            }
            this.deltaMS = t, this.deltaTime = this.deltaMS * Ei.targetFPMS;
            const i = this._head;
            let s = i.next;
            for (; s;) s = s.emit(this.deltaTime);
            i.next || this._cancelIfNeeded()
        } else this.deltaTime = this.deltaMS = this.elapsedMS = 0;
        this.lastTime = e
    }
    get FPS() {
        return 1e3 / this.elapsedMS
    }
    get minFPS() {
        return 1e3 / this._maxElapsedMS
    }
    set minFPS(e) {
        const t = Math.min(this.maxFPS, e),
            i = Math.min(Math.max(0, t) / 1e3, Ei.targetFPMS);
        this._maxElapsedMS = 1 / i
    }
    get maxFPS() {
        return this._minElapsedMS ? Math.round(1e3 / this._minElapsedMS) : 0
    }
    set maxFPS(e) {
        if (e === 0) this._minElapsedMS = 0;
        else {
            const t = Math.max(this.minFPS, e);
            this._minElapsedMS = 1 / (t / 1e3)
        }
    }
    static get shared() {
        if (!Ei._shared) {
            const e = Ei._shared = new Ei;
            e.autoStart = !0, e._protected = !0
        }
        return Ei._shared
    }
    static get system() {
        if (!Ei._system) {
            const e = Ei._system = new Ei;
            e.autoStart = !0, e._protected = !0
        }
        return Ei._system
    }
};
let gi = Ei;
gi.targetFPMS = .06;
Object.defineProperties(ut, {
    TARGET_FPMS: {
        get() {
            return gi.targetFPMS
        },
        set(e) {
            Qt("7.1.0", "settings.TARGET_FPMS is deprecated, use Ticker.targetFPMS"), gi.targetFPMS = e
        }
    }
});
class h1 {
    static init(t) {
        t = Object.assign({
            autoStart: !0,
            sharedTicker: !1
        }, t), Object.defineProperty(this, "ticker", {
            set(i) {
                this._ticker && this._ticker.remove(this.render, this), this._ticker = i, i && i.add(this.render, this, Lo.LOW)
            },
            get() {
                return this._ticker
            }
        }), this.stop = () => {
            this._ticker.stop()
        }, this.start = () => {
            this._ticker.start()
        }, this._ticker = null, this.ticker = t.sharedTicker ? gi.shared : new gi, t.autoStart && this.start()
    }
    static destroy() {
        if (this._ticker) {
            const t = this._ticker;
            this.ticker = null, t.destroy()
        }
    }
}
h1.extension = lt.Application;
vt.add(h1);
const u1 = [];
vt.handleByList(lt.Renderer, u1);

function ma(e) {
    for (const t of u1)
        if (t.test(e)) return new t(e);
    throw new Error("Unable to auto-detect a suitable renderer.")
}
var p6 = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);
    vTextureCoord = aTextureCoord;
}`,
    m6 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 vTextureCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
    gl_Position = filterVertexPosition();
    vTextureCoord = filterTextureCoord();
}
`;
const g6 = p6,
    d1 = m6;
class f1 {
    constructor(t) {
        this.renderer = t
    }
    contextChange(t) {
        let i;
        if (this.renderer.context.webGLVersion === 1) {
            const s = t.getParameter(t.FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.FRAMEBUFFER, null), i = t.getParameter(t.SAMPLES), t.bindFramebuffer(t.FRAMEBUFFER, s)
        } else {
            const s = t.getParameter(t.DRAW_FRAMEBUFFER_BINDING);
            t.bindFramebuffer(t.DRAW_FRAMEBUFFER, null), i = t.getParameter(t.SAMPLES), t.bindFramebuffer(t.DRAW_FRAMEBUFFER, s)
        }
        i >= Fe.HIGH ? this.multisample = Fe.HIGH : i >= Fe.MEDIUM ? this.multisample = Fe.MEDIUM : i >= Fe.LOW ? this.multisample = Fe.LOW : this.multisample = Fe.NONE
    }
    destroy() {}
}
f1.extension = {
    type: lt.RendererSystem,
    name: "_multisample"
};
vt.add(f1);
class v6 {
    constructor(t) {
        this.buffer = t || null, this.updateID = -1, this.byteLength = -1, this.refCount = 0
    }
}
class p1 {
    constructor(t) {
        this.renderer = t, this.managedBuffers = {}, this.boundBufferBases = {}
    }
    destroy() {
        this.renderer = null
    }
    contextChange() {
        this.disposeAll(!0), this.gl = this.renderer.gl, this.CONTEXT_UID = this.renderer.CONTEXT_UID
    }
    bind(t) {
        const {
            gl: i,
            CONTEXT_UID: s
        } = this, n = t._glBuffers[s] || this.createGLBuffer(t);
        i.bindBuffer(t.type, n.buffer)
    }
    unbind(t) {
        const {
            gl: i
        } = this;
        i.bindBuffer(t, null)
    }
    bindBufferBase(t, i) {
        const {
            gl: s,
            CONTEXT_UID: n
        } = this;
        if (this.boundBufferBases[i] !== t) {
            const r = t._glBuffers[n] || this.createGLBuffer(t);
            this.boundBufferBases[i] = t, s.bindBufferBase(s.UNIFORM_BUFFER, i, r.buffer)
        }
    }
    bindBufferRange(t, i, s) {
        const {
            gl: n,
            CONTEXT_UID: r
        } = this;
        s = s || 0;
        const o = t._glBuffers[r] || this.createGLBuffer(t);
        n.bindBufferRange(n.UNIFORM_BUFFER, i || 0, o.buffer, s * 256, 256)
    }
    update(t) {
        const {
            gl: i,
            CONTEXT_UID: s
        } = this, n = t._glBuffers[s] || this.createGLBuffer(t);
        if (t._updateID !== n.updateID)
            if (n.updateID = t._updateID, i.bindBuffer(t.type, n.buffer), n.byteLength >= t.data.byteLength) i.bufferSubData(t.type, 0, t.data);
            else {
                const r = t.static ? i.STATIC_DRAW : i.DYNAMIC_DRAW;
                n.byteLength = t.data.byteLength, i.bufferData(t.type, t.data, r)
            }
    }
    dispose(t, i) {
        if (!this.managedBuffers[t.id]) return;
        delete this.managedBuffers[t.id];
        const s = t._glBuffers[this.CONTEXT_UID],
            n = this.gl;
        t.disposeRunner.remove(this), s && (i || n.deleteBuffer(s.buffer), delete t._glBuffers[this.CONTEXT_UID])
    }
    disposeAll(t) {
        const i = Object.keys(this.managedBuffers);
        for (let s = 0; s < i.length; s++) this.dispose(this.managedBuffers[i[s]], t)
    }
    createGLBuffer(t) {
        const {
            CONTEXT_UID: i,
            gl: s
        } = this;
        return t._glBuffers[i] = new v6(s.createBuffer()), this.managedBuffers[t.id] = t, t.disposeRunner.add(this), t._glBuffers[i]
    }
}
p1.extension = {
    type: lt.RendererSystem,
    name: "buffer"
};
vt.add(p1);
class m1 {
    constructor(t) {
        this.renderer = t
    }
    render(t, i) {
        const s = this.renderer;
        let n, r, o, a;
        if (i && (n = i.renderTexture, r = i.clear, o = i.transform, a = i.skipUpdateTransform), this.renderingToScreen = !n, s.runners.prerender.emit(), s.emit("prerender"), s.projection.transform = o, !s.context.isLost) {
            if (n || (this.lastObjectRendered = t), !a) {
                const l = t.enableTempParent();
                t.updateTransform(), t.disableTempParent(l)
            }
            s.renderTexture.bind(n), s.batch.currentRenderer.start(), (r ?? s.background.clearBeforeRender) && s.renderTexture.clear(), t.render(s), s.batch.currentRenderer.flush(), n && (i.blit && s.framebuffer.blit(), n.baseTexture.update()), s.runners.postrender.emit(), s.projection.transform = null, s.emit("postrender")
        }
    }
    destroy() {
        this.renderer = null, this.lastObjectRendered = null
    }
}
m1.extension = {
    type: lt.RendererSystem,
    name: "objectRenderer"
};
vt.add(m1);
const pd = class extends o1 {
    constructor(e) {
        super(), e = Object.assign({}, ut.RENDER_OPTIONS, e), this.gl = null, this.CONTEXT_UID = 0, this.globalUniforms = new hs({
            projectionMatrix: new pe
        }, !0);
        const t = {
            runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
            systems: pd.__systems,
            priority: ["_view", "textureGenerator", "background", "_plugin", "startup", "context", "state", "texture", "buffer", "geometry", "framebuffer", "transformFeedback", "mask", "scissor", "stencil", "projection", "textureGC", "filter", "renderTexture", "batch", "objectRenderer", "_multisample"]
        };
        this.setup(t), "useContextAlpha" in e && (Qt("7.0.0", "options.useContextAlpha is deprecated, use options.premultipliedAlpha and options.backgroundAlpha instead"), e.premultipliedAlpha = e.useContextAlpha && e.useContextAlpha !== "notMultiplied", e.backgroundAlpha = e.useContextAlpha === !1 ? 1 : e.backgroundAlpha);
        const i = {
            hello: e.hello,
            _plugin: pd.__plugins,
            background: {
                alpha: e.backgroundAlpha,
                color: e.background ?? e.backgroundColor,
                clearBeforeRender: e.clearBeforeRender
            },
            _view: {
                height: e.height,
                width: e.width,
                autoDensity: e.autoDensity,
                resolution: e.resolution,
                view: e.view
            },
            context: {
                antialias: e.antialias,
                context: e.context,
                powerPreference: e.powerPreference,
                premultipliedAlpha: e.premultipliedAlpha,
                preserveDrawingBuffer: e.preserveDrawingBuffer
            }
        };
        this.startup.run(i), this.options = e
    }
    static test(e) {
        return e?.forceCanvas ? !1 : w_()
    }
    render(e, t) {
        this.objectRenderer.render(e, t)
    }
    resize(e, t) {
        this._view.resizeView(e, t)
    }
    reset() {
        return this.runners.reset.emit(), this
    }
    clear() {
        this.renderTexture.bind(), this.renderTexture.clear()
    }
    destroy(e = !1) {
        this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, {
            _view: e
        }), super.destroy()
    }
    get plugins() {
        return this._plugin.plugins
    }
    get multisample() {
        return this._multisample.multisample
    }
    get width() {
        return this._view.element.width
    }
    get height() {
        return this._view.element.height
    }
    get resolution() {
        return this._view.resolution
    }
    set resolution(e) {
        this._view.resolution = e, this.runners.resolutionChange.emit(e)
    }
    get autoDensity() {
        return this._view.autoDensity
    }
    get view() {
        return this._view.element
    }
    get screen() {
        return this._view.screen
    }
    get lastObjectRendered() {
        return this.objectRenderer.lastObjectRendered
    }
    get renderingToScreen() {
        return this.objectRenderer.renderingToScreen
    }
    get rendererLogId() {
        return `WebGL ${this.context.webGLVersion}`
    }
    get clearBeforeRender() {
        return Qt("7.0.0", "renderer.clearBeforeRender has been deprecated, please use renderer.background.clearBeforeRender instead."), this.background.clearBeforeRender
    }
    get useContextAlpha() {
        return Qt("7.0.0", "renderer.useContextAlpha has been deprecated, please use renderer.context.premultipliedAlpha instead."), this.context.useContextAlpha
    }
    get preserveDrawingBuffer() {
        return Qt("7.0.0", "renderer.preserveDrawingBuffer has been deprecated, we cannot truly know this unless pixi created the context"), this.context.preserveDrawingBuffer
    }
    get backgroundColor() {
        return Qt("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color
    }
    set backgroundColor(e) {
        Qt("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color = e
    }
    get backgroundAlpha() {
        return Qt("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.color
    }
    set backgroundAlpha(e) {
        Qt("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha = e
    }
    get powerPreference() {
        return Qt("7.0.0", "renderer.powerPreference has been deprecated, we can only know this if pixi creates the context"), this.context.powerPreference
    }
    generateTexture(e, t) {
        return this.textureGenerator.generateTexture(e, t)
    }
};
let jo = pd;
jo.extension = {
    type: lt.Renderer,
    priority: 1
};
jo.__plugins = {};
jo.__systems = {};
vt.handleByMap(lt.RendererPlugin, jo.__plugins);
vt.handleByMap(lt.RendererSystem, jo.__systems);
vt.add(jo);
class g1 extends Ua {
    constructor(t, i) {
        const {
            width: s,
            height: n
        } = i || {};
        super(s, n), this.items = [], this.itemDirtyIds = [];
        for (let r = 0; r < t; r++) {
            const o = new Nt;
            this.items.push(o), this.itemDirtyIds.push(-2)
        }
        this.length = t, this._load = null, this.baseTexture = null
    }
    initFromArray(t, i) {
        for (let s = 0; s < this.length; s++) !t[s] || (t[s].castToBaseTexture ? this.addBaseTextureAt(t[s].castToBaseTexture(), s) : t[s] instanceof Ua ? this.addResourceAt(t[s], s) : this.addResourceAt(R_(t[s], i), s))
    }
    dispose() {
        for (let t = 0, i = this.length; t < i; t++) this.items[t].destroy();
        this.items = null, this.itemDirtyIds = null, this._load = null
    }
    addResourceAt(t, i) {
        if (!this.items[i]) throw new Error(`Index ${i} is out of bounds`);
        return t.valid && !this.valid && this.resize(t.width, t.height), this.items[i].setResource(t), this
    }
    bind(t) {
        if (this.baseTexture !== null) throw new Error("Only one base texture per TextureArray is allowed");
        super.bind(t);
        for (let i = 0; i < this.length; i++) this.items[i].parentTextureArray = t, this.items[i].on("update", t.update, t)
    }
    unbind(t) {
        super.unbind(t);
        for (let i = 0; i < this.length; i++) this.items[i].parentTextureArray = null, this.items[i].off("update", t.update, t)
    }
    load() {
        if (this._load) return this._load;
        const i = this.items.map(s => s.resource).filter(s => s).map(s => s.load());
        return this._load = Promise.all(i).then(() => {
            const {
                realWidth: s,
                realHeight: n
            } = this.items[0];
            return this.resize(s, n), Promise.resolve(this)
        }), this._load
    }
}
class _6 extends g1 {
    constructor(t, i) {
        const {
            width: s,
            height: n
        } = i || {};
        let r, o;
        Array.isArray(t) ? (r = t, o = t.length) : o = t, super(o, {
            width: s,
            height: n
        }), r && this.initFromArray(r, i)
    }
    addBaseTextureAt(t, i) {
        if (t.resource) this.addResourceAt(t.resource, i);
        else throw new Error("ArrayResource does not support RenderTexture");
        return this
    }
    bind(t) {
        super.bind(t), t.target = mo.TEXTURE_2D_ARRAY
    }
    upload(t, i, s) {
        const {
            length: n,
            itemDirtyIds: r,
            items: o
        } = this, {
            gl: a
        } = t;
        s.dirtyId < 0 && a.texImage3D(a.TEXTURE_2D_ARRAY, 0, s.internalFormat, this._width, this._height, n, 0, i.format, s.type, null);
        for (let l = 0; l < n; l++) {
            const c = o[l];
            r[l] < c.dirtyId && (r[l] = c.dirtyId, c.valid && a.texSubImage3D(a.TEXTURE_2D_ARRAY, 0, 0, 0, l, c.resource.width, c.resource.height, 1, i.format, s.type, c.resource.source))
        }
        return !0
    }
}
class v1 extends Dn {
    constructor(t) {
        super(t)
    }
    static test(t) {
        const {
            OffscreenCanvas: i
        } = globalThis;
        return i && t instanceof i ? !0 : globalThis.HTMLCanvasElement && t instanceof HTMLCanvasElement
    }
}
const ga = class extends g1 {
    constructor(e, t) {
        const {
            width: i,
            height: s,
            autoLoad: n,
            linkBaseTexture: r
        } = t || {};
        if (e && e.length !== ga.SIDES) throw new Error(`Invalid length. Got ${e.length}, expected 6`);
        super(6, {
            width: i,
            height: s
        });
        for (let o = 0; o < ga.SIDES; o++) this.items[o].target = mo.TEXTURE_CUBE_MAP_POSITIVE_X + o;
        this.linkBaseTexture = r !== !1, e && this.initFromArray(e, t), n !== !1 && this.load()
    }
    bind(e) {
        super.bind(e), e.target = mo.TEXTURE_CUBE_MAP
    }
    addBaseTextureAt(e, t, i) {
        if (i === void 0 && (i = this.linkBaseTexture), !this.items[t]) throw new Error(`Index ${t} is out of bounds`);
        if (!this.linkBaseTexture || e.parentTextureArray || Object.keys(e._glTextures).length > 0)
            if (e.resource) this.addResourceAt(e.resource, t);
            else throw new Error("CubeResource does not support copying of renderTexture.");
        else e.target = mo.TEXTURE_CUBE_MAP_POSITIVE_X + t, e.parentTextureArray = this.baseTexture, this.items[t] = e;
        return e.valid && !this.valid && this.resize(e.realWidth, e.realHeight), this.items[t] = e, this
    }
    upload(e, t, i) {
        const s = this.itemDirtyIds;
        for (let n = 0; n < ga.SIDES; n++) {
            const r = this.items[n];
            (s[n] < r.dirtyId || i.dirtyId < t.dirtyId) && (r.valid && r.resource ? (r.resource.upload(e, r, i), s[n] = r.dirtyId) : s[n] < -1 && (e.gl.texImage2D(r.target, 0, i.internalFormat, t.realWidth, t.realHeight, 0, t.format, i.type, null), s[n] = -1))
        }
        return !0
    }
    static test(e) {
        return Array.isArray(e) && e.length === ga.SIDES
    }
};
let _1 = ga;
_1.SIDES = 6;
class ao extends Dn {
    constructor(t, i) {
        var s = (...n) => {
            super(...n)
        };
        i = i || {}, typeof t == "string" ? (s(ao.EMPTY), this.url = t) : (s(t), this.url = null), this.crossOrigin = i.crossOrigin ?? !0, this.alphaMode = typeof i.alphaMode == "number" ? i.alphaMode : null, this._load = null, i.autoLoad !== !1 && this.load()
    }
    load() {
        return this._load ? this._load : (this._load = new Promise(async (t, i) => {
            if (this.url === null) {
                t(this);
                return
            }
            try {
                const s = await ut.ADAPTER.fetch(this.url, {
                    mode: this.crossOrigin ? "cors" : "no-cors"
                });
                if (this.destroyed) return;
                const n = await s.blob();
                if (this.destroyed) return;
                const r = await createImageBitmap(n, {
                    premultiplyAlpha: this.alphaMode === null || this.alphaMode === _s.UNPACK ? "premultiply" : "none"
                });
                if (this.destroyed) return;
                this.source = r, this.update(), t(this)
            } catch (s) {
                if (this.destroyed) return;
                i(s), this.onError.emit(s)
            }
        }), this._load)
    }
    upload(t, i, s) {
        return this.source instanceof ImageBitmap ? (typeof this.alphaMode == "number" && (i.alphaMode = this.alphaMode), super.upload(t, i, s)) : (this.load(), !1)
    }
    dispose() {
        this.source instanceof ImageBitmap && this.source.close(), super.dispose(), this._load = null
    }
    static test(t) {
        return !!globalThis.createImageBitmap && typeof ImageBitmap < "u" && (typeof t == "string" || t instanceof ImageBitmap)
    }
    static get EMPTY() {
        return ao._EMPTY = ao._EMPTY ?? ut.ADAPTER.createCanvas(0, 0), ao._EMPTY
    }
}
const Ql = class extends Dn {
    constructor(e, t) {
        t = t || {}, super(ut.ADAPTER.createCanvas()), this._width = 0, this._height = 0, this.svg = e, this.scale = t.scale || 1, this._overrideWidth = t.width, this._overrideHeight = t.height, this._resolve = null, this._crossorigin = t.crossorigin, this._load = null, t.autoLoad !== !1 && this.load()
    }
    load() {
        return this._load ? this._load : (this._load = new Promise(e => {
            if (this._resolve = () => {
                    this.resize(this.source.width, this.source.height), e(this)
                }, Ql.SVG_XML.test(this.svg.trim())) {
                if (!btoa) throw new Error("Your browser doesn't support base64 conversions.");
                this.svg = `data:image/svg+xml;base64,${btoa(unescape(encodeURIComponent(this.svg)))}`
            }
            this._loadSvg()
        }), this._load)
    }
    _loadSvg() {
        const e = new Image;
        Dn.crossOrigin(e, this.svg, this._crossorigin), e.src = this.svg, e.onerror = t => {
            !this._resolve || (e.onerror = null, this.onError.emit(t))
        }, e.onload = () => {
            if (!this._resolve) return;
            const t = e.width,
                i = e.height;
            if (!t || !i) throw new Error("The SVG image must have width and height defined (in pixels), canvas API needs them.");
            let s = t * this.scale,
                n = i * this.scale;
            (this._overrideWidth || this._overrideHeight) && (s = this._overrideWidth || this._overrideHeight / i * t, n = this._overrideHeight || this._overrideWidth / t * i), s = Math.round(s), n = Math.round(n);
            const r = this.source;
            r.width = s, r.height = n, r._pixiId = `canvas_${Ln()}`, r.getContext("2d").drawImage(e, 0, 0, t, i, 0, 0, s, n), this._resolve(), this._resolve = null
        }
    }
    static getSize(e) {
        const t = Ql.SVG_SIZE.exec(e),
            i = {};
        return t && (i[t[1]] = Math.round(parseFloat(t[3])), i[t[5]] = Math.round(parseFloat(t[7]))), i
    }
    dispose() {
        super.dispose(), this._resolve = null, this._crossorigin = null
    }
    static test(e, t) {
        return t === "svg" || typeof e == "string" && e.startsWith("data:image/svg+xml") || typeof e == "string" && Ql.SVG_XML.test(e)
    }
};
let Ga = Ql;
Ga.SVG_XML = /^(<\?xml[^?]+\?>)?\s*(<!--[^(-->)]*-->)?\s*\<svg/m;
Ga.SVG_SIZE = /<svg[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*(?:\s(width|height)=('|")(\d*(?:\.\d+)?)(?:px)?('|"))[^>]*>/i;
const md = class extends Dn {
    constructor(e, t) {
        if (t = t || {}, !(e instanceof HTMLVideoElement)) {
            const i = document.createElement("video");
            i.setAttribute("preload", "auto"), i.setAttribute("webkit-playsinline", ""), i.setAttribute("playsinline", ""), typeof e == "string" && (e = [e]);
            const s = e[0].src || e[0];
            Dn.crossOrigin(i, s, t.crossorigin);
            for (let n = 0; n < e.length; ++n) {
                const r = document.createElement("source");
                let {
                    src: o,
                    mime: a
                } = e[n];
                o = o || e[n];
                const l = o.split("?").shift().toLowerCase(),
                    c = l.slice(l.lastIndexOf(".") + 1);
                a = a || md.MIME_TYPES[c] || `video/${c}`, r.src = o, r.type = a, i.appendChild(r)
            }
            e = i
        }
        super(e), this.noSubImage = !0, this._autoUpdate = !0, this._isConnectedToTicker = !1, this._updateFPS = t.updateFPS || 0, this._msToNextUpdate = 0, this.autoPlay = t.autoPlay !== !1, this._load = null, this._resolve = null, this._onCanPlay = this._onCanPlay.bind(this), this._onError = this._onError.bind(this), t.autoLoad !== !1 && this.load()
    }
    update(e = 0) {
        if (!this.destroyed) {
            const t = gi.shared.elapsedMS * this.source.playbackRate;
            this._msToNextUpdate = Math.floor(this._msToNextUpdate - t), (!this._updateFPS || this._msToNextUpdate <= 0) && (super.update(), this._msToNextUpdate = this._updateFPS ? Math.floor(1e3 / this._updateFPS) : 0)
        }
    }
    load() {
        if (this._load) return this._load;
        const e = this.source;
        return (e.readyState === e.HAVE_ENOUGH_DATA || e.readyState === e.HAVE_FUTURE_DATA) && e.width && e.height && (e.complete = !0), e.addEventListener("play", this._onPlayStart.bind(this)), e.addEventListener("pause", this._onPlayStop.bind(this)), this._isSourceReady() ? this._onCanPlay() : (e.addEventListener("canplay", this._onCanPlay), e.addEventListener("canplaythrough", this._onCanPlay), e.addEventListener("error", this._onError, !0)), this._load = new Promise(t => {
            this.valid ? t(this) : (this._resolve = t, e.load())
        }), this._load
    }
    _onError(e) {
        this.source.removeEventListener("error", this._onError, !0), this.onError.emit(e)
    }
    _isSourcePlaying() {
        const e = this.source;
        return !e.paused && !e.ended && this._isSourceReady()
    }
    _isSourceReady() {
        return this.source.readyState > 2
    }
    _onPlayStart() {
        this.valid || this._onCanPlay(), this.autoUpdate && !this._isConnectedToTicker && (gi.shared.add(this.update, this), this._isConnectedToTicker = !0)
    }
    _onPlayStop() {
        this._isConnectedToTicker && (gi.shared.remove(this.update, this), this._isConnectedToTicker = !1)
    }
    _onCanPlay() {
        const e = this.source;
        e.removeEventListener("canplay", this._onCanPlay), e.removeEventListener("canplaythrough", this._onCanPlay);
        const t = this.valid;
        this.resize(e.videoWidth, e.videoHeight), !t && this._resolve && (this._resolve(this), this._resolve = null), this._isSourcePlaying() ? this._onPlayStart() : this.autoPlay && e.play()
    }
    dispose() {
        this._isConnectedToTicker && (gi.shared.remove(this.update, this), this._isConnectedToTicker = !1);
        const e = this.source;
        e && (e.removeEventListener("error", this._onError, !0), e.pause(), e.src = "", e.load()), super.dispose()
    }
    get autoUpdate() {
        return this._autoUpdate
    }
    set autoUpdate(e) {
        e !== this._autoUpdate && (this._autoUpdate = e, !this._autoUpdate && this._isConnectedToTicker ? (gi.shared.remove(this.update, this), this._isConnectedToTicker = !1) : this._autoUpdate && !this._isConnectedToTicker && this._isSourcePlaying() && (gi.shared.add(this.update, this), this._isConnectedToTicker = !0))
    }
    get updateFPS() {
        return this._updateFPS
    }
    set updateFPS(e) {
        e !== this._updateFPS && (this._updateFPS = e)
    }
    static test(e, t) {
        return globalThis.HTMLVideoElement && e instanceof HTMLVideoElement || md.TYPES.includes(t)
    }
};
let $f = md;
$f.TYPES = ["mp4", "m4v", "webm", "ogg", "ogv", "h264", "avi", "mov"];
$f.MIME_TYPES = {
    ogv: "video/ogg",
    mov: "video/quicktime",
    m4v: "video/mp4"
};
ld.push(ao, H_, v1, $f, Ga, qa, _1, _6);
class Ec {
    constructor() {
        this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0, this.rect = null, this.updateID = -1
    }
    isEmpty() {
        return this.minX > this.maxX || this.minY > this.maxY
    }
    clear() {
        this.minX = 1 / 0, this.minY = 1 / 0, this.maxX = -1 / 0, this.maxY = -1 / 0
    }
    getRectangle(t) {
        return this.minX > this.maxX || this.minY > this.maxY ? qt.EMPTY : (t = t || new qt(0, 0, 1, 1), t.x = this.minX, t.y = this.minY, t.width = this.maxX - this.minX, t.height = this.maxY - this.minY, t)
    }
    addPoint(t) {
        this.minX = Math.min(this.minX, t.x), this.maxX = Math.max(this.maxX, t.x), this.minY = Math.min(this.minY, t.y), this.maxY = Math.max(this.maxY, t.y)
    }
    addPointMatrix(t, i) {
        const {
            a: s,
            b: n,
            c: r,
            d: o,
            tx: a,
            ty: l
        } = t, c = s * i.x + r * i.y + a, h = n * i.x + o * i.y + l;
        this.minX = Math.min(this.minX, c), this.maxX = Math.max(this.maxX, c), this.minY = Math.min(this.minY, h), this.maxY = Math.max(this.maxY, h)
    }
    addQuad(t) {
        let i = this.minX,
            s = this.minY,
            n = this.maxX,
            r = this.maxY,
            o = t[0],
            a = t[1];
        i = o < i ? o : i, s = a < s ? a : s, n = o > n ? o : n, r = a > r ? a : r, o = t[2], a = t[3], i = o < i ? o : i, s = a < s ? a : s, n = o > n ? o : n, r = a > r ? a : r, o = t[4], a = t[5], i = o < i ? o : i, s = a < s ? a : s, n = o > n ? o : n, r = a > r ? a : r, o = t[6], a = t[7], i = o < i ? o : i, s = a < s ? a : s, n = o > n ? o : n, r = a > r ? a : r, this.minX = i, this.minY = s, this.maxX = n, this.maxY = r
    }
    addFrame(t, i, s, n, r) {
        this.addFrameMatrix(t.worldTransform, i, s, n, r)
    }
    addFrameMatrix(t, i, s, n, r) {
        const o = t.a,
            a = t.b,
            l = t.c,
            c = t.d,
            h = t.tx,
            u = t.ty;
        let d = this.minX,
            f = this.minY,
            p = this.maxX,
            m = this.maxY,
            g = o * i + l * s + h,
            y = a * i + c * s + u;
        d = g < d ? g : d, f = y < f ? y : f, p = g > p ? g : p, m = y > m ? y : m, g = o * n + l * s + h, y = a * n + c * s + u, d = g < d ? g : d, f = y < f ? y : f, p = g > p ? g : p, m = y > m ? y : m, g = o * i + l * r + h, y = a * i + c * r + u, d = g < d ? g : d, f = y < f ? y : f, p = g > p ? g : p, m = y > m ? y : m, g = o * n + l * r + h, y = a * n + c * r + u, d = g < d ? g : d, f = y < f ? y : f, p = g > p ? g : p, m = y > m ? y : m, this.minX = d, this.minY = f, this.maxX = p, this.maxY = m
    }
    addVertexData(t, i, s) {
        let n = this.minX,
            r = this.minY,
            o = this.maxX,
            a = this.maxY;
        for (let l = i; l < s; l += 2) {
            const c = t[l],
                h = t[l + 1];
            n = c < n ? c : n, r = h < r ? h : r, o = c > o ? c : o, a = h > a ? h : a
        }
        this.minX = n, this.minY = r, this.maxX = o, this.maxY = a
    }
    addVertices(t, i, s, n) {
        this.addVerticesMatrix(t.worldTransform, i, s, n)
    }
    addVerticesMatrix(t, i, s, n, r = 0, o = r) {
        const a = t.a,
            l = t.b,
            c = t.c,
            h = t.d,
            u = t.tx,
            d = t.ty;
        let f = this.minX,
            p = this.minY,
            m = this.maxX,
            g = this.maxY;
        for (let y = s; y < n; y += 2) {
            const x = i[y],
                v = i[y + 1],
                _ = a * x + c * v + u,
                C = h * v + l * x + d;
            f = Math.min(f, _ - r), m = Math.max(m, _ + r), p = Math.min(p, C - o), g = Math.max(g, C + o)
        }
        this.minX = f, this.minY = p, this.maxX = m, this.maxY = g
    }
    addBounds(t) {
        const i = this.minX,
            s = this.minY,
            n = this.maxX,
            r = this.maxY;
        this.minX = t.minX < i ? t.minX : i, this.minY = t.minY < s ? t.minY : s, this.maxX = t.maxX > n ? t.maxX : n, this.maxY = t.maxY > r ? t.maxY : r
    }
    addBoundsMask(t, i) {
        const s = t.minX > i.minX ? t.minX : i.minX,
            n = t.minY > i.minY ? t.minY : i.minY,
            r = t.maxX < i.maxX ? t.maxX : i.maxX,
            o = t.maxY < i.maxY ? t.maxY : i.maxY;
        if (s <= r && n <= o) {
            const a = this.minX,
                l = this.minY,
                c = this.maxX,
                h = this.maxY;
            this.minX = s < a ? s : a, this.minY = n < l ? n : l, this.maxX = r > c ? r : c, this.maxY = o > h ? o : h
        }
    }
    addBoundsMatrix(t, i) {
        this.addFrameMatrix(i, t.minX, t.minY, t.maxX, t.maxY)
    }
    addBoundsArea(t, i) {
        const s = t.minX > i.x ? t.minX : i.x,
            n = t.minY > i.y ? t.minY : i.y,
            r = t.maxX < i.x + i.width ? t.maxX : i.x + i.width,
            o = t.maxY < i.y + i.height ? t.maxY : i.y + i.height;
        if (s <= r && n <= o) {
            const a = this.minX,
                l = this.minY,
                c = this.maxX,
                h = this.maxY;
            this.minX = s < a ? s : a, this.minY = n < l ? n : l, this.maxX = r > c ? r : c, this.maxY = o > h ? o : h
        }
    }
    pad(t = 0, i = t) {
        this.isEmpty() || (this.minX -= t, this.maxX += t, this.minY -= i, this.maxY += i)
    }
    addFramePad(t, i, s, n, r, o) {
        t -= r, i -= o, s += r, n += o, this.minX = this.minX < t ? this.minX : t, this.maxX = this.maxX > s ? this.maxX : s, this.minY = this.minY < i ? this.minY : i, this.maxY = this.maxY > n ? this.maxY : n
    }
}
class Ae extends $o {
    constructor() {
        super(), this.tempDisplayObjectParent = null, this.transform = new uh, this.alpha = 1, this.visible = !0, this.renderable = !0, this.cullable = !1, this.cullArea = null, this.parent = null, this.worldAlpha = 1, this._lastSortedIndex = 0, this._zIndex = 0, this.filterArea = null, this.filters = null, this._enabledFilters = null, this._bounds = new Ec, this._localBounds = null, this._boundsID = 0, this._boundsRect = null, this._localBoundsRect = null, this._mask = null, this._maskRefCount = 0, this._destroyed = !1, this.isSprite = !1, this.isMask = !1
    }
    static mixin(t) {
        const i = Object.keys(t);
        for (let s = 0; s < i.length; ++s) {
            const n = i[s];
            Object.defineProperty(Ae.prototype, n, Object.getOwnPropertyDescriptor(t, n))
        }
    }
    get destroyed() {
        return this._destroyed
    }
    _recursivePostUpdateTransform() {
        this.parent ? (this.parent._recursivePostUpdateTransform(), this.transform.updateTransform(this.parent.transform)) : this.transform.updateTransform(this._tempDisplayObjectParent.transform)
    }
    updateTransform() {
        this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha
    }
    getBounds(t, i) {
        return t || (this.parent ? (this._recursivePostUpdateTransform(), this.updateTransform()) : (this.parent = this._tempDisplayObjectParent, this.updateTransform(), this.parent = null)), this._bounds.updateID !== this._boundsID && (this.calculateBounds(), this._bounds.updateID = this._boundsID), i || (this._boundsRect || (this._boundsRect = new qt), i = this._boundsRect), this._bounds.getRectangle(i)
    }
    getLocalBounds(t) {
        t || (this._localBoundsRect || (this._localBoundsRect = new qt), t = this._localBoundsRect), this._localBounds || (this._localBounds = new Ec);
        const i = this.transform,
            s = this.parent;
        this.parent = null, this.transform = this._tempDisplayObjectParent.transform;
        const n = this._bounds,
            r = this._boundsID;
        this._bounds = this._localBounds;
        const o = this.getBounds(!1, t);
        return this.parent = s, this.transform = i, this._bounds = n, this._bounds.updateID += this._boundsID - r, o
    }
    toGlobal(t, i, s = !1) {
        return s || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.apply(t, i)
    }
    toLocal(t, i, s, n) {
        return i && (t = i.toGlobal(t, s, n)), n || (this._recursivePostUpdateTransform(), this.parent ? this.displayObjectUpdateTransform() : (this.parent = this._tempDisplayObjectParent, this.displayObjectUpdateTransform(), this.parent = null)), this.worldTransform.applyInverse(t, s)
    }
    setParent(t) {
        if (!t || !t.addChild) throw new Error("setParent: Argument must be a Container");
        return t.addChild(this), t
    }
    removeFromParent() {
        this.parent?.removeChild(this)
    }
    setTransform(t = 0, i = 0, s = 1, n = 1, r = 0, o = 0, a = 0, l = 0, c = 0) {
        return this.position.x = t, this.position.y = i, this.scale.x = s || 1, this.scale.y = n || 1, this.rotation = r, this.skew.x = o, this.skew.y = a, this.pivot.x = l, this.pivot.y = c, this
    }
    destroy(t) {
        this.removeFromParent(), this._destroyed = !0, this.transform = null, this.parent = null, this._bounds = null, this.mask = null, this.cullArea = null, this.filters = null, this.filterArea = null, this.hitArea = null, this.interactive = !1, this.interactiveChildren = !1, this.emit("destroyed"), this.removeAllListeners()
    }
    get _tempDisplayObjectParent() {
        return this.tempDisplayObjectParent === null && (this.tempDisplayObjectParent = new y6), this.tempDisplayObjectParent
    }
    enableTempParent() {
        const t = this.parent;
        return this.parent = this._tempDisplayObjectParent, t
    }
    disableTempParent(t) {
        this.parent = t
    }
    get x() {
        return this.position.x
    }
    set x(t) {
        this.transform.position.x = t
    }
    get y() {
        return this.position.y
    }
    set y(t) {
        this.transform.position.y = t
    }
    get worldTransform() {
        return this.transform.worldTransform
    }
    get localTransform() {
        return this.transform.localTransform
    }
    get position() {
        return this.transform.position
    }
    set position(t) {
        this.transform.position.copyFrom(t)
    }
    get scale() {
        return this.transform.scale
    }
    set scale(t) {
        this.transform.scale.copyFrom(t)
    }
    get pivot() {
        return this.transform.pivot
    }
    set pivot(t) {
        this.transform.pivot.copyFrom(t)
    }
    get skew() {
        return this.transform.skew
    }
    set skew(t) {
        this.transform.skew.copyFrom(t)
    }
    get rotation() {
        return this.transform.rotation
    }
    set rotation(t) {
        this.transform.rotation = t
    }
    get angle() {
        return this.transform.rotation * _4
    }
    set angle(t) {
        this.transform.rotation = t * y4
    }
    get zIndex() {
        return this._zIndex
    }
    set zIndex(t) {
        this._zIndex = t, this.parent && (this.parent.sortDirty = !0)
    }
    get worldVisible() {
        let t = this;
        do {
            if (!t.visible) return !1;
            t = t.parent
        } while (t);
        return !0
    }
    get mask() {
        return this._mask
    }
    set mask(t) {
        if (this._mask !== t) {
            if (this._mask) {
                const i = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                i && (i._maskRefCount--, i._maskRefCount === 0 && (i.renderable = !0, i.isMask = !1))
            }
            if (this._mask = t, this._mask) {
                const i = this._mask.isMaskData ? this._mask.maskObject : this._mask;
                i && (i._maskRefCount === 0 && (i.renderable = !1, i.isMask = !0), i._maskRefCount++)
            }
        }
    }
}
class y6 extends Ae {
    constructor() {
        super(...arguments), this.sortDirty = null
    }
}
Ae.prototype.displayObjectUpdateTransform = Ae.prototype.updateTransform;
const b6 = new pe;

function x6(e, t) {
    return e.zIndex === t.zIndex ? e._lastSortedIndex - t._lastSortedIndex : e.zIndex - t.zIndex
}
const gd = class extends Ae {
    constructor() {
        super(), this.children = [], this.sortableChildren = gd.defaultSortableChildren, this.sortDirty = !1
    }
    onChildrenChange(e) {}
    addChild(...e) {
        if (e.length > 1)
            for (let t = 0; t < e.length; t++) this.addChild(e[t]);
        else {
            const t = e[0];
            t.parent && t.parent.removeChild(t), t.parent = this, this.sortDirty = !0, t.transform._parentID = -1, this.children.push(t), this._boundsID++, this.onChildrenChange(this.children.length - 1), this.emit("childAdded", t, this, this.children.length - 1), t.emit("added", this)
        }
        return e[0]
    }
    addChildAt(e, t) {
        if (t < 0 || t > this.children.length) throw new Error(`${e}addChildAt: The index ${t} supplied is out of bounds ${this.children.length}`);
        return e.parent && e.parent.removeChild(e), e.parent = this, this.sortDirty = !0, e.transform._parentID = -1, this.children.splice(t, 0, e), this._boundsID++, this.onChildrenChange(t), e.emit("added", this), this.emit("childAdded", e, this, t), e
    }
    swapChildren(e, t) {
        if (e === t) return;
        const i = this.getChildIndex(e),
            s = this.getChildIndex(t);
        this.children[i] = t, this.children[s] = e, this.onChildrenChange(i < s ? i : s)
    }
    getChildIndex(e) {
        const t = this.children.indexOf(e);
        if (t === -1) throw new Error("The supplied DisplayObject must be a child of the caller");
        return t
    }
    setChildIndex(e, t) {
        if (t < 0 || t >= this.children.length) throw new Error(`The index ${t} supplied is out of bounds ${this.children.length}`);
        const i = this.getChildIndex(e);
        wr(this.children, i, 1), this.children.splice(t, 0, e), this.onChildrenChange(t)
    }
    getChildAt(e) {
        if (e < 0 || e >= this.children.length) throw new Error(`getChildAt: Index (${e}) does not exist.`);
        return this.children[e]
    }
    removeChild(...e) {
        if (e.length > 1)
            for (let t = 0; t < e.length; t++) this.removeChild(e[t]);
        else {
            const t = e[0],
                i = this.children.indexOf(t);
            if (i === -1) return null;
            t.parent = null, t.transform._parentID = -1, wr(this.children, i, 1), this._boundsID++, this.onChildrenChange(i), t.emit("removed", this), this.emit("childRemoved", t, this, i)
        }
        return e[0]
    }
    removeChildAt(e) {
        const t = this.getChildAt(e);
        return t.parent = null, t.transform._parentID = -1, wr(this.children, e, 1), this._boundsID++, this.onChildrenChange(e), t.emit("removed", this), this.emit("childRemoved", t, this, e), t
    }
    removeChildren(e = 0, t = this.children.length) {
        const i = e,
            s = t,
            n = s - i;
        let r;
        if (n > 0 && n <= s) {
            r = this.children.splice(i, n);
            for (let o = 0; o < r.length; ++o) r[o].parent = null, r[o].transform && (r[o].transform._parentID = -1);
            this._boundsID++, this.onChildrenChange(e);
            for (let o = 0; o < r.length; ++o) r[o].emit("removed", this), this.emit("childRemoved", r[o], this, o);
            return r
        } else if (n === 0 && this.children.length === 0) return [];
        throw new RangeError("removeChildren: numeric values are outside the acceptable range.")
    }
    sortChildren() {
        let e = !1;
        for (let t = 0, i = this.children.length; t < i; ++t) {
            const s = this.children[t];
            s._lastSortedIndex = t, !e && s.zIndex !== 0 && (e = !0)
        }
        e && this.children.length > 1 && this.children.sort(x6), this.sortDirty = !1
    }
    updateTransform() {
        this.sortableChildren && this.sortDirty && this.sortChildren(), this._boundsID++, this.transform.updateTransform(this.parent.transform), this.worldAlpha = this.alpha * this.parent.worldAlpha;
        for (let e = 0, t = this.children.length; e < t; ++e) {
            const i = this.children[e];
            i.visible && i.updateTransform()
        }
    }
    calculateBounds() {
        this._bounds.clear(), this._calculateBounds();
        for (let e = 0; e < this.children.length; e++) {
            const t = this.children[e];
            if (!(!t.visible || !t.renderable))
                if (t.calculateBounds(), t._mask) {
                    const i = t._mask.isMaskData ? t._mask.maskObject : t._mask;
                    i ? (i.calculateBounds(), this._bounds.addBoundsMask(t._bounds, i._bounds)) : this._bounds.addBounds(t._bounds)
                } else t.filterArea ? this._bounds.addBoundsArea(t._bounds, t.filterArea) : this._bounds.addBounds(t._bounds)
        }
        this._bounds.updateID = this._boundsID
    }
    getLocalBounds(e, t = !1) {
        const i = super.getLocalBounds(e);
        if (!t)
            for (let s = 0, n = this.children.length; s < n; ++s) {
                const r = this.children[s];
                r.visible && r.updateTransform()
            }
        return i
    }
    _calculateBounds() {}
    _renderWithCulling(e) {
        const t = e.renderTexture.sourceFrame;
        if (!(t.width > 0 && t.height > 0)) return;
        let i, s;
        this.cullArea ? (i = this.cullArea, s = this.worldTransform) : this._render !== gd.prototype._render && (i = this.getBounds(!0));
        const n = e.projection.transform;
        if (n && (s ? (s = b6.copyFrom(s), s.prepend(n)) : s = n), i && t.intersects(i, s)) this._render(e);
        else if (this.cullArea) return;
        for (let r = 0, o = this.children.length; r < o; ++r) {
            const a = this.children[r],
                l = a.cullable;
            a.cullable = l || !this.cullArea, a.render(e), a.cullable = l
        }
    }
    render(e) {
        if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable))
            if (this._mask || this.filters?.length) this.renderAdvanced(e);
            else if (this.cullable) this._renderWithCulling(e);
        else {
            this._render(e);
            for (let t = 0, i = this.children.length; t < i; ++t) this.children[t].render(e)
        }
    }
    renderAdvanced(e) {
        const t = this.filters,
            i = this._mask;
        if (t) {
            this._enabledFilters || (this._enabledFilters = []), this._enabledFilters.length = 0;
            for (let n = 0; n < t.length; n++) t[n].enabled && this._enabledFilters.push(t[n])
        }
        const s = t && this._enabledFilters?.length || i && (!i.isMaskData || i.enabled && (i.autoDetect || i.type !== Ue.NONE));
        if (s && e.batch.flush(), t && this._enabledFilters?.length && e.filter.push(this, this._enabledFilters), i && e.mask.push(this, this._mask), this.cullable) this._renderWithCulling(e);
        else {
            this._render(e);
            for (let n = 0, r = this.children.length; n < r; ++n) this.children[n].render(e)
        }
        s && e.batch.flush(), i && e.mask.pop(this), t && this._enabledFilters?.length && e.filter.pop()
    }
    _render(e) {}
    destroy(e) {
        super.destroy(), this.sortDirty = !1;
        const t = typeof e == "boolean" ? e : e?.children,
            i = this.removeChildren(0, this.children.length);
        if (t)
            for (let s = 0; s < i.length; ++s) i[s].destroy(e)
    }
    get width() {
        return this.scale.x * this.getLocalBounds().width
    }
    set width(e) {
        const t = this.getLocalBounds().width;
        t !== 0 ? this.scale.x = e / t : this.scale.x = 1, this._width = e
    }
    get height() {
        return this.scale.y * this.getLocalBounds().height
    }
    set height(e) {
        const t = this.getLocalBounds().height;
        t !== 0 ? this.scale.y = e / t : this.scale.y = 1, this._height = e
    }
};
let ae = gd;
ae.defaultSortableChildren = !1;
ae.prototype.containerUpdateTransform = ae.prototype.updateTransform;
Object.defineProperties(ut, {
    SORTABLE_CHILDREN: {
        get() {
            return ae.defaultSortableChildren
        },
        set(e) {
            Qt("7.1.0", "settings.SORTABLE_CHILDREN is deprecated, use Container.defaultSortableChildren"), ae.defaultSortableChildren = e
        }
    }
});
const ea = new Zt,
    w6 = new Uint16Array([0, 1, 2, 0, 2, 3]);
class hi extends ae {
    constructor(t) {
        super(), this._anchor = new wn(this._onAnchorUpdate, this, t ? t.defaultAnchor.x : 0, t ? t.defaultAnchor.y : 0), this._texture = null, this._width = 0, this._height = 0, this._tint = null, this._tintRGB = null, this.tint = 16777215, this.blendMode = j.NORMAL, this._cachedTint = 16777215, this.uvs = null, this.texture = t || ht.EMPTY, this.vertexData = new Float32Array(8), this.vertexTrimmedData = null, this._transformID = -1, this._textureID = -1, this._transformTrimmedID = -1, this._textureTrimmedID = -1, this.indices = w6, this.pluginName = "batch", this.isSprite = !0, this._roundPixels = ut.ROUND_PIXELS
    }
    _onTextureUpdate() {
        this._textureID = -1, this._textureTrimmedID = -1, this._cachedTint = 16777215, this._width && (this.scale.x = rr(this.scale.x) * this._width / this._texture.orig.width), this._height && (this.scale.y = rr(this.scale.y) * this._height / this._texture.orig.height)
    }
    _onAnchorUpdate() {
        this._transformID = -1, this._transformTrimmedID = -1
    }
    calculateVertices() {
        const t = this._texture;
        if (this._transformID === this.transform._worldID && this._textureID === t._updateID) return;
        this._textureID !== t._updateID && (this.uvs = this._texture._uvs.uvsFloat32), this._transformID = this.transform._worldID, this._textureID = t._updateID;
        const i = this.transform.worldTransform,
            s = i.a,
            n = i.b,
            r = i.c,
            o = i.d,
            a = i.tx,
            l = i.ty,
            c = this.vertexData,
            h = t.trim,
            u = t.orig,
            d = this._anchor;
        let f = 0,
            p = 0,
            m = 0,
            g = 0;
        if (h ? (p = h.x - d._x * u.width, f = p + h.width, g = h.y - d._y * u.height, m = g + h.height) : (p = -d._x * u.width, f = p + u.width, g = -d._y * u.height, m = g + u.height), c[0] = s * p + r * g + a, c[1] = o * g + n * p + l, c[2] = s * f + r * g + a, c[3] = o * g + n * f + l, c[4] = s * f + r * m + a, c[5] = o * m + n * f + l, c[6] = s * p + r * m + a, c[7] = o * m + n * p + l, this._roundPixels) {
            const y = ut.RESOLUTION;
            for (let x = 0; x < c.length; ++x) c[x] = Math.round(c[x] * y) / y
        }
    }
    calculateTrimmedVertices() {
        if (!this.vertexTrimmedData) this.vertexTrimmedData = new Float32Array(8);
        else if (this._transformTrimmedID === this.transform._worldID && this._textureTrimmedID === this._texture._updateID) return;
        this._transformTrimmedID = this.transform._worldID, this._textureTrimmedID = this._texture._updateID;
        const t = this._texture,
            i = this.vertexTrimmedData,
            s = t.orig,
            n = this._anchor,
            r = this.transform.worldTransform,
            o = r.a,
            a = r.b,
            l = r.c,
            c = r.d,
            h = r.tx,
            u = r.ty,
            d = -n._x * s.width,
            f = d + s.width,
            p = -n._y * s.height,
            m = p + s.height;
        i[0] = o * d + l * p + h, i[1] = c * p + a * d + u, i[2] = o * f + l * p + h, i[3] = c * p + a * f + u, i[4] = o * f + l * m + h, i[5] = c * m + a * f + u, i[6] = o * d + l * m + h, i[7] = c * m + a * d + u
    }
    _render(t) {
        this.calculateVertices(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this)
    }
    _calculateBounds() {
        const t = this._texture.trim,
            i = this._texture.orig;
        !t || t.width === i.width && t.height === i.height ? (this.calculateVertices(), this._bounds.addQuad(this.vertexData)) : (this.calculateTrimmedVertices(), this._bounds.addQuad(this.vertexTrimmedData))
    }
    getLocalBounds(t) {
        return this.children.length === 0 ? (this._localBounds || (this._localBounds = new Ec), this._localBounds.minX = this._texture.orig.width * -this._anchor._x, this._localBounds.minY = this._texture.orig.height * -this._anchor._y, this._localBounds.maxX = this._texture.orig.width * (1 - this._anchor._x), this._localBounds.maxY = this._texture.orig.height * (1 - this._anchor._y), t || (this._localBoundsRect || (this._localBoundsRect = new qt), t = this._localBoundsRect), this._localBounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
    }
    containsPoint(t) {
        this.worldTransform.applyInverse(t, ea);
        const i = this._texture.orig.width,
            s = this._texture.orig.height,
            n = -i * this.anchor.x;
        let r = 0;
        return ea.x >= n && ea.x < n + i && (r = -s * this.anchor.y, ea.y >= r && ea.y < r + s)
    }
    destroy(t) {
        if (super.destroy(t), this._texture.off("update", this._onTextureUpdate, this), this._anchor = null, typeof t == "boolean" ? t : t?.texture) {
            const s = typeof t == "boolean" ? t : t?.baseTexture;
            this._texture.destroy(!!s)
        }
        this._texture = null
    }
    static from(t, i) {
        const s = t instanceof ht ? t : ht.from(t, i);
        return new hi(s)
    }
    set roundPixels(t) {
        this._roundPixels !== t && (this._transformID = -1), this._roundPixels = t
    }
    get roundPixels() {
        return this._roundPixels
    }
    get width() {
        return Math.abs(this.scale.x) * this._texture.orig.width
    }
    set width(t) {
        const i = rr(this.scale.x) || 1;
        this.scale.x = i * t / this._texture.orig.width, this._width = t
    }
    get height() {
        return Math.abs(this.scale.y) * this._texture.orig.height
    }
    set height(t) {
        const i = rr(this.scale.y) || 1;
        this.scale.y = i * t / this._texture.orig.height, this._height = t
    }
    get anchor() {
        return this._anchor
    }
    set anchor(t) {
        this._anchor.copyFrom(t)
    }
    get tint() {
        return this._tint
    }
    set tint(t) {
        this._tint = t, this._tintRGB = (t >> 16) + (t & 65280) + ((t & 255) << 16)
    }
    get texture() {
        return this._texture
    }
    set texture(t) {
        this._texture !== t && (this._texture && this._texture.off("update", this._onTextureUpdate, this), this._texture = t || ht.EMPTY, this._cachedTint = 16777215, this._textureID = -1, this._textureTrimmedID = -1, t && (t.baseTexture.valid ? this._onTextureUpdate() : t.once("update", this._onTextureUpdate, this)))
    }
}
const y1 = new pe;
Ae.prototype._cacheAsBitmap = !1;
Ae.prototype._cacheData = null;
Ae.prototype._cacheAsBitmapResolution = null;
Ae.prototype._cacheAsBitmapMultisample = null;
class T6 {
    constructor() {
        this.textureCacheId = null, this.originalRender = null, this.originalRenderCanvas = null, this.originalCalculateBounds = null, this.originalGetLocalBounds = null, this.originalUpdateTransform = null, this.originalDestroy = null, this.originalMask = null, this.originalFilterArea = null, this.originalContainsPoint = null, this.sprite = null
    }
}
Object.defineProperties(Ae.prototype, {
    cacheAsBitmapResolution: {
        get() {
            return this._cacheAsBitmapResolution
        },
        set(e) {
            e !== this._cacheAsBitmapResolution && (this._cacheAsBitmapResolution = e, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmapMultisample: {
        get() {
            return this._cacheAsBitmapMultisample
        },
        set(e) {
            e !== this._cacheAsBitmapMultisample && (this._cacheAsBitmapMultisample = e, this.cacheAsBitmap && (this.cacheAsBitmap = !1, this.cacheAsBitmap = !0))
        }
    },
    cacheAsBitmap: {
        get() {
            return this._cacheAsBitmap
        },
        set(e) {
            if (this._cacheAsBitmap === e) return;
            this._cacheAsBitmap = e;
            let t;
            e ? (this._cacheData || (this._cacheData = new T6), t = this._cacheData, t.originalRender = this.render, t.originalRenderCanvas = this.renderCanvas, t.originalUpdateTransform = this.updateTransform, t.originalCalculateBounds = this.calculateBounds, t.originalGetLocalBounds = this.getLocalBounds, t.originalDestroy = this.destroy, t.originalContainsPoint = this.containsPoint, t.originalMask = this._mask, t.originalFilterArea = this.filterArea, this.render = this._renderCached, this.renderCanvas = this._renderCachedCanvas, this.destroy = this._cacheAsBitmapDestroy) : (t = this._cacheData, t.sprite && this._destroyCachedDisplayObject(), this.render = t.originalRender, this.renderCanvas = t.originalRenderCanvas, this.calculateBounds = t.originalCalculateBounds, this.getLocalBounds = t.originalGetLocalBounds, this.destroy = t.originalDestroy, this.updateTransform = t.originalUpdateTransform, this.containsPoint = t.originalContainsPoint, this._mask = t.originalMask, this.filterArea = t.originalFilterArea)
        }
    }
});
Ae.prototype._renderCached = function(t) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObject(t), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._render(t))
};
Ae.prototype._initCachedDisplayObject = function(t) {
    if (this._cacheData?.sprite) return;
    const i = this.alpha;
    this.alpha = 1, t.batch.flush();
    const s = this.getLocalBounds(null, !0).clone();
    if (this.filters?.length) {
        const d = this.filters[0].padding;
        s.pad(d)
    }
    s.ceil(ut.RESOLUTION);
    const n = t.renderTexture.current,
        r = t.renderTexture.sourceFrame.clone(),
        o = t.renderTexture.destinationFrame.clone(),
        a = t.projection.transform,
        l = fs.create({
            width: s.width,
            height: s.height,
            resolution: this.cacheAsBitmapResolution || t.resolution,
            multisample: this.cacheAsBitmapMultisample ?? t.multisample
        }),
        c = `cacheAsBitmap_${Ln()}`;
    this._cacheData.textureCacheId = c, Nt.addToCache(l.baseTexture, c), ht.addToCache(l, c);
    const h = this.transform.localTransform.copyTo(y1).invert().translate(-s.x, -s.y);
    this.render = this._cacheData.originalRender, t.render(this, {
        renderTexture: l,
        clear: !0,
        transform: h,
        skipUpdateTransform: !1
    }), t.framebuffer.blit(), t.projection.transform = a, t.renderTexture.bind(n, r, o), this.render = this._renderCached, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = i;
    const u = new hi(l);
    u.transform.worldTransform = this.transform.worldTransform, u.anchor.x = -(s.x / s.width), u.anchor.y = -(s.y / s.height), u.alpha = i, u._bounds = this._bounds, this._cacheData.sprite = u, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.enableTempParent(), this.updateTransform(), this.disableTempParent(null)), this.containsPoint = u.containsPoint.bind(u)
};
Ae.prototype._renderCachedCanvas = function(t) {
    !this.visible || this.worldAlpha <= 0 || !this.renderable || (this._initCachedDisplayObjectCanvas(t), this._cacheData.sprite.worldAlpha = this.worldAlpha, this._cacheData.sprite._renderCanvas(t))
};
Ae.prototype._initCachedDisplayObjectCanvas = function(t) {
    if (this._cacheData?.sprite) return;
    const i = this.getLocalBounds(null, !0),
        s = this.alpha;
    this.alpha = 1;
    const n = t.canvasContext.activeContext,
        r = t._projTransform;
    i.ceil(ut.RESOLUTION);
    const o = fs.create({
            width: i.width,
            height: i.height
        }),
        a = `cacheAsBitmap_${Ln()}`;
    this._cacheData.textureCacheId = a, Nt.addToCache(o.baseTexture, a), ht.addToCache(o, a);
    const l = y1;
    this.transform.localTransform.copyTo(l), l.invert(), l.tx -= i.x, l.ty -= i.y, this.renderCanvas = this._cacheData.originalRenderCanvas, t.render(this, {
        renderTexture: o,
        clear: !0,
        transform: l,
        skipUpdateTransform: !1
    }), t.canvasContext.activeContext = n, t._projTransform = r, this.renderCanvas = this._renderCachedCanvas, this.updateTransform = this.displayObjectUpdateTransform, this.calculateBounds = this._calculateCachedBounds, this.getLocalBounds = this._getCachedLocalBounds, this._mask = null, this.filterArea = null, this.alpha = s;
    const c = new hi(o);
    c.transform.worldTransform = this.transform.worldTransform, c.anchor.x = -(i.x / i.width), c.anchor.y = -(i.y / i.height), c.alpha = s, c._bounds = this._bounds, this._cacheData.sprite = c, this.transform._parentID = -1, this.parent ? this.updateTransform() : (this.parent = t._tempDisplayObjectParent, this.updateTransform(), this.parent = null), this.containsPoint = c.containsPoint.bind(c)
};
Ae.prototype._calculateCachedBounds = function() {
    this._bounds.clear(), this._cacheData.sprite.transform._worldID = this.transform._worldID, this._cacheData.sprite._calculateBounds(), this._bounds.updateID = this._boundsID
};
Ae.prototype._getCachedLocalBounds = function() {
    return this._cacheData.sprite.getLocalBounds(null)
};
Ae.prototype._destroyCachedDisplayObject = function() {
    this._cacheData.sprite._texture.destroy(!0), this._cacheData.sprite = null, Nt.removeFromCache(this._cacheData.textureCacheId), ht.removeFromCache(this._cacheData.textureCacheId), this._cacheData.textureCacheId = null
};
Ae.prototype._cacheAsBitmapDestroy = function(t) {
    this.cacheAsBitmap = !1, this.destroy(t)
};
Ae.prototype.name = null;
ae.prototype.getChildByName = function(t, i) {
    for (let s = 0, n = this.children.length; s < n; s++)
        if (this.children[s].name === t) return this.children[s];
    if (i)
        for (let s = 0, n = this.children.length; s < n; s++) {
            const r = this.children[s];
            if (!r.getChildByName) continue;
            const o = r.getChildByName(t, !0);
            if (o) return o
        }
    return null
};
Ae.prototype.getGlobalPosition = function(t = new Zt, i = !1) {
    return this.parent ? this.parent.toGlobal(this.position, t, i) : (t.x = this.position.x, t.y = this.position.y), t
};
var E6 = `varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform float uAlpha;

void main(void)
{
   gl_FragColor = texture2D(uSampler, vTextureCoord) * uAlpha;
}
`;
class S6 extends oi {
    constructor(t = 1) {
        super(g6, E6, {
            uAlpha: 1
        }), this.alpha = t
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
const C6 = {
        5: [.153388, .221461, .250301],
        7: [.071303, .131514, .189879, .214607],
        9: [.028532, .067234, .124009, .179044, .20236],
        11: [.0093, .028002, .065984, .121703, .175713, .198596],
        13: [.002406, .009255, .027867, .065666, .121117, .174868, .197641],
        15: [489e-6, .002403, .009246, .02784, .065602, .120999, .174697, .197448]
    },
    A6 = ["varying vec2 vBlurTexCoords[%size%];", "uniform sampler2D uSampler;", "void main(void)", "{", "    gl_FragColor = vec4(0.0);", "    %blur%", "}"].join(`
`);

function I6(e) {
    const t = C6[e],
        i = t.length;
    let s = A6,
        n = "";
    const r = "gl_FragColor += texture2D(uSampler, vBlurTexCoords[%index%]) * %value%;";
    let o;
    for (let a = 0; a < e; a++) {
        let l = r.replace("%index%", a.toString());
        o = a, a >= i && (o = e - a - 1), l = l.replace("%value%", t[o].toString()), n += l, n += `
`
    }
    return s = s.replace("%blur%", n), s = s.replace("%size%", e.toString()), s
}
const M6 = `
    attribute vec2 aVertexPosition;

    uniform mat3 projectionMatrix;

    uniform float strength;

    varying vec2 vBlurTexCoords[%size%];

    uniform vec4 inputSize;
    uniform vec4 outputFrame;

    vec4 filterVertexPosition( void )
    {
        vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

        return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
    }

    vec2 filterTextureCoord( void )
    {
        return aVertexPosition * (outputFrame.zw * inputSize.zw);
    }

    void main(void)
    {
        gl_Position = filterVertexPosition();

        vec2 textureCoord = filterTextureCoord();
        %blur%
    }`;

function R6(e, t) {
    const i = Math.ceil(e / 2);
    let s = M6,
        n = "",
        r;
    t ? r = "vBlurTexCoords[%index%] =  textureCoord + vec2(%sampleIndex% * strength, 0.0);" : r = "vBlurTexCoords[%index%] =  textureCoord + vec2(0.0, %sampleIndex% * strength);";
    for (let o = 0; o < e; o++) {
        let a = r.replace("%index%", o.toString());
        a = a.replace("%sampleIndex%", `${o-(i-1)}.0`), n += a, n += `
`
    }
    return s = s.replace("%blur%", n), s = s.replace("%size%", e.toString()), s
}
class vd extends oi {
    constructor(t, i = 8, s = 4, n = ut.FILTER_RESOLUTION, r = 5) {
        const o = R6(r, t),
            a = I6(r);
        super(o, a), this.horizontal = t, this.resolution = n, this._quality = 0, this.quality = s, this.blur = i
    }
    apply(t, i, s, n) {
        if (s ? this.horizontal ? this.uniforms.strength = 1 / s.width * (s.width / i.width) : this.uniforms.strength = 1 / s.height * (s.height / i.height) : this.horizontal ? this.uniforms.strength = 1 / t.renderer.width * (t.renderer.width / i.width) : this.uniforms.strength = 1 / t.renderer.height * (t.renderer.height / i.height), this.uniforms.strength *= this.strength, this.uniforms.strength /= this.passes, this.passes === 1) t.applyFilter(this, i, s, n);
        else {
            const r = t.getFilterTexture(),
                o = t.renderer;
            let a = i,
                l = r;
            this.state.blend = !1, t.applyFilter(this, a, l, Ss.CLEAR);
            for (let c = 1; c < this.passes - 1; c++) {
                t.bindAndClear(a, Ss.BLIT), this.uniforms.uSampler = l;
                const h = l;
                l = a, a = h, o.shader.bind(this), o.geometry.draw(5)
            }
            this.state.blend = !0, t.applyFilter(this, l, s, n), t.returnFilterTexture(r)
        }
    }
    get blur() {
        return this.strength
    }
    set blur(t) {
        this.padding = 1 + Math.abs(t) * 2, this.strength = t
    }
    get quality() {
        return this._quality
    }
    set quality(t) {
        this._quality = t, this.passes = t
    }
}
class k6 extends oi {
    constructor(t = 8, i = 4, s = oi.defaultResolution, n = 5) {
        super(), this.blurXFilter = new vd(!0, t, i, s, n), this.blurYFilter = new vd(!1, t, i, s, n), this.resolution = s, this.quality = i, this.blur = t, this.repeatEdgePixels = !1
    }
    apply(t, i, s, n) {
        const r = Math.abs(this.blurXFilter.strength),
            o = Math.abs(this.blurYFilter.strength);
        if (r && o) {
            const a = t.getFilterTexture();
            this.blurXFilter.apply(t, i, a, Ss.CLEAR), this.blurYFilter.apply(t, a, s, n), t.returnFilterTexture(a)
        } else o ? this.blurYFilter.apply(t, i, s, n) : this.blurXFilter.apply(t, i, s, n)
    }
    updatePadding() {
        this._repeatEdgePixels ? this.padding = 0 : this.padding = Math.max(Math.abs(this.blurXFilter.strength), Math.abs(this.blurYFilter.strength)) * 2
    }
    get blur() {
        return this.blurXFilter.blur
    }
    set blur(t) {
        this.blurXFilter.blur = this.blurYFilter.blur = t, this.updatePadding()
    }
    get quality() {
        return this.blurXFilter.quality
    }
    set quality(t) {
        this.blurXFilter.quality = this.blurYFilter.quality = t
    }
    get blurX() {
        return this.blurXFilter.blur
    }
    set blurX(t) {
        this.blurXFilter.blur = t, this.updatePadding()
    }
    get blurY() {
        return this.blurYFilter.blur
    }
    set blurY(t) {
        this.blurYFilter.blur = t, this.updatePadding()
    }
    get blendMode() {
        return this.blurYFilter.blendMode
    }
    set blendMode(t) {
        this.blurYFilter.blendMode = t
    }
    get repeatEdgePixels() {
        return this._repeatEdgePixels
    }
    set repeatEdgePixels(t) {
        this._repeatEdgePixels = t, this.updatePadding()
    }
}
var P6 = `varying vec2 vTextureCoord;
uniform sampler2D uSampler;
uniform float m[20];
uniform float uAlpha;

void main(void)
{
    vec4 c = texture2D(uSampler, vTextureCoord);

    if (uAlpha == 0.0) {
        gl_FragColor = c;
        return;
    }

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (c.a > 0.0) {
      c.rgb /= c.a;
    }

    vec4 result;

    result.r = (m[0] * c.r);
        result.r += (m[1] * c.g);
        result.r += (m[2] * c.b);
        result.r += (m[3] * c.a);
        result.r += m[4];

    result.g = (m[5] * c.r);
        result.g += (m[6] * c.g);
        result.g += (m[7] * c.b);
        result.g += (m[8] * c.a);
        result.g += m[9];

    result.b = (m[10] * c.r);
       result.b += (m[11] * c.g);
       result.b += (m[12] * c.b);
       result.b += (m[13] * c.a);
       result.b += m[14];

    result.a = (m[15] * c.r);
       result.a += (m[16] * c.g);
       result.a += (m[17] * c.b);
       result.a += (m[18] * c.a);
       result.a += m[19];

    vec3 rgb = mix(c.rgb, result.rgb, uAlpha);

    // Premultiply alpha again.
    rgb *= result.a;

    gl_FragColor = vec4(rgb, result.a);
}
`;
class _d extends oi {
    constructor() {
        const t = {
            m: new Float32Array([1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0]),
            uAlpha: 1
        };
        super(d1, P6, t), this.alpha = 1
    }
    _loadMatrix(t, i = !1) {
        let s = t;
        i && (this._multiply(s, this.uniforms.m, t), s = this._colorMatrix(s)), this.uniforms.m = s
    }
    _multiply(t, i, s) {
        return t[0] = i[0] * s[0] + i[1] * s[5] + i[2] * s[10] + i[3] * s[15], t[1] = i[0] * s[1] + i[1] * s[6] + i[2] * s[11] + i[3] * s[16], t[2] = i[0] * s[2] + i[1] * s[7] + i[2] * s[12] + i[3] * s[17], t[3] = i[0] * s[3] + i[1] * s[8] + i[2] * s[13] + i[3] * s[18], t[4] = i[0] * s[4] + i[1] * s[9] + i[2] * s[14] + i[3] * s[19] + i[4], t[5] = i[5] * s[0] + i[6] * s[5] + i[7] * s[10] + i[8] * s[15], t[6] = i[5] * s[1] + i[6] * s[6] + i[7] * s[11] + i[8] * s[16], t[7] = i[5] * s[2] + i[6] * s[7] + i[7] * s[12] + i[8] * s[17], t[8] = i[5] * s[3] + i[6] * s[8] + i[7] * s[13] + i[8] * s[18], t[9] = i[5] * s[4] + i[6] * s[9] + i[7] * s[14] + i[8] * s[19] + i[9], t[10] = i[10] * s[0] + i[11] * s[5] + i[12] * s[10] + i[13] * s[15], t[11] = i[10] * s[1] + i[11] * s[6] + i[12] * s[11] + i[13] * s[16], t[12] = i[10] * s[2] + i[11] * s[7] + i[12] * s[12] + i[13] * s[17], t[13] = i[10] * s[3] + i[11] * s[8] + i[12] * s[13] + i[13] * s[18], t[14] = i[10] * s[4] + i[11] * s[9] + i[12] * s[14] + i[13] * s[19] + i[14], t[15] = i[15] * s[0] + i[16] * s[5] + i[17] * s[10] + i[18] * s[15], t[16] = i[15] * s[1] + i[16] * s[6] + i[17] * s[11] + i[18] * s[16], t[17] = i[15] * s[2] + i[16] * s[7] + i[17] * s[12] + i[18] * s[17], t[18] = i[15] * s[3] + i[16] * s[8] + i[17] * s[13] + i[18] * s[18], t[19] = i[15] * s[4] + i[16] * s[9] + i[17] * s[14] + i[18] * s[19] + i[19], t
    }
    _colorMatrix(t) {
        const i = new Float32Array(t);
        return i[4] /= 255, i[9] /= 255, i[14] /= 255, i[19] /= 255, i
    }
    brightness(t, i) {
        const s = [t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, i)
    }
    tint(t, i) {
        const s = t >> 16 & 255,
            n = t >> 8 & 255,
            r = t & 255,
            o = [s / 255, 0, 0, 0, 0, 0, n / 255, 0, 0, 0, 0, 0, r / 255, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(o, i)
    }
    greyscale(t, i) {
        const s = [t, t, t, 0, 0, t, t, t, 0, 0, t, t, t, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, i)
    }
    blackAndWhite(t) {
        const i = [.3, .6, .1, 0, 0, .3, .6, .1, 0, 0, .3, .6, .1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    hue(t, i) {
        t = (t || 0) / 180 * Math.PI;
        const s = Math.cos(t),
            n = Math.sin(t),
            r = Math.sqrt,
            o = 1 / 3,
            a = r(o),
            l = s + (1 - s) * o,
            c = o * (1 - s) - a * n,
            h = o * (1 - s) + a * n,
            u = o * (1 - s) + a * n,
            d = s + o * (1 - s),
            f = o * (1 - s) - a * n,
            p = o * (1 - s) - a * n,
            m = o * (1 - s) + a * n,
            g = s + o * (1 - s),
            y = [l, c, h, 0, 0, u, d, f, 0, 0, p, m, g, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(y, i)
    }
    contrast(t, i) {
        const s = (t || 0) + 1,
            n = -.5 * (s - 1),
            r = [s, 0, 0, 0, n, 0, s, 0, 0, n, 0, 0, s, 0, n, 0, 0, 0, 1, 0];
        this._loadMatrix(r, i)
    }
    saturate(t = 0, i) {
        const s = t * 2 / 3 + 1,
            n = (s - 1) * -.5,
            r = [s, n, n, 0, 0, n, s, n, 0, 0, n, n, s, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(r, i)
    }
    desaturate() {
        this.saturate(-1)
    }
    negative(t) {
        const i = [-1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    sepia(t) {
        const i = [.393, .7689999, .18899999, 0, 0, .349, .6859999, .16799999, 0, 0, .272, .5339999, .13099999, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    technicolor(t) {
        const i = [1.9125277891456083, -.8545344976951645, -.09155508482755585, 0, 11.793603434377337, -.3087833385928097, 1.7658908555458428, -.10601743074722245, 0, -70.35205161461398, -.231103377548616, -.7501899197440212, 1.847597816108189, 0, 30.950940869491138, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    polaroid(t) {
        const i = [1.438, -.062, -.062, 0, 0, -.122, 1.378, -.122, 0, 0, -.016, -.016, 1.483, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    toBGR(t) {
        const i = [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    kodachrome(t) {
        const i = [1.1285582396593525, -.3967382283601348, -.03992559172921793, 0, 63.72958762196502, -.16404339962244616, 1.0835251566291304, -.05498805115633132, 0, 24.732407896706203, -.16786010706155763, -.5603416277695248, 1.6014850761964943, 0, 35.62982807460946, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    browni(t) {
        const i = [.5997023498159715, .34553243048391263, -.2708298674538042, 0, 47.43192855600873, -.037703249837783157, .8609577587992641, .15059552388459913, 0, -36.96841498319127, .24113635128153335, -.07441037908422492, .44972182064877153, 0, -7.562075277591283, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    vintage(t) {
        const i = [.6279345635605994, .3202183420819367, -.03965408211312453, 0, 9.651285835294123, .02578397704808868, .6441188644374771, .03259127616149294, 0, 7.462829176470591, .0466055556782719, -.0851232987247891, .5241648018700465, 0, 5.159190588235296, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    colorTone(t, i, s, n, r) {
        t = t || .2, i = i || .15, s = s || 16770432, n = n || 3375104;
        const o = (s >> 16 & 255) / 255,
            a = (s >> 8 & 255) / 255,
            l = (s & 255) / 255,
            c = (n >> 16 & 255) / 255,
            h = (n >> 8 & 255) / 255,
            u = (n & 255) / 255,
            d = [.3, .59, .11, 0, 0, o, a, l, t, 0, c, h, u, i, 0, o - c, a - h, l - u, 0, 0];
        this._loadMatrix(d, r)
    }
    night(t, i) {
        t = t || .1;
        const s = [t * -2, -t, 0, 0, 0, -t, 0, t, 0, 0, 0, t, t * 2, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(s, i)
    }
    predator(t, i) {
        const s = [11.224130630493164 * t, -4.794486999511719 * t, -2.8746118545532227 * t, 0 * t, .40342438220977783 * t, -3.6330697536468506 * t, 9.193157196044922 * t, -2.951810836791992 * t, 0 * t, -1.316135048866272 * t, -3.2184197902679443 * t, -4.2375030517578125 * t, 7.476448059082031 * t, 0 * t, .8044459223747253 * t, 0, 0, 0, 1, 0];
        this._loadMatrix(s, i)
    }
    lsd(t) {
        const i = [2, -.4, .5, 0, 0, -.5, 2, -.4, 0, 0, -.4, -.5, 3, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(i, t)
    }
    reset() {
        const t = [1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0];
        this._loadMatrix(t, !1)
    }
    get matrix() {
        return this.uniforms.m
    }
    set matrix(t) {
        this.uniforms.m = t
    }
    get alpha() {
        return this.uniforms.uAlpha
    }
    set alpha(t) {
        this.uniforms.uAlpha = t
    }
}
_d.prototype.grayscale = _d.prototype.greyscale;
var L6 = `varying vec2 vFilterCoord;
varying vec2 vTextureCoord;

uniform vec2 scale;
uniform mat2 rotation;
uniform sampler2D uSampler;
uniform sampler2D mapSampler;

uniform highp vec4 inputSize;
uniform vec4 inputClamp;

void main(void)
{
  vec4 map =  texture2D(mapSampler, vFilterCoord);

  map -= 0.5;
  map.xy = scale * inputSize.zw * (rotation * map.xy);

  gl_FragColor = texture2D(uSampler, clamp(vec2(vTextureCoord.x + map.x, vTextureCoord.y + map.y), inputClamp.xy, inputClamp.zw));
}
`,
    O6 = `attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;
uniform mat3 filterMatrix;

varying vec2 vTextureCoord;
varying vec2 vFilterCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

vec2 filterTextureCoord( void )
{
    return aVertexPosition * (outputFrame.zw * inputSize.zw);
}

void main(void)
{
	gl_Position = filterVertexPosition();
	vTextureCoord = filterTextureCoord();
	vFilterCoord = ( filterMatrix * vec3( vTextureCoord, 1.0)  ).xy;
}
`;
class D6 extends oi {
    constructor(t, i) {
        const s = new pe;
        t.renderable = !1, super(O6, L6, {
            mapSampler: t._texture,
            filterMatrix: s,
            scale: {
                x: 1,
                y: 1
            },
            rotation: new Float32Array([1, 0, 0, 1])
        }), this.maskSprite = t, this.maskMatrix = s, i == null && (i = 20), this.scale = new Zt(i, i)
    }
    apply(t, i, s, n) {
        this.uniforms.filterMatrix = t.calculateSpriteMatrix(this.maskMatrix, this.maskSprite), this.uniforms.scale.x = this.scale.x, this.uniforms.scale.y = this.scale.y;
        const r = this.maskSprite.worldTransform,
            o = Math.sqrt(r.a * r.a + r.b * r.b),
            a = Math.sqrt(r.c * r.c + r.d * r.d);
        o !== 0 && a !== 0 && (this.uniforms.rotation[0] = r.a / o, this.uniforms.rotation[1] = r.b / o, this.uniforms.rotation[2] = r.c / a, this.uniforms.rotation[3] = r.d / a), t.applyFilter(this, i, s, n)
    }
    get map() {
        return this.uniforms.mapSampler
    }
    set map(t) {
        this.uniforms.mapSampler = t
    }
}
var N6 = `varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;
uniform sampler2D uSampler;
uniform highp vec4 inputSize;


/**
 Basic FXAA implementation based on the code on geeks3d.com with the
 modification that the texture2DLod stuff was removed since it's
 unsupported by WebGL.

 --

 From:
 https://github.com/mitsuhiko/webgl-meincraft

 Copyright (c) 2011 by Armin Ronacher.

 Some rights reserved.

 Redistribution and use in source and binary forms, with or without
 modification, are permitted provided that the following conditions are
 met:

 * Redistributions of source code must retain the above copyright
 notice, this list of conditions and the following disclaimer.

 * Redistributions in binary form must reproduce the above
 copyright notice, this list of conditions and the following
 disclaimer in the documentation and/or other materials provided
 with the distribution.

 * The names of the contributors may not be used to endorse or
 promote products derived from this software without specific
 prior written permission.

 THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

#ifndef FXAA_REDUCE_MIN
#define FXAA_REDUCE_MIN   (1.0/ 128.0)
#endif
#ifndef FXAA_REDUCE_MUL
#define FXAA_REDUCE_MUL   (1.0 / 8.0)
#endif
#ifndef FXAA_SPAN_MAX
#define FXAA_SPAN_MAX     8.0
#endif

//optimized version for mobile, where dependent
//texture reads can be a bottleneck
vec4 fxaa(sampler2D tex, vec2 fragCoord, vec2 inverseVP,
          vec2 v_rgbNW, vec2 v_rgbNE,
          vec2 v_rgbSW, vec2 v_rgbSE,
          vec2 v_rgbM) {
    vec4 color;
    vec3 rgbNW = texture2D(tex, v_rgbNW).xyz;
    vec3 rgbNE = texture2D(tex, v_rgbNE).xyz;
    vec3 rgbSW = texture2D(tex, v_rgbSW).xyz;
    vec3 rgbSE = texture2D(tex, v_rgbSE).xyz;
    vec4 texColor = texture2D(tex, v_rgbM);
    vec3 rgbM  = texColor.xyz;
    vec3 luma = vec3(0.299, 0.587, 0.114);
    float lumaNW = dot(rgbNW, luma);
    float lumaNE = dot(rgbNE, luma);
    float lumaSW = dot(rgbSW, luma);
    float lumaSE = dot(rgbSE, luma);
    float lumaM  = dot(rgbM,  luma);
    float lumaMin = min(lumaM, min(min(lumaNW, lumaNE), min(lumaSW, lumaSE)));
    float lumaMax = max(lumaM, max(max(lumaNW, lumaNE), max(lumaSW, lumaSE)));

    mediump vec2 dir;
    dir.x = -((lumaNW + lumaNE) - (lumaSW + lumaSE));
    dir.y =  ((lumaNW + lumaSW) - (lumaNE + lumaSE));

    float dirReduce = max((lumaNW + lumaNE + lumaSW + lumaSE) *
                          (0.25 * FXAA_REDUCE_MUL), FXAA_REDUCE_MIN);

    float rcpDirMin = 1.0 / (min(abs(dir.x), abs(dir.y)) + dirReduce);
    dir = min(vec2(FXAA_SPAN_MAX, FXAA_SPAN_MAX),
              max(vec2(-FXAA_SPAN_MAX, -FXAA_SPAN_MAX),
                  dir * rcpDirMin)) * inverseVP;

    vec3 rgbA = 0.5 * (
                       texture2D(tex, fragCoord * inverseVP + dir * (1.0 / 3.0 - 0.5)).xyz +
                       texture2D(tex, fragCoord * inverseVP + dir * (2.0 / 3.0 - 0.5)).xyz);
    vec3 rgbB = rgbA * 0.5 + 0.25 * (
                                     texture2D(tex, fragCoord * inverseVP + dir * -0.5).xyz +
                                     texture2D(tex, fragCoord * inverseVP + dir * 0.5).xyz);

    float lumaB = dot(rgbB, luma);
    if ((lumaB < lumaMin) || (lumaB > lumaMax))
        color = vec4(rgbA, texColor.a);
    else
        color = vec4(rgbB, texColor.a);
    return color;
}

void main() {

      vec4 color;

      color = fxaa(uSampler, vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);

      gl_FragColor = color;
}
`,
    F6 = `
attribute vec2 aVertexPosition;

uniform mat3 projectionMatrix;

varying vec2 v_rgbNW;
varying vec2 v_rgbNE;
varying vec2 v_rgbSW;
varying vec2 v_rgbSE;
varying vec2 v_rgbM;

varying vec2 vFragCoord;

uniform vec4 inputSize;
uniform vec4 outputFrame;

vec4 filterVertexPosition( void )
{
    vec2 position = aVertexPosition * max(outputFrame.zw, vec2(0.)) + outputFrame.xy;

    return vec4((projectionMatrix * vec3(position, 1.0)).xy, 0.0, 1.0);
}

void texcoords(vec2 fragCoord, vec2 inverseVP,
               out vec2 v_rgbNW, out vec2 v_rgbNE,
               out vec2 v_rgbSW, out vec2 v_rgbSE,
               out vec2 v_rgbM) {
    v_rgbNW = (fragCoord + vec2(-1.0, -1.0)) * inverseVP;
    v_rgbNE = (fragCoord + vec2(1.0, -1.0)) * inverseVP;
    v_rgbSW = (fragCoord + vec2(-1.0, 1.0)) * inverseVP;
    v_rgbSE = (fragCoord + vec2(1.0, 1.0)) * inverseVP;
    v_rgbM = vec2(fragCoord * inverseVP);
}

void main(void) {

   gl_Position = filterVertexPosition();

   vFragCoord = aVertexPosition * outputFrame.zw;

   texcoords(vFragCoord, inputSize.zw, v_rgbNW, v_rgbNE, v_rgbSW, v_rgbSE, v_rgbM);
}
`;
class B6 extends oi {
    constructor() {
        super(F6, N6)
    }
}
var U6 = `precision highp float;

varying vec2 vTextureCoord;
varying vec4 vColor;

uniform float uNoise;
uniform float uSeed;
uniform sampler2D uSampler;

float rand(vec2 co)
{
    return fract(sin(dot(co.xy, vec2(12.9898, 78.233))) * 43758.5453);
}

void main()
{
    vec4 color = texture2D(uSampler, vTextureCoord);
    float randomValue = rand(gl_FragCoord.xy * uSeed);
    float diff = (randomValue - 0.5) * uNoise;

    // Un-premultiply alpha before applying the color matrix. See issue #3539.
    if (color.a > 0.0) {
        color.rgb /= color.a;
    }

    color.r += diff;
    color.g += diff;
    color.b += diff;

    // Premultiply alpha again.
    color.rgb *= color.a;

    gl_FragColor = color;
}
`;
class G6 extends oi {
    constructor(t = .5, i = Math.random()) {
        super(d1, U6, {
            uNoise: 0,
            uSeed: 0
        }), this.noise = t, this.seed = i
    }
    get noise() {
        return this.uniforms.uNoise
    }
    set noise(t) {
        this.uniforms.uNoise = t
    }
    get seed() {
        return this.uniforms.uSeed
    }
    set seed(t) {
        this.uniforms.uSeed = t
    }
}
const fg = {
    AlphaFilter: S6,
    BlurFilter: k6,
    BlurFilterPass: vd,
    ColorMatrixFilter: _d,
    DisplacementFilter: D6,
    FXAAFilter: B6,
    NoiseFilter: G6
};
Object.entries(fg).forEach(([e, t]) => {
    Object.defineProperty(fg, e, {
        get() {
            return Qt("7.1.0", `filters.${e} has moved to ${e}`), t
        }
    })
});
class Ja {
    constructor(t) {
        this.bubbles = !0, this.cancelBubble = !0, this.cancelable = !1, this.composed = !1, this.defaultPrevented = !1, this.eventPhase = Ja.prototype.NONE, this.propagationStopped = !1, this.propagationImmediatelyStopped = !1, this.layer = new Zt, this.page = new Zt, this.AT_TARGET = 1, this.BUBBLING_PHASE = 2, this.CAPTURING_PHASE = 3, this.NONE = 0, this.manager = t
    }
    get layerX() {
        return this.layer.x
    }
    get layerY() {
        return this.layer.y
    }
    get pageX() {
        return this.page.x
    }
    get pageY() {
        return this.page.y
    }
    get data() {
        return this
    }
    composedPath() {
        return this.manager && (!this.path || this.path[this.path.length - 1] !== this.target) && (this.path = this.target ? this.manager.propagationPath(this.target) : []), this.path
    }
    initEvent(t, i, s) {
        throw new Error("initEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    initUIEvent(t, i, s, n, r) {
        throw new Error("initUIEvent() is a legacy DOM API. It is not implemented in the Federated Events API.")
    }
    preventDefault() {
        this.nativeEvent instanceof Event && this.nativeEvent.cancelable && this.nativeEvent.preventDefault(), this.defaultPrevented = !0
    }
    stopImmediatePropagation() {
        this.propagationImmediatelyStopped = !0
    }
    stopPropagation() {
        this.propagationStopped = !0
    }
}
class Sc extends Ja {
    constructor() {
        super(...arguments), this.client = new Zt, this.movement = new Zt, this.offset = new Zt, this.global = new Zt, this.screen = new Zt
    }
    get clientX() {
        return this.client.x
    }
    get clientY() {
        return this.client.y
    }
    get x() {
        return this.clientX
    }
    get y() {
        return this.clientY
    }
    get movementX() {
        return this.movement.x
    }
    get movementY() {
        return this.movement.y
    }
    get offsetX() {
        return this.offset.x
    }
    get offsetY() {
        return this.offset.y
    }
    get globalX() {
        return this.global.x
    }
    get globalY() {
        return this.global.y
    }
    get screenX() {
        return this.screen.x
    }
    get screenY() {
        return this.screen.y
    }
    getModifierState(t) {
        return "getModifierState" in this.nativeEvent && this.nativeEvent.getModifierState(t)
    }
    initMouseEvent(t, i, s, n, r, o, a, l, c, h, u, d, f, p, m) {
        throw new Error("Method not implemented.")
    }
}
class Ji extends Sc {
    constructor() {
        super(...arguments), this.width = 0, this.height = 0, this.isPrimary = !1
    }
    getCoalescedEvents() {
        return this.type === "pointermove" || this.type === "mousemove" || this.type === "touchmove" ? [this] : []
    }
    getPredictedEvents() {
        throw new Error("getPredictedEvents is not supported!")
    }
}
class yd extends Sc {
    constructor() {
        super(...arguments), this.DOM_DELTA_LINE = 0, this.DOM_DELTA_PAGE = 1, this.DOM_DELTA_PIXEL = 2
    }
}
const H6 = 2048,
    V6 = new Zt,
    ru = new Zt;
class z6 {
    constructor(t) {
        this.dispatch = new $o, this.moveOnAll = !1, this.mappingState = {
            trackingData: {}
        }, this.eventPool = new Map, this.rootTarget = t, this.hitPruneFn = this.hitPruneFn.bind(this), this.hitTestFn = this.hitTestFn.bind(this), this.mapPointerDown = this.mapPointerDown.bind(this), this.mapPointerMove = this.mapPointerMove.bind(this), this.mapPointerOut = this.mapPointerOut.bind(this), this.mapPointerOver = this.mapPointerOver.bind(this), this.mapPointerUp = this.mapPointerUp.bind(this), this.mapPointerUpOutside = this.mapPointerUpOutside.bind(this), this.mapWheel = this.mapWheel.bind(this), this.mappingTable = {}, this.addEventMapping("pointerdown", this.mapPointerDown), this.addEventMapping("pointermove", this.mapPointerMove), this.addEventMapping("pointerout", this.mapPointerOut), this.addEventMapping("pointerleave", this.mapPointerOut), this.addEventMapping("pointerover", this.mapPointerOver), this.addEventMapping("pointerup", this.mapPointerUp), this.addEventMapping("pointerupoutside", this.mapPointerUpOutside), this.addEventMapping("wheel", this.mapWheel)
    }
    addEventMapping(t, i) {
        this.mappingTable[t] || (this.mappingTable[t] = []), this.mappingTable[t].push({
            fn: i,
            priority: 0
        }), this.mappingTable[t].sort((s, n) => s.priority - n.priority)
    }
    dispatchEvent(t, i) {
        t.propagationStopped = !1, t.propagationImmediatelyStopped = !1, this.propagate(t, i), this.dispatch.emit(i || t.type, t)
    }
    mapEvent(t) {
        if (!this.rootTarget) return;
        const i = this.mappingTable[t.type];
        if (i)
            for (let s = 0, n = i.length; s < n; s++) i[s].fn(t);
        else console.warn(`[EventBoundary]: Event mapping not defined for ${t.type}`)
    }
    hitTest(t, i) {
        const s = this.hitTestRecursive(this.rootTarget, this.rootTarget.interactive, V6.set(t, i), this.hitTestFn, this.hitPruneFn);
        return s && s[0]
    }
    propagate(t, i) {
        if (!t.target) return;
        const s = t.composedPath();
        t.eventPhase = t.CAPTURING_PHASE;
        for (let n = 0, r = s.length - 1; n < r; n++)
            if (t.currentTarget = s[n], this.notifyTarget(t, i), t.propagationStopped || t.propagationImmediatelyStopped) return;
        if (t.eventPhase = t.AT_TARGET, t.currentTarget = t.target, this.notifyTarget(t, i), !(t.propagationStopped || t.propagationImmediatelyStopped)) {
            t.eventPhase = t.BUBBLING_PHASE;
            for (let n = s.length - 2; n >= 0; n--)
                if (t.currentTarget = s[n], this.notifyTarget(t, i), t.propagationStopped || t.propagationImmediatelyStopped) return
        }
    }
    all(t, i, s = this.rootTarget) {
        t.eventPhase = t.BUBBLING_PHASE;
        const n = s.children;
        if (n)
            for (let r = 0; r < n.length; r++) this.all(t, i, n[r]);
        t.currentTarget = s, this.notifyTarget(t, i)
    }
    propagationPath(t) {
        const i = [t];
        for (let s = 0; s < H6 && t !== this.rootTarget; s++) {
            if (!t.parent) throw new Error("Cannot find propagation path to disconnected target");
            i.push(t.parent), t = t.parent
        }
        return i.reverse(), i
    }
    hitTestRecursive(t, i, s, n, r) {
        if (!t || !t.visible || r(t, s)) return null;
        if (t.interactiveChildren && t.children) {
            const o = t.children;
            for (let a = o.length - 1; a >= 0; a--) {
                const l = o[a],
                    c = this.hitTestRecursive(l, i || l.interactive, s, n, r);
                if (c) {
                    if (c.length > 0 && !c[c.length - 1].parent) continue;
                    return (c.length > 0 || t.interactive) && c.push(t), c
                }
            }
        }
        return i && n(t, s) ? t.interactive ? [t] : [] : null
    }
    hitPruneFn(t, i) {
        if (t.hitArea && (t.worldTransform.applyInverse(i, ru), !t.hitArea.contains(ru.x, ru.y))) return !0;
        if (t._mask) {
            const s = t._mask.isMaskData ? t._mask.maskObject : t._mask;
            if (s && !s.containsPoint?.(i)) return !0
        }
        return !1
    }
    hitTestFn(t, i) {
        return t.hitArea ? !0 : t.containsPoint ? t.containsPoint(i) : !1
    }
    notifyTarget(t, i) {
        i = i ?? t.type;
        const s = `on${i}`;
        t.currentTarget[s]?.(t);
        const n = t.eventPhase === t.CAPTURING_PHASE || t.eventPhase === t.AT_TARGET ? `${i}capture` : i;
        this.notifyListeners(t, n), t.eventPhase === t.AT_TARGET && this.notifyListeners(t, i)
    }
    mapPointerDown(t) {
        if (!(t instanceof Ji)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const i = this.createPointerEvent(t);
        if (this.dispatchEvent(i, "pointerdown"), i.pointerType === "touch") this.dispatchEvent(i, "touchstart");
        else if (i.pointerType === "mouse" || i.pointerType === "pen") {
            const n = i.button === 2;
            this.dispatchEvent(i, n ? "rightdown" : "mousedown")
        }
        const s = this.trackingData(t.pointerId);
        s.pressTargetsByButton[t.button] = i.composedPath(), this.freeEvent(i)
    }
    mapPointerMove(t) {
        if (!(t instanceof Ji)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const i = this.createPointerEvent(t),
            s = i.pointerType === "mouse" || i.pointerType === "pen",
            n = this.trackingData(t.pointerId),
            r = this.findMountedTarget(n.overTargets);
        if (n.overTargets && r !== i.target) {
            const a = t.type === "mousemove" ? "mouseout" : "pointerout",
                l = this.createPointerEvent(t, a, r);
            if (this.dispatchEvent(l, "pointerout"), s && this.dispatchEvent(l, "mouseout"), !i.composedPath().includes(r)) {
                const c = this.createPointerEvent(t, "pointerleave", r);
                for (c.eventPhase = c.AT_TARGET; c.target && !i.composedPath().includes(c.target);) c.currentTarget = c.target, this.notifyTarget(c), s && this.notifyTarget(c, "mouseleave"), c.target = c.target.parent;
                this.freeEvent(c)
            }
            this.freeEvent(l)
        }
        if (r !== i.target) {
            const a = t.type === "mousemove" ? "mouseover" : "pointerover",
                l = this.clonePointerEvent(i, a);
            this.dispatchEvent(l, "pointerover"), s && this.dispatchEvent(l, "mouseover");
            let c = r?.parent;
            for (; c && c !== this.rootTarget.parent && c !== i.target;) c = c.parent;
            if (!c || c === this.rootTarget.parent) {
                const u = this.clonePointerEvent(i, "pointerenter");
                for (u.eventPhase = u.AT_TARGET; u.target && u.target !== r && u.target !== this.rootTarget.parent;) u.currentTarget = u.target, this.notifyTarget(u), s && this.notifyTarget(u, "mouseenter"), u.target = u.target.parent;
                this.freeEvent(u)
            }
            this.freeEvent(l)
        }
        const o = this.moveOnAll ? "all" : "dispatchEvent";
        this[o](i, "pointermove"), i.pointerType === "touch" && this[o](i, "touchmove"), s && (this[o](i, "mousemove"), this.cursor = i.target?.cursor), n.overTargets = i.composedPath(), this.freeEvent(i)
    }
    mapPointerOver(t) {
        if (!(t instanceof Ji)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const i = this.trackingData(t.pointerId),
            s = this.createPointerEvent(t),
            n = s.pointerType === "mouse" || s.pointerType === "pen";
        this.dispatchEvent(s, "pointerover"), n && this.dispatchEvent(s, "mouseover"), s.pointerType === "mouse" && (this.cursor = s.target?.cursor);
        const r = this.clonePointerEvent(s, "pointerenter");
        for (r.eventPhase = r.AT_TARGET; r.target && r.target !== this.rootTarget.parent;) r.currentTarget = r.target, this.notifyTarget(r), n && this.notifyTarget(r, "mouseenter"), r.target = r.target.parent;
        i.overTargets = s.composedPath(), this.freeEvent(s), this.freeEvent(r)
    }
    mapPointerOut(t) {
        if (!(t instanceof Ji)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const i = this.trackingData(t.pointerId);
        if (i.overTargets) {
            const s = t.pointerType === "mouse" || t.pointerType === "pen",
                n = this.findMountedTarget(i.overTargets),
                r = this.createPointerEvent(t, "pointerout", n);
            this.dispatchEvent(r), s && this.dispatchEvent(r, "mouseout");
            const o = this.createPointerEvent(t, "pointerleave", n);
            for (o.eventPhase = o.AT_TARGET; o.target && o.target !== this.rootTarget.parent;) o.currentTarget = o.target, this.notifyTarget(o), s && this.notifyTarget(o, "mouseleave"), o.target = o.target.parent;
            i.overTargets = null, this.freeEvent(r), this.freeEvent(o)
        }
        this.cursor = null
    }
    mapPointerUp(t) {
        if (!(t instanceof Ji)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const i = performance.now(),
            s = this.createPointerEvent(t);
        if (this.dispatchEvent(s, "pointerup"), s.pointerType === "touch") this.dispatchEvent(s, "touchend");
        else if (s.pointerType === "mouse" || s.pointerType === "pen") {
            const a = s.button === 2;
            this.dispatchEvent(s, a ? "rightup" : "mouseup")
        }
        const n = this.trackingData(t.pointerId),
            r = this.findMountedTarget(n.pressTargetsByButton[t.button]);
        let o = r;
        if (r && !s.composedPath().includes(r)) {
            let a = r;
            for (; a && !s.composedPath().includes(a);) {
                if (s.currentTarget = a, this.notifyTarget(s, "pointerupoutside"), s.pointerType === "touch") this.notifyTarget(s, "touchendoutside");
                else if (s.pointerType === "mouse" || s.pointerType === "pen") {
                    const l = s.button === 2;
                    this.notifyTarget(s, l ? "rightupoutside" : "mouseupoutside")
                }
                a = a.parent
            }
            delete n.pressTargetsByButton[t.button], o = a
        }
        if (o) {
            const a = this.clonePointerEvent(s, "click");
            a.target = o, a.path = null, n.clicksByButton[t.button] || (n.clicksByButton[t.button] = {
                clickCount: 0,
                target: a.target,
                timeStamp: i
            });
            const l = n.clicksByButton[t.button];
            l.target === a.target && i - l.timeStamp < 200 ? ++l.clickCount : l.clickCount = 1, l.target = a.target, l.timeStamp = i, a.detail = l.clickCount, a.pointerType === "mouse" ? this.dispatchEvent(a, "click") : a.pointerType === "touch" && this.dispatchEvent(a, "tap"), this.dispatchEvent(a, "pointertap"), this.freeEvent(a)
        }
        this.freeEvent(s)
    }
    mapPointerUpOutside(t) {
        if (!(t instanceof Ji)) {
            console.warn("EventBoundary cannot map a non-pointer event as a pointer event");
            return
        }
        const i = this.trackingData(t.pointerId),
            s = this.findMountedTarget(i.pressTargetsByButton[t.button]),
            n = this.createPointerEvent(t);
        if (s) {
            let r = s;
            for (; r;) n.currentTarget = r, this.notifyTarget(n, "pointerupoutside"), n.pointerType === "touch" ? this.notifyTarget(n, "touchendoutside") : (n.pointerType === "mouse" || n.pointerType === "pen") && this.notifyTarget(n, n.button === 2 ? "rightupoutside" : "mouseupoutside"), r = r.parent;
            delete i.pressTargetsByButton[t.button]
        }
        this.freeEvent(n)
    }
    mapWheel(t) {
        if (!(t instanceof yd)) {
            console.warn("EventBoundary cannot map a non-wheel event as a wheel event");
            return
        }
        const i = this.createWheelEvent(t);
        this.dispatchEvent(i), this.freeEvent(i)
    }
    findMountedTarget(t) {
        if (!t) return null;
        let i = t[0];
        for (let s = 1; s < t.length && t[s].parent === i; s++) i = t[s];
        return i
    }
    createPointerEvent(t, i, s) {
        const n = this.allocateEvent(Ji);
        return this.copyPointerData(t, n), this.copyMouseData(t, n), this.copyData(t, n), n.nativeEvent = t.nativeEvent, n.originalEvent = t, n.target = s ?? this.hitTest(n.global.x, n.global.y), typeof i == "string" && (n.type = i), n
    }
    createWheelEvent(t) {
        const i = this.allocateEvent(yd);
        return this.copyWheelData(t, i), this.copyMouseData(t, i), this.copyData(t, i), i.nativeEvent = t.nativeEvent, i.originalEvent = t, i.target = this.hitTest(i.global.x, i.global.y), i
    }
    clonePointerEvent(t, i) {
        const s = this.allocateEvent(Ji);
        return s.nativeEvent = t.nativeEvent, s.originalEvent = t.originalEvent, this.copyPointerData(t, s), this.copyMouseData(t, s), this.copyData(t, s), s.target = t.target, s.path = t.composedPath().slice(), s.type = i ?? s.type, s
    }
    copyWheelData(t, i) {
        i.deltaMode = t.deltaMode, i.deltaX = t.deltaX, i.deltaY = t.deltaY, i.deltaZ = t.deltaZ
    }
    copyPointerData(t, i) {
        t instanceof Ji && i instanceof Ji && (i.pointerId = t.pointerId, i.width = t.width, i.height = t.height, i.isPrimary = t.isPrimary, i.pointerType = t.pointerType, i.pressure = t.pressure, i.tangentialPressure = t.tangentialPressure, i.tiltX = t.tiltX, i.tiltY = t.tiltY, i.twist = t.twist)
    }
    copyMouseData(t, i) {
        t instanceof Sc && i instanceof Sc && (i.altKey = t.altKey, i.button = t.button, i.buttons = t.buttons, i.client.copyFrom(t.client), i.ctrlKey = t.ctrlKey, i.metaKey = t.metaKey, i.movement.copyFrom(t.movement), i.screen.copyFrom(t.screen), i.global.copyFrom(t.global))
    }
    copyData(t, i) {
        i.isTrusted = t.isTrusted, i.srcElement = t.srcElement, i.timeStamp = performance.now(), i.type = t.type, i.detail = t.detail, i.view = t.view, i.which = t.which, i.layer.copyFrom(t.layer), i.page.copyFrom(t.page)
    }
    trackingData(t) {
        return this.mappingState.trackingData[t] || (this.mappingState.trackingData[t] = {
            pressTargetsByButton: {},
            clicksByButton: {},
            overTarget: null
        }), this.mappingState.trackingData[t]
    }
    allocateEvent(t) {
        this.eventPool.has(t) || this.eventPool.set(t, []);
        const i = this.eventPool.get(t).pop() || new t(this);
        return i.eventPhase = i.NONE, i.currentTarget = null, i.path = null, i.target = null, i
    }
    freeEvent(t) {
        if (t.manager !== this) throw new Error("It is illegal to free an event not managed by this EventBoundary!");
        const i = t.constructor;
        this.eventPool.has(i) || this.eventPool.set(i, []), this.eventPool.get(i).push(t)
    }
    notifyListeners(t, i) {
        const s = t.currentTarget._events[i];
        if (!!s)
            if ("fn" in s) s.fn.call(s.context, t);
            else
                for (let n = 0, r = s.length; n < r && !t.propagationImmediatelyStopped; n++) s[n].fn.call(s[n].context, t)
    }
}
const $6 = 1,
    j6 = {
        touchstart: "pointerdown",
        touchend: "pointerup",
        touchendoutside: "pointerupoutside",
        touchmove: "pointermove",
        touchcancel: "pointercancel"
    };
class b1 {
    constructor(t) {
        this.supportsTouchEvents = "ontouchstart" in globalThis, this.supportsPointerEvents = !!globalThis.PointerEvent, this.domElement = null, this.resolution = 1, this.renderer = t, this.rootBoundary = new z6(null), this.autoPreventDefault = !0, this.eventsAdded = !1, this.rootPointerEvent = new Ji(null), this.rootWheelEvent = new yd(null), this.cursorStyles = {
            default: "inherit",
            pointer: "pointer"
        }, this.onPointerDown = this.onPointerDown.bind(this), this.onPointerMove = this.onPointerMove.bind(this), this.onPointerUp = this.onPointerUp.bind(this), this.onPointerOverOut = this.onPointerOverOut.bind(this), this.onWheel = this.onWheel.bind(this)
    }
    init() {
        const {
            view: t,
            resolution: i
        } = this.renderer;
        this.setTargetElement(t), this.resolution = i
    }
    resolutionChange(t) {
        this.resolution = t
    }
    destroy() {
        this.setTargetElement(null), this.renderer = null
    }
    setCursor(t) {
        t = t || "default";
        let i = !0;
        if (globalThis.OffscreenCanvas && this.domElement instanceof OffscreenCanvas && (i = !1), this.currentCursor === t) return;
        this.currentCursor = t;
        const s = this.cursorStyles[t];
        if (s) switch (typeof s) {
            case "string":
                i && (this.domElement.style.cursor = s);
                break;
            case "function":
                s(t);
                break;
            case "object":
                i && Object.assign(this.domElement.style, s);
                break
        } else i && typeof t == "string" && !Object.prototype.hasOwnProperty.call(this.cursorStyles, t) && (this.domElement.style.cursor = t)
    }
    onPointerDown(t) {
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && t.pointerType === "touch") return;
        const i = this.normalizeToPointerData(t);
        this.autoPreventDefault && i[0].isNormalized && (t.cancelable || !("cancelable" in t)) && t.preventDefault();
        for (let s = 0, n = i.length; s < n; s++) {
            const r = i[s],
                o = this.bootstrapEvent(this.rootPointerEvent, r);
            this.rootBoundary.mapEvent(o)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerMove(t) {
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && t.pointerType === "touch") return;
        const i = this.normalizeToPointerData(t);
        for (let s = 0, n = i.length; s < n; s++) {
            const r = this.bootstrapEvent(this.rootPointerEvent, i[s]);
            this.rootBoundary.mapEvent(r)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerUp(t) {
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && t.pointerType === "touch") return;
        let i = t.target;
        t.composedPath && t.composedPath().length > 0 && (i = t.composedPath()[0]);
        const s = i !== this.domElement ? "outside" : "",
            n = this.normalizeToPointerData(t);
        for (let r = 0, o = n.length; r < o; r++) {
            const a = this.bootstrapEvent(this.rootPointerEvent, n[r]);
            a.type += s, this.rootBoundary.mapEvent(a)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onPointerOverOut(t) {
        if (this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.supportsTouchEvents && t.pointerType === "touch") return;
        const i = this.normalizeToPointerData(t);
        for (let s = 0, n = i.length; s < n; s++) {
            const r = this.bootstrapEvent(this.rootPointerEvent, i[s]);
            this.rootBoundary.mapEvent(r)
        }
        this.setCursor(this.rootBoundary.cursor)
    }
    onWheel(t) {
        const i = this.normalizeWheelEvent(t);
        this.rootBoundary.rootTarget = this.renderer.lastObjectRendered, this.rootBoundary.mapEvent(i)
    }
    setTargetElement(t) {
        this.removeEvents(), this.domElement = t, this.addEvents()
    }
    addEvents() {
        if (this.eventsAdded || !this.domElement) return;
        const t = this.domElement.style;
        t && (globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "none", t.msTouchAction = "none") : this.supportsPointerEvents && (t.touchAction = "none")), this.supportsPointerEvents ? (globalThis.document.addEventListener("pointermove", this.onPointerMove, !0), this.domElement.addEventListener("pointerdown", this.onPointerDown, !0), this.domElement.addEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.addEventListener("pointerover", this.onPointerOverOut, !0), globalThis.addEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.addEventListener("mousemove", this.onPointerMove, !0), this.domElement.addEventListener("mousedown", this.onPointerDown, !0), this.domElement.addEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.addEventListener("mouseover", this.onPointerOverOut, !0), globalThis.addEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.domElement.addEventListener("touchstart", this.onPointerDown, !0), this.domElement.addEventListener("touchend", this.onPointerUp, !0), this.domElement.addEventListener("touchmove", this.onPointerMove, !0)), this.domElement.addEventListener("wheel", this.onWheel, {
            passive: !0,
            capture: !0
        }), this.eventsAdded = !0
    }
    removeEvents() {
        if (!this.eventsAdded || !this.domElement) return;
        const t = this.domElement.style;
        globalThis.navigator.msPointerEnabled ? (t.msContentZooming = "", t.msTouchAction = "") : this.supportsPointerEvents && (t.touchAction = ""), this.supportsPointerEvents ? (globalThis.document.removeEventListener("pointermove", this.onPointerMove, !0), this.domElement.removeEventListener("pointerdown", this.onPointerDown, !0), this.domElement.removeEventListener("pointerleave", this.onPointerOverOut, !0), this.domElement.removeEventListener("pointerover", this.onPointerOverOut, !0), globalThis.removeEventListener("pointerup", this.onPointerUp, !0)) : (globalThis.document.removeEventListener("mousemove", this.onPointerMove, !0), this.domElement.removeEventListener("mousedown", this.onPointerDown, !0), this.domElement.removeEventListener("mouseout", this.onPointerOverOut, !0), this.domElement.removeEventListener("mouseover", this.onPointerOverOut, !0), globalThis.removeEventListener("mouseup", this.onPointerUp, !0)), this.supportsTouchEvents && (this.domElement.removeEventListener("touchstart", this.onPointerDown, !0), this.domElement.removeEventListener("touchend", this.onPointerUp, !0), this.domElement.removeEventListener("touchmove", this.onPointerMove, !0)), this.domElement.removeEventListener("wheel", this.onWheel, !0), this.domElement = null, this.eventsAdded = !1
    }
    mapPositionToPoint(t, i, s) {
        let n;
        this.domElement.parentElement ? n = this.domElement.getBoundingClientRect() : n = {
            x: 0,
            y: 0,
            width: this.domElement.width,
            height: this.domElement.height,
            left: 0,
            top: 0
        };
        const r = 1 / this.resolution;
        t.x = (i - n.left) * (this.domElement.width / n.width) * r, t.y = (s - n.top) * (this.domElement.height / n.height) * r
    }
    normalizeToPointerData(t) {
        const i = [];
        if (this.supportsTouchEvents && t instanceof TouchEvent)
            for (let s = 0, n = t.changedTouches.length; s < n; s++) {
                const r = t.changedTouches[s];
                typeof r.button > "u" && (r.button = 0), typeof r.buttons > "u" && (r.buttons = 1), typeof r.isPrimary > "u" && (r.isPrimary = t.touches.length === 1 && t.type === "touchstart"), typeof r.width > "u" && (r.width = r.radiusX || 1), typeof r.height > "u" && (r.height = r.radiusY || 1), typeof r.tiltX > "u" && (r.tiltX = 0), typeof r.tiltY > "u" && (r.tiltY = 0), typeof r.pointerType > "u" && (r.pointerType = "touch"), typeof r.pointerId > "u" && (r.pointerId = r.identifier || 0), typeof r.pressure > "u" && (r.pressure = r.force || .5), typeof r.twist > "u" && (r.twist = 0), typeof r.tangentialPressure > "u" && (r.tangentialPressure = 0), typeof r.layerX > "u" && (r.layerX = r.offsetX = r.clientX), typeof r.layerY > "u" && (r.layerY = r.offsetY = r.clientY), r.isNormalized = !0, r.type = t.type, i.push(r)
            } else if (!globalThis.MouseEvent || t instanceof MouseEvent && (!this.supportsPointerEvents || !(t instanceof globalThis.PointerEvent))) {
                const s = t;
                typeof s.isPrimary > "u" && (s.isPrimary = !0), typeof s.width > "u" && (s.width = 1), typeof s.height > "u" && (s.height = 1), typeof s.tiltX > "u" && (s.tiltX = 0), typeof s.tiltY > "u" && (s.tiltY = 0), typeof s.pointerType > "u" && (s.pointerType = "mouse"), typeof s.pointerId > "u" && (s.pointerId = $6), typeof s.pressure > "u" && (s.pressure = .5), typeof s.twist > "u" && (s.twist = 0), typeof s.tangentialPressure > "u" && (s.tangentialPressure = 0), s.isNormalized = !0, i.push(s)
            } else i.push(t);
        return i
    }
    normalizeWheelEvent(t) {
        const i = this.rootWheelEvent;
        return this.transferMouseData(i, t), i.deltaX = t.deltaX, i.deltaY = t.deltaY, i.deltaZ = t.deltaZ, i.deltaMode = t.deltaMode, this.mapPositionToPoint(i.screen, t.clientX, t.clientY), i.global.copyFrom(i.screen), i.offset.copyFrom(i.screen), i.nativeEvent = t, i.type = t.type, i
    }
    bootstrapEvent(t, i) {
        return t.originalEvent = null, t.nativeEvent = i, t.pointerId = i.pointerId, t.width = i.width, t.height = i.height, t.isPrimary = i.isPrimary, t.pointerType = i.pointerType, t.pressure = i.pressure, t.tangentialPressure = i.tangentialPressure, t.tiltX = i.tiltX, t.tiltY = i.tiltY, t.twist = i.twist, this.transferMouseData(t, i), this.mapPositionToPoint(t.screen, i.clientX, i.clientY), t.global.copyFrom(t.screen), t.offset.copyFrom(t.screen), t.isTrusted = i.isTrusted, t.type === "pointerleave" && (t.type = "pointerout"), t.type.startsWith("mouse") && (t.type = t.type.replace("mouse", "pointer")), t.type.startsWith("touch") && (t.type = j6[t.type] || t.type), t
    }
    transferMouseData(t, i) {
        t.isTrusted = i.isTrusted, t.srcElement = i.srcElement, t.timeStamp = performance.now(), t.type = i.type, t.altKey = i.altKey, t.button = i.button, t.buttons = i.buttons, t.client.x = i.clientX, t.client.y = i.clientY, t.ctrlKey = i.ctrlKey, t.metaKey = i.metaKey, t.movement.x = i.movementX, t.movement.y = i.movementY, t.page.x = i.pageX, t.page.y = i.pageY, t.relatedTarget = null, t.shiftKey = i.shiftKey
    }
}
b1.extension = {
    name: "events",
    type: [lt.RendererSystem, lt.CanvasRendererSystem]
};
vt.add(b1);
const W6 = {
    onclick: null,
    onmousedown: null,
    onmouseenter: null,
    onmouseleave: null,
    onmousemove: null,
    onmouseout: null,
    onmouseover: null,
    onmouseup: null,
    onmouseupoutside: null,
    onpointercancel: null,
    onpointerdown: null,
    onpointerenter: null,
    onpointerleave: null,
    onpointermove: null,
    onpointerout: null,
    onpointerover: null,
    onpointertap: null,
    onpointerup: null,
    onpointerupoutside: null,
    onrightclick: null,
    onrightdown: null,
    onrightup: null,
    onrightupoutside: null,
    ontap: null,
    ontouchcancel: null,
    ontouchend: null,
    ontouchendoutside: null,
    ontouchmove: null,
    ontouchstart: null,
    onwheel: null,
    interactive: !1,
    interactiveChildren: !0,
    hitArea: null,
    addEventListener(e, t, i) {
        const s = typeof i == "boolean" && i || typeof i == "object" && i.capture,
            n = typeof t == "function" ? void 0 : t;
        e = s ? `${e}capture` : e, t = typeof t == "function" ? t : t.handleEvent, this.on(e, t, n)
    },
    removeEventListener(e, t, i) {
        const s = typeof i == "boolean" && i || typeof i == "object" && i.capture,
            n = typeof t == "function" ? void 0 : t;
        e = s ? `${e}capture` : e, t = typeof t == "function" ? t : t.handleEvent, this.off(e, t, n)
    },
    dispatchEvent(e) {
        if (!(e instanceof Ja)) throw new Error("DisplayObject cannot propagate events outside of the Federated Events API");
        return e.defaultPrevented = !1, e.path = null, e.target = this, e.manager.dispatchEvent(e), !e.defaultPrevented
    }
};
Ae.mixin(W6);
const X6 = {
    accessible: !1,
    accessibleTitle: null,
    accessibleHint: null,
    tabIndex: 0,
    _accessibleActive: !1,
    _accessibleDiv: null,
    accessibleType: "button",
    accessiblePointerEvents: "auto",
    accessibleChildren: !0,
    renderId: -1
};
Ae.mixin(X6);
const Y6 = 9,
    Rl = 100,
    K6 = 0,
    Z6 = 0,
    pg = 2,
    mg = 1,
    q6 = -1e3,
    J6 = -1e3,
    Q6 = 2;
class x1 {
    constructor(t) {
        this.debug = !1, this._isActive = !1, this._isMobileAccessibility = !1, this.pool = [], this.renderId = 0, this.children = [], this.androidUpdateCount = 0, this.androidUpdateFrequency = 500, this._hookDiv = null, (Is.tablet || Is.phone) && this.createTouchHook();
        const i = document.createElement("div");
        i.style.width = `${Rl}px`, i.style.height = `${Rl}px`, i.style.position = "absolute", i.style.top = `${K6}px`, i.style.left = `${Z6}px`, i.style.zIndex = pg.toString(), this.div = i, this.renderer = t, this._onKeyDown = this._onKeyDown.bind(this), this._onMouseMove = this._onMouseMove.bind(this), globalThis.addEventListener("keydown", this._onKeyDown, !1)
    }
    get isActive() {
        return this._isActive
    }
    get isMobileAccessibility() {
        return this._isMobileAccessibility
    }
    createTouchHook() {
        const t = document.createElement("button");
        t.style.width = `${mg}px`, t.style.height = `${mg}px`, t.style.position = "absolute", t.style.top = `${q6}px`, t.style.left = `${J6}px`, t.style.zIndex = Q6.toString(), t.style.backgroundColor = "#FF0000", t.title = "select to enable accessibility for this content", t.addEventListener("focus", () => {
            this._isMobileAccessibility = !0, this.activate(), this.destroyTouchHook()
        }), document.body.appendChild(t), this._hookDiv = t
    }
    destroyTouchHook() {
        !this._hookDiv || (document.body.removeChild(this._hookDiv), this._hookDiv = null)
    }
    activate() {
        this._isActive || (this._isActive = !0, globalThis.document.addEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown, !1), this.renderer.on("postrender", this.update, this), this.renderer.view.parentNode?.appendChild(this.div))
    }
    deactivate() {
        !this._isActive || this._isMobileAccessibility || (this._isActive = !1, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.addEventListener("keydown", this._onKeyDown, !1), this.renderer.off("postrender", this.update), this.div.parentNode?.removeChild(this.div))
    }
    updateAccessibleObjects(t) {
        if (!t.visible || !t.accessibleChildren) return;
        t.accessible && t.interactive && (t._accessibleActive || this.addChild(t), t.renderId = this.renderId);
        const i = t.children;
        if (i)
            for (let s = 0; s < i.length; s++) this.updateAccessibleObjects(i[s])
    }
    update() {
        const t = performance.now();
        if (Is.android.device && t < this.androidUpdateCount || (this.androidUpdateCount = t + this.androidUpdateFrequency, !this.renderer.renderingToScreen)) return;
        this.renderer.lastObjectRendered && this.updateAccessibleObjects(this.renderer.lastObjectRendered);
        const {
            x: i,
            y: s,
            width: n,
            height: r
        } = this.renderer.view.getBoundingClientRect(), {
            width: o,
            height: a,
            resolution: l
        } = this.renderer, c = n / o * l, h = r / a * l;
        let u = this.div;
        u.style.left = `${i}px`, u.style.top = `${s}px`, u.style.width = `${o}px`, u.style.height = `${a}px`;
        for (let d = 0; d < this.children.length; d++) {
            const f = this.children[d];
            if (f.renderId !== this.renderId) f._accessibleActive = !1, wr(this.children, d, 1), this.div.removeChild(f._accessibleDiv), this.pool.push(f._accessibleDiv), f._accessibleDiv = null, d--;
            else {
                u = f._accessibleDiv;
                let p = f.hitArea;
                const m = f.worldTransform;
                f.hitArea ? (u.style.left = `${(m.tx+p.x*m.a)*c}px`, u.style.top = `${(m.ty+p.y*m.d)*h}px`, u.style.width = `${p.width*m.a*c}px`, u.style.height = `${p.height*m.d*h}px`) : (p = f.getBounds(), this.capHitArea(p), u.style.left = `${p.x*c}px`, u.style.top = `${p.y*h}px`, u.style.width = `${p.width*c}px`, u.style.height = `${p.height*h}px`, u.title !== f.accessibleTitle && f.accessibleTitle !== null && (u.title = f.accessibleTitle), u.getAttribute("aria-label") !== f.accessibleHint && f.accessibleHint !== null && u.setAttribute("aria-label", f.accessibleHint)), (f.accessibleTitle !== u.title || f.tabIndex !== u.tabIndex) && (u.title = f.accessibleTitle, u.tabIndex = f.tabIndex, this.debug && this.updateDebugHTML(u))
            }
        }
        this.renderId++
    }
    updateDebugHTML(t) {
        t.innerHTML = `type: ${t.type}</br> title : ${t.title}</br> tabIndex: ${t.tabIndex}`
    }
    capHitArea(t) {
        t.x < 0 && (t.width += t.x, t.x = 0), t.y < 0 && (t.height += t.y, t.y = 0);
        const {
            width: i,
            height: s
        } = this.renderer;
        t.x + t.width > i && (t.width = i - t.x), t.y + t.height > s && (t.height = s - t.y)
    }
    addChild(t) {
        let i = this.pool.pop();
        i || (i = document.createElement("button"), i.style.width = `${Rl}px`, i.style.height = `${Rl}px`, i.style.backgroundColor = this.debug ? "rgba(255,255,255,0.5)" : "transparent", i.style.position = "absolute", i.style.zIndex = pg.toString(), i.style.borderStyle = "none", navigator.userAgent.toLowerCase().includes("chrome") ? i.setAttribute("aria-live", "off") : i.setAttribute("aria-live", "polite"), navigator.userAgent.match(/rv:.*Gecko\//) ? i.setAttribute("aria-relevant", "additions") : i.setAttribute("aria-relevant", "text"), i.addEventListener("click", this._onClick.bind(this)), i.addEventListener("focus", this._onFocus.bind(this)), i.addEventListener("focusout", this._onFocusOut.bind(this))), i.style.pointerEvents = t.accessiblePointerEvents, i.type = t.accessibleType, t.accessibleTitle && t.accessibleTitle !== null ? i.title = t.accessibleTitle : (!t.accessibleHint || t.accessibleHint === null) && (i.title = `displayObject ${t.tabIndex}`), t.accessibleHint && t.accessibleHint !== null && i.setAttribute("aria-label", t.accessibleHint), this.debug && this.updateDebugHTML(i), t._accessibleActive = !0, t._accessibleDiv = i, i.displayObject = t, this.children.push(t), this.div.appendChild(t._accessibleDiv), t._accessibleDiv.tabIndex = t.tabIndex
    }
    _dispatchEvent(t, i) {
        const {
            displayObject: s
        } = t.target, n = this.renderer.events.rootBoundary, r = Object.assign(new Ja(n), {
            target: s
        });
        n.rootTarget = this.renderer.lastObjectRendered, i.forEach(o => n.dispatchEvent(r, o))
    }
    _onClick(t) {
        this._dispatchEvent(t, ["click", "pointertap", "tap"])
    }
    _onFocus(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "assertive"), this._dispatchEvent(t, ["mouseover"])
    }
    _onFocusOut(t) {
        t.target.getAttribute("aria-live") || t.target.setAttribute("aria-live", "polite"), this._dispatchEvent(t, ["mouseout"])
    }
    _onKeyDown(t) {
        t.keyCode === Y6 && this.activate()
    }
    _onMouseMove(t) {
        t.movementX === 0 && t.movementY === 0 || this.deactivate()
    }
    destroy() {
        this.destroyTouchHook(), this.div = null, globalThis.document.removeEventListener("mousemove", this._onMouseMove, !0), globalThis.removeEventListener("keydown", this._onKeyDown), this.pool = null, this.children = null, this.renderer = null
    }
}
x1.extension = {
    name: "accessibility",
    type: [lt.RendererPlugin, lt.CanvasRendererPlugin]
};
vt.add(x1);
const bd = class {
    constructor(e) {
        this.stage = new ae, e = Object.assign({
            forceCanvas: !1
        }, e), this.renderer = ma(e), bd._plugins.forEach(t => {
            t.init.call(this, e)
        })
    }
    render() {
        this.renderer.render(this.stage)
    }
    get view() {
        return this.renderer.view
    }
    get screen() {
        return this.renderer.screen
    }
    destroy(e, t) {
        const i = bd._plugins.slice(0);
        i.reverse(), i.forEach(s => {
            s.destroy.call(this)
        }), this.stage.destroy(t), this.stage = null, this.renderer.destroy(e), this.renderer = null
    }
};
let w1 = bd;
w1._plugins = [];
vt.handleByList(lt.Application, w1._plugins);
class T1 {
    static init(t) {
        Object.defineProperty(this, "resizeTo", {
            set(i) {
                globalThis.removeEventListener("resize", this.queueResize), this._resizeTo = i, i && (globalThis.addEventListener("resize", this.queueResize), this.resize())
            },
            get() {
                return this._resizeTo
            }
        }), this.queueResize = () => {
            !this._resizeTo || (this.cancelResize(), this._resizeId = requestAnimationFrame(() => this.resize()))
        }, this.cancelResize = () => {
            this._resizeId && (cancelAnimationFrame(this._resizeId), this._resizeId = null)
        }, this.resize = () => {
            if (!this._resizeTo) return;
            this.cancelResize();
            let i, s;
            if (this._resizeTo === globalThis.window) i = globalThis.innerWidth, s = globalThis.innerHeight;
            else {
                const {
                    clientWidth: n,
                    clientHeight: r
                } = this._resizeTo;
                i = n, s = r
            }
            this.renderer.resize(i, s), this.render()
        }, this._resizeId = null, this._resizeTo = null, this.resizeTo = t.resizeTo || null
    }
    static destroy() {
        globalThis.removeEventListener("resize", this.queueResize), this.cancelResize(), this.cancelResize = null, this.queueResize = null, this.resizeTo = null, this.resize = null
    }
}
T1.extension = lt.Application;
vt.add(T1);
const gg = {
    loader: lt.LoadParser,
    resolver: lt.ResolveParser,
    cache: lt.CacheParser,
    detection: lt.DetectionParser
};
vt.handle(lt.Asset, e => {
    const t = e.ref;
    Object.entries(gg).filter(([i]) => !!t[i]).forEach(([i, s]) => vt.add(Object.assign(t[i], {
        extension: t[i].extension ?? s
    })))
}, e => {
    const t = e.ref;
    Object.keys(gg).filter(i => !!t[i]).forEach(i => vt.remove(t[i]))
});
class tI {
    constructor(t, i = !1) {
        this._loader = t, this._assetList = [], this._isLoading = !1, this._maxConcurrent = 1, this.verbose = i
    }
    add(t) {
        t.forEach(i => {
            this._assetList.push(i)
        }), this.verbose && console.log("[BackgroundLoader] assets: ", this._assetList), this._isActive && !this._isLoading && this._next()
    }
    async _next() {
        if (this._assetList.length && this._isActive) {
            this._isLoading = !0;
            const t = [],
                i = Math.min(this._assetList.length, this._maxConcurrent);
            for (let s = 0; s < i; s++) t.push(this._assetList.pop());
            await this._loader.load(t), this._isLoading = !1, this._next()
        }
    }
    get active() {
        return this._isActive
    }
    set active(t) {
        this._isActive !== t && (this._isActive = t, t && !this._isLoading && this._next())
    }
}

function E1(e, t) {
    if (Array.isArray(t)) {
        for (const i of t)
            if (e.startsWith(`data:${i}`)) return !0;
        return !1
    }
    return e.startsWith(`data:${t}`)
}

function fh(e, t) {
    const i = e.split("?")[0],
        s = Xe.extname(i).toLowerCase();
    return Array.isArray(t) ? t.includes(s) : s === t
}
const qs = (e, t) => (Array.isArray(e) || (e = [e]), t ? e.map(i => typeof i == "string" ? t(i) : i) : e);

function S1(e, t, i, s, n) {
    const r = t[i];
    for (let o = 0; o < r.length; o++) {
        const a = r[o];
        i < t.length - 1 ? S1(e.replace(s[i], a), t, i + 1, s, n) : n.push(e.replace(s[i], a))
    }
}

function eI(e) {
    const t = /\{(.*?)\}/g,
        i = e.match(t),
        s = [];
    if (i) {
        const n = [];
        i.forEach(r => {
            const o = r.substring(1, r.length - 1).split(",");
            n.push(o)
        }), S1(e, n, 0, i, s)
    } else s.push(e);
    return s
}
const Cc = e => !Array.isArray(e);
class iI {
    constructor() {
        this._parsers = [], this._cache = new Map, this._cacheMap = new Map
    }
    reset() {
        this._cacheMap.clear(), this._cache.clear()
    }
    has(t) {
        return this._cache.has(t)
    }
    get(t) {
        const i = this._cache.get(t);
        return i || console.warn(`[Assets] Asset id ${t} was not found in the Cache`), i
    }
    set(t, i) {
        const s = qs(t);
        let n;
        for (let a = 0; a < this.parsers.length; a++) {
            const l = this.parsers[a];
            if (l.test(i)) {
                n = l.getCacheableAssets(s, i);
                break
            }
        }
        n || (n = {}, s.forEach(a => {
            n[a] = i
        }));
        const r = Object.keys(n),
            o = {
                cacheKeys: r,
                keys: s
            };
        if (s.forEach(a => {
                this._cacheMap.set(a, o)
            }), r.forEach(a => {
                this._cache.has(a) && this._cache.get(a) !== i && console.warn("[Cache] already has key:", a), this._cache.set(a, n[a])
            }), i instanceof ht) {
            const a = i;
            s.forEach(l => {
                a.baseTexture !== ht.EMPTY.baseTexture && Nt.addToCache(a.baseTexture, l), ht.addToCache(a, l)
            })
        }
    }
    remove(t) {
        if (this._cacheMap.get(t), !this._cacheMap.has(t)) {
            console.warn(`[Assets] Asset id ${t} was not found in the Cache`);
            return
        }
        const i = this._cacheMap.get(t);
        i.cacheKeys.forEach(n => {
            this._cache.delete(n)
        }), i.keys.forEach(n => {
            this._cacheMap.delete(n)
        })
    }
    get parsers() {
        return this._parsers
    }
}
const ia = new iI;
class sI {
    constructor() {
        this._parsers = [], this.promiseCache = {}
    }
    reset() {
        this.promiseCache = {}
    }
    _getLoadPromiseAndParser(t, i) {
        const s = {
            promise: null,
            parser: null
        };
        return s.promise = (async () => {
            let n = null;
            for (let r = 0; r < this.parsers.length; r++) {
                const o = this.parsers[r];
                if (o.load && o.test?.(t, i, this)) {
                    n = await o.load(t, i, this), s.parser = o;
                    break
                }
            }
            if (!s.parser) return console.warn(`[Assets] ${t} could not be loaded as we don't know how to parse it, ensure the correct parser has being added`), null;
            for (let r = 0; r < this.parsers.length; r++) {
                const o = this.parsers[r];
                o.parse && o.parse && await o.testParse?.(n, i, this) && (n = await o.parse(n, i, this) || n, s.parser = o)
            }
            return n
        })(), s
    }
    async load(t, i) {
        let s = 0;
        const n = {},
            r = Cc(t),
            o = qs(t, c => ({
                src: c
            })),
            a = o.length,
            l = o.map(async c => {
                const h = Xe.toAbsolute(c.src);
                if (!n[c.src]) try {
                    this.promiseCache[h] || (this.promiseCache[h] = this._getLoadPromiseAndParser(h, c)), n[c.src] = await this.promiseCache[h].promise, i && i(++s / a)
                } catch (u) {
                    throw delete this.promiseCache[h], delete n[c.src], new Error(`[Loader.load] Failed to load ${h}.
${u}`)
                }
            });
        return await Promise.all(l), r ? n[o[0].src] : n
    }
    async unload(t) {
        const s = qs(t, n => ({
            src: n
        })).map(async n => {
            const r = Xe.toAbsolute(n.src),
                o = this.promiseCache[r];
            if (o) {
                const a = await o.promise;
                o.parser?.unload?.(a, n, this), delete this.promiseCache[r]
            }
        });
        await Promise.all(s)
    }
    get parsers() {
        return this._parsers
    }
}
var Us = (e => (e[e.Low = 0] = "Low", e[e.Normal = 1] = "Normal", e[e.High = 2] = "High", e))(Us || {});
const nI = {
    extension: {
        type: lt.LoadParser,
        priority: Us.Low
    },
    test(e) {
        return Xe.extname(e).toLowerCase() === ".json"
    },
    async load(e) {
        return await (await ut.ADAPTER.fetch(e)).json()
    }
};
vt.add(nI);
const rI = {
    extension: {
        type: lt.LoadParser,
        priority: Us.Low
    },
    test(e) {
        return Xe.extname(e).toLowerCase() === ".txt"
    },
    async load(e) {
        return await (await ut.ADAPTER.fetch(e)).text()
    }
};
vt.add(rI);
const oI = ["normal", "bold", "100", "200", "300", "400", "500", "600", "700", "800", "900"],
    aI = [".ttf", ".otf", ".woff", ".woff2"],
    lI = ["font/ttf", "font/otf", "font/woff", "font/woff2"];

function cI(e) {
    const t = Xe.extname(e);
    return Xe.basename(e, t).replace(/(-|_)/g, " ").toLowerCase().split(" ").map(r => r.charAt(0).toUpperCase() + r.slice(1)).join(" ")
}
const hI = {
    extension: {
        type: lt.LoadParser,
        priority: Us.Low
    },
    test(e) {
        return E1(e, lI) || fh(e, aI)
    },
    async load(e, t) {
        if (!globalThis.navigator.onLine) throw new Error("[loadWebFont] Cannot load font - navigator is offline");
        const i = ut.ADAPTER.getFontFaceSet();
        if (i) {
            const s = [],
                n = t.data?.family ?? cI(e),
                r = t.data?.weights?.filter(a => oI.includes(a)) ?? ["normal"],
                o = t.data ?? {};
            for (let a = 0; a < r.length; a++) {
                const l = r[a],
                    c = new FontFace(n, `url(${encodeURI(e)})`, {
                        ...o,
                        weight: l
                    });
                await c.load(), i.add(c), s.push(c)
            }
            return s.length === 1 ? s[0] : s
        }
        return console.warn("[loadWebFont] FontFace API is not supported. Skipping loading font"), null
    },
    unload(e) {
        (Array.isArray(e) ? e : [e]).forEach(t => ut.ADAPTER.getFontFaceSet().delete(t))
    }
};
vt.add(hI);
let vg = 0,
    ou;
const uI = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mP8/x8AAwMCAO+ip1sAAAAASUVORK5CYII=",
    dI = {
        id: "checkImageBitmap",
        code: `
    async function checkImageBitmap()
    {
        try
        {
            if (typeof createImageBitmap !== 'function') return false;

            const response = await fetch('${uI}');
            const imageBlob =  await response.blob();
            const imageBitmap = await createImageBitmap(imageBlob);

            return imageBitmap.width === 1 && imageBitmap.height === 1;
        }
        catch (e)
        {
            return false;
        }
    }
    checkImageBitmap().then((result) => { self.postMessage(result); });
    `
    },
    fI = {
        id: "loadImageBitmap",
        code: `
    async function loadImageBitmap(url)
    {
        const response = await fetch(url);

        if (!response.ok)
        {
            throw new Error(\`[WorkerManager.loadImageBitmap] Failed to fetch \${url}: \`
                + \`\${response.status} \${response.statusText}\`);
        }

        const imageBlob =  await response.blob();
        const imageBitmap = await createImageBitmap(imageBlob);

        return imageBitmap;
    }
    self.onmessage = async (event) =>
    {
        try
        {
            const imageBitmap = await loadImageBitmap(event.data.data[0]);

            self.postMessage({
                data: imageBitmap,
                uuid: event.data.uuid,
                id: event.data.id,
            }, [imageBitmap]);
        }
        catch(e)
        {
            self.postMessage({
                error: e,
                uuid: event.data.uuid,
                id: event.data.id,
            });
        }
    };`
    };
let au;
class pI {
    constructor() {
        this._initialized = !1, this._createdWorkers = 0, this.workerPool = [], this.queue = [], this.resolveHash = {}
    }
    isImageBitmapSupported() {
        return this._isImageBitmapSupported !== void 0 ? this._isImageBitmapSupported : (this._isImageBitmapSupported = new Promise(t => {
            const i = URL.createObjectURL(new Blob([dI.code], {
                    type: "application/javascript"
                })),
                s = new Worker(i);
            s.addEventListener("message", n => {
                s.terminate(), URL.revokeObjectURL(i), t(n.data)
            })
        }), this._isImageBitmapSupported)
    }
    loadImageBitmap(t) {
        return this._run("loadImageBitmap", [t])
    }
    async _initWorkers() {
        this._initialized || (this._initialized = !0)
    }
    getWorker() {
        ou === void 0 && (ou = navigator.hardwareConcurrency || 4);
        let t = this.workerPool.pop();
        return !t && this._createdWorkers < ou && (au || (au = URL.createObjectURL(new Blob([fI.code], {
            type: "application/javascript"
        }))), this._createdWorkers++, t = new Worker(au), t.addEventListener("message", i => {
            this.complete(i.data), this.returnWorker(i.target), this.next()
        })), t
    }
    returnWorker(t) {
        this.workerPool.push(t)
    }
    complete(t) {
        t.error !== void 0 ? this.resolveHash[t.uuid].reject(t.error) : this.resolveHash[t.uuid].resolve(t.data), this.resolveHash[t.uuid] = null
    }
    async _run(t, i) {
        await this._initWorkers();
        const s = new Promise((n, r) => {
            this.queue.push({
                id: t,
                arguments: i,
                resolve: n,
                reject: r
            })
        });
        return this.next(), s
    }
    next() {
        if (!this.queue.length) return;
        const t = this.getWorker();
        if (!t) return;
        const i = this.queue.pop(),
            s = i.id;
        this.resolveHash[vg] = {
            resolve: i.resolve,
            reject: i.reject
        }, t.postMessage({
            data: i.arguments,
            uuid: vg++,
            id: s
        })
    }
}
const _g = new pI;

function ph(e, t, i) {
    const s = new ht(e);
    return s.baseTexture.on("dispose", () => {
        delete t.promiseCache[i]
    }), s
}
const mI = [".jpeg", ".jpg", ".png", ".webp", ".avif"],
    gI = ["image/jpeg", "image/png", "image/webp", "image/avif"];
async function vI(e) {
    const t = await ut.ADAPTER.fetch(e);
    if (!t.ok) throw new Error(`[loadImageBitmap] Failed to fetch ${e}: ${t.status} ${t.statusText}`);
    const i = await t.blob();
    return await createImageBitmap(i)
}
const Ha = {
    extension: {
        type: lt.LoadParser,
        priority: Us.High
    },
    config: {
        preferWorkers: !0
    },
    test(e) {
        return E1(e, gI) || fh(e, mI)
    },
    async load(e, t, i) {
        let s = null;
        globalThis.createImageBitmap ? this.config.preferWorkers && await _g.isImageBitmapSupported() ? s = await _g.loadImageBitmap(e) : s = await vI(e) : s = await new Promise(r => {
            s = new Image, s.crossOrigin = "anonymous", s.src = e, s.complete ? r(s) : s.onload = () => {
                r(s)
            }
        });
        const n = new Nt(s, {
            resolution: en(e),
            ...t.data
        });
        return n.resource.src = e, ph(n, i, e)
    },
    unload(e) {
        e.destroy(!0)
    }
};
vt.add(Ha);
const _I = {
    extension: {
        type: lt.LoadParser,
        priority: Us.High
    },
    test(e) {
        return Xe.extname(e).toLowerCase() === ".svg"
    },
    async testParse(e) {
        return Ga.test(e)
    },
    async parse(e, t, i) {
        const s = new Ga(e, t?.data?.resourceOptions),
            n = new Nt(s, {
                resolution: en(e),
                ...t?.data
            });
        n.resource.src = e;
        const r = ph(n, i, e);
        return t?.data?.resourceOptions?.autoLoad || await s.load(), r
    },
    async load(e, t) {
        return (await ut.ADAPTER.fetch(e)).text()
    },
    unload: Ha.unload
};
vt.add(_I);
class yI {
    constructor() {
        this._bundleIdConnector = "-", this._createBundleAssetId = (t, i) => `${t}${this._bundleIdConnector}${i}`, this._extractAssetIdFromBundle = (t, i) => i.replace(`${t}${this._bundleIdConnector}`, ""), this._assetMap = {}, this._preferredOrder = [], this._parsers = [], this._resolverHash = {}, this._bundles = {}
    }
    setBundleIdentifier(t) {
        if (this._bundleIdConnector = t.connector ?? this._bundleIdConnector, this._createBundleAssetId = t.createBundleAssetId ?? this._createBundleAssetId, this._extractAssetIdFromBundle = t.extractAssetIdFromBundle ?? this._extractAssetIdFromBundle, this._extractAssetIdFromBundle("foo", this._createBundleAssetId("foo", "bar")) !== "bar") throw new Error("[Resolver] GenerateBundleAssetId are not working correctly")
    }
    prefer(...t) {
        t.forEach(i => {
            this._preferredOrder.push(i), i.priority || (i.priority = Object.keys(i.params))
        }), this._resolverHash = {}
    }
    set basePath(t) {
        this._basePath = t
    }
    get basePath() {
        return this._basePath
    }
    set rootPath(t) {
        this._rootPath = t
    }
    get rootPath() {
        return this._rootPath
    }
    get parsers() {
        return this._parsers
    }
    reset() {
        this._preferredOrder = [], this._resolverHash = {}, this._assetMap = {}, this._rootPath = null, this._basePath = null, this._manifest = null
    }
    setDefaultSearchParams(t) {
        if (typeof t == "string") this._defaultSearchParams = t;
        else {
            const i = t;
            this._defaultSearchParams = Object.keys(i).map(s => `${encodeURIComponent(s)}=${encodeURIComponent(i[s])}`).join("&")
        }
    }
    addManifest(t) {
        this._manifest && console.warn("[Resolver] Manifest already exists, this will be overwritten"), this._manifest = t, t.bundles.forEach(i => {
            this.addBundle(i.name, i.assets)
        })
    }
    addBundle(t, i) {
        const s = [];
        Array.isArray(i) ? i.forEach(n => {
            if (typeof n.name == "string") {
                const r = this._createBundleAssetId(t, n.name);
                s.push(r), this.add([n.name, r], n.srcs)
            } else {
                const r = n.name.map(o => this._createBundleAssetId(t, o));
                r.forEach(o => {
                    s.push(o)
                }), this.add([...n.name, ...r], n.srcs)
            }
        }) : Object.keys(i).forEach(n => {
            s.push(this._createBundleAssetId(t, n)), this.add([n, this._createBundleAssetId(t, n)], i[n])
        }), this._bundles[t] = s
    }
    add(t, i, s) {
        const n = qs(t);
        n.forEach(o => {
            this._assetMap[o] && console.warn(`[Resolver] already has key: ${o} overwriting`)
        }), Array.isArray(i) || (typeof i == "string" ? i = eI(i) : i = [i]);
        const r = i.map(o => {
            let a = o;
            if (typeof o == "string") {
                let l = !1;
                for (let c = 0; c < this._parsers.length; c++) {
                    const h = this._parsers[c];
                    if (h.test(o)) {
                        a = h.parse(o), l = !0;
                        break
                    }
                }
                l || (a = {
                    src: o
                })
            }
            return a.format || (a.format = a.src.split(".").pop()), a.alias || (a.alias = n), (this._basePath || this._rootPath) && (a.src = Xe.toAbsolute(a.src, this._basePath, this._rootPath)), a.src = this._appendDefaultSearchParams(a.src), a.data = a.data ?? s, a
        });
        n.forEach(o => {
            this._assetMap[o] = r
        })
    }
    resolveBundle(t) {
        const i = Cc(t);
        t = qs(t);
        const s = {};
        return t.forEach(n => {
            const r = this._bundles[n];
            if (r) {
                const o = this.resolve(r),
                    a = {};
                for (const l in o) {
                    const c = o[l];
                    a[this._extractAssetIdFromBundle(n, l)] = c
                }
                s[n] = a
            }
        }), i ? s[t[0]] : s
    }
    resolveUrl(t) {
        const i = this.resolve(t);
        if (typeof t != "string") {
            const s = {};
            for (const n in i) s[n] = i[n].src;
            return s
        }
        return i.src
    }
    resolve(t) {
        const i = Cc(t);
        t = qs(t);
        const s = {};
        return t.forEach(n => {
            if (!this._resolverHash[n])
                if (this._assetMap[n]) {
                    let r = this._assetMap[n];
                    const o = this._getPreferredOrder(r),
                        a = r[0];
                    o?.priority.forEach(l => {
                        o.params[l].forEach(c => {
                            const h = r.filter(u => u[l] ? u[l] === c : !1);
                            h.length && (r = h)
                        })
                    }), this._resolverHash[n] = r[0] ?? a
                } else {
                    let r = n;
                    (this._basePath || this._rootPath) && (r = Xe.toAbsolute(r, this._basePath, this._rootPath)), r = this._appendDefaultSearchParams(r), this._resolverHash[n] = {
                        src: r
                    }
                } s[n] = this._resolverHash[n]
        }), i ? s[t[0]] : s
    }
    _getPreferredOrder(t) {
        for (let i = 0; i < t.length; i++) {
            const s = t[0],
                n = this._preferredOrder.find(r => r.params.format.includes(s.format));
            if (n) return n
        }
        return this._preferredOrder[0]
    }
    _appendDefaultSearchParams(t) {
        if (!this._defaultSearchParams) return t;
        const i = /\?/.test(t) ? "&" : "?";
        return `${t}${i}${this._defaultSearchParams}`
    }
}
class bI {
    constructor() {
        this._detections = [], this._initialized = !1, this.resolver = new yI, this.loader = new sI, this.cache = ia, this._backgroundLoader = new tI(this.loader), this._backgroundLoader.active = !0, this.reset()
    }
    async init(t = {}) {
        if (this._initialized) {
            console.warn("[Assets]AssetManager already initialized, did you load before calling this Asset.init()?");
            return
        }
        if (this._initialized = !0, t.defaultSearchParams && this.resolver.setDefaultSearchParams(t.defaultSearchParams), t.basePath && (this.resolver.basePath = t.basePath), t.bundleIdentifier && this.resolver.setBundleIdentifier(t.bundleIdentifier), t.manifest) {
            let r = t.manifest;
            typeof r == "string" && (r = await this.load(r)), this.resolver.addManifest(r)
        }
        const i = t.texturePreference?.resolution ?? 1,
            s = typeof i == "number" ? [i] : i;
        let n = [];
        if (t.texturePreference?.format) {
            const r = t.texturePreference?.format;
            n = typeof r == "string" ? [r] : r;
            for (const o of this._detections) await o.test() || (n = await o.remove(n))
        } else
            for (const r of this._detections) await r.test() && (n = await r.add(n));
        this.resolver.prefer({
            params: {
                format: n,
                resolution: s
            }
        })
    }
    add(t, i, s) {
        this.resolver.add(t, i, s)
    }
    async load(t, i) {
        this._initialized || await this.init();
        const s = Cc(t),
            n = qs(t).map(a => typeof a != "string" ? (this.resolver.add(a.src, a), a.src) : a),
            r = this.resolver.resolve(n),
            o = await this._mapLoadToResolve(r, i);
        return s ? o[n[0]] : o
    }
    addBundle(t, i) {
        this.resolver.addBundle(t, i)
    }
    async loadBundle(t, i) {
        this._initialized || await this.init();
        let s = !1;
        typeof t == "string" && (s = !0, t = [t]);
        const n = this.resolver.resolveBundle(t),
            r = {},
            o = Object.keys(n);
        let a = 0,
            l = 0;
        const c = () => {
                i?.(++a / l)
            },
            h = o.map(u => {
                const d = n[u];
                return l += Object.keys(d).length, this._mapLoadToResolve(d, c).then(f => {
                    r[u] = f
                })
            });
        return await Promise.all(h), s ? r[t[0]] : r
    }
    async backgroundLoad(t) {
        this._initialized || await this.init(), typeof t == "string" && (t = [t]);
        const i = this.resolver.resolve(t);
        this._backgroundLoader.add(Object.values(i))
    }
    async backgroundLoadBundle(t) {
        this._initialized || await this.init(), typeof t == "string" && (t = [t]);
        const i = this.resolver.resolveBundle(t);
        Object.values(i).forEach(s => {
            this._backgroundLoader.add(Object.values(s))
        })
    }
    reset() {
        this.resolver.reset(), this.loader.reset(), this.cache.reset(), this._initialized = !1
    }
    get(t) {
        if (typeof t == "string") return ia.get(t);
        const i = {};
        for (let s = 0; s < t.length; s++) i[s] = ia.get(t[s]);
        return i
    }
    async _mapLoadToResolve(t, i) {
        const s = Object.values(t),
            n = Object.keys(t);
        this._backgroundLoader.active = !1;
        const r = await this.loader.load(s, i);
        this._backgroundLoader.active = !0;
        const o = {};
        return s.forEach((a, l) => {
            const c = r[a.src],
                h = [a.src];
            a.alias && h.push(...a.alias), o[n[l]] = c, ia.set(h, c)
        }), o
    }
    async unload(t) {
        this._initialized || await this.init();
        const i = qs(t).map(n => typeof n != "string" ? n.src : n),
            s = this.resolver.resolve(i);
        await this._unloadFromResolved(s)
    }
    async unloadBundle(t) {
        this._initialized || await this.init(), t = qs(t);
        const i = this.resolver.resolveBundle(t),
            s = Object.keys(i).map(n => this._unloadFromResolved(i[n]));
        await Promise.all(s)
    }
    async _unloadFromResolved(t) {
        const i = Object.values(t);
        i.forEach(s => {
            ia.remove(s.src)
        }), await this.loader.unload(i)
    }
    get detections() {
        return this._detections
    }
    get preferWorkers() {
        return Ha.config.preferWorkers
    }
    set preferWorkers(t) {
        Ha.config.preferWorkers = t
    }
}
const kl = new bI;
vt.handleByList(lt.LoadParser, kl.loader.parsers).handleByList(lt.ResolveParser, kl.resolver.parsers).handleByList(lt.CacheParser, kl.cache.parsers).handleByList(lt.DetectionParser, kl.detections);
const xI = {
    extension: lt.CacheParser,
    test: e => Array.isArray(e) && e.every(t => t instanceof ht),
    getCacheableAssets: (e, t) => {
        const i = {};
        return e.forEach(s => {
            t.forEach((n, r) => {
                i[s + (r === 0 ? "" : r + 1)] = n
            })
        }), i
    }
};
vt.add(xI);
const wI = {
    extension: {
        type: lt.DetectionParser,
        priority: 1
    },
    test: async () => {
        if (!globalThis.createImageBitmap) return !1;
        const e = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAAB0AAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAIAAAACAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQ0MAAAAABNjb2xybmNseAACAAIAAYAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAACVtZGF0EgAKCBgANogQEAwgMg8f8D///8WfhwB8+ErK42A=",
            t = await ut.ADAPTER.fetch(e).then(i => i.blob());
        return createImageBitmap(t).then(() => !0, () => !1)
    },
    add: async e => [...e, "avif"],
    remove: async e => e.filter(t => t !== "avif")
};
vt.add(wI);
const TI = {
    extension: {
        type: lt.DetectionParser,
        priority: 0
    },
    test: async () => {
        if (!globalThis.createImageBitmap) return !1;
        const e = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAAAAAAfQ//73v/+BiOh/AAA=",
            t = await ut.ADAPTER.fetch(e).then(i => i.blob());
        return createImageBitmap(t).then(() => !0, () => !1)
    },
    add: async e => [...e, "webp"],
    remove: async e => e.filter(t => t !== "webp")
};
vt.add(TI);
const yg = ["png", "jpg", "jpeg"],
    EI = {
        extension: {
            type: lt.DetectionParser,
            priority: -1
        },
        test: () => Promise.resolve(!0),
        add: async e => [...e, ...yg],
        remove: async e => e.filter(t => !yg.includes(t))
    };
vt.add(EI);
const SI = {
    extension: lt.ResolveParser,
    test: Ha.test,
    parse: e => ({
        resolution: parseFloat(ut.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
        format: e.split(".").pop(),
        src: e
    })
};
vt.add(SI);
var Si = (e => (e[e.COMPRESSED_RGB_S3TC_DXT1_EXT = 33776] = "COMPRESSED_RGB_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777] = "COMPRESSED_RGBA_S3TC_DXT1_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778] = "COMPRESSED_RGBA_S3TC_DXT3_EXT", e[e.COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779] = "COMPRESSED_RGBA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT", e[e.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919] = "COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT", e[e.COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916] = "COMPRESSED_SRGB_S3TC_DXT1_EXT", e[e.COMPRESSED_R11_EAC = 37488] = "COMPRESSED_R11_EAC", e[e.COMPRESSED_SIGNED_R11_EAC = 37489] = "COMPRESSED_SIGNED_R11_EAC", e[e.COMPRESSED_RG11_EAC = 37490] = "COMPRESSED_RG11_EAC", e[e.COMPRESSED_SIGNED_RG11_EAC = 37491] = "COMPRESSED_SIGNED_RG11_EAC", e[e.COMPRESSED_RGB8_ETC2 = 37492] = "COMPRESSED_RGB8_ETC2", e[e.COMPRESSED_RGBA8_ETC2_EAC = 37496] = "COMPRESSED_RGBA8_ETC2_EAC", e[e.COMPRESSED_SRGB8_ETC2 = 37493] = "COMPRESSED_SRGB8_ETC2", e[e.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497] = "COMPRESSED_SRGB8_ALPHA8_ETC2_EAC", e[e.COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494] = "COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495] = "COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2", e[e.COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840] = "COMPRESSED_RGB_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842] = "COMPRESSED_RGBA_PVRTC_4BPPV1_IMG", e[e.COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841] = "COMPRESSED_RGB_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843] = "COMPRESSED_RGBA_PVRTC_2BPPV1_IMG", e[e.COMPRESSED_RGB_ETC1_WEBGL = 36196] = "COMPRESSED_RGB_ETC1_WEBGL", e[e.COMPRESSED_RGB_ATC_WEBGL = 35986] = "COMPRESSED_RGB_ATC_WEBGL", e[e.COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL = 35986] = "COMPRESSED_RGBA_ATC_EXPLICIT_ALPHA_WEBGL", e[e.COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL = 34798] = "COMPRESSED_RGBA_ATC_INTERPOLATED_ALPHA_WEBGL", e[e.COMPRESSED_RGBA_ASTC_4x4_KHR = 37808] = "COMPRESSED_RGBA_ASTC_4x4_KHR", e))(Si || {});
const Ac = {
    [33776]: .5,
    [33777]: .5,
    [33778]: 1,
    [33779]: 1,
    [35916]: .5,
    [35917]: .5,
    [35918]: 1,
    [35919]: 1,
    [37488]: .5,
    [37489]: .5,
    [37490]: 1,
    [37491]: 1,
    [37492]: .5,
    [37496]: 1,
    [37493]: .5,
    [37497]: 1,
    [37494]: .5,
    [37495]: .5,
    [35840]: .5,
    [35842]: .5,
    [35841]: .25,
    [35843]: .25,
    [36196]: .5,
    [35986]: .5,
    [35986]: 1,
    [34798]: 1,
    [37808]: 1
};
let Hs, so;

function bg() {
    so = {
        s3tc: Hs.getExtension("WEBGL_compressed_texture_s3tc"),
        s3tc_sRGB: Hs.getExtension("WEBGL_compressed_texture_s3tc_srgb"),
        etc: Hs.getExtension("WEBGL_compressed_texture_etc"),
        etc1: Hs.getExtension("WEBGL_compressed_texture_etc1"),
        pvrtc: Hs.getExtension("WEBGL_compressed_texture_pvrtc") || Hs.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
        atc: Hs.getExtension("WEBGL_compressed_texture_atc"),
        astc: Hs.getExtension("WEBGL_compressed_texture_astc")
    }
}
const CI = {
    extension: {
        type: lt.DetectionParser,
        priority: 2
    },
    test: async () => {
        const t = ut.ADAPTER.createCanvas().getContext("webgl");
        return t ? (Hs = t, !0) : (console.warn("WebGL not available for compressed textures."), !1)
    },
    add: async e => {
        so || bg();
        const t = [];
        for (const i in so) !so[i] || t.push(i);
        return [...t, ...e]
    },
    remove: async e => (so || bg(), e.filter(t => !(t in so)))
};
vt.add(CI);
class AI extends qa {
    constructor(t, i = {
        width: 1,
        height: 1,
        autoLoad: !0
    }) {
        let s, n;
        typeof t == "string" ? (s = t, n = new Uint8Array) : (s = null, n = t), super(n, i), this.origin = s, this.buffer = n ? new ad(n) : null, this.origin && i.autoLoad !== !1 && this.load(), n?.length && (this.loaded = !0, this.onBlobLoaded(this.buffer.rawBinaryData))
    }
    onBlobLoaded(t) {}
    async load() {
        const s = await (await (await fetch(this.origin)).blob()).arrayBuffer();
        return this.data = new Uint32Array(s), this.buffer = new ad(s), this.loaded = !0, this.onBlobLoaded(s), this.update(), this
    }
}
class Tr extends AI {
    constructor(t, i) {
        super(t, i), this.format = i.format, this.levels = i.levels || 1, this._width = i.width, this._height = i.height, this._extension = Tr._formatToExtension(this.format), (i.levelBuffers || this.buffer) && (this._levelBuffers = i.levelBuffers || Tr._createLevelBuffers(t instanceof Uint8Array ? t : this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height))
    }
    upload(t, i, s) {
        const n = t.gl;
        if (!t.context.extensions[this._extension]) throw new Error(`${this._extension} textures are not supported on the current machine`);
        if (!this._levelBuffers) return !1;
        for (let o = 0, a = this.levels; o < a; o++) {
            const {
                levelID: l,
                levelWidth: c,
                levelHeight: h,
                levelBuffer: u
            } = this._levelBuffers[o];
            n.compressedTexImage2D(n.TEXTURE_2D, l, this.format, c, h, 0, u)
        }
        return !0
    }
    onBlobLoaded() {
        this._levelBuffers = Tr._createLevelBuffers(this.buffer.uint8View, this.format, this.levels, 4, 4, this.width, this.height)
    }
    static _formatToExtension(t) {
        if (t >= 33776 && t <= 33779) return "s3tc";
        if (t >= 37488 && t <= 37497) return "etc";
        if (t >= 35840 && t <= 35843) return "pvrtc";
        if (t >= 36196) return "etc1";
        if (t >= 35986 && t <= 34798) return "atc";
        throw new Error("Invalid (compressed) texture format given!")
    }
    static _createLevelBuffers(t, i, s, n, r, o, a) {
        const l = new Array(s);
        let c = t.byteOffset,
            h = o,
            u = a,
            d = h + n - 1 & ~(n - 1),
            f = u + r - 1 & ~(r - 1),
            p = d * f * Ac[i];
        for (let m = 0; m < s; m++) l[m] = {
            levelID: m,
            levelWidth: s > 1 ? h : d,
            levelHeight: s > 1 ? u : f,
            levelBuffer: new Uint8Array(t.buffer, c, p)
        }, c += p, h = h >> 1 || 1, u = u >> 1 || 1, d = h + n - 1 & ~(n - 1), f = u + r - 1 & ~(r - 1), p = d * f * Ac[i];
        return l
    }
}
const lu = 4,
    Pl = 124,
    II = 32,
    xg = 20,
    MI = 542327876,
    Ll = {
        SIZE: 1,
        FLAGS: 2,
        HEIGHT: 3,
        WIDTH: 4,
        MIPMAP_COUNT: 7,
        PIXEL_FORMAT: 19
    },
    RI = {
        SIZE: 0,
        FLAGS: 1,
        FOURCC: 2,
        RGB_BITCOUNT: 3,
        R_BIT_MASK: 4,
        G_BIT_MASK: 5,
        B_BIT_MASK: 6,
        A_BIT_MASK: 7
    },
    Ol = {
        DXGI_FORMAT: 0,
        RESOURCE_DIMENSION: 1,
        MISC_FLAG: 2,
        ARRAY_SIZE: 3,
        MISC_FLAGS2: 4
    },
    kI = 1,
    PI = 2,
    LI = 4,
    OI = 64,
    DI = 512,
    NI = 131072,
    FI = 827611204,
    BI = 861165636,
    UI = 894720068,
    GI = 808540228,
    HI = 4,
    VI = {
        [FI]: Si.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        [BI]: Si.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        [UI]: Si.COMPRESSED_RGBA_S3TC_DXT5_EXT
    },
    zI = {
        [70]: Si.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        [71]: Si.COMPRESSED_RGBA_S3TC_DXT1_EXT,
        [73]: Si.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        [74]: Si.COMPRESSED_RGBA_S3TC_DXT3_EXT,
        [76]: Si.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        [77]: Si.COMPRESSED_RGBA_S3TC_DXT5_EXT,
        [72]: Si.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT,
        [75]: Si.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT,
        [78]: Si.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
    };

function $I(e) {
    const t = new Uint32Array(e);
    if (t[0] !== MI) throw new Error("Invalid DDS file magic word");
    const s = new Uint32Array(e, 0, Pl / Uint32Array.BYTES_PER_ELEMENT),
        n = s[Ll.HEIGHT],
        r = s[Ll.WIDTH],
        o = s[Ll.MIPMAP_COUNT],
        a = new Uint32Array(e, Ll.PIXEL_FORMAT * Uint32Array.BYTES_PER_ELEMENT, II / Uint32Array.BYTES_PER_ELEMENT),
        l = a[kI];
    if (l & LI) {
        const c = a[RI.FOURCC];
        if (c !== GI) {
            const v = VI[c],
                _ = lu + Pl,
                C = new Uint8Array(e, _);
            return [new Tr(C, {
                format: v,
                width: r,
                height: n,
                levels: o
            })]
        }
        const h = lu + Pl,
            u = new Uint32Array(t.buffer, h, xg / Uint32Array.BYTES_PER_ELEMENT),
            d = u[Ol.DXGI_FORMAT],
            f = u[Ol.RESOURCE_DIMENSION],
            p = u[Ol.MISC_FLAG],
            m = u[Ol.ARRAY_SIZE],
            g = zI[d];
        if (g === void 0) throw new Error(`DDSParser cannot parse texture data with DXGI format ${d}`);
        if (p === HI) throw new Error("DDSParser does not support cubemap textures");
        if (f === 6) throw new Error("DDSParser does not supported 3D texture data");
        const y = new Array,
            x = lu + Pl + xg;
        if (m === 1) y.push(new Uint8Array(e, x));
        else {
            const v = Ac[g];
            let _ = 0,
                C = r,
                k = n;
            for (let T = 0; T < o; T++) {
                const L = Math.max(1, C + 3 & -4),
                    D = Math.max(1, k + 3 & -4);
                _ += L * D * v, C = C >>> 1, k = k >>> 1
            }
            let S = x;
            for (let T = 0; T < m; T++) y.push(new Uint8Array(e, S, _)), S += _
        }
        return y.map(v => new Tr(v, {
            format: g,
            width: r,
            height: n,
            levels: o
        }))
    }
    throw l & OI ? new Error("DDSParser does not support uncompressed texture data.") : l & DI ? new Error("DDSParser does not supported YUV uncompressed texture data.") : l & NI ? new Error("DDSParser does not support single-channel (lumninance) texture data!") : l & PI ? new Error("DDSParser does not support single-channel (alpha) texture data!") : new Error("DDSParser failed to load a texture file due to an unknown reason!")
}
const wg = [171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10],
    jI = 67305985,
    Zi = {
        FILE_IDENTIFIER: 0,
        ENDIANNESS: 12,
        GL_TYPE: 16,
        GL_TYPE_SIZE: 20,
        GL_FORMAT: 24,
        GL_INTERNAL_FORMAT: 28,
        GL_BASE_INTERNAL_FORMAT: 32,
        PIXEL_WIDTH: 36,
        PIXEL_HEIGHT: 40,
        PIXEL_DEPTH: 44,
        NUMBER_OF_ARRAY_ELEMENTS: 48,
        NUMBER_OF_FACES: 52,
        NUMBER_OF_MIPMAP_LEVELS: 56,
        BYTES_OF_KEY_VALUE_DATA: 60
    },
    xd = 64,
    Tg = {
        [Rt.UNSIGNED_BYTE]: 1,
        [Rt.UNSIGNED_SHORT]: 2,
        [Rt.INT]: 4,
        [Rt.UNSIGNED_INT]: 4,
        [Rt.FLOAT]: 4,
        [Rt.HALF_FLOAT]: 8
    },
    WI = {
        [ot.RGBA]: 4,
        [ot.RGB]: 3,
        [ot.RG]: 2,
        [ot.RED]: 1,
        [ot.LUMINANCE]: 1,
        [ot.LUMINANCE_ALPHA]: 2,
        [ot.ALPHA]: 1
    },
    XI = {
        [Rt.UNSIGNED_SHORT_4_4_4_4]: 2,
        [Rt.UNSIGNED_SHORT_5_5_5_1]: 2,
        [Rt.UNSIGNED_SHORT_5_6_5]: 2
    };

function YI(e, t, i = !1) {
    const s = new DataView(t);
    if (!KI(e, s)) return null;
    const n = s.getUint32(Zi.ENDIANNESS, !0) === jI,
        r = s.getUint32(Zi.GL_TYPE, n),
        o = s.getUint32(Zi.GL_FORMAT, n),
        a = s.getUint32(Zi.GL_INTERNAL_FORMAT, n),
        l = s.getUint32(Zi.PIXEL_WIDTH, n),
        c = s.getUint32(Zi.PIXEL_HEIGHT, n) || 1,
        h = s.getUint32(Zi.PIXEL_DEPTH, n) || 1,
        u = s.getUint32(Zi.NUMBER_OF_ARRAY_ELEMENTS, n) || 1,
        d = s.getUint32(Zi.NUMBER_OF_FACES, n),
        f = s.getUint32(Zi.NUMBER_OF_MIPMAP_LEVELS, n),
        p = s.getUint32(Zi.BYTES_OF_KEY_VALUE_DATA, n);
    if (c === 0 || h !== 1) throw new Error("Only 2D textures are supported");
    if (d !== 1) throw new Error("CubeTextures are not supported by KTXLoader yet!");
    if (u !== 1) throw new Error("WebGL does not support array textures");
    const m = 4,
        g = 4,
        y = l + 3 & -4,
        x = c + 3 & -4,
        v = new Array(u);
    let _ = l * c;
    r === 0 && (_ = y * x);
    let C;
    if (r !== 0 ? Tg[r] ? C = Tg[r] * WI[o] : C = XI[r] : C = Ac[a], C === void 0) throw new Error("Unable to resolve the pixel format stored in the *.ktx file!");
    const k = i ? qI(s, p, n) : null;
    let T = _ * C,
        L = l,
        D = c,
        O = y,
        K = x,
        P = xd + p;
    for (let N = 0; N < f; N++) {
        const W = s.getUint32(P, n);
        let V = P + 4;
        for (let Q = 0; Q < u; Q++) {
            let pt = v[Q];
            pt || (pt = v[Q] = new Array(f)), pt[N] = {
                levelID: N,
                levelWidth: f > 1 || r !== 0 ? L : O,
                levelHeight: f > 1 || r !== 0 ? D : K,
                levelBuffer: new Uint8Array(t, V, T)
            }, V += T
        }
        P += W + 4, P = P % 4 !== 0 ? P + 4 - P % 4 : P, L = L >> 1 || 1, D = D >> 1 || 1, O = L + m - 1 & ~(m - 1), K = D + g - 1 & ~(g - 1), T = O * K * C
    }
    return r !== 0 ? {
        uncompressed: v.map(N => {
            let W = N[0].levelBuffer,
                V = !1;
            return r === Rt.FLOAT ? W = new Float32Array(N[0].levelBuffer.buffer, N[0].levelBuffer.byteOffset, N[0].levelBuffer.byteLength / 4) : r === Rt.UNSIGNED_INT ? (V = !0, W = new Uint32Array(N[0].levelBuffer.buffer, N[0].levelBuffer.byteOffset, N[0].levelBuffer.byteLength / 4)) : r === Rt.INT && (V = !0, W = new Int32Array(N[0].levelBuffer.buffer, N[0].levelBuffer.byteOffset, N[0].levelBuffer.byteLength / 4)), {
                resource: new qa(W, {
                    width: N[0].levelWidth,
                    height: N[0].levelHeight
                }),
                type: r,
                format: V ? ZI(o) : o
            }
        }),
        kvData: k
    } : {
        compressed: v.map(N => new Tr(null, {
            format: a,
            width: l,
            height: c,
            levels: f,
            levelBuffers: N
        })),
        kvData: k
    }
}

function KI(e, t) {
    for (let i = 0; i < wg.length; i++)
        if (t.getUint8(i) !== wg[i]) return console.error(`${e} is not a valid *.ktx file!`), !1;
    return !0
}

function ZI(e) {
    switch (e) {
        case ot.RGBA:
            return ot.RGBA_INTEGER;
        case ot.RGB:
            return ot.RGB_INTEGER;
        case ot.RG:
            return ot.RG_INTEGER;
        case ot.RED:
            return ot.RED_INTEGER;
        default:
            return e
    }
}

function qI(e, t, i) {
    const s = new Map;
    let n = 0;
    for (; n < t;) {
        const r = e.getUint32(xd + n, i),
            o = xd + n + 4,
            a = 3 - (r + 3) % 4;
        if (r === 0 || r > t - n) {
            console.error("KTXLoader: keyAndValueByteSize out of bounds");
            break
        }
        let l = 0;
        for (; l < r && e.getUint8(o + l) !== 0; l++);
        if (l === -1) {
            console.error("KTXLoader: Failed to find null byte terminating kvData key");
            break
        }
        const c = new TextDecoder().decode(new Uint8Array(e.buffer, o, l)),
            h = new DataView(e.buffer, o + l + 1, r - l - 1);
        s.set(c, h), n += 4 + r + a
    }
    return s
}
const JI = {
    extension: {
        type: lt.LoadParser,
        priority: Us.High
    },
    test(e) {
        return fh(e, ".dds")
    },
    async load(e, t, i) {
        const n = await (await ut.ADAPTER.fetch(e)).arrayBuffer(),
            o = $I(n).map(a => {
                const l = new Nt(a, {
                    mipmap: ds.OFF,
                    alphaMode: _s.NO_PREMULTIPLIED_ALPHA,
                    resolution: en(e),
                    ...t.data
                });
                return ph(l, i, e)
            });
        return o.length === 1 ? o[0] : o
    },
    unload(e) {
        Array.isArray(e) ? e.forEach(t => t.destroy(!0)) : e.destroy(!0)
    }
};
vt.add(JI);
const QI = {
    extension: {
        type: lt.LoadParser,
        priority: Us.High
    },
    test(e) {
        return fh(e, ".ktx")
    },
    async load(e, t, i) {
        const n = await (await ut.ADAPTER.fetch(e)).arrayBuffer(),
            {
                compressed: r,
                uncompressed: o,
                kvData: a
            } = YI(e, n),
            l = r ?? o,
            c = {
                mipmap: ds.OFF,
                alphaMode: _s.NO_PREMULTIPLIED_ALPHA,
                resolution: en(e),
                ...t.data
            },
            h = l.map(u => {
                l === o && Object.assign(c, {
                    type: u.type,
                    format: u.format
                });
                const d = new Nt(u, c);
                return d.ktxKeyValueData = a, ph(d, i, e)
            });
        return h.length === 1 ? h[0] : h
    },
    unload(e) {
        Array.isArray(e) ? e.forEach(t => t.destroy(!0)) : e.destroy(!0)
    }
};
vt.add(QI);
const tM = {
    extension: lt.ResolveParser,
    test: e => {
        const i = e.split("?")[0].split(".").pop();
        return ["basis", "ktx", "dds"].includes(i)
    },
    parse: e => {
        if (e.split("?")[0].split(".").pop() === "ktx") {
            const s = [".s3tc.ktx", ".s3tc_sRGB.ktx", ".etc.ktx", ".etc1.ktx", ".pvrt.ktx", ".atc.ktx", ".astc.ktx"];
            if (s.some(n => e.endsWith(n))) return {
                resolution: parseFloat(ut.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
                format: s.find(n => e.endsWith(n)),
                src: e
            }
        }
        return {
            resolution: parseFloat(ut.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
            format: e.split(".").pop(),
            src: e
        }
    }
};
vt.add(tM);
const Eg = new qt,
    Sg = 4,
    wd = class {
        constructor(e) {
            this.renderer = e
        }
        async image(e, t, i) {
            const s = new Image;
            return s.src = await this.base64(e, t, i), s
        }
        async base64(e, t, i) {
            const s = this.canvas(e);
            if (s.toDataURL !== void 0) return s.toDataURL(t, i);
            if (s.convertToBlob !== void 0) {
                const n = await s.convertToBlob({
                    type: t,
                    quality: i
                });
                return await new Promise(r => {
                    const o = new FileReader;
                    o.onload = () => r(o.result), o.readAsDataURL(n)
                })
            }
            throw new Error("Extract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented")
        }
        canvas(e, t) {
            const i = this.renderer;
            let s, n = !1,
                r, o = !1;
            e && (e instanceof fs ? r = e : (r = this.renderer.generateTexture(e), o = !0)), r ? (s = r.baseTexture.resolution, t = t ?? r.frame, n = !1, i.renderTexture.bind(r)) : (s = i.resolution, t || (t = Eg, t.width = i.width, t.height = i.height), n = !0, i.renderTexture.bind(null));
            const a = Math.round(t.width * s),
                l = Math.round(t.height * s);
            let c = new Po(a, l, 1);
            const h = new Uint8Array(Sg * a * l),
                u = i.gl;
            u.readPixels(Math.round(t.x * s), Math.round(t.y * s), a, l, u.RGBA, u.UNSIGNED_BYTE, h);
            const d = c.context.getImageData(0, 0, a, l);
            if (wd.arrayPostDivide(h, d.data), c.context.putImageData(d, 0, 0), n) {
                const f = new Po(c.width, c.height, 1);
                f.context.scale(1, -1), f.context.drawImage(c.canvas, 0, -l), c.destroy(), c = f
            }
            return o && r.destroy(!0), c.canvas
        }
        pixels(e, t) {
            const i = this.renderer;
            let s, n, r = !1;
            e && (e instanceof fs ? n = e : (n = this.renderer.generateTexture(e), r = !0)), n ? (s = n.baseTexture.resolution, t = t ?? n.frame, i.renderTexture.bind(n)) : (s = i.resolution, t || (t = Eg, t.width = i.width, t.height = i.height), i.renderTexture.bind(null));
            const o = Math.round(t.width * s),
                a = Math.round(t.height * s),
                l = new Uint8Array(Sg * o * a),
                c = i.gl;
            return c.readPixels(Math.round(t.x * s), Math.round(t.y * s), o, a, c.RGBA, c.UNSIGNED_BYTE, l), r && n.destroy(!0), wd.arrayPostDivide(l, l), l
        }
        destroy() {
            this.renderer = null
        }
        static arrayPostDivide(e, t) {
            for (let i = 0; i < e.length; i += 4) {
                const s = t[i + 3] = e[i + 3];
                s !== 0 ? (t[i] = Math.round(Math.min(e[i] * 255 / s, 255)), t[i + 1] = Math.round(Math.min(e[i + 1] * 255 / s, 255)), t[i + 2] = Math.round(Math.min(e[i + 2] * 255 / s, 255))) : (t[i] = e[i], t[i + 1] = e[i + 1], t[i + 2] = e[i + 2])
            }
        }
    };
let C1 = wd;
C1.extension = {
    name: "extract",
    type: lt.RendererSystem
};
vt.add(C1);
const Ic = {
    build(e) {
        const t = e.points;
        let i, s, n, r, o, a;
        if (e.type === we.CIRC) {
            const p = e.shape;
            i = p.x, s = p.y, o = a = p.radius, n = r = 0
        } else if (e.type === we.ELIP) {
            const p = e.shape;
            i = p.x, s = p.y, o = p.width, a = p.height, n = r = 0
        } else {
            const p = e.shape,
                m = p.width / 2,
                g = p.height / 2;
            i = p.x + m, s = p.y + g, o = a = Math.max(0, Math.min(p.radius, Math.min(m, g))), n = m - o, r = g - a
        }
        if (!(o >= 0 && a >= 0 && n >= 0 && r >= 0)) {
            t.length = 0;
            return
        }
        const l = Math.ceil(2.3 * Math.sqrt(o + a)),
            c = l * 8 + (n ? 4 : 0) + (r ? 4 : 0);
        if (t.length = c, c === 0) return;
        if (l === 0) {
            t.length = 8, t[0] = t[6] = i + n, t[1] = t[3] = s + r, t[2] = t[4] = i - n, t[5] = t[7] = s - r;
            return
        }
        let h = 0,
            u = l * 4 + (n ? 2 : 0) + 2,
            d = u,
            f = c; {
            const p = n + o,
                m = r,
                g = i + p,
                y = i - p,
                x = s + m;
            if (t[h++] = g, t[h++] = x, t[--u] = x, t[--u] = y, r) {
                const v = s - m;
                t[d++] = y, t[d++] = v, t[--f] = v, t[--f] = g
            }
        }
        for (let p = 1; p < l; p++) {
            const m = Math.PI / 2 * (p / l),
                g = n + Math.cos(m) * o,
                y = r + Math.sin(m) * a,
                x = i + g,
                v = i - g,
                _ = s + y,
                C = s - y;
            t[h++] = x, t[h++] = _, t[--u] = _, t[--u] = v, t[d++] = v, t[d++] = C, t[--f] = C, t[--f] = x
        } {
            const p = n,
                m = r + a,
                g = i + p,
                y = i - p,
                x = s + m,
                v = s - m;
            t[h++] = g, t[h++] = x, t[--f] = v, t[--f] = g, n && (t[h++] = y, t[h++] = x, t[--f] = v, t[--f] = y)
        }
    },
    triangulate(e, t) {
        const i = e.points,
            s = t.points,
            n = t.indices;
        if (i.length === 0) return;
        let r = s.length / 2;
        const o = r;
        let a, l;
        if (e.type !== we.RREC) {
            const h = e.shape;
            a = h.x, l = h.y
        } else {
            const h = e.shape;
            a = h.x + h.width / 2, l = h.y + h.height / 2
        }
        const c = e.matrix;
        s.push(e.matrix ? c.a * a + c.c * l + c.tx : a, e.matrix ? c.b * a + c.d * l + c.ty : l), r++, s.push(i[0], i[1]);
        for (let h = 2; h < i.length; h += 2) s.push(i[h], i[h + 1]), n.push(r++, o, r);
        n.push(o + 1, o, r)
    }
};

function Cg(e, t = !1) {
    const i = e.length;
    if (i < 6) return;
    let s = 0;
    for (let n = 0, r = e[i - 2], o = e[i - 1]; n < i; n += 2) {
        const a = e[n],
            l = e[n + 1];
        s += (a - r) * (l + o), r = a, o = l
    }
    if (!t && s > 0 || t && s <= 0) {
        const n = i / 2;
        for (let r = n + n % 2; r < i; r += 2) {
            const o = i - r - 2,
                a = i - r - 1,
                l = r,
                c = r + 1;
            [e[o], e[l]] = [e[l], e[o]], [e[a], e[c]] = [e[c], e[a]]
        }
    }
}
const A1 = {
        build(e) {
            e.points = e.shape.points.slice()
        },
        triangulate(e, t) {
            let i = e.points;
            const s = e.holes,
                n = t.points,
                r = t.indices;
            if (i.length >= 6) {
                Cg(i, !1);
                const o = [];
                for (let c = 0; c < s.length; c++) {
                    const h = s[c];
                    Cg(h.points, !0), o.push(i.length / 2), i = i.concat(h.points)
                }
                const a = b_(i, o, 2);
                if (!a) return;
                const l = n.length / 2;
                for (let c = 0; c < a.length; c += 3) r.push(a[c] + l), r.push(a[c + 1] + l), r.push(a[c + 2] + l);
                for (let c = 0; c < i.length; c++) n.push(i[c])
            }
        }
    },
    eM = {
        build(e) {
            const t = e.shape,
                i = t.x,
                s = t.y,
                n = t.width,
                r = t.height,
                o = e.points;
            o.length = 0, n >= 0 && r >= 0 && o.push(i, s, i + n, s, i + n, s + r, i, s + r)
        },
        triangulate(e, t) {
            const i = e.points,
                s = t.points;
            if (i.length === 0) return;
            const n = s.length / 2;
            s.push(i[0], i[1], i[2], i[3], i[6], i[7], i[4], i[5]), t.indices.push(n, n + 1, n + 2, n + 1, n + 2, n + 3)
        }
    },
    iM = {
        build(e) {
            Ic.build(e)
        },
        triangulate(e, t) {
            Ic.triangulate(e, t)
        }
    };
var bn = (e => (e.MITER = "miter", e.BEVEL = "bevel", e.ROUND = "round", e))(bn || {}),
    or = (e => (e.BUTT = "butt", e.ROUND = "round", e.SQUARE = "square", e))(or || {});
const Oo = {
    adaptive: !0,
    maxLength: 10,
    minSegments: 8,
    maxSegments: 2048,
    epsilon: 1e-4,
    _segmentsCount(e, t = 20) {
        if (!this.adaptive || !e || isNaN(e)) return t;
        let i = Math.ceil(e / this.maxLength);
        return i < this.minSegments ? i = this.minSegments : i > this.maxSegments && (i = this.maxSegments), i
    }
};
class Ag {
    static curveTo(t, i, s, n, r, o) {
        const a = o[o.length - 2],
            c = o[o.length - 1] - i,
            h = a - t,
            u = n - i,
            d = s - t,
            f = Math.abs(c * d - h * u);
        if (f < 1e-8 || r === 0) return (o[o.length - 2] !== t || o[o.length - 1] !== i) && o.push(t, i), null;
        const p = c * c + h * h,
            m = u * u + d * d,
            g = c * u + h * d,
            y = r * Math.sqrt(p) / f,
            x = r * Math.sqrt(m) / f,
            v = y * g / p,
            _ = x * g / m,
            C = y * d + x * h,
            k = y * u + x * c,
            S = h * (x + v),
            T = c * (x + v),
            L = d * (y + _),
            D = u * (y + _),
            O = Math.atan2(T - k, S - C),
            K = Math.atan2(D - k, L - C);
        return {
            cx: C + t,
            cy: k + i,
            radius: r,
            startAngle: O,
            endAngle: K,
            anticlockwise: h * u > d * c
        }
    }
    static arc(t, i, s, n, r, o, a, l, c) {
        const h = a - o,
            u = Oo._segmentsCount(Math.abs(h) * r, Math.ceil(Math.abs(h) / Tc) * 40),
            d = h / (u * 2),
            f = d * 2,
            p = Math.cos(d),
            m = Math.sin(d),
            g = u - 1,
            y = g % 1 / g;
        for (let x = 0; x <= g; ++x) {
            const v = x + y * x,
                _ = d + o + f * v,
                C = Math.cos(_),
                k = -Math.sin(_);
            c.push((p * C + m * k) * r + s, (p * -k + m * C) * r + n)
        }
    }
}
class sM {
    constructor() {
        this.reset()
    }
    begin(t, i, s) {
        this.reset(), this.style = t, this.start = i, this.attribStart = s
    }
    end(t, i) {
        this.attribSize = i - this.attribStart, this.size = t - this.start
    }
    reset() {
        this.style = null, this.size = 0, this.start = 0, this.attribStart = 0, this.attribSize = 0
    }
}
class jf {
    static curveLength(t, i, s, n, r, o, a, l) {
        let h = 0,
            u = 0,
            d = 0,
            f = 0,
            p = 0,
            m = 0,
            g = 0,
            y = 0,
            x = 0,
            v = 0,
            _ = 0,
            C = t,
            k = i;
        for (let S = 1; S <= 10; ++S) u = S / 10, d = u * u, f = d * u, p = 1 - u, m = p * p, g = m * p, y = g * t + 3 * m * u * s + 3 * p * d * r + f * a, x = g * i + 3 * m * u * n + 3 * p * d * o + f * l, v = C - y, _ = k - x, C = y, k = x, h += Math.sqrt(v * v + _ * _);
        return h
    }
    static curveTo(t, i, s, n, r, o, a) {
        const l = a[a.length - 2],
            c = a[a.length - 1];
        a.length -= 2;
        const h = Oo._segmentsCount(jf.curveLength(l, c, t, i, s, n, r, o));
        let u = 0,
            d = 0,
            f = 0,
            p = 0,
            m = 0;
        a.push(l, c);
        for (let g = 1, y = 0; g <= h; ++g) y = g / h, u = 1 - y, d = u * u, f = d * u, p = y * y, m = p * y, a.push(f * l + 3 * d * y * t + 3 * u * p * s + m * r, f * c + 3 * d * y * i + 3 * u * p * n + m * o)
    }
}

function Ig(e, t, i, s, n, r, o, a) {
    const l = e - i * n,
        c = t - s * n,
        h = e + i * r,
        u = t + s * r;
    let d, f;
    o ? (d = s, f = -i) : (d = -s, f = i);
    const p = l + d,
        m = c + f,
        g = h + d,
        y = u + f;
    return a.push(p, m), a.push(g, y), 2
}

function Vn(e, t, i, s, n, r, o, a) {
    const l = i - e,
        c = s - t;
    let h = Math.atan2(l, c),
        u = Math.atan2(n - e, r - t);
    a && h < u ? h += Math.PI * 2 : !a && h > u && (u += Math.PI * 2);
    let d = h;
    const f = u - h,
        p = Math.abs(f),
        m = Math.sqrt(l * l + c * c),
        g = (15 * p * Math.sqrt(m) / Math.PI >> 0) + 1,
        y = f / g;
    if (d += y, a) {
        o.push(e, t), o.push(i, s);
        for (let x = 1, v = d; x < g; x++, v += y) o.push(e, t), o.push(e + Math.sin(v) * m, t + Math.cos(v) * m);
        o.push(e, t), o.push(n, r)
    } else {
        o.push(i, s), o.push(e, t);
        for (let x = 1, v = d; x < g; x++, v += y) o.push(e + Math.sin(v) * m, t + Math.cos(v) * m), o.push(e, t);
        o.push(n, r), o.push(e, t)
    }
    return g * 2
}

function nM(e, t) {
    const i = e.shape;
    let s = e.points || i.points.slice();
    const n = t.closePointEps;
    if (s.length === 0) return;
    const r = e.lineStyle,
        o = new Zt(s[0], s[1]),
        a = new Zt(s[s.length - 2], s[s.length - 1]),
        l = i.type !== we.POLY || i.closeStroke,
        c = Math.abs(o.x - a.x) < n && Math.abs(o.y - a.y) < n;
    if (l) {
        s = s.slice(), c && (s.pop(), s.pop(), a.set(s[s.length - 2], s[s.length - 1]));
        const Q = (o.x + a.x) * .5,
            pt = (a.y + o.y) * .5;
        s.unshift(Q, pt), s.push(Q, pt)
    }
    const h = t.points,
        u = s.length / 2;
    let d = s.length;
    const f = h.length / 2,
        p = r.width / 2,
        m = p * p,
        g = r.miterLimit * r.miterLimit;
    let y = s[0],
        x = s[1],
        v = s[2],
        _ = s[3],
        C = 0,
        k = 0,
        S = -(x - _),
        T = y - v,
        L = 0,
        D = 0,
        O = Math.sqrt(S * S + T * T);
    S /= O, T /= O, S *= p, T *= p;
    const K = r.alignment,
        P = (1 - K) * 2,
        N = K * 2;
    l || (r.cap === or.ROUND ? d += Vn(y - S * (P - N) * .5, x - T * (P - N) * .5, y - S * P, x - T * P, y + S * N, x + T * N, h, !0) + 2 : r.cap === or.SQUARE && (d += Ig(y, x, S, T, P, N, !0, h))), h.push(y - S * P, x - T * P), h.push(y + S * N, x + T * N);
    for (let Q = 1; Q < u - 1; ++Q) {
        y = s[(Q - 1) * 2], x = s[(Q - 1) * 2 + 1], v = s[Q * 2], _ = s[Q * 2 + 1], C = s[(Q + 1) * 2], k = s[(Q + 1) * 2 + 1], S = -(x - _), T = y - v, O = Math.sqrt(S * S + T * T), S /= O, T /= O, S *= p, T *= p, L = -(_ - k), D = v - C, O = Math.sqrt(L * L + D * D), L /= O, D /= O, L *= p, D *= p;
        const pt = v - y,
            bt = x - _,
            ct = v - C,
            gt = k - _,
            xt = pt * ct + bt * gt,
            It = bt * ct - gt * pt,
            St = It < 0;
        if (Math.abs(It) < .001 * Math.abs(xt)) {
            h.push(v - S * P, _ - T * P), h.push(v + S * N, _ + T * N), xt >= 0 && (r.join === bn.ROUND ? d += Vn(v, _, v - S * P, _ - T * P, v - L * P, _ - D * P, h, !1) + 4 : d += 2, h.push(v - L * N, _ - D * N), h.push(v + L * P, _ + D * P));
            continue
        }
        const J = (-S + y) * (-T + _) - (-S + v) * (-T + x),
            wt = (-L + C) * (-D + _) - (-L + v) * (-D + k),
            Tt = (pt * wt - ct * J) / It,
            Bt = (gt * J - bt * wt) / It,
            kt = (Tt - v) * (Tt - v) + (Bt - _) * (Bt - _),
            re = v + (Tt - v) * P,
            Xt = _ + (Bt - _) * P,
            ce = v - (Tt - v) * N,
            E = _ - (Bt - _) * N,
            M = Math.min(pt * pt + bt * bt, ct * ct + gt * gt),
            F = St ? P : N,
            $ = M + F * F * m;
        kt <= $ ? r.join === bn.BEVEL || kt / m > g ? (St ? (h.push(re, Xt), h.push(v + S * N, _ + T * N), h.push(re, Xt), h.push(v + L * N, _ + D * N)) : (h.push(v - S * P, _ - T * P), h.push(ce, E), h.push(v - L * P, _ - D * P), h.push(ce, E)), d += 2) : r.join === bn.ROUND ? St ? (h.push(re, Xt), h.push(v + S * N, _ + T * N), d += Vn(v, _, v + S * N, _ + T * N, v + L * N, _ + D * N, h, !0) + 4, h.push(re, Xt), h.push(v + L * N, _ + D * N)) : (h.push(v - S * P, _ - T * P), h.push(ce, E), d += Vn(v, _, v - S * P, _ - T * P, v - L * P, _ - D * P, h, !1) + 4, h.push(v - L * P, _ - D * P), h.push(ce, E)) : (h.push(re, Xt), h.push(ce, E)) : (h.push(v - S * P, _ - T * P), h.push(v + S * N, _ + T * N), r.join === bn.ROUND ? St ? d += Vn(v, _, v + S * N, _ + T * N, v + L * N, _ + D * N, h, !0) + 2 : d += Vn(v, _, v - S * P, _ - T * P, v - L * P, _ - D * P, h, !1) + 2 : r.join === bn.MITER && kt / m <= g && (St ? (h.push(ce, E), h.push(ce, E)) : (h.push(re, Xt), h.push(re, Xt)), d += 2), h.push(v - L * P, _ - D * P), h.push(v + L * N, _ + D * N), d += 2)
    }
    y = s[(u - 2) * 2], x = s[(u - 2) * 2 + 1], v = s[(u - 1) * 2], _ = s[(u - 1) * 2 + 1], S = -(x - _), T = y - v, O = Math.sqrt(S * S + T * T), S /= O, T /= O, S *= p, T *= p, h.push(v - S * P, _ - T * P), h.push(v + S * N, _ + T * N), l || (r.cap === or.ROUND ? d += Vn(v - S * (P - N) * .5, _ - T * (P - N) * .5, v - S * P, _ - T * P, v + S * N, _ + T * N, h, !1) + 2 : r.cap === or.SQUARE && (d += Ig(v, _, S, T, P, N, !1, h)));
    const W = t.indices,
        V = Oo.epsilon * Oo.epsilon;
    for (let Q = f; Q < d + f - 2; ++Q) y = h[Q * 2], x = h[Q * 2 + 1], v = h[(Q + 1) * 2], _ = h[(Q + 1) * 2 + 1], C = h[(Q + 2) * 2], k = h[(Q + 2) * 2 + 1], !(Math.abs(y * (_ - k) + v * (k - x) + C * (x - _)) < V) && W.push(Q, Q + 1, Q + 2)
}

function rM(e, t) {
    let i = 0;
    const s = e.shape,
        n = e.points || s.points,
        r = s.type !== we.POLY || s.closeStroke;
    if (n.length === 0) return;
    const o = t.points,
        a = t.indices,
        l = n.length / 2,
        c = o.length / 2;
    let h = c;
    for (o.push(n[0], n[1]), i = 1; i < l; i++) o.push(n[i * 2], n[i * 2 + 1]), a.push(h, h + 1), h++;
    r && a.push(h, c)
}

function Mg(e, t) {
    e.lineStyle.native ? rM(e, t) : nM(e, t)
}
class Wf {
    static curveLength(t, i, s, n, r, o) {
        const a = t - 2 * s + r,
            l = i - 2 * n + o,
            c = 2 * s - 2 * t,
            h = 2 * n - 2 * i,
            u = 4 * (a * a + l * l),
            d = 4 * (a * c + l * h),
            f = c * c + h * h,
            p = 2 * Math.sqrt(u + d + f),
            m = Math.sqrt(u),
            g = 2 * u * m,
            y = 2 * Math.sqrt(f),
            x = d / m;
        return (g * p + m * d * (p - y) + (4 * f * u - d * d) * Math.log((2 * m + x + p) / (x + y))) / (4 * g)
    }
    static curveTo(t, i, s, n, r) {
        const o = r[r.length - 2],
            a = r[r.length - 1],
            l = Oo._segmentsCount(Wf.curveLength(o, a, t, i, s, n));
        let c = 0,
            h = 0;
        for (let u = 1; u <= l; ++u) {
            const d = u / l;
            c = o + (t - o) * d, h = a + (i - a) * d, r.push(c + (t + (s - t) * d - c) * d, h + (i + (n - i) * d - h) * d)
        }
    }
}
const cu = {
        [we.POLY]: A1,
        [we.CIRC]: Ic,
        [we.ELIP]: Ic,
        [we.RECT]: eM,
        [we.RREC]: iM
    },
    Rg = [],
    Dl = [];
class Mc {
    constructor(t, i = null, s = null, n = null) {
        this.points = [], this.holes = [], this.shape = t, this.lineStyle = s, this.fillStyle = i, this.matrix = n, this.type = t.type
    }
    clone() {
        return new Mc(this.shape, this.fillStyle, this.lineStyle, this.matrix)
    }
    destroy() {
        this.shape = null, this.holes.length = 0, this.holes = null, this.points.length = 0, this.points = null, this.lineStyle = null, this.fillStyle = null
    }
}
const Gr = new Zt,
    I1 = class extends k_ {
        constructor() {
            super(), this.closePointEps = 1e-4, this.boundsPadding = 0, this.uvsFloat32 = null, this.indicesUint16 = null, this.batchable = !1, this.points = [], this.colors = [], this.uvs = [], this.indices = [], this.textureIds = [], this.graphicsData = [], this.drawCalls = [], this.batchDirty = -1, this.batches = [], this.dirty = 0, this.cacheDirty = -1, this.clearDirty = 0, this.shapeIndex = 0, this._bounds = new Ec, this.boundsDirty = -1
        }
        get bounds() {
            return this.updateBatches(), this.boundsDirty !== this.dirty && (this.boundsDirty = this.dirty, this.calculateBounds()), this._bounds
        }
        invalidate() {
            this.boundsDirty = -1, this.dirty++, this.batchDirty++, this.shapeIndex = 0, this.points.length = 0, this.colors.length = 0, this.uvs.length = 0, this.indices.length = 0, this.textureIds.length = 0;
            for (let e = 0; e < this.drawCalls.length; e++) this.drawCalls[e].texArray.clear(), Dl.push(this.drawCalls[e]);
            this.drawCalls.length = 0;
            for (let e = 0; e < this.batches.length; e++) {
                const t = this.batches[e];
                t.reset(), Rg.push(t)
            }
            this.batches.length = 0
        }
        clear() {
            return this.graphicsData.length > 0 && (this.invalidate(), this.clearDirty++, this.graphicsData.length = 0), this
        }
        drawShape(e, t = null, i = null, s = null) {
            const n = new Mc(e, t, i, s);
            return this.graphicsData.push(n), this.dirty++, this
        }
        drawHole(e, t = null) {
            if (!this.graphicsData.length) return null;
            const i = new Mc(e, null, null, t),
                s = this.graphicsData[this.graphicsData.length - 1];
            return i.lineStyle = s.lineStyle, s.holes.push(i), this.dirty++, this
        }
        destroy() {
            super.destroy();
            for (let e = 0; e < this.graphicsData.length; ++e) this.graphicsData[e].destroy();
            this.points.length = 0, this.points = null, this.colors.length = 0, this.colors = null, this.uvs.length = 0, this.uvs = null, this.indices.length = 0, this.indices = null, this.indexBuffer.destroy(), this.indexBuffer = null, this.graphicsData.length = 0, this.graphicsData = null, this.drawCalls.length = 0, this.drawCalls = null, this.batches.length = 0, this.batches = null, this._bounds = null
        }
        containsPoint(e) {
            const t = this.graphicsData;
            for (let i = 0; i < t.length; ++i) {
                const s = t[i];
                if (!!s.fillStyle.visible && s.shape && (s.matrix ? s.matrix.applyInverse(e, Gr) : Gr.copyFrom(e), s.shape.contains(Gr.x, Gr.y))) {
                    let n = !1;
                    if (s.holes) {
                        for (let r = 0; r < s.holes.length; r++)
                            if (s.holes[r].shape.contains(Gr.x, Gr.y)) {
                                n = !0;
                                break
                            }
                    }
                    if (!n) return !0
                }
            }
            return !1
        }
        updateBatches() {
            if (!this.graphicsData.length) {
                this.batchable = !0;
                return
            }
            if (!this.validateBatching()) return;
            this.cacheDirty = this.dirty;
            const e = this.uvs,
                t = this.graphicsData;
            let i = null,
                s = null;
            this.batches.length > 0 && (i = this.batches[this.batches.length - 1], s = i.style);
            for (let a = this.shapeIndex; a < t.length; a++) {
                this.shapeIndex++;
                const l = t[a],
                    c = l.fillStyle,
                    h = l.lineStyle;
                cu[l.type].build(l), l.matrix && this.transformPoints(l.points, l.matrix), (c.visible || h.visible) && this.processHoles(l.holes);
                for (let d = 0; d < 2; d++) {
                    const f = d === 0 ? c : h;
                    if (!f.visible) continue;
                    const p = f.texture.baseTexture,
                        m = this.indices.length,
                        g = this.points.length / 2;
                    p.wrapMode = Zs.REPEAT, d === 0 ? this.processFill(l) : this.processLine(l);
                    const y = this.points.length / 2 - g;
                    y !== 0 && (i && !this._compareStyles(s, f) && (i.end(m, g), i = null), i || (i = Rg.pop() || new sM, i.begin(f, m, g), this.batches.push(i), s = f), this.addUvs(this.points, e, f.texture, g, y, f.matrix))
                }
            }
            const n = this.indices.length,
                r = this.points.length / 2;
            if (i && i.end(n, r), this.batches.length === 0) {
                this.batchable = !0;
                return
            }
            const o = r > 65535;
            this.indicesUint16 && this.indices.length === this.indicesUint16.length && o === this.indicesUint16.BYTES_PER_ELEMENT > 2 ? this.indicesUint16.set(this.indices) : this.indicesUint16 = o ? new Uint32Array(this.indices) : new Uint16Array(this.indices), this.batchable = this.isBatchable(), this.batchable ? this.packBatches() : this.buildDrawCalls()
        }
        _compareStyles(e, t) {
            return !(!e || !t || e.texture.baseTexture !== t.texture.baseTexture || e.color + e.alpha !== t.color + t.alpha || !!e.native != !!t.native)
        }
        validateBatching() {
            if (this.dirty === this.cacheDirty || !this.graphicsData.length) return !1;
            for (let e = 0, t = this.graphicsData.length; e < t; e++) {
                const i = this.graphicsData[e],
                    s = i.fillStyle,
                    n = i.lineStyle;
                if (s && !s.texture.baseTexture.valid || n && !n.texture.baseTexture.valid) return !1
            }
            return !0
        }
        packBatches() {
            this.batchDirty++, this.uvsFloat32 = new Float32Array(this.uvs);
            const e = this.batches;
            for (let t = 0, i = e.length; t < i; t++) {
                const s = e[t];
                for (let n = 0; n < s.size; n++) {
                    const r = s.start + n;
                    this.indicesUint16[r] = this.indicesUint16[r] - s.attribStart
                }
            }
        }
        isBatchable() {
            if (this.points.length > 65535 * 2) return !1;
            const e = this.batches;
            for (let t = 0; t < e.length; t++)
                if (e[t].style.native) return !1;
            return this.points.length < I1.BATCHABLE_SIZE * 2
        }
        buildDrawCalls() {
            let e = ++Nt._globalBatch;
            for (let h = 0; h < this.drawCalls.length; h++) this.drawCalls[h].texArray.clear(), Dl.push(this.drawCalls[h]);
            this.drawCalls.length = 0;
            const t = this.colors,
                i = this.textureIds;
            let s = Dl.pop();
            s || (s = new cd, s.texArray = new ud), s.texArray.count = 0, s.start = 0, s.size = 0, s.type = rs.TRIANGLES;
            let n = 0,
                r = null,
                o = 0,
                a = !1,
                l = rs.TRIANGLES,
                c = 0;
            this.drawCalls.push(s);
            for (let h = 0; h < this.batches.length; h++) {
                const u = this.batches[h],
                    d = 8,
                    f = u.style,
                    p = f.texture.baseTexture;
                a !== !!f.native && (a = !!f.native, l = a ? rs.LINES : rs.TRIANGLES, r = null, n = d, e++), r !== p && (r = p, p._batchEnabled !== e && (n === d && (e++, n = 0, s.size > 0 && (s = Dl.pop(), s || (s = new cd, s.texArray = new ud), this.drawCalls.push(s)), s.start = c, s.size = 0, s.texArray.count = 0, s.type = l), p.touched = 1, p._batchEnabled = e, p._batchLocation = n, p.wrapMode = Zs.REPEAT, s.texArray.elements[s.texArray.count++] = p, n++)), s.size += u.size, c += u.size, o = p._batchLocation, this.addColors(t, f.color, f.alpha, u.attribSize, u.attribStart), this.addTextureIds(i, o, u.attribSize, u.attribStart)
            }
            Nt._globalBatch = e, this.packAttributes()
        }
        packAttributes() {
            const e = this.points,
                t = this.uvs,
                i = this.colors,
                s = this.textureIds,
                n = new ArrayBuffer(e.length * 3 * 4),
                r = new Float32Array(n),
                o = new Uint32Array(n);
            let a = 0;
            for (let l = 0; l < e.length / 2; l++) r[a++] = e[l * 2], r[a++] = e[l * 2 + 1], r[a++] = t[l * 2], r[a++] = t[l * 2 + 1], o[a++] = i[l], r[a++] = s[l];
            this._buffer.update(n), this._indexBuffer.update(this.indicesUint16)
        }
        processFill(e) {
            e.holes.length ? A1.triangulate(e, this) : cu[e.type].triangulate(e, this)
        }
        processLine(e) {
            Mg(e, this);
            for (let t = 0; t < e.holes.length; t++) Mg(e.holes[t], this)
        }
        processHoles(e) {
            for (let t = 0; t < e.length; t++) {
                const i = e[t];
                cu[i.type].build(i), i.matrix && this.transformPoints(i.points, i.matrix)
            }
        }
        calculateBounds() {
            const e = this._bounds;
            e.clear(), e.addVertexData(this.points, 0, this.points.length), e.pad(this.boundsPadding, this.boundsPadding)
        }
        transformPoints(e, t) {
            for (let i = 0; i < e.length / 2; i++) {
                const s = e[i * 2],
                    n = e[i * 2 + 1];
                e[i * 2] = t.a * s + t.c * n + t.tx, e[i * 2 + 1] = t.b * s + t.d * n + t.ty
            }
        }
        addColors(e, t, i, s, n = 0) {
            const r = (t >> 16) + (t & 65280) + ((t & 255) << 16),
                o = ch(r, i);
            e.length = Math.max(e.length, n + s);
            for (let a = 0; a < s; a++) e[n + a] = o
        }
        addTextureIds(e, t, i, s = 0) {
            e.length = Math.max(e.length, s + i);
            for (let n = 0; n < i; n++) e[s + n] = t
        }
        addUvs(e, t, i, s, n, r = null) {
            let o = 0;
            const a = t.length,
                l = i.frame;
            for (; o < n;) {
                let h = e[(s + o) * 2],
                    u = e[(s + o) * 2 + 1];
                if (r) {
                    const d = r.a * h + r.c * u + r.tx;
                    u = r.b * h + r.d * u + r.ty, h = d
                }
                o++, t.push(h / l.width, u / l.height)
            }
            const c = i.baseTexture;
            (l.width < c.width || l.height < c.height) && this.adjustUvs(t, i, a, n)
        }
        adjustUvs(e, t, i, s) {
            const n = t.baseTexture,
                r = 1e-6,
                o = i + s * 2,
                a = t.frame,
                l = a.width / n.width,
                c = a.height / n.height;
            let h = a.x / a.width,
                u = a.y / a.height,
                d = Math.floor(e[i] + r),
                f = Math.floor(e[i + 1] + r);
            for (let p = i + 2; p < o; p += 2) d = Math.min(d, Math.floor(e[p] + r)), f = Math.min(f, Math.floor(e[p + 1] + r));
            h -= d, u -= f;
            for (let p = i; p < o; p += 2) e[p] = (e[p] + h) * l, e[p + 1] = (e[p + 1] + u) * c
        }
    };
let M1 = I1;
M1.BATCHABLE_SIZE = 100;
class mh {
    constructor() {
        this.color = 16777215, this.alpha = 1, this.texture = ht.WHITE, this.matrix = null, this.visible = !1, this.reset()
    }
    clone() {
        const t = new mh;
        return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t
    }
    reset() {
        this.color = 16777215, this.alpha = 1, this.texture = ht.WHITE, this.matrix = null, this.visible = !1
    }
    destroy() {
        this.texture = null, this.matrix = null
    }
}
class Xf extends mh {
    constructor() {
        super(...arguments), this.width = 0, this.alignment = .5, this.native = !1, this.cap = or.BUTT, this.join = bn.MITER, this.miterLimit = 10
    }
    clone() {
        const t = new Xf;
        return t.color = this.color, t.alpha = this.alpha, t.texture = this.texture, t.matrix = this.matrix, t.visible = this.visible, t.width = this.width, t.alignment = this.alignment, t.native = this.native, t.cap = this.cap, t.join = this.join, t.miterLimit = this.miterLimit, t
    }
    reset() {
        super.reset(), this.color = 0, this.alignment = .5, this.width = 0, this.native = !1
    }
}
const oM = new Float32Array(3),
    hu = {},
    tc = class extends ae {
        constructor(e = null) {
            super(), this.shader = null, this.pluginName = "batch", this.currentPath = null, this.batches = [], this.batchTint = -1, this.batchDirty = -1, this.vertexData = null, this._fillStyle = new mh, this._lineStyle = new Xf, this._matrix = null, this._holeMode = !1, this.state = rn.for2d(), this._geometry = e || new M1, this._geometry.refCount++, this._transformID = -1, this.tint = 16777215, this.blendMode = j.NORMAL
        }
        get geometry() {
            return this._geometry
        }
        clone() {
            return this.finishPoly(), new tc(this._geometry)
        }
        set blendMode(e) {
            this.state.blendMode = e
        }
        get blendMode() {
            return this.state.blendMode
        }
        get tint() {
            return this._tint
        }
        set tint(e) {
            this._tint = e
        }
        get fill() {
            return this._fillStyle
        }
        get line() {
            return this._lineStyle
        }
        lineStyle(e = null, t = 0, i = 1, s = .5, n = !1) {
            return typeof e == "number" && (e = {
                width: e,
                color: t,
                alpha: i,
                alignment: s,
                native: n
            }), this.lineTextureStyle(e)
        }
        lineTextureStyle(e) {
            e = Object.assign({
                width: 0,
                texture: ht.WHITE,
                color: e?.texture ? 16777215 : 0,
                alpha: 1,
                matrix: null,
                alignment: .5,
                native: !1,
                cap: or.BUTT,
                join: bn.MITER,
                miterLimit: 10
            }, e), this.currentPath && this.startPoly();
            const t = e.width > 0 && e.alpha > 0;
            return t ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._lineStyle, {
                visible: t
            }, e)) : this._lineStyle.reset(), this
        }
        startPoly() {
            if (this.currentPath) {
                const e = this.currentPath.points,
                    t = this.currentPath.points.length;
                t > 2 && (this.drawShape(this.currentPath), this.currentPath = new vo, this.currentPath.closeStroke = !1, this.currentPath.points.push(e[t - 2], e[t - 1]))
            } else this.currentPath = new vo, this.currentPath.closeStroke = !1
        }
        finishPoly() {
            this.currentPath && (this.currentPath.points.length > 2 ? (this.drawShape(this.currentPath), this.currentPath = null) : this.currentPath.points.length = 0)
        }
        moveTo(e, t) {
            return this.startPoly(), this.currentPath.points[0] = e, this.currentPath.points[1] = t, this
        }
        lineTo(e, t) {
            this.currentPath || this.moveTo(0, 0);
            const i = this.currentPath.points,
                s = i[i.length - 2],
                n = i[i.length - 1];
            return (s !== e || n !== t) && i.push(e, t), this
        }
        _initCurve(e = 0, t = 0) {
            this.currentPath ? this.currentPath.points.length === 0 && (this.currentPath.points = [e, t]) : this.moveTo(e, t)
        }
        quadraticCurveTo(e, t, i, s) {
            this._initCurve();
            const n = this.currentPath.points;
            return n.length === 0 && this.moveTo(0, 0), Wf.curveTo(e, t, i, s, n), this
        }
        bezierCurveTo(e, t, i, s, n, r) {
            return this._initCurve(), jf.curveTo(e, t, i, s, n, r, this.currentPath.points), this
        }
        arcTo(e, t, i, s, n) {
            this._initCurve(e, t);
            const r = this.currentPath.points,
                o = Ag.curveTo(e, t, i, s, n, r);
            if (o) {
                const {
                    cx: a,
                    cy: l,
                    radius: c,
                    startAngle: h,
                    endAngle: u,
                    anticlockwise: d
                } = o;
                this.arc(a, l, c, h, u, d)
            }
            return this
        }
        arc(e, t, i, s, n, r = !1) {
            if (s === n) return this;
            if (!r && n <= s ? n += Tc : r && s <= n && (s += Tc), n - s === 0) return this;
            const a = e + Math.cos(s) * i,
                l = t + Math.sin(s) * i,
                c = this._geometry.closePointEps;
            let h = this.currentPath ? this.currentPath.points : null;
            if (h) {
                const u = Math.abs(h[h.length - 2] - a),
                    d = Math.abs(h[h.length - 1] - l);
                u < c && d < c || h.push(a, l)
            } else this.moveTo(a, l), h = this.currentPath.points;
            return Ag.arc(a, l, e, t, i, s, n, r, h), this
        }
        beginFill(e = 0, t = 1) {
            return this.beginTextureFill({
                texture: ht.WHITE,
                color: e,
                alpha: t
            })
        }
        beginTextureFill(e) {
            e = Object.assign({
                texture: ht.WHITE,
                color: 16777215,
                alpha: 1,
                matrix: null
            }, e), this.currentPath && this.startPoly();
            const t = e.alpha > 0;
            return t ? (e.matrix && (e.matrix = e.matrix.clone(), e.matrix.invert()), Object.assign(this._fillStyle, {
                visible: t
            }, e)) : this._fillStyle.reset(), this
        }
        endFill() {
            return this.finishPoly(), this._fillStyle.reset(), this
        }
        drawRect(e, t, i, s) {
            return this.drawShape(new qt(e, t, i, s))
        }
        drawRoundedRect(e, t, i, s, n) {
            return this.drawShape(new Hf(e, t, i, s, n))
        }
        drawCircle(e, t, i) {
            return this.drawShape(new Uf(e, t, i))
        }
        drawEllipse(e, t, i, s) {
            return this.drawShape(new Gf(e, t, i, s))
        }
        drawPolygon(...e) {
            let t, i = !0;
            const s = e[0];
            s.points ? (i = s.closeStroke, t = s.points) : Array.isArray(e[0]) ? t = e[0] : t = e;
            const n = new vo(t);
            return n.closeStroke = i, this.drawShape(n), this
        }
        drawShape(e) {
            return this._holeMode ? this._geometry.drawHole(e, this._matrix) : this._geometry.drawShape(e, this._fillStyle.clone(), this._lineStyle.clone(), this._matrix), this
        }
        clear() {
            return this._geometry.clear(), this._lineStyle.reset(), this._fillStyle.reset(), this._boundsID++, this._matrix = null, this._holeMode = !1, this.currentPath = null, this
        }
        isFastRect() {
            const e = this._geometry.graphicsData;
            return e.length === 1 && e[0].shape.type === we.RECT && !e[0].matrix && !e[0].holes.length && !(e[0].lineStyle.visible && e[0].lineStyle.width)
        }
        _render(e) {
            this.finishPoly();
            const t = this._geometry;
            t.updateBatches(), t.batchable ? (this.batchDirty !== t.batchDirty && this._populateBatches(), this._renderBatched(e)) : (e.batch.flush(), this._renderDirect(e))
        }
        _populateBatches() {
            const e = this._geometry,
                t = this.blendMode,
                i = e.batches.length;
            this.batchTint = -1, this._transformID = -1, this.batchDirty = e.batchDirty, this.batches.length = i, this.vertexData = new Float32Array(e.points);
            for (let s = 0; s < i; s++) {
                const n = e.batches[s],
                    r = n.style.color,
                    o = new Float32Array(this.vertexData.buffer, n.attribStart * 4 * 2, n.attribSize * 2),
                    a = new Float32Array(e.uvsFloat32.buffer, n.attribStart * 4 * 2, n.attribSize * 2),
                    l = new Uint16Array(e.indicesUint16.buffer, n.start * 2, n.size),
                    c = {
                        vertexData: o,
                        blendMode: t,
                        indices: l,
                        uvs: a,
                        _batchRGB: tn(r),
                        _tintRGB: r,
                        _texture: n.style.texture,
                        alpha: n.style.alpha,
                        worldAlpha: 1
                    };
                this.batches[s] = c
            }
        }
        _renderBatched(e) {
            if (!!this.batches.length) {
                e.batch.setObjectRenderer(e.plugins[this.pluginName]), this.calculateVertices(), this.calculateTints();
                for (let t = 0, i = this.batches.length; t < i; t++) {
                    const s = this.batches[t];
                    s.worldAlpha = this.worldAlpha * s.alpha, e.plugins[this.pluginName].render(s)
                }
            }
        }
        _renderDirect(e) {
            const t = this._resolveDirectShader(e),
                i = this._geometry,
                s = this.tint,
                n = this.worldAlpha,
                r = t.uniforms,
                o = i.drawCalls;
            r.translationMatrix = this.transform.worldTransform, r.tint[0] = (s >> 16 & 255) / 255 * n, r.tint[1] = (s >> 8 & 255) / 255 * n, r.tint[2] = (s & 255) / 255 * n, r.tint[3] = n, e.shader.bind(t), e.geometry.bind(i, t), e.state.set(this.state);
            for (let a = 0, l = o.length; a < l; a++) this._renderDrawCallDirect(e, i.drawCalls[a])
        }
        _renderDrawCallDirect(e, t) {
            const {
                texArray: i,
                type: s,
                size: n,
                start: r
            } = t, o = i.count;
            for (let a = 0; a < o; a++) e.texture.bind(i.elements[a], a);
            e.geometry.draw(s, n, r)
        }
        _resolveDirectShader(e) {
            let t = this.shader;
            const i = this.pluginName;
            if (!t) {
                if (!hu[i]) {
                    const {
                        maxTextures: s
                    } = e.plugins[i], n = new Int32Array(s);
                    for (let a = 0; a < s; a++) n[a] = a;
                    const r = {
                            tint: new Float32Array([1, 1, 1, 1]),
                            translationMatrix: new pe,
                            default: hs.from({
                                uSamplers: n
                            }, !0)
                        },
                        o = e.plugins[i]._shader.program;
                    hu[i] = new Ls(o, r)
                }
                t = hu[i]
            }
            return t
        }
        _calculateBounds() {
            this.finishPoly();
            const e = this._geometry;
            if (!e.graphicsData.length) return;
            const {
                minX: t,
                minY: i,
                maxX: s,
                maxY: n
            } = e.bounds;
            this._bounds.addFrame(this.transform, t, i, s, n)
        }
        containsPoint(e) {
            return this.worldTransform.applyInverse(e, tc._TEMP_POINT), this._geometry.containsPoint(tc._TEMP_POINT)
        }
        calculateTints() {
            if (this.batchTint !== this.tint) {
                this.batchTint = this.tint;
                const e = tn(this.tint, oM);
                for (let t = 0; t < this.batches.length; t++) {
                    const i = this.batches[t],
                        s = i._batchRGB,
                        n = e[0] * s[0] * 255,
                        r = e[1] * s[1] * 255,
                        o = e[2] * s[2] * 255,
                        a = (n << 16) + (r << 8) + (o | 0);
                    i._tintRGB = (a >> 16) + (a & 65280) + ((a & 255) << 16)
                }
            }
        }
        calculateVertices() {
            const e = this.transform._worldID;
            if (this._transformID === e) return;
            this._transformID = e;
            const t = this.transform.worldTransform,
                i = t.a,
                s = t.b,
                n = t.c,
                r = t.d,
                o = t.tx,
                a = t.ty,
                l = this._geometry.points,
                c = this.vertexData;
            let h = 0;
            for (let u = 0; u < l.length; u += 2) {
                const d = l[u],
                    f = l[u + 1];
                c[h++] = i * d + n * f + o, c[h++] = r * f + s * d + a
            }
        }
        closePath() {
            const e = this.currentPath;
            return e && (e.closeStroke = !0, this.finishPoly()), this
        }
        setMatrix(e) {
            return this._matrix = e, this
        }
        beginHole() {
            return this.finishPoly(), this._holeMode = !0, this
        }
        endHole() {
            return this.finishPoly(), this._holeMode = !1, this
        }
        destroy(e) {
            this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose(), this._matrix = null, this.currentPath = null, this._lineStyle.destroy(), this._lineStyle = null, this._fillStyle.destroy(), this._fillStyle = null, this._geometry = null, this.shader = null, this.vertexData = null, this.batches.length = 0, this.batches = null, super.destroy(e)
        }
    };
let ke = tc;
ke.curves = Oo;
ke._TEMP_POINT = new Zt;
class aM {
    constructor(t, i) {
        this.uvBuffer = t, this.uvMatrix = i, this.data = null, this._bufferUpdateId = -1, this._textureUpdateId = -1, this._updateID = 0
    }
    update(t) {
        if (!t && this._bufferUpdateId === this.uvBuffer._updateID && this._textureUpdateId === this.uvMatrix._updateID) return;
        this._bufferUpdateId = this.uvBuffer._updateID, this._textureUpdateId = this.uvMatrix._updateID;
        const i = this.uvBuffer.data;
        (!this.data || this.data.length !== i.length) && (this.data = new Float32Array(i.length)), this.uvMatrix.multiplyUvs(i, this.data), this._updateID++
    }
}
const uu = new Zt,
    kg = new vo,
    R1 = class extends ae {
        constructor(e, t, i, s = rs.TRIANGLES) {
            super(), this.geometry = e, this.shader = t, this.state = i || rn.for2d(), this.drawMode = s, this.start = 0, this.size = 0, this.uvs = null, this.indices = null, this.vertexData = new Float32Array(1), this.vertexDirty = -1, this._transformID = -1, this._roundPixels = ut.ROUND_PIXELS, this.batchUvs = null
        }
        get geometry() {
            return this._geometry
        }
        set geometry(e) {
            this._geometry !== e && (this._geometry && (this._geometry.refCount--, this._geometry.refCount === 0 && this._geometry.dispose()), this._geometry = e, this._geometry && this._geometry.refCount++, this.vertexDirty = -1)
        }
        get uvBuffer() {
            return this.geometry.buffers[1]
        }
        get verticesBuffer() {
            return this.geometry.buffers[0]
        }
        set material(e) {
            this.shader = e
        }
        get material() {
            return this.shader
        }
        set blendMode(e) {
            this.state.blendMode = e
        }
        get blendMode() {
            return this.state.blendMode
        }
        set roundPixels(e) {
            this._roundPixels !== e && (this._transformID = -1), this._roundPixels = e
        }
        get roundPixels() {
            return this._roundPixels
        }
        get tint() {
            return "tint" in this.shader ? this.shader.tint : null
        }
        set tint(e) {
            this.shader.tint = e
        }
        get texture() {
            return "texture" in this.shader ? this.shader.texture : null
        }
        set texture(e) {
            this.shader.texture = e
        }
        _render(e) {
            const t = this.geometry.buffers[0].data;
            this.shader.batchable && this.drawMode === rs.TRIANGLES && t.length < R1.BATCHABLE_SIZE * 2 ? this._renderToBatch(e) : this._renderDefault(e)
        }
        _renderDefault(e) {
            const t = this.shader;
            t.alpha = this.worldAlpha, t.update && t.update(), e.batch.flush(), t.uniforms.translationMatrix = this.transform.worldTransform.toArray(!0), e.shader.bind(t), e.state.set(this.state), e.geometry.bind(this.geometry, t), e.geometry.draw(this.drawMode, this.size, this.start, this.geometry.instanceCount)
        }
        _renderToBatch(e) {
            const t = this.geometry,
                i = this.shader;
            i.uvMatrix && (i.uvMatrix.update(), this.calculateUvs()), this.calculateVertices(), this.indices = t.indexBuffer.data, this._tintRGB = i._tintRGB, this._texture = i.texture;
            const s = this.material.pluginName;
            e.batch.setObjectRenderer(e.plugins[s]), e.plugins[s].render(this)
        }
        calculateVertices() {
            const t = this.geometry.buffers[0],
                i = t.data,
                s = t._updateID;
            if (s === this.vertexDirty && this._transformID === this.transform._worldID) return;
            this._transformID = this.transform._worldID, this.vertexData.length !== i.length && (this.vertexData = new Float32Array(i.length));
            const n = this.transform.worldTransform,
                r = n.a,
                o = n.b,
                a = n.c,
                l = n.d,
                c = n.tx,
                h = n.ty,
                u = this.vertexData;
            for (let d = 0; d < u.length / 2; d++) {
                const f = i[d * 2],
                    p = i[d * 2 + 1];
                u[d * 2] = r * f + a * p + c, u[d * 2 + 1] = o * f + l * p + h
            }
            if (this._roundPixels) {
                const d = ut.RESOLUTION;
                for (let f = 0; f < u.length; ++f) u[f] = Math.round(u[f] * d) / d
            }
            this.vertexDirty = s
        }
        calculateUvs() {
            const e = this.geometry.buffers[1],
                t = this.shader;
            t.uvMatrix.isSimple ? this.uvs = e.data : (this.batchUvs || (this.batchUvs = new aM(e, t.uvMatrix)), this.batchUvs.update(), this.uvs = this.batchUvs.data)
        }
        _calculateBounds() {
            this.calculateVertices(), this._bounds.addVertexData(this.vertexData, 0, this.vertexData.length)
        }
        containsPoint(e) {
            if (!this.getBounds().contains(e.x, e.y)) return !1;
            this.worldTransform.applyInverse(e, uu);
            const t = this.geometry.getBuffer("aVertexPosition").data,
                i = kg.points,
                s = this.geometry.getIndex().data,
                n = s.length,
                r = this.drawMode === 4 ? 3 : 1;
            for (let o = 0; o + 2 < n; o += r) {
                const a = s[o] * 2,
                    l = s[o + 1] * 2,
                    c = s[o + 2] * 2;
                if (i[0] = t[a], i[1] = t[a + 1], i[2] = t[l], i[3] = t[l + 1], i[4] = t[c], i[5] = t[c + 1], kg.contains(uu.x, uu.y)) return !0
            }
            return !1
        }
        destroy(e) {
            super.destroy(e), this._cachedTexture && (this._cachedTexture.destroy(), this._cachedTexture = null), this.geometry = null, this.shader = null, this.state = null, this.uvs = null, this.indices = null, this.vertexData = null
        }
    };
let ti = R1;
ti.BATCHABLE_SIZE = 100;
class gh extends On {
    constructor(t, i, s) {
        super();
        const n = new Ne(t),
            r = new Ne(i, !0),
            o = new Ne(s, !0, !0);
        this.addAttribute("aVertexPosition", n, 2, !1, Rt.FLOAT).addAttribute("aTextureCoord", r, 2, !1, Rt.FLOAT).addIndex(o), this._updateId = -1
    }
    get vertexDirtyId() {
        return this.buffers[0]._updateID
    }
}
var lM = `varying vec2 vTextureCoord;
uniform vec4 uColor;

uniform sampler2D uSampler;

void main(void)
{
    gl_FragColor = texture2D(uSampler, vTextureCoord) * uColor;
}
`,
    cM = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTextureMatrix;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;
}
`;
class Do extends Ls {
    constructor(t, i) {
        const s = {
            uSampler: t,
            alpha: 1,
            uTextureMatrix: pe.IDENTITY,
            uColor: new Float32Array([1, 1, 1, 1])
        };
        i = Object.assign({
            tint: 16777215,
            alpha: 1,
            pluginName: "batch"
        }, i), i.uniforms && Object.assign(s, i.uniforms), super(i.program || os.from(cM, lM), s), this._colorDirty = !1, this.uvMatrix = new zf(t), this.batchable = i.program === void 0, this.pluginName = i.pluginName, this.tint = i.tint, this.alpha = i.alpha
    }
    get texture() {
        return this.uniforms.uSampler
    }
    set texture(t) {
        this.uniforms.uSampler !== t && (!this.uniforms.uSampler.baseTexture.alphaMode != !t.baseTexture.alphaMode && (this._colorDirty = !0), this.uniforms.uSampler = t, this.uvMatrix.texture = t)
    }
    set alpha(t) {
        t !== this._alpha && (this._alpha = t, this._colorDirty = !0)
    }
    get alpha() {
        return this._alpha
    }
    set tint(t) {
        t !== this._tint && (this._tint = t, this._tintRGB = (t >> 16) + (t & 65280) + ((t & 255) << 16), this._colorDirty = !0)
    }
    get tint() {
        return this._tint
    }
    update() {
        if (this._colorDirty) {
            this._colorDirty = !1;
            const t = this.texture.baseTexture;
            Bf(this._tint, this._alpha, this.uniforms.uColor, t.alphaMode)
        }
        this.uvMatrix.update() && (this.uniforms.uTextureMatrix = this.uvMatrix.mapCoord)
    }
}
class hM extends gh {
    constructor(t = 100, i = 100, s = 10, n = 10) {
        super(), this.segWidth = s, this.segHeight = n, this.width = t, this.height = i, this.build()
    }
    build() {
        const t = this.segWidth * this.segHeight,
            i = [],
            s = [],
            n = [],
            r = this.segWidth - 1,
            o = this.segHeight - 1,
            a = this.width / r,
            l = this.height / o;
        for (let h = 0; h < t; h++) {
            const u = h % this.segWidth,
                d = h / this.segWidth | 0;
            i.push(u * a, d * l), s.push(u / r, d / o)
        }
        const c = r * o;
        for (let h = 0; h < c; h++) {
            const u = h % r,
                d = h / r | 0,
                f = d * this.segWidth + u,
                p = d * this.segWidth + u + 1,
                m = (d + 1) * this.segWidth + u,
                g = (d + 1) * this.segWidth + u + 1;
            n.push(f, p, m, p, g, m)
        }
        this.buffers[0].data = new Float32Array(i), this.buffers[1].data = new Float32Array(s), this.indexBuffer.data = new Uint16Array(n), this.buffers[0].update(), this.buffers[1].update(), this.indexBuffer.update()
    }
}
class uM extends gh {
    constructor(t = 200, i, s = 0) {
        super(new Float32Array(i.length * 4), new Float32Array(i.length * 4), new Uint16Array((i.length - 1) * 6)), this.points = i, this._width = t, this.textureScale = s, this.build()
    }
    get width() {
        return this._width
    }
    build() {
        const t = this.points;
        if (!t) return;
        const i = this.getBuffer("aVertexPosition"),
            s = this.getBuffer("aTextureCoord"),
            n = this.getIndex();
        if (t.length < 1) return;
        i.data.length / 4 !== t.length && (i.data = new Float32Array(t.length * 4), s.data = new Float32Array(t.length * 4), n.data = new Uint16Array((t.length - 1) * 6));
        const r = s.data,
            o = n.data;
        r[0] = 0, r[1] = 0, r[2] = 0, r[3] = 1;
        let a = 0,
            l = t[0];
        const c = this._width * this.textureScale,
            h = t.length;
        for (let d = 0; d < h; d++) {
            const f = d * 4;
            if (this.textureScale > 0) {
                const p = l.x - t[d].x,
                    m = l.y - t[d].y,
                    g = Math.sqrt(p * p + m * m);
                l = t[d], a += g / c
            } else a = d / (h - 1);
            r[f] = a, r[f + 1] = 0, r[f + 2] = a, r[f + 3] = 1
        }
        let u = 0;
        for (let d = 0; d < h - 1; d++) {
            const f = d * 2;
            o[u++] = f, o[u++] = f + 1, o[u++] = f + 2, o[u++] = f + 2, o[u++] = f + 1, o[u++] = f + 3
        }
        s.update(), n.update(), this.updateVertices()
    }
    updateVertices() {
        const t = this.points;
        if (t.length < 1) return;
        let i = t[0],
            s, n = 0,
            r = 0;
        const o = this.buffers[0].data,
            a = t.length;
        for (let l = 0; l < a; l++) {
            const c = t[l],
                h = l * 4;
            l < t.length - 1 ? s = t[l + 1] : s = c, r = -(s.x - i.x), n = s.y - i.y;
            const u = Math.sqrt(n * n + r * r),
                d = this.textureScale > 0 ? this.textureScale * this._width / 2 : this._width / 2;
            n /= u, r /= u, n *= d, r *= d, o[h] = c.x + n, o[h + 1] = c.y + r, o[h + 2] = c.x - n, o[h + 3] = c.y - r, i = c
        }
        this.buffers[0].update()
    }
    update() {
        this.textureScale > 0 ? this.build() : this.updateVertices()
    }
}
class dM extends ti {
    constructor(t, i, s) {
        const n = new hM(t.width, t.height, i, s),
            r = new Do(ht.WHITE);
        super(n, r), this.texture = t, this.autoResize = !0
    }
    textureUpdated() {
        this._textureID = this.shader.texture._updateID;
        const t = this.geometry,
            {
                width: i,
                height: s
            } = this.shader.texture;
        this.autoResize && (t.width !== i || t.height !== s) && (t.width = this.shader.texture.width, t.height = this.shader.texture.height, t.build())
    }
    set texture(t) {
        this.shader.texture !== t && (this.shader.texture = t, this._textureID = -1, t.baseTexture.valid ? this.textureUpdated() : t.once("update", this.textureUpdated, this))
    }
    get texture() {
        return this.shader.texture
    }
    _render(t) {
        this._textureID !== this.shader.texture._updateID && this.textureUpdated(), super._render(t)
    }
    destroy(t) {
        this.shader.texture.off("update", this.textureUpdated, this), super.destroy(t)
    }
}
const Nl = 10;
class vh extends dM {
    constructor(t, i = Nl, s = Nl, n = Nl, r = Nl) {
        super(ht.WHITE, 4, 4), this._origWidth = t.orig.width, this._origHeight = t.orig.height, this._width = this._origWidth, this._height = this._origHeight, this._leftWidth = i, this._rightWidth = n, this._topHeight = s, this._bottomHeight = r, this.texture = t
    }
    textureUpdated() {
        this._textureID = this.shader.texture._updateID, this._refresh()
    }
    get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data
    }
    set vertices(t) {
        this.geometry.getBuffer("aVertexPosition").data = t
    }
    updateHorizontalVertices() {
        const t = this.vertices,
            i = this._getMinScale();
        t[9] = t[11] = t[13] = t[15] = this._topHeight * i, t[17] = t[19] = t[21] = t[23] = this._height - this._bottomHeight * i, t[25] = t[27] = t[29] = t[31] = this._height
    }
    updateVerticalVertices() {
        const t = this.vertices,
            i = this._getMinScale();
        t[2] = t[10] = t[18] = t[26] = this._leftWidth * i, t[4] = t[12] = t[20] = t[28] = this._width - this._rightWidth * i, t[6] = t[14] = t[22] = t[30] = this._width
    }
    _getMinScale() {
        const t = this._leftWidth + this._rightWidth,
            i = this._width > t ? 1 : this._width / t,
            s = this._topHeight + this._bottomHeight,
            n = this._height > s ? 1 : this._height / s;
        return Math.min(i, n)
    }
    get width() {
        return this._width
    }
    set width(t) {
        this._width = t, this._refresh()
    }
    get height() {
        return this._height
    }
    set height(t) {
        this._height = t, this._refresh()
    }
    get leftWidth() {
        return this._leftWidth
    }
    set leftWidth(t) {
        this._leftWidth = t, this._refresh()
    }
    get rightWidth() {
        return this._rightWidth
    }
    set rightWidth(t) {
        this._rightWidth = t, this._refresh()
    }
    get topHeight() {
        return this._topHeight
    }
    set topHeight(t) {
        this._topHeight = t, this._refresh()
    }
    get bottomHeight() {
        return this._bottomHeight
    }
    set bottomHeight(t) {
        this._bottomHeight = t, this._refresh()
    }
    _refresh() {
        const t = this.texture,
            i = this.geometry.buffers[1].data;
        this._origWidth = t.orig.width, this._origHeight = t.orig.height;
        const s = 1 / this._origWidth,
            n = 1 / this._origHeight;
        i[0] = i[8] = i[16] = i[24] = 0, i[1] = i[3] = i[5] = i[7] = 0, i[6] = i[14] = i[22] = i[30] = 1, i[25] = i[27] = i[29] = i[31] = 1, i[2] = i[10] = i[18] = i[26] = s * this._leftWidth, i[4] = i[12] = i[20] = i[28] = 1 - s * this._rightWidth, i[9] = i[11] = i[13] = i[15] = n * this._topHeight, i[17] = i[19] = i[21] = i[23] = 1 - n * this._bottomHeight, this.updateHorizontalVertices(), this.updateVerticalVertices(), this.geometry.buffers[0].update(), this.geometry.buffers[1].update()
    }
}
class fM extends ti {
    constructor(t = ht.EMPTY, i, s, n, r) {
        const o = new gh(i, s, n);
        o.getBuffer("aVertexPosition").static = !1;
        const a = new Do(t);
        super(o, a, null, r), this.autoUpdate = !0
    }
    get vertices() {
        return this.geometry.getBuffer("aVertexPosition").data
    }
    set vertices(t) {
        this.geometry.getBuffer("aVertexPosition").data = t
    }
    _render(t) {
        this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), super._render(t)
    }
}
class pM extends ti {
    constructor(t, i, s = 0) {
        const n = new uM(t.height, i, s),
            r = new Do(t);
        s > 0 && (t.baseTexture.wrapMode = Zs.REPEAT), super(n, r), this.autoUpdate = !0
    }
    _render(t) {
        const i = this.geometry;
        (this.autoUpdate || i._width !== this.shader.texture.height) && (i._width = this.shader.texture.height, i.update()), super._render(t)
    }
}
class Td extends ae {
    constructor(t = 1500, i, s = 16384, n = !1) {
        super();
        const r = 16384;
        s > r && (s = r), this._properties = [!1, !0, !1, !1, !1], this._maxSize = t, this._batchSize = s, this._buffers = null, this._bufferUpdateIDs = [], this._updateID = 0, this.interactiveChildren = !1, this.blendMode = j.NORMAL, this.autoResize = n, this.roundPixels = !0, this.baseTexture = null, this.setProperties(i), this._tint = 0, this.tintRgb = new Float32Array(4), this.tint = 16777215
    }
    setProperties(t) {
        t && (this._properties[0] = "vertices" in t || "scale" in t ? !!t.vertices || !!t.scale : this._properties[0], this._properties[1] = "position" in t ? !!t.position : this._properties[1], this._properties[2] = "rotation" in t ? !!t.rotation : this._properties[2], this._properties[3] = "uvs" in t ? !!t.uvs : this._properties[3], this._properties[4] = "tint" in t || "alpha" in t ? !!t.tint || !!t.alpha : this._properties[4])
    }
    updateTransform() {
        this.displayObjectUpdateTransform()
    }
    get tint() {
        return this._tint
    }
    set tint(t) {
        this._tint = t, tn(t, this.tintRgb)
    }
    render(t) {
        !this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable || (this.baseTexture || (this.baseTexture = this.children[0]._texture.baseTexture, this.baseTexture.valid || this.baseTexture.once("update", () => this.onChildrenChange(0))), t.batch.setObjectRenderer(t.plugins.particle), t.plugins.particle.render(this))
    }
    onChildrenChange(t) {
        const i = Math.floor(t / this._batchSize);
        for (; this._bufferUpdateIDs.length < i;) this._bufferUpdateIDs.push(0);
        this._bufferUpdateIDs[i] = ++this._updateID
    }
    dispose() {
        if (this._buffers) {
            for (let t = 0; t < this._buffers.length; ++t) this._buffers[t].destroy();
            this._buffers = null
        }
    }
    destroy(t) {
        super.destroy(t), this.dispose(), this._properties = null, this._buffers = null, this._bufferUpdateIDs = null
    }
}
class Pg {
    constructor(t, i, s) {
        this.geometry = new On, this.indexBuffer = null, this.size = s, this.dynamicProperties = [], this.staticProperties = [];
        for (let n = 0; n < t.length; ++n) {
            let r = t[n];
            r = {
                attributeName: r.attributeName,
                size: r.size,
                uploadFunction: r.uploadFunction,
                type: r.type || Rt.FLOAT,
                offset: r.offset
            }, i[n] ? this.dynamicProperties.push(r) : this.staticProperties.push(r)
        }
        this.staticStride = 0, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.dynamicStride = 0, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this._updateID = 0, this.initBuffers()
    }
    initBuffers() {
        const t = this.geometry;
        let i = 0;
        this.indexBuffer = new Ne(S_(this.size), !0, !0), t.addIndex(this.indexBuffer), this.dynamicStride = 0;
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const a = this.dynamicProperties[o];
            a.offset = i, i += a.size, this.dynamicStride += a.size
        }
        const s = new ArrayBuffer(this.size * this.dynamicStride * 4 * 4);
        this.dynamicData = new Float32Array(s), this.dynamicDataUint32 = new Uint32Array(s), this.dynamicBuffer = new Ne(this.dynamicData, !1, !1);
        let n = 0;
        this.staticStride = 0;
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const a = this.staticProperties[o];
            a.offset = n, n += a.size, this.staticStride += a.size
        }
        const r = new ArrayBuffer(this.size * this.staticStride * 4 * 4);
        this.staticData = new Float32Array(r), this.staticDataUint32 = new Uint32Array(r), this.staticBuffer = new Ne(this.staticData, !0, !1);
        for (let o = 0; o < this.dynamicProperties.length; ++o) {
            const a = this.dynamicProperties[o];
            t.addAttribute(a.attributeName, this.dynamicBuffer, 0, a.type === Rt.UNSIGNED_BYTE, a.type, this.dynamicStride * 4, a.offset * 4)
        }
        for (let o = 0; o < this.staticProperties.length; ++o) {
            const a = this.staticProperties[o];
            t.addAttribute(a.attributeName, this.staticBuffer, 0, a.type === Rt.UNSIGNED_BYTE, a.type, this.staticStride * 4, a.offset * 4)
        }
    }
    uploadDynamic(t, i, s) {
        for (let n = 0; n < this.dynamicProperties.length; n++) {
            const r = this.dynamicProperties[n];
            r.uploadFunction(t, i, s, r.type === Rt.UNSIGNED_BYTE ? this.dynamicDataUint32 : this.dynamicData, this.dynamicStride, r.offset)
        }
        this.dynamicBuffer._updateID++
    }
    uploadStatic(t, i, s) {
        for (let n = 0; n < this.staticProperties.length; n++) {
            const r = this.staticProperties[n];
            r.uploadFunction(t, i, s, r.type === Rt.UNSIGNED_BYTE ? this.staticDataUint32 : this.staticData, this.staticStride, r.offset)
        }
        this.staticBuffer._updateID++
    }
    destroy() {
        this.indexBuffer = null, this.dynamicProperties = null, this.dynamicBuffer = null, this.dynamicData = null, this.dynamicDataUint32 = null, this.staticProperties = null, this.staticBuffer = null, this.staticData = null, this.staticDataUint32 = null, this.geometry.destroy()
    }
}
var mM = `varying vec2 vTextureCoord;
varying vec4 vColor;

uniform sampler2D uSampler;

void main(void){
    vec4 color = texture2D(uSampler, vTextureCoord) * vColor;
    gl_FragColor = color;
}`,
    gM = `attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;
attribute vec4 aColor;

attribute vec2 aPositionCoord;
attribute float aRotation;

uniform mat3 translationMatrix;
uniform vec4 uColor;

varying vec2 vTextureCoord;
varying vec4 vColor;

void main(void){
    float x = (aVertexPosition.x) * cos(aRotation) - (aVertexPosition.y) * sin(aRotation);
    float y = (aVertexPosition.x) * sin(aRotation) + (aVertexPosition.y) * cos(aRotation);

    vec2 v = vec2(x, y);
    v = v + aPositionCoord;

    gl_Position = vec4((translationMatrix * vec3(v, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = aTextureCoord;
    vColor = aColor * uColor;
}
`;
class k1 extends dh {
    constructor(t) {
        super(t), this.shader = null, this.properties = null, this.tempMatrix = new pe, this.properties = [{
            attributeName: "aVertexPosition",
            size: 2,
            uploadFunction: this.uploadVertices,
            offset: 0
        }, {
            attributeName: "aPositionCoord",
            size: 2,
            uploadFunction: this.uploadPosition,
            offset: 0
        }, {
            attributeName: "aRotation",
            size: 1,
            uploadFunction: this.uploadRotation,
            offset: 0
        }, {
            attributeName: "aTextureCoord",
            size: 2,
            uploadFunction: this.uploadUvs,
            offset: 0
        }, {
            attributeName: "aColor",
            size: 1,
            type: Rt.UNSIGNED_BYTE,
            uploadFunction: this.uploadTint,
            offset: 0
        }], this.shader = Ls.from(gM, mM, {}), this.state = rn.for2d()
    }
    render(t) {
        const i = t.children,
            s = t._maxSize,
            n = t._batchSize,
            r = this.renderer;
        let o = i.length;
        if (o === 0) return;
        o > s && !t.autoResize && (o = s);
        let a = t._buffers;
        a || (a = t._buffers = this.generateBuffers(t));
        const l = i[0]._texture.baseTexture,
            c = l.alphaMode > 0;
        this.state.blendMode = Ff(t.blendMode, c), r.state.set(this.state);
        const h = r.gl,
            u = t.worldTransform.copyTo(this.tempMatrix);
        u.prepend(r.globalUniforms.uniforms.projectionMatrix), this.shader.uniforms.translationMatrix = u.toArray(!0), this.shader.uniforms.uColor = T_(t.tintRgb, t.worldAlpha, this.shader.uniforms.uColor, c), this.shader.uniforms.uSampler = l, this.renderer.shader.bind(this.shader);
        let d = !1;
        for (let f = 0, p = 0; f < o; f += n, p += 1) {
            let m = o - f;
            m > n && (m = n), p >= a.length && a.push(this._generateOneMoreBuffer(t));
            const g = a[p];
            g.uploadDynamic(i, f, m);
            const y = t._bufferUpdateIDs[p] || 0;
            d = d || g._updateID < y, d && (g._updateID = t._updateID, g.uploadStatic(i, f, m)), r.geometry.bind(g.geometry), h.drawElements(h.TRIANGLES, m * 6, h.UNSIGNED_SHORT, 0)
        }
    }
    generateBuffers(t) {
        const i = [],
            s = t._maxSize,
            n = t._batchSize,
            r = t._properties;
        for (let o = 0; o < s; o += n) i.push(new Pg(this.properties, r, n));
        return i
    }
    _generateOneMoreBuffer(t) {
        const i = t._batchSize,
            s = t._properties;
        return new Pg(this.properties, s, i)
    }
    uploadVertices(t, i, s, n, r, o) {
        let a = 0,
            l = 0,
            c = 0,
            h = 0;
        for (let u = 0; u < s; ++u) {
            const d = t[i + u],
                f = d._texture,
                p = d.scale.x,
                m = d.scale.y,
                g = f.trim,
                y = f.orig;
            g ? (l = g.x - d.anchor.x * y.width, a = l + g.width, h = g.y - d.anchor.y * y.height, c = h + g.height) : (a = y.width * (1 - d.anchor.x), l = y.width * -d.anchor.x, c = y.height * (1 - d.anchor.y), h = y.height * -d.anchor.y), n[o] = l * p, n[o + 1] = h * m, n[o + r] = a * p, n[o + r + 1] = h * m, n[o + r * 2] = a * p, n[o + r * 2 + 1] = c * m, n[o + r * 3] = l * p, n[o + r * 3 + 1] = c * m, o += r * 4
        }
    }
    uploadPosition(t, i, s, n, r, o) {
        for (let a = 0; a < s; a++) {
            const l = t[i + a].position;
            n[o] = l.x, n[o + 1] = l.y, n[o + r] = l.x, n[o + r + 1] = l.y, n[o + r * 2] = l.x, n[o + r * 2 + 1] = l.y, n[o + r * 3] = l.x, n[o + r * 3 + 1] = l.y, o += r * 4
        }
    }
    uploadRotation(t, i, s, n, r, o) {
        for (let a = 0; a < s; a++) {
            const l = t[i + a].rotation;
            n[o] = l, n[o + r] = l, n[o + r * 2] = l, n[o + r * 3] = l, o += r * 4
        }
    }
    uploadUvs(t, i, s, n, r, o) {
        for (let a = 0; a < s; ++a) {
            const l = t[i + a]._texture._uvs;
            l ? (n[o] = l.x0, n[o + 1] = l.y0, n[o + r] = l.x1, n[o + r + 1] = l.y1, n[o + r * 2] = l.x2, n[o + r * 2 + 1] = l.y2, n[o + r * 3] = l.x3, n[o + r * 3 + 1] = l.y3, o += r * 4) : (n[o] = 0, n[o + 1] = 0, n[o + r] = 0, n[o + r + 1] = 0, n[o + r * 2] = 0, n[o + r * 2 + 1] = 0, n[o + r * 3] = 0, n[o + r * 3 + 1] = 0, o += r * 4)
        }
    }
    uploadTint(t, i, s, n, r, o) {
        for (let a = 0; a < s; ++a) {
            const l = t[i + a],
                c = l._texture.baseTexture.alphaMode > 0,
                h = l.alpha,
                u = h < 1 && c ? ch(l._tintRGB, h) : l._tintRGB + (h * 255 << 24);
            n[o] = u, n[o + r] = u, n[o + r * 2] = u, n[o + r * 3] = u, o += r * 4
        }
    }
    destroy() {
        super.destroy(), this.shader && (this.shader.destroy(), this.shader = null), this.tempMatrix = null
    }
}
k1.extension = {
    name: "particle",
    type: lt.RendererPlugin
};
vt.add(k1);
var _h = (e => (e[e.LINEAR_VERTICAL = 0] = "LINEAR_VERTICAL", e[e.LINEAR_HORIZONTAL = 1] = "LINEAR_HORIZONTAL", e))(_h || {});
const Fl = {
        willReadFrequently: !0
    },
    Et = class {
        static get experimentalLetterSpacingSupported() {
            let e = Et._experimentalLetterSpacingSupported;
            if (e !== void 0) {
                const t = ut.ADAPTER.getCanvasRenderingContext2D().prototype;
                e = Et._experimentalLetterSpacingSupported = "letterSpacing" in t || "textLetterSpacing" in t
            }
            return e
        }
        constructor(e, t, i, s, n, r, o, a, l) {
            this.text = e, this.style = t, this.width = i, this.height = s, this.lines = n, this.lineWidths = r, this.lineHeight = o, this.maxLineWidth = a, this.fontProperties = l
        }
        static measureText(e, t, i, s = Et._canvas) {
            i = i ?? t.wordWrap;
            const n = t.toFontString(),
                r = Et.measureFont(n);
            r.fontSize === 0 && (r.fontSize = t.fontSize, r.ascent = t.fontSize);
            const o = s.getContext("2d", Fl);
            o.font = n;
            const l = (i ? Et.wordWrap(e, t, s) : e).split(/(?:\r\n|\r|\n)/),
                c = new Array(l.length);
            let h = 0;
            for (let p = 0; p < l.length; p++) {
                const m = Et._measureText(l[p], t.letterSpacing, o);
                c[p] = m, h = Math.max(h, m)
            }
            let u = h + t.strokeThickness;
            t.dropShadow && (u += t.dropShadowDistance);
            const d = t.lineHeight || r.fontSize + t.strokeThickness;
            let f = Math.max(d, r.fontSize + t.strokeThickness * 2) + (l.length - 1) * (d + t.leading);
            return t.dropShadow && (f += t.dropShadowDistance), new Et(e, t, u, f, l, c, d + t.leading, h, r)
        }
        static _measureText(e, t, i) {
            let s = !1;
            Et.experimentalLetterSpacingSupported && (Et.experimentalLetterSpacing ? (i.letterSpacing = `${t}px`, i.textLetterSpacing = `${t}px`, s = !0) : (i.letterSpacing = "0px", i.textLetterSpacing = "0px"));
            let n = i.measureText(e).width;
            return n > 0 && (s ? n -= t : n += (Et.graphemeSegmenter(e).length - 1) * t), n
        }
        static wordWrap(e, t, i = Et._canvas) {
            const s = i.getContext("2d", Fl);
            let n = 0,
                r = "",
                o = "";
            const a = Object.create(null),
                {
                    letterSpacing: l,
                    whiteSpace: c
                } = t,
                h = Et.collapseSpaces(c),
                u = Et.collapseNewlines(c);
            let d = !h;
            const f = t.wordWrapWidth + l,
                p = Et.tokenize(e);
            for (let m = 0; m < p.length; m++) {
                let g = p[m];
                if (Et.isNewline(g)) {
                    if (!u) {
                        o += Et.addLine(r), d = !h, r = "", n = 0;
                        continue
                    }
                    g = " "
                }
                if (h) {
                    const x = Et.isBreakingSpace(g),
                        v = Et.isBreakingSpace(r[r.length - 1]);
                    if (x && v) continue
                }
                const y = Et.getFromCache(g, l, a, s);
                if (y > f)
                    if (r !== "" && (o += Et.addLine(r), r = "", n = 0), Et.canBreakWords(g, t.breakWords)) {
                        const x = Et.wordWrapSplit(g);
                        for (let v = 0; v < x.length; v++) {
                            let _ = x[v],
                                C = _,
                                k = 1;
                            for (; x[v + k];) {
                                const T = x[v + k];
                                if (!Et.canBreakChars(C, T, g, v, t.breakWords)) _ += T;
                                else break;
                                C = T, k++
                            }
                            v += k - 1;
                            const S = Et.getFromCache(_, l, a, s);
                            S + n > f && (o += Et.addLine(r), d = !1, r = "", n = 0), r += _, n += S
                        }
                    } else {
                        r.length > 0 && (o += Et.addLine(r), r = "", n = 0);
                        const x = m === p.length - 1;
                        o += Et.addLine(g, !x), d = !1, r = "", n = 0
                    }
                else y + n > f && (d = !1, o += Et.addLine(r), r = "", n = 0), (r.length > 0 || !Et.isBreakingSpace(g) || d) && (r += g, n += y)
            }
            return o += Et.addLine(r, !1), o
        }
        static addLine(e, t = !0) {
            return e = Et.trimRight(e), e = t ? `${e}
` : e, e
        }
        static getFromCache(e, t, i, s) {
            let n = i[e];
            return typeof n != "number" && (n = Et._measureText(e, t, s) + t, i[e] = n), n
        }
        static collapseSpaces(e) {
            return e === "normal" || e === "pre-line"
        }
        static collapseNewlines(e) {
            return e === "normal"
        }
        static trimRight(e) {
            if (typeof e != "string") return "";
            for (let t = e.length - 1; t >= 0; t--) {
                const i = e[t];
                if (!Et.isBreakingSpace(i)) break;
                e = e.slice(0, -1)
            }
            return e
        }
        static isNewline(e) {
            return typeof e != "string" ? !1 : Et._newlines.includes(e.charCodeAt(0))
        }
        static isBreakingSpace(e, t) {
            return typeof e != "string" ? !1 : Et._breakingSpaces.includes(e.charCodeAt(0))
        }
        static tokenize(e) {
            const t = [];
            let i = "";
            if (typeof e != "string") return t;
            for (let s = 0; s < e.length; s++) {
                const n = e[s],
                    r = e[s + 1];
                if (Et.isBreakingSpace(n, r) || Et.isNewline(n)) {
                    i !== "" && (t.push(i), i = ""), t.push(n);
                    continue
                }
                i += n
            }
            return i !== "" && t.push(i), t
        }
        static canBreakWords(e, t) {
            return t
        }
        static canBreakChars(e, t, i, s, n) {
            return !0
        }
        static wordWrapSplit(e) {
            return Et.graphemeSegmenter(e)
        }
        static measureFont(e) {
            if (Et._fonts[e]) return Et._fonts[e];
            const t = {
                    ascent: 0,
                    descent: 0,
                    fontSize: 0
                },
                i = Et._canvas,
                s = Et._context;
            s.font = e;
            const n = Et.METRICS_STRING + Et.BASELINE_SYMBOL,
                r = Math.ceil(s.measureText(n).width);
            let o = Math.ceil(s.measureText(Et.BASELINE_SYMBOL).width);
            const a = Math.ceil(Et.HEIGHT_MULTIPLIER * o);
            if (o = o * Et.BASELINE_MULTIPLIER | 0, r === 0 || a === 0) return Et._fonts[e] = t, t;
            i.width = r, i.height = a, s.fillStyle = "#f00", s.fillRect(0, 0, r, a), s.font = e, s.textBaseline = "alphabetic", s.fillStyle = "#000", s.fillText(n, 0, o);
            const l = s.getImageData(0, 0, r, a).data,
                c = l.length,
                h = r * 4;
            let u = 0,
                d = 0,
                f = !1;
            for (u = 0; u < o; ++u) {
                for (let p = 0; p < h; p += 4)
                    if (l[d + p] !== 255) {
                        f = !0;
                        break
                    } if (!f) d += h;
                else break
            }
            for (t.ascent = o - u, d = c - h, f = !1, u = a; u > o; --u) {
                for (let p = 0; p < h; p += 4)
                    if (l[d + p] !== 255) {
                        f = !0;
                        break
                    } if (!f) d -= h;
                else break
            }
            return t.descent = u - o, t.fontSize = t.ascent + t.descent, Et._fonts[e] = t, t
        }
        static clearMetrics(e = "") {
            e ? delete Et._fonts[e] : Et._fonts = {}
        }
        static get _canvas() {
            if (!Et.__canvas) {
                let e;
                try {
                    const t = new OffscreenCanvas(0, 0);
                    if (t.getContext("2d", Fl)?.measureText) return Et.__canvas = t, t;
                    e = ut.ADAPTER.createCanvas()
                } catch {
                    e = ut.ADAPTER.createCanvas()
                }
                e.width = e.height = 10, Et.__canvas = e
            }
            return Et.__canvas
        }
        static get _context() {
            return Et.__context || (Et.__context = Et._canvas.getContext("2d", Fl)), Et.__context
        }
    };
let He = Et;
He.METRICS_STRING = "|\xC9q\xC5";
He.BASELINE_SYMBOL = "M";
He.BASELINE_MULTIPLIER = 1.4;
He.HEIGHT_MULTIPLIER = 2;
He.graphemeSegmenter = (() => {
    if (typeof Intl?.Segmenter == "function") {
        const e = new Intl.Segmenter;
        return t => [...e.segment(t)].map(i => i.segment)
    }
    return e => [...e]
})();
He.experimentalLetterSpacing = !1;
He._fonts = {};
He._newlines = [10, 13];
He._breakingSpaces = [9, 32, 8192, 8193, 8194, 8195, 8196, 8197, 8198, 8200, 8201, 8202, 8287, 12288];
const vM = ["serif", "sans-serif", "monospace", "cursive", "fantasy", "system-ui"],
    va = class {
        constructor(e) {
            this.styleID = 0, this.reset(), fu(this, e, e)
        }
        clone() {
            const e = {};
            return fu(e, this, va.defaultStyle), new va(e)
        }
        reset() {
            fu(this, va.defaultStyle, va.defaultStyle)
        }
        get align() {
            return this._align
        }
        set align(e) {
            this._align !== e && (this._align = e, this.styleID++)
        }
        get breakWords() {
            return this._breakWords
        }
        set breakWords(e) {
            this._breakWords !== e && (this._breakWords = e, this.styleID++)
        }
        get dropShadow() {
            return this._dropShadow
        }
        set dropShadow(e) {
            this._dropShadow !== e && (this._dropShadow = e, this.styleID++)
        }
        get dropShadowAlpha() {
            return this._dropShadowAlpha
        }
        set dropShadowAlpha(e) {
            this._dropShadowAlpha !== e && (this._dropShadowAlpha = e, this.styleID++)
        }
        get dropShadowAngle() {
            return this._dropShadowAngle
        }
        set dropShadowAngle(e) {
            this._dropShadowAngle !== e && (this._dropShadowAngle = e, this.styleID++)
        }
        get dropShadowBlur() {
            return this._dropShadowBlur
        }
        set dropShadowBlur(e) {
            this._dropShadowBlur !== e && (this._dropShadowBlur = e, this.styleID++)
        }
        get dropShadowColor() {
            return this._dropShadowColor
        }
        set dropShadowColor(e) {
            const t = du(e);
            this._dropShadowColor !== t && (this._dropShadowColor = t, this.styleID++)
        }
        get dropShadowDistance() {
            return this._dropShadowDistance
        }
        set dropShadowDistance(e) {
            this._dropShadowDistance !== e && (this._dropShadowDistance = e, this.styleID++)
        }
        get fill() {
            return this._fill
        }
        set fill(e) {
            const t = du(e);
            this._fill !== t && (this._fill = t, this.styleID++)
        }
        get fillGradientType() {
            return this._fillGradientType
        }
        set fillGradientType(e) {
            this._fillGradientType !== e && (this._fillGradientType = e, this.styleID++)
        }
        get fillGradientStops() {
            return this._fillGradientStops
        }
        set fillGradientStops(e) {
            _M(this._fillGradientStops, e) || (this._fillGradientStops = e, this.styleID++)
        }
        get fontFamily() {
            return this._fontFamily
        }
        set fontFamily(e) {
            this.fontFamily !== e && (this._fontFamily = e, this.styleID++)
        }
        get fontSize() {
            return this._fontSize
        }
        set fontSize(e) {
            this._fontSize !== e && (this._fontSize = e, this.styleID++)
        }
        get fontStyle() {
            return this._fontStyle
        }
        set fontStyle(e) {
            this._fontStyle !== e && (this._fontStyle = e, this.styleID++)
        }
        get fontVariant() {
            return this._fontVariant
        }
        set fontVariant(e) {
            this._fontVariant !== e && (this._fontVariant = e, this.styleID++)
        }
        get fontWeight() {
            return this._fontWeight
        }
        set fontWeight(e) {
            this._fontWeight !== e && (this._fontWeight = e, this.styleID++)
        }
        get letterSpacing() {
            return this._letterSpacing
        }
        set letterSpacing(e) {
            this._letterSpacing !== e && (this._letterSpacing = e, this.styleID++)
        }
        get lineHeight() {
            return this._lineHeight
        }
        set lineHeight(e) {
            this._lineHeight !== e && (this._lineHeight = e, this.styleID++)
        }
        get leading() {
            return this._leading
        }
        set leading(e) {
            this._leading !== e && (this._leading = e, this.styleID++)
        }
        get lineJoin() {
            return this._lineJoin
        }
        set lineJoin(e) {
            this._lineJoin !== e && (this._lineJoin = e, this.styleID++)
        }
        get miterLimit() {
            return this._miterLimit
        }
        set miterLimit(e) {
            this._miterLimit !== e && (this._miterLimit = e, this.styleID++)
        }
        get padding() {
            return this._padding
        }
        set padding(e) {
            this._padding !== e && (this._padding = e, this.styleID++)
        }
        get stroke() {
            return this._stroke
        }
        set stroke(e) {
            const t = du(e);
            this._stroke !== t && (this._stroke = t, this.styleID++)
        }
        get strokeThickness() {
            return this._strokeThickness
        }
        set strokeThickness(e) {
            this._strokeThickness !== e && (this._strokeThickness = e, this.styleID++)
        }
        get textBaseline() {
            return this._textBaseline
        }
        set textBaseline(e) {
            this._textBaseline !== e && (this._textBaseline = e, this.styleID++)
        }
        get trim() {
            return this._trim
        }
        set trim(e) {
            this._trim !== e && (this._trim = e, this.styleID++)
        }
        get whiteSpace() {
            return this._whiteSpace
        }
        set whiteSpace(e) {
            this._whiteSpace !== e && (this._whiteSpace = e, this.styleID++)
        }
        get wordWrap() {
            return this._wordWrap
        }
        set wordWrap(e) {
            this._wordWrap !== e && (this._wordWrap = e, this.styleID++)
        }
        get wordWrapWidth() {
            return this._wordWrapWidth
        }
        set wordWrapWidth(e) {
            this._wordWrapWidth !== e && (this._wordWrapWidth = e, this.styleID++)
        }
        toFontString() {
            const e = typeof this.fontSize == "number" ? `${this.fontSize}px` : this.fontSize;
            let t = this.fontFamily;
            Array.isArray(this.fontFamily) || (t = this.fontFamily.split(","));
            for (let i = t.length - 1; i >= 0; i--) {
                let s = t[i].trim();
                !/([\"\'])[^\'\"]+\1/.test(s) && !vM.includes(s) && (s = `"${s}"`), t[i] = s
            }
            return `${this.fontStyle} ${this.fontVariant} ${this.fontWeight} ${e} ${t.join(",")}`
        }
    };
let ki = va;
ki.defaultStyle = {
    align: "left",
    breakWords: !1,
    dropShadow: !1,
    dropShadowAlpha: 1,
    dropShadowAngle: Math.PI / 6,
    dropShadowBlur: 0,
    dropShadowColor: "black",
    dropShadowDistance: 5,
    fill: "black",
    fillGradientType: _h.LINEAR_VERTICAL,
    fillGradientStops: [],
    fontFamily: "Arial",
    fontSize: 26,
    fontStyle: "normal",
    fontVariant: "normal",
    fontWeight: "normal",
    leading: 0,
    letterSpacing: 0,
    lineHeight: 0,
    lineJoin: "miter",
    miterLimit: 10,
    padding: 0,
    stroke: "black",
    strokeThickness: 0,
    textBaseline: "alphabetic",
    trim: !1,
    whiteSpace: "pre",
    wordWrap: !1,
    wordWrapWidth: 100
};

function Lg(e) {
    return typeof e == "number" ? ah(e) : (typeof e == "string" && e.startsWith("0x") && (e = e.replace("0x", "#")), e)
}

function du(e) {
    if (Array.isArray(e)) {
        for (let t = 0; t < e.length; ++t) e[t] = Lg(e[t]);
        return e
    } else return Lg(e)
}

function _M(e, t) {
    if (!Array.isArray(e) || !Array.isArray(t) || e.length !== t.length) return !1;
    for (let i = 0; i < e.length; ++i)
        if (e[i] !== t[i]) return !1;
    return !0
}

function fu(e, t, i) {
    for (const s in i) Array.isArray(t[s]) ? e[s] = t[s].slice() : e[s] = t[s]
}
const yM = {
        texture: !0,
        children: !1,
        baseTexture: !0
    },
    Ed = class extends hi {
        constructor(e, t, i) {
            let s = !1;
            i || (i = ut.ADAPTER.createCanvas(), s = !0), i.width = 3, i.height = 3;
            const n = ht.from(i);
            n.orig = new qt, n.trim = new qt, super(n), this._ownCanvas = s, this.canvas = i, this.context = i.getContext("2d", {
                willReadFrequently: !0
            }), this._resolution = Ed.defaultResolution ?? ut.RESOLUTION, this._autoResolution = Ed.defaultAutoResolution, this._text = null, this._style = null, this._styleListener = null, this._font = "", this.text = e, this.style = t, this.localStyleID = -1
        }
        static get experimentalLetterSpacing() {
            return He.experimentalLetterSpacing
        }
        static set experimentalLetterSpacing(e) {
            Qt("7.1.0", "Text.experimentalLetterSpacing is deprecated, use TextMetrics.experimentalLetterSpacing"), He.experimentalLetterSpacing = e
        }
        updateText(e) {
            const t = this._style;
            if (this.localStyleID !== t.styleID && (this.dirty = !0, this.localStyleID = t.styleID), !this.dirty && e) return;
            this._font = this._style.toFontString();
            const i = this.context,
                s = He.measureText(this._text || " ", this._style, this._style.wordWrap, this.canvas),
                n = s.width,
                r = s.height,
                o = s.lines,
                a = s.lineHeight,
                l = s.lineWidths,
                c = s.maxLineWidth,
                h = s.fontProperties;
            this.canvas.width = Math.ceil(Math.ceil(Math.max(1, n) + t.padding * 2) * this._resolution), this.canvas.height = Math.ceil(Math.ceil(Math.max(1, r) + t.padding * 2) * this._resolution), i.scale(this._resolution, this._resolution), i.clearRect(0, 0, this.canvas.width, this.canvas.height), i.font = this._font, i.lineWidth = t.strokeThickness, i.textBaseline = t.textBaseline, i.lineJoin = t.lineJoin, i.miterLimit = t.miterLimit;
            let u, d;
            const f = t.dropShadow ? 2 : 1;
            for (let p = 0; p < f; ++p) {
                const m = t.dropShadow && p === 0,
                    g = m ? Math.ceil(Math.max(1, r) + t.padding * 2) : 0,
                    y = g * this._resolution;
                if (m) {
                    i.fillStyle = "black", i.strokeStyle = "black";
                    const v = t.dropShadowColor,
                        _ = tn(typeof v == "number" ? v : lh(v)),
                        C = t.dropShadowBlur * this._resolution,
                        k = t.dropShadowDistance * this._resolution;
                    i.shadowColor = `rgba(${_[0]*255},${_[1]*255},${_[2]*255},${t.dropShadowAlpha})`, i.shadowBlur = C, i.shadowOffsetX = Math.cos(t.dropShadowAngle) * k, i.shadowOffsetY = Math.sin(t.dropShadowAngle) * k + y
                } else i.fillStyle = this._generateFillStyle(t, o, s), i.strokeStyle = t.stroke, i.shadowColor = "black", i.shadowBlur = 0, i.shadowOffsetX = 0, i.shadowOffsetY = 0;
                let x = (a - h.fontSize) / 2;
                a - h.fontSize < 0 && (x = 0);
                for (let v = 0; v < o.length; v++) u = t.strokeThickness / 2, d = t.strokeThickness / 2 + v * a + h.ascent + x, t.align === "right" ? u += c - l[v] : t.align === "center" && (u += (c - l[v]) / 2), t.stroke && t.strokeThickness && this.drawLetterSpacing(o[v], u + t.padding, d + t.padding - g, !0), t.fill && this.drawLetterSpacing(o[v], u + t.padding, d + t.padding - g)
            }
            this.updateTexture()
        }
        drawLetterSpacing(e, t, i, s = !1) {
            const r = this._style.letterSpacing;
            let o = !1;
            if (He.experimentalLetterSpacingSupported && (He.experimentalLetterSpacing ? (this.context.letterSpacing = `${r}px`, this.context.textLetterSpacing = `${r}px`, o = !0) : (this.context.letterSpacing = "0px", this.context.textLetterSpacing = "0px")), r === 0 || o) {
                s ? this.context.strokeText(e, t, i) : this.context.fillText(e, t, i);
                return
            }
            let a = t;
            const l = He.graphemeSegmenter(e);
            let c = this.context.measureText(e).width,
                h = 0;
            for (let u = 0; u < l.length; ++u) {
                const d = l[u];
                s ? this.context.strokeText(d, a, i) : this.context.fillText(d, a, i);
                let f = "";
                for (let p = u + 1; p < l.length; ++p) f += l[p];
                h = this.context.measureText(f).width, a += c - h + r, c = h
            }
        }
        updateTexture() {
            const e = this.canvas;
            if (this._style.trim) {
                const r = I_(e);
                r.data && (e.width = r.width, e.height = r.height, this.context.putImageData(r.data, 0, 0))
            }
            const t = this._texture,
                i = this._style,
                s = i.trim ? 0 : i.padding,
                n = t.baseTexture;
            t.trim.width = t._frame.width = e.width / this._resolution, t.trim.height = t._frame.height = e.height / this._resolution, t.trim.x = -s, t.trim.y = -s, t.orig.width = t._frame.width - s * 2, t.orig.height = t._frame.height - s * 2, this._onTextureUpdate(), n.setRealSize(e.width, e.height, this._resolution), t.updateUvs(), this.dirty = !1
        }
        _render(e) {
            this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0), this.updateText(!0), super._render(e)
        }
        updateTransform() {
            this.updateText(!0), super.updateTransform()
        }
        getBounds(e, t) {
            return this.updateText(!0), this._textureID === -1 && (e = !1), super.getBounds(e, t)
        }
        getLocalBounds(e) {
            return this.updateText(!0), super.getLocalBounds.call(this, e)
        }
        _calculateBounds() {
            this.calculateVertices(), this._bounds.addQuad(this.vertexData)
        }
        _generateFillStyle(e, t, i) {
            const s = e.fill;
            if (Array.isArray(s)) {
                if (s.length === 1) return s[0]
            } else return s;
            let n;
            const r = e.dropShadow ? e.dropShadowDistance : 0,
                o = e.padding || 0,
                a = this.canvas.width / this._resolution - r - o * 2,
                l = this.canvas.height / this._resolution - r - o * 2,
                c = s.slice(),
                h = e.fillGradientStops.slice();
            if (!h.length) {
                const u = c.length + 1;
                for (let d = 1; d < u; ++d) h.push(d / u)
            }
            if (c.unshift(s[0]), h.unshift(0), c.push(s[s.length - 1]), h.push(1), e.fillGradientType === _h.LINEAR_VERTICAL) {
                n = this.context.createLinearGradient(a / 2, o, a / 2, l + o);
                const u = i.fontProperties.fontSize + e.strokeThickness;
                for (let d = 0; d < t.length; d++) {
                    const f = i.lineHeight * (d - 1) + u,
                        p = i.lineHeight * d;
                    let m = p;
                    d > 0 && f > p && (m = (p + f) / 2);
                    const g = p + u,
                        y = i.lineHeight * (d + 1);
                    let x = g;
                    d + 1 < t.length && y < g && (x = (g + y) / 2);
                    const v = (x - m) / l;
                    for (let _ = 0; _ < c.length; _++) {
                        let C = 0;
                        typeof h[_] == "number" ? C = h[_] : C = _ / c.length;
                        let k = Math.min(1, Math.max(0, m / l + C * v));
                        k = Number(k.toFixed(5)), n.addColorStop(k, c[_])
                    }
                }
            } else {
                n = this.context.createLinearGradient(o, l / 2, a + o, l / 2);
                const u = c.length + 1;
                let d = 1;
                for (let f = 0; f < c.length; f++) {
                    let p;
                    typeof h[f] == "number" ? p = h[f] : p = d / u, n.addColorStop(p, c[f]), d++
                }
            }
            return n
        }
        destroy(e) {
            typeof e == "boolean" && (e = {
                children: e
            }), e = Object.assign({}, yM, e), super.destroy(e), this._ownCanvas && (this.canvas.height = this.canvas.width = 0), this.context = null, this.canvas = null, this._style = null
        }
        get width() {
            return this.updateText(!0), Math.abs(this.scale.x) * this._texture.orig.width
        }
        set width(e) {
            this.updateText(!0);
            const t = rr(this.scale.x) || 1;
            this.scale.x = t * e / this._texture.orig.width, this._width = e
        }
        get height() {
            return this.updateText(!0), Math.abs(this.scale.y) * this._texture.orig.height
        }
        set height(e) {
            this.updateText(!0);
            const t = rr(this.scale.y) || 1;
            this.scale.y = t * e / this._texture.orig.height, this._height = e
        }
        get style() {
            return this._style
        }
        set style(e) {
            e = e || {}, e instanceof ki ? this._style = e : this._style = new ki(e), this.localStyleID = -1, this.dirty = !0
        }
        get text() {
            return this._text
        }
        set text(e) {
            e = String(e ?? ""), this._text !== e && (this._text = e, this.dirty = !0)
        }
        get resolution() {
            return this._resolution
        }
        set resolution(e) {
            this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0)
        }
    };
let ys = Ed;
ys.defaultAutoResolution = !0;
class bM {
    constructor(t) {
        this.maxItemsPerFrame = t, this.itemsLeft = 0
    }
    beginFrame() {
        this.itemsLeft = this.maxItemsPerFrame
    }
    allowedToUpload() {
        return this.itemsLeft-- > 0
    }
}

function xM(e, t) {
    let i = !1;
    if (e?._textures?.length) {
        for (let s = 0; s < e._textures.length; s++)
            if (e._textures[s] instanceof ht) {
                const n = e._textures[s].baseTexture;
                t.includes(n) || (t.push(n), i = !0)
            }
    }
    return i
}

function wM(e, t) {
    if (e.baseTexture instanceof Nt) {
        const i = e.baseTexture;
        return t.includes(i) || t.push(i), !0
    }
    return !1
}

function TM(e, t) {
    if (e._texture && e._texture instanceof ht) {
        const i = e._texture.baseTexture;
        return t.includes(i) || t.push(i), !0
    }
    return !1
}

function EM(e, t) {
    return t instanceof ys ? (t.updateText(!0), !0) : !1
}

function SM(e, t) {
    if (t instanceof ki) {
        const i = t.toFontString();
        return He.measureFont(i), !0
    }
    return !1
}

function CM(e, t) {
    if (e instanceof ys) {
        t.includes(e.style) || t.push(e.style), t.includes(e) || t.push(e);
        const i = e._texture.baseTexture;
        return t.includes(i) || t.push(i), !0
    }
    return !1
}

function AM(e, t) {
    return e instanceof ki ? (t.includes(e) || t.push(e), !0) : !1
}
const P1 = class {
    constructor(e) {
        this.limiter = new bM(P1.uploadsPerFrame), this.renderer = e, this.uploadHookHelper = null, this.queue = [], this.addHooks = [], this.uploadHooks = [], this.completes = [], this.ticking = !1, this.delayedTick = () => {
            !this.queue || this.prepareItems()
        }, this.registerFindHook(CM), this.registerFindHook(AM), this.registerFindHook(xM), this.registerFindHook(wM), this.registerFindHook(TM), this.registerUploadHook(EM), this.registerUploadHook(SM)
    }
    upload(e) {
        return new Promise(t => {
            e && this.add(e), this.queue.length ? (this.completes.push(t), this.ticking || (this.ticking = !0, gi.system.addOnce(this.tick, this, Lo.UTILITY))) : t()
        })
    }
    tick() {
        setTimeout(this.delayedTick, 0)
    }
    prepareItems() {
        for (this.limiter.beginFrame(); this.queue.length && this.limiter.allowedToUpload();) {
            const e = this.queue[0];
            let t = !1;
            if (e && !e._destroyed) {
                for (let i = 0, s = this.uploadHooks.length; i < s; i++)
                    if (this.uploadHooks[i](this.uploadHookHelper, e)) {
                        this.queue.shift(), t = !0;
                        break
                    }
            }
            t || this.queue.shift()
        }
        if (this.queue.length) gi.system.addOnce(this.tick, this, Lo.UTILITY);
        else {
            this.ticking = !1;
            const e = this.completes.slice(0);
            this.completes.length = 0;
            for (let t = 0, i = e.length; t < i; t++) e[t]()
        }
    }
    registerFindHook(e) {
        return e && this.addHooks.push(e), this
    }
    registerUploadHook(e) {
        return e && this.uploadHooks.push(e), this
    }
    add(e) {
        for (let t = 0, i = this.addHooks.length; t < i && !this.addHooks[t](e, this.queue); t++);
        if (e instanceof ae)
            for (let t = e.children.length - 1; t >= 0; t--) this.add(e.children[t]);
        return this
    }
    destroy() {
        this.ticking && gi.system.remove(this.tick, this), this.ticking = !1, this.addHooks = null, this.uploadHooks = null, this.renderer = null, this.completes = null, this.queue = null, this.limiter = null, this.uploadHookHelper = null
    }
};
let Va = P1;
Va.uploadsPerFrame = 4;
Object.defineProperties(ut, {
    UPLOADS_PER_FRAME: {
        get() {
            return Va.uploadsPerFrame
        },
        set(e) {
            Qt("7.1.0", "settings.UPLOADS_PER_FRAME is deprecated, use prepare.BasePrepare.uploadsPerFrame"), Va.uploadsPerFrame = e
        }
    }
});

function L1(e, t) {
    return t instanceof Nt ? (t._glTextures[e.CONTEXT_UID] || e.texture.bind(t), !0) : !1
}

function IM(e, t) {
    if (!(t instanceof ke)) return !1;
    const {
        geometry: i
    } = t;
    t.finishPoly(), i.updateBatches();
    const {
        batches: s
    } = i;
    for (let n = 0; n < s.length; n++) {
        const {
            texture: r
        } = s[n].style;
        r && L1(e, r.baseTexture)
    }
    return i.batchable || e.geometry.bind(i, t._resolveDirectShader(e)), !0
}

function MM(e, t) {
    return e instanceof ke ? (t.push(e), !0) : !1
}
class O1 extends Va {
    constructor(t) {
        super(t), this.uploadHookHelper = this.renderer, this.registerFindHook(MM), this.registerUploadHook(L1), this.registerUploadHook(IM)
    }
}
O1.extension = {
    name: "prepare",
    type: lt.RendererSystem
};
vt.add(O1);
const sa = new Zt;
class Yf extends hi {
    constructor(t, i = 100, s = 100) {
        super(t), this.tileTransform = new uh, this._width = i, this._height = s, this.uvMatrix = this.texture.uvMatrix || new zf(t), this.pluginName = "tilingSprite", this.uvRespectAnchor = !1
    }
    get clampMargin() {
        return this.uvMatrix.clampMargin
    }
    set clampMargin(t) {
        this.uvMatrix.clampMargin = t, this.uvMatrix.update(!0)
    }
    get tileScale() {
        return this.tileTransform.scale
    }
    set tileScale(t) {
        this.tileTransform.scale.copyFrom(t)
    }
    get tilePosition() {
        return this.tileTransform.position
    }
    set tilePosition(t) {
        this.tileTransform.position.copyFrom(t)
    }
    _onTextureUpdate() {
        this.uvMatrix && (this.uvMatrix.texture = this._texture), this._cachedTint = 16777215
    }
    _render(t) {
        const i = this._texture;
        !i || !i.valid || (this.tileTransform.updateLocalTransform(), this.uvMatrix.update(), t.batch.setObjectRenderer(t.plugins[this.pluginName]), t.plugins[this.pluginName].render(this))
    }
    _calculateBounds() {
        const t = this._width * -this._anchor._x,
            i = this._height * -this._anchor._y,
            s = this._width * (1 - this._anchor._x),
            n = this._height * (1 - this._anchor._y);
        this._bounds.addFrame(this.transform, t, i, s, n)
    }
    getLocalBounds(t) {
        return this.children.length === 0 ? (this._bounds.minX = this._width * -this._anchor._x, this._bounds.minY = this._height * -this._anchor._y, this._bounds.maxX = this._width * (1 - this._anchor._x), this._bounds.maxY = this._height * (1 - this._anchor._y), t || (this._localBoundsRect || (this._localBoundsRect = new qt), t = this._localBoundsRect), this._bounds.getRectangle(t)) : super.getLocalBounds.call(this, t)
    }
    containsPoint(t) {
        this.worldTransform.applyInverse(t, sa);
        const i = this._width,
            s = this._height,
            n = -i * this.anchor._x;
        if (sa.x >= n && sa.x < n + i) {
            const r = -s * this.anchor._y;
            if (sa.y >= r && sa.y < r + s) return !0
        }
        return !1
    }
    destroy(t) {
        super.destroy(t), this.tileTransform = null, this.uvMatrix = null
    }
    static from(t, i) {
        const s = t instanceof ht ? t : ht.from(t, i);
        return new Yf(s, i.width, i.height)
    }
    get width() {
        return this._width
    }
    set width(t) {
        this._width = t
    }
    get height() {
        return this._height
    }
    set height(t) {
        this._height = t
    }
}
var RM = `#version 300 es
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

in vec2 vTextureCoord;

out vec4 fragmentColor;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    vec4 texSample = texture(uSampler, coord, unclamped == coord ? 0.0f : -32.0f);// lod-bias very negative to force lod 0

    fragmentColor = texSample * uColor;
}
`,
    kM = `#version 300 es
#define SHADER_NAME Tiling-Sprite-300

precision lowp float;

in vec2 aVertexPosition;
in vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

out vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
    PM = `#version 100
#ifdef GL_EXT_shader_texture_lod
    #extension GL_EXT_shader_texture_lod : enable
#endif
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;
uniform mat3 uMapCoord;
uniform vec4 uClampFrame;
uniform vec2 uClampOffset;

void main(void)
{
    vec2 coord = vTextureCoord + ceil(uClampOffset - vTextureCoord);
    coord = (uMapCoord * vec3(coord, 1.0)).xy;
    vec2 unclamped = coord;
    coord = clamp(coord, uClampFrame.xy, uClampFrame.zw);

    #ifdef GL_EXT_shader_texture_lod
        vec4 texSample = unclamped == coord
            ? texture2D(uSampler, coord) 
            : texture2DLodEXT(uSampler, coord, 0);
    #else
        vec4 texSample = texture2D(uSampler, coord);
    #endif

    gl_FragColor = texSample * uColor;
}
`,
    Og = `#version 100
#define SHADER_NAME Tiling-Sprite-100

precision lowp float;

attribute vec2 aVertexPosition;
attribute vec2 aTextureCoord;

uniform mat3 projectionMatrix;
uniform mat3 translationMatrix;
uniform mat3 uTransform;

varying vec2 vTextureCoord;

void main(void)
{
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);

    vTextureCoord = (uTransform * vec3(aTextureCoord, 1.0)).xy;
}
`,
    LM = `#version 100
#define SHADER_NAME Tiling-Sprite-Simple-100

precision lowp float;

varying vec2 vTextureCoord;

uniform sampler2D uSampler;
uniform vec4 uColor;

void main(void)
{
    vec4 texSample = texture2D(uSampler, vTextureCoord);
    gl_FragColor = texSample * uColor;
}
`;
const Bl = new pe;
class D1 extends dh {
    constructor(t) {
        super(t), t.runners.contextChange.add(this), this.quad = new $_, this.state = rn.for2d()
    }
    contextChange() {
        const t = this.renderer,
            i = {
                globals: t.globalUniforms
            };
        this.simpleShader = Ls.from(Og, LM, i), this.shader = t.context.webGLVersion > 1 ? Ls.from(kM, RM, i) : Ls.from(Og, PM, i)
    }
    render(t) {
        const i = this.renderer,
            s = this.quad;
        let n = s.vertices;
        n[0] = n[6] = t._width * -t.anchor.x, n[1] = n[3] = t._height * -t.anchor.y, n[2] = n[4] = t._width * (1 - t.anchor.x), n[5] = n[7] = t._height * (1 - t.anchor.y);
        const r = t.uvRespectAnchor ? t.anchor.x : 0,
            o = t.uvRespectAnchor ? t.anchor.y : 0;
        n = s.uvs, n[0] = n[6] = -r, n[1] = n[3] = -o, n[2] = n[4] = 1 - r, n[5] = n[7] = 1 - o, s.invalidate();
        const a = t._texture,
            l = a.baseTexture,
            c = l.alphaMode > 0,
            h = t.tileTransform.localTransform,
            u = t.uvMatrix;
        let d = l.isPowerOfTwo && a.frame.width === l.width && a.frame.height === l.height;
        d && (l._glTextures[i.CONTEXT_UID] ? d = l.wrapMode !== Zs.CLAMP : l.wrapMode === Zs.CLAMP && (l.wrapMode = Zs.REPEAT));
        const f = d ? this.simpleShader : this.shader,
            p = a.width,
            m = a.height,
            g = t._width,
            y = t._height;
        Bl.set(h.a * p / g, h.b * p / y, h.c * m / g, h.d * m / y, h.tx / g, h.ty / y), Bl.invert(), d ? Bl.prepend(u.mapCoord) : (f.uniforms.uMapCoord = u.mapCoord.toArray(!0), f.uniforms.uClampFrame = u.uClampFrame, f.uniforms.uClampOffset = u.uClampOffset), f.uniforms.uTransform = Bl.toArray(!0), f.uniforms.uColor = Bf(t.tint, t.worldAlpha, f.uniforms.uColor, c), f.uniforms.translationMatrix = t.transform.worldTransform.toArray(!0), f.uniforms.uSampler = a, i.shader.bind(f), i.geometry.bind(s), this.state.blendMode = Ff(t.blendMode, c), i.state.set(this.state), i.geometry.draw(this.renderer.gl.TRIANGLES, 6, 0)
    }
}
D1.extension = {
    name: "tilingSprite",
    type: lt.RendererPlugin
};
vt.add(D1);
const _a = class {
    constructor(e, t, i = null) {
        this.linkedSheets = [], this._texture = e instanceof ht ? e : null, this.baseTexture = e instanceof Nt ? e : this._texture.baseTexture, this.textures = {}, this.animations = {}, this.data = t;
        const s = this.baseTexture.resource;
        this.resolution = this._updateResolution(i || (s ? s.url : null)), this._frames = this.data.frames, this._frameKeys = Object.keys(this._frames), this._batchIndex = 0, this._callback = null
    }
    _updateResolution(e = null) {
        const {
            scale: t
        } = this.data.meta;
        let i = en(e, null);
        return i === null && (i = parseFloat(t ?? "1")), i !== 1 && this.baseTexture.setResolution(i), i
    }
    parse() {
        return new Promise(e => {
            this._callback = e, this._batchIndex = 0, this._frameKeys.length <= _a.BATCH_SIZE ? (this._processFrames(0), this._processAnimations(), this._parseComplete()) : this._nextBatch()
        })
    }
    _processFrames(e) {
        let t = e;
        const i = _a.BATCH_SIZE;
        for (; t - e < i && t < this._frameKeys.length;) {
            const s = this._frameKeys[t],
                n = this._frames[s],
                r = n.frame;
            if (r) {
                let o = null,
                    a = null;
                const l = n.trimmed !== !1 && n.sourceSize ? n.sourceSize : n.frame,
                    c = new qt(0, 0, Math.floor(l.w) / this.resolution, Math.floor(l.h) / this.resolution);
                n.rotated ? o = new qt(Math.floor(r.x) / this.resolution, Math.floor(r.y) / this.resolution, Math.floor(r.h) / this.resolution, Math.floor(r.w) / this.resolution) : o = new qt(Math.floor(r.x) / this.resolution, Math.floor(r.y) / this.resolution, Math.floor(r.w) / this.resolution, Math.floor(r.h) / this.resolution), n.trimmed !== !1 && n.spriteSourceSize && (a = new qt(Math.floor(n.spriteSourceSize.x) / this.resolution, Math.floor(n.spriteSourceSize.y) / this.resolution, Math.floor(r.w) / this.resolution, Math.floor(r.h) / this.resolution)), this.textures[s] = new ht(this.baseTexture, o, c, a, n.rotated ? 2 : 0, n.anchor), ht.addToCache(this.textures[s], s)
            }
            t++
        }
    }
    _processAnimations() {
        const e = this.data.animations || {};
        for (const t in e) {
            this.animations[t] = [];
            for (let i = 0; i < e[t].length; i++) {
                const s = e[t][i];
                this.animations[t].push(this.textures[s])
            }
        }
    }
    _parseComplete() {
        const e = this._callback;
        this._callback = null, this._batchIndex = 0, e.call(this, this.textures)
    }
    _nextBatch() {
        this._processFrames(this._batchIndex * _a.BATCH_SIZE), this._batchIndex++, setTimeout(() => {
            this._batchIndex * _a.BATCH_SIZE < this._frameKeys.length ? this._nextBatch() : (this._processAnimations(), this._parseComplete())
        }, 0)
    }
    destroy(e = !1) {
        for (const t in this.textures) this.textures[t].destroy();
        this._frames = null, this._frameKeys = null, this.data = null, this.textures = null, e && (this._texture?.destroy(), this.baseTexture.destroy()), this._texture = null, this.baseTexture = null, this.linkedSheets = []
    }
};
let Sd = _a;
Sd.BATCH_SIZE = 1e3;
const OM = ["jpg", "png", "jpeg", "avif", "webp"];

function N1(e, t, i) {
    const s = {};
    if (e.forEach(n => {
            s[n] = t
        }), Object.keys(t.textures).forEach(n => {
            s[n] = t.textures[n]
        }), !i) {
        const n = Xe.dirname(e[0]);
        t.linkedSheets.forEach((r, o) => {
            const a = N1([`${n}/${t.data.meta.related_multi_packs[o]}`], r, !0);
            Object.assign(s, a)
        })
    }
    return s
}
const DM = {
    extension: lt.Asset,
    cache: {
        test: e => e instanceof Sd,
        getCacheableAssets: (e, t) => N1(e, t, !1)
    },
    resolver: {
        test: e => {
            const i = e.split("?")[0].split("."),
                s = i.pop(),
                n = i.pop();
            return s === "json" && OM.includes(n)
        },
        parse: e => {
            const t = e.split(".");
            return {
                resolution: parseFloat(ut.RETINA_PREFIX.exec(e)?.[1] ?? "1"),
                format: t[t.length - 2],
                src: e
            }
        }
    },
    loader: {
        extension: {
            type: lt.LoadParser,
            priority: Us.Normal
        },
        async testParse(e, t) {
            return Xe.extname(t.src).toLowerCase() === ".json" && !!e.frames
        },
        async parse(e, t, i) {
            let s = Xe.dirname(t.src);
            s && s.lastIndexOf("/") !== s.length - 1 && (s += "/");
            const n = s + e.meta.image,
                o = (await i.load([n]))[n],
                a = new Sd(o.baseTexture, e, t.src);
            await a.parse();
            const l = e?.meta?.related_multi_packs;
            if (Array.isArray(l)) {
                const c = [];
                for (const u of l) {
                    if (typeof u != "string") continue;
                    const d = s + u;
                    t.data?.ignoreMultiPack || c.push(i.load({
                        src: d,
                        data: {
                            ignoreMultiPack: !0
                        }
                    }))
                }
                const h = await Promise.all(c);
                a.linkedSheets = h, h.forEach(u => {
                    u.linkedSheets = [a].concat(a.linkedSheets.filter(d => d !== u))
                })
            }
            return a
        },
        unload(e) {
            e.destroy(!0)
        }
    }
};
vt.add(DM);
class Rc {
    constructor() {
        this.info = [], this.common = [], this.page = [], this.char = [], this.kerning = [], this.distanceField = []
    }
}
class ec {
    static test(t) {
        return typeof t == "string" && t.startsWith("info face=")
    }
    static parse(t) {
        const i = t.match(/^[a-z]+\s+.+$/gm),
            s = {
                info: [],
                common: [],
                page: [],
                char: [],
                chars: [],
                kerning: [],
                kernings: [],
                distanceField: []
            };
        for (const r in i) {
            const o = i[r].match(/^[a-z]+/gm)[0],
                a = i[r].match(/[a-zA-Z]+=([^\s"']+|"([^"]*)")/gm),
                l = {};
            for (const c in a) {
                const h = a[c].split("="),
                    u = h[0],
                    d = h[1].replace(/"/gm, ""),
                    f = parseFloat(d),
                    p = isNaN(f) ? d : f;
                l[u] = p
            }
            s[o].push(l)
        }
        const n = new Rc;
        return s.info.forEach(r => n.info.push({
            face: r.face,
            size: parseInt(r.size, 10)
        })), s.common.forEach(r => n.common.push({
            lineHeight: parseInt(r.lineHeight, 10)
        })), s.page.forEach(r => n.page.push({
            id: parseInt(r.id, 10),
            file: r.file
        })), s.char.forEach(r => n.char.push({
            id: parseInt(r.id, 10),
            page: parseInt(r.page, 10),
            x: parseInt(r.x, 10),
            y: parseInt(r.y, 10),
            width: parseInt(r.width, 10),
            height: parseInt(r.height, 10),
            xoffset: parseInt(r.xoffset, 10),
            yoffset: parseInt(r.yoffset, 10),
            xadvance: parseInt(r.xadvance, 10)
        })), s.kerning.forEach(r => n.kerning.push({
            first: parseInt(r.first, 10),
            second: parseInt(r.second, 10),
            amount: parseInt(r.amount, 10)
        })), s.distanceField.forEach(r => n.distanceField.push({
            distanceRange: parseInt(r.distanceRange, 10),
            fieldType: r.fieldType
        })), n
    }
}
class Cd {
    static test(t) {
        const i = t;
        return "getElementsByTagName" in i && i.getElementsByTagName("page").length && i.getElementsByTagName("info")[0].getAttribute("face") !== null
    }
    static parse(t) {
        const i = new Rc,
            s = t.getElementsByTagName("info"),
            n = t.getElementsByTagName("common"),
            r = t.getElementsByTagName("page"),
            o = t.getElementsByTagName("char"),
            a = t.getElementsByTagName("kerning"),
            l = t.getElementsByTagName("distanceField");
        for (let c = 0; c < s.length; c++) i.info.push({
            face: s[c].getAttribute("face"),
            size: parseInt(s[c].getAttribute("size"), 10)
        });
        for (let c = 0; c < n.length; c++) i.common.push({
            lineHeight: parseInt(n[c].getAttribute("lineHeight"), 10)
        });
        for (let c = 0; c < r.length; c++) i.page.push({
            id: parseInt(r[c].getAttribute("id"), 10) || 0,
            file: r[c].getAttribute("file")
        });
        for (let c = 0; c < o.length; c++) {
            const h = o[c];
            i.char.push({
                id: parseInt(h.getAttribute("id"), 10),
                page: parseInt(h.getAttribute("page"), 10) || 0,
                x: parseInt(h.getAttribute("x"), 10),
                y: parseInt(h.getAttribute("y"), 10),
                width: parseInt(h.getAttribute("width"), 10),
                height: parseInt(h.getAttribute("height"), 10),
                xoffset: parseInt(h.getAttribute("xoffset"), 10),
                yoffset: parseInt(h.getAttribute("yoffset"), 10),
                xadvance: parseInt(h.getAttribute("xadvance"), 10)
            })
        }
        for (let c = 0; c < a.length; c++) i.kerning.push({
            first: parseInt(a[c].getAttribute("first"), 10),
            second: parseInt(a[c].getAttribute("second"), 10),
            amount: parseInt(a[c].getAttribute("amount"), 10)
        });
        for (let c = 0; c < l.length; c++) i.distanceField.push({
            fieldType: l[c].getAttribute("fieldType"),
            distanceRange: parseInt(l[c].getAttribute("distanceRange"), 10)
        });
        return i
    }
}
class Ad {
    static test(t) {
        return typeof t == "string" && t.includes("<font>") ? Cd.test(ut.ADAPTER.parseXML(t)) : !1
    }
    static parse(t) {
        return Cd.parse(ut.ADAPTER.parseXML(t))
    }
}
const pu = [ec, Cd, Ad];

function NM(e) {
    for (let t = 0; t < pu.length; t++)
        if (pu[t].test(e)) return pu[t];
    return null
}

function FM(e, t, i, s, n, r) {
    const o = i.fill;
    if (Array.isArray(o)) {
        if (o.length === 1) return o[0]
    } else return o;
    let a;
    const l = i.dropShadow ? i.dropShadowDistance : 0,
        c = i.padding || 0,
        h = e.width / s - l - c * 2,
        u = e.height / s - l - c * 2,
        d = o.slice(),
        f = i.fillGradientStops.slice();
    if (!f.length) {
        const p = d.length + 1;
        for (let m = 1; m < p; ++m) f.push(m / p)
    }
    if (d.unshift(o[0]), f.unshift(0), d.push(o[o.length - 1]), f.push(1), i.fillGradientType === _h.LINEAR_VERTICAL) {
        a = t.createLinearGradient(h / 2, c, h / 2, u + c);
        let p = 0;
        const g = (r.fontProperties.fontSize + i.strokeThickness) / u;
        for (let y = 0; y < n.length; y++) {
            const x = r.lineHeight * y;
            for (let v = 0; v < d.length; v++) {
                let _ = 0;
                typeof f[v] == "number" ? _ = f[v] : _ = v / d.length;
                const C = x / u + _ * g;
                let k = Math.max(p, C);
                k = Math.min(k, 1), a.addColorStop(k, d[v]), p = k
            }
        }
    } else {
        a = t.createLinearGradient(c, u / 2, h + c, u / 2);
        const p = d.length + 1;
        let m = 1;
        for (let g = 0; g < d.length; g++) {
            let y;
            typeof f[g] == "number" ? y = f[g] : y = m / p, a.addColorStop(y, d[g]), m++
        }
    }
    return a
}

function BM(e, t, i, s, n, r, o) {
    const a = i.text,
        l = i.fontProperties;
    t.translate(s, n), t.scale(r, r);
    const c = o.strokeThickness / 2,
        h = -(o.strokeThickness / 2);
    if (t.font = o.toFontString(), t.lineWidth = o.strokeThickness, t.textBaseline = o.textBaseline, t.lineJoin = o.lineJoin, t.miterLimit = o.miterLimit, t.fillStyle = FM(e, t, o, r, [a], i), t.strokeStyle = o.stroke, o.dropShadow) {
        const u = o.dropShadowColor,
            d = tn(typeof u == "number" ? u : lh(u)),
            f = o.dropShadowBlur * r,
            p = o.dropShadowDistance * r;
        t.shadowColor = `rgba(${d[0]*255},${d[1]*255},${d[2]*255},${o.dropShadowAlpha})`, t.shadowBlur = f, t.shadowOffsetX = Math.cos(o.dropShadowAngle) * p, t.shadowOffsetY = Math.sin(o.dropShadowAngle) * p
    } else t.shadowColor = "black", t.shadowBlur = 0, t.shadowOffsetX = 0, t.shadowOffsetY = 0;
    o.stroke && o.strokeThickness && t.strokeText(a, c, h + i.lineHeight - l.descent), o.fill && t.fillText(a, c, h + i.lineHeight - l.descent), t.setTransform(1, 0, 0, 1, 0, 0), t.fillStyle = "rgba(0, 0, 0, 0)"
}

function ic(e) {
    return e.codePointAt ? e.codePointAt(0) : e.charCodeAt(0)
}

function F1(e) {
    return Array.from ? Array.from(e) : e.split("")
}

function UM(e) {
    typeof e == "string" && (e = [e]);
    const t = [];
    for (let i = 0, s = e.length; i < s; i++) {
        const n = e[i];
        if (Array.isArray(n)) {
            if (n.length !== 2) throw new Error(`[BitmapFont]: Invalid character range length, expecting 2 got ${n.length}.`);
            const r = n[0].charCodeAt(0),
                o = n[1].charCodeAt(0);
            if (o < r) throw new Error("[BitmapFont]: Invalid character range.");
            for (let a = r, l = o; a <= l; a++) t.push(String.fromCharCode(a))
        } else t.push(...F1(n))
    }
    if (t.length === 0) throw new Error("[BitmapFont]: Empty set when resolving characters.");
    return t
}
const Qi = class {
    constructor(e, t, i) {
        const [s] = e.info, [n] = e.common, [r] = e.page, [o] = e.distanceField, a = en(r.file), l = {};
        this._ownsTextures = i, this.font = s.face, this.size = s.size, this.lineHeight = n.lineHeight / a, this.chars = {}, this.pageTextures = l;
        for (let c = 0; c < e.page.length; c++) {
            const {
                id: h,
                file: u
            } = e.page[c];
            l[h] = t instanceof Array ? t[c] : t[u], o?.fieldType && o.fieldType !== "none" && (l[h].baseTexture.alphaMode = _s.NO_PREMULTIPLIED_ALPHA, l[h].baseTexture.mipmap = ds.OFF)
        }
        for (let c = 0; c < e.char.length; c++) {
            const {
                id: h,
                page: u
            } = e.char[c];
            let {
                x: d,
                y: f,
                width: p,
                height: m,
                xoffset: g,
                yoffset: y,
                xadvance: x
            } = e.char[c];
            d /= a, f /= a, p /= a, m /= a, g /= a, y /= a, x /= a;
            const v = new qt(d + l[u].frame.x / a, f + l[u].frame.y / a, p, m);
            this.chars[h] = {
                xOffset: g,
                yOffset: y,
                xAdvance: x,
                kerning: {},
                texture: new ht(l[u].baseTexture, v),
                page: u
            }
        }
        for (let c = 0; c < e.kerning.length; c++) {
            let {
                first: h,
                second: u,
                amount: d
            } = e.kerning[c];
            h /= a, u /= a, d /= a, this.chars[u] && (this.chars[u].kerning[h] = d)
        }
        this.distanceFieldRange = o?.distanceRange, this.distanceFieldType = o?.fieldType?.toLowerCase() ?? "none"
    }
    destroy() {
        for (const e in this.chars) this.chars[e].texture.destroy(), this.chars[e].texture = null;
        for (const e in this.pageTextures) this._ownsTextures && this.pageTextures[e].destroy(!0), this.pageTextures[e] = null;
        this.chars = null, this.pageTextures = null
    }
    static install(e, t, i) {
        let s;
        if (e instanceof Rc) s = e;
        else {
            const r = NM(e);
            if (!r) throw new Error("Unrecognized data format for font.");
            s = r.parse(e)
        }
        t instanceof ht && (t = [t]);
        const n = new Qi(s, t, i);
        return Qi.available[n.font] = n, n
    }
    static uninstall(e) {
        const t = Qi.available[e];
        if (!t) throw new Error(`No font found named '${e}'`);
        t.destroy(), delete Qi.available[e]
    }
    static from(e, t, i) {
        if (!e) throw new Error("[BitmapFont] Property `name` is required.");
        const {
            chars: s,
            padding: n,
            resolution: r,
            textureWidth: o,
            textureHeight: a,
            ...l
        } = Object.assign({}, Qi.defaultOptions, i), c = UM(s), h = t instanceof ki ? t : new ki(t), u = o, d = new Rc;
        d.info[0] = {
            face: h.fontFamily,
            size: h.fontSize
        }, d.common[0] = {
            lineHeight: h.fontSize
        };
        let f = 0,
            p = 0,
            m, g, y, x = 0;
        const v = [];
        for (let C = 0; C < c.length; C++) {
            m || (m = ut.ADAPTER.createCanvas(), m.width = o, m.height = a, g = m.getContext("2d"), y = new Nt(m, {
                resolution: r,
                ...l
            }), v.push(new ht(y)), d.page.push({
                id: v.length - 1,
                file: ""
            }));
            const k = c[C],
                S = He.measureText(k, h, !1, m),
                T = S.width,
                L = Math.ceil(S.height),
                D = Math.ceil((h.fontStyle === "italic" ? 2 : 1) * T);
            if (p >= a - L * r) {
                if (p === 0) throw new Error(`[BitmapFont] textureHeight ${a}px is too small (fontFamily: '${h.fontFamily}', fontSize: ${h.fontSize}px, char: '${k}')`);
                --C, m = null, g = null, y = null, p = 0, f = 0, x = 0;
                continue
            }
            if (x = Math.max(L + S.fontProperties.descent, x), D * r + f >= u) {
                if (f === 0) throw new Error(`[BitmapFont] textureWidth ${o}px is too small (fontFamily: '${h.fontFamily}', fontSize: ${h.fontSize}px, char: '${k}')`);
                --C, p += x * r, p = Math.ceil(p), f = 0, x = 0;
                continue
            }
            BM(m, g, S, f, p, r, h);
            const O = ic(S.text);
            d.char.push({
                id: O,
                page: v.length - 1,
                x: f / r,
                y: p / r,
                width: D,
                height: L,
                xoffset: 0,
                yoffset: 0,
                xadvance: Math.ceil(T - (h.dropShadow ? h.dropShadowDistance : 0) - (h.stroke ? h.strokeThickness : 0))
            }), f += (D + 2 * n) * r, f = Math.ceil(f)
        }
        for (let C = 0, k = c.length; C < k; C++) {
            const S = c[C];
            for (let T = 0; T < k; T++) {
                const L = c[T],
                    D = g.measureText(S).width,
                    O = g.measureText(L).width,
                    P = g.measureText(S + L).width - (D + O);
                P && d.kerning.push({
                    first: ic(S),
                    second: ic(L),
                    amount: P
                })
            }
        }
        const _ = new Qi(d, v, !0);
        return Qi.available[e] !== void 0 && Qi.uninstall(e), Qi.available[e] = _, _
    }
};
let le = Qi;
le.ALPHA = [
    ["a", "z"],
    ["A", "Z"], " "
];
le.NUMERIC = [
    ["0", "9"]
];
le.ALPHANUMERIC = [
    ["a", "z"],
    ["A", "Z"],
    ["0", "9"], " "
];
le.ASCII = [
    [" ", "~"]
];
le.defaultOptions = {
    resolution: 1,
    textureWidth: 512,
    textureHeight: 512,
    padding: 4,
    chars: Qi.ALPHANUMERIC
};
le.available = {};
var GM = `// Pixi texture info\r
varying vec2 vTextureCoord;\r
uniform sampler2D uSampler;\r
\r
// Tint\r
uniform vec4 uColor;\r
\r
// on 2D applications fwidth is screenScale / glyphAtlasScale * distanceFieldRange\r
uniform float uFWidth;\r
\r
void main(void) {\r
\r
  // To stack MSDF and SDF we need a non-pre-multiplied-alpha texture.\r
  vec4 texColor = texture2D(uSampler, vTextureCoord);\r
\r
  // MSDF\r
  float median = texColor.r + texColor.g + texColor.b -\r
                  min(texColor.r, min(texColor.g, texColor.b)) -\r
                  max(texColor.r, max(texColor.g, texColor.b));\r
  // SDF\r
  median = min(median, texColor.a);\r
\r
  float screenPxDistance = uFWidth * (median - 0.5);\r
  float alpha = clamp(screenPxDistance + 0.5, 0.0, 1.0);\r
  if (median < 0.01) {\r
    alpha = 0.0;\r
  } else if (median > 0.99) {\r
    alpha = 1.0;\r
  }\r
\r
  // NPM Textures, NPM outputs\r
  gl_FragColor = vec4(uColor.rgb, uColor.a * alpha);\r
\r
}\r
`,
    HM = `// Mesh material default fragment\r
attribute vec2 aVertexPosition;\r
attribute vec2 aTextureCoord;\r
\r
uniform mat3 projectionMatrix;\r
uniform mat3 translationMatrix;\r
uniform mat3 uTextureMatrix;\r
\r
varying vec2 vTextureCoord;\r
\r
void main(void)\r
{\r
    gl_Position = vec4((projectionMatrix * translationMatrix * vec3(aVertexPosition, 1.0)).xy, 0.0, 1.0);\r
\r
    vTextureCoord = (uTextureMatrix * vec3(aTextureCoord, 1.0)).xy;\r
}\r
`;
const Dg = [],
    Ng = [],
    Fg = [],
    B1 = class extends ae {
        constructor(e, t = {}) {
            super(), this._tint = 16777215;
            const {
                align: i,
                tint: s,
                maxWidth: n,
                letterSpacing: r,
                fontName: o,
                fontSize: a
            } = Object.assign({}, B1.styleDefaults, t);
            if (!le.available[o]) throw new Error(`Missing BitmapFont "${o}"`);
            this._activePagesMeshData = [], this._textWidth = 0, this._textHeight = 0, this._align = i, this._tint = s, this._font = void 0, this._fontName = o, this._fontSize = a, this.text = e, this._maxWidth = n, this._maxLineHeight = 0, this._letterSpacing = r, this._anchor = new wn(() => {
                this.dirty = !0
            }, this, 0, 0), this._roundPixels = ut.ROUND_PIXELS, this.dirty = !0, this._resolution = ut.RESOLUTION, this._autoResolution = !0, this._textureCache = {}
        }
        updateText() {
            const e = le.available[this._fontName],
                t = this.fontSize,
                i = t / e.size,
                s = new Zt,
                n = [],
                r = [],
                o = [],
                a = this._text.replace(/(?:\r\n|\r)/g, `
`) || " ",
                l = F1(a),
                c = this._maxWidth * e.size / t,
                h = e.distanceFieldType === "none" ? Dg : Ng;
            let u = null,
                d = 0,
                f = 0,
                p = 0,
                m = -1,
                g = 0,
                y = 0,
                x = 0,
                v = 0;
            for (let D = 0; D < l.length; D++) {
                const O = l[D],
                    K = ic(O);
                if (/(?:\s)/.test(O) && (m = D, g = d, v++), O === "\r" || O === `
`) {
                    r.push(d), o.push(-1), f = Math.max(f, d), ++p, ++y, s.x = 0, s.y += e.lineHeight, u = null, v = 0;
                    continue
                }
                const P = e.chars[K];
                if (!P) continue;
                u && P.kerning[u] && (s.x += P.kerning[u]);
                const N = Fg.pop() || {
                    texture: ht.EMPTY,
                    line: 0,
                    charCode: 0,
                    prevSpaces: 0,
                    position: new Zt
                };
                N.texture = P.texture, N.line = p, N.charCode = K, N.position.x = s.x + P.xOffset + this._letterSpacing / 2, N.position.y = s.y + P.yOffset, N.prevSpaces = v, n.push(N), d = N.position.x + Math.max(P.xAdvance - P.xOffset, P.texture.orig.width), s.x += P.xAdvance + this._letterSpacing, x = Math.max(x, P.yOffset + P.texture.height), u = K, m !== -1 && c > 0 && s.x > c && (++y, wr(n, 1 + m - y, 1 + D - m), D = m, m = -1, r.push(g), o.push(n.length > 0 ? n[n.length - 1].prevSpaces : 0), f = Math.max(f, g), p++, s.x = 0, s.y += e.lineHeight, u = null, v = 0)
            }
            const _ = l[l.length - 1];
            _ !== "\r" && _ !== `
` && (/(?:\s)/.test(_) && (d = g), r.push(d), f = Math.max(f, d), o.push(-1));
            const C = [];
            for (let D = 0; D <= p; D++) {
                let O = 0;
                this._align === "right" ? O = f - r[D] : this._align === "center" ? O = (f - r[D]) / 2 : this._align === "justify" && (O = o[D] < 0 ? 0 : (f - r[D]) / o[D]), C.push(O)
            }
            const k = n.length,
                S = {},
                T = [],
                L = this._activePagesMeshData;
            h.push(...L);
            for (let D = 0; D < k; D++) {
                const O = n[D].texture,
                    K = O.baseTexture.uid;
                if (!S[K]) {
                    let P = h.pop();
                    if (!P) {
                        const W = new gh;
                        let V, Q;
                        e.distanceFieldType === "none" ? (V = new Do(ht.EMPTY), Q = j.NORMAL) : (V = new Do(ht.EMPTY, {
                            program: os.from(HM, GM),
                            uniforms: {
                                uFWidth: 0
                            }
                        }), Q = j.NORMAL_NPM);
                        const pt = new ti(W, V);
                        pt.blendMode = Q, P = {
                            index: 0,
                            indexCount: 0,
                            vertexCount: 0,
                            uvsCount: 0,
                            total: 0,
                            mesh: pt,
                            vertices: null,
                            uvs: null,
                            indices: null
                        }
                    }
                    P.index = 0, P.indexCount = 0, P.vertexCount = 0, P.uvsCount = 0, P.total = 0;
                    const {
                        _textureCache: N
                    } = this;
                    N[K] = N[K] || new ht(O.baseTexture), P.mesh.texture = N[K], P.mesh.tint = this._tint, T.push(P), S[K] = P
                }
                S[K].total++
            }
            for (let D = 0; D < L.length; D++) T.includes(L[D]) || this.removeChild(L[D].mesh);
            for (let D = 0; D < T.length; D++) T[D].mesh.parent !== this && this.addChild(T[D].mesh);
            this._activePagesMeshData = T;
            for (const D in S) {
                const O = S[D],
                    K = O.total;
                if (!(O.indices?.length > 6 * K) || O.vertices.length < ti.BATCHABLE_SIZE * 2) O.vertices = new Float32Array(4 * 2 * K), O.uvs = new Float32Array(4 * 2 * K), O.indices = new Uint16Array(6 * K);
                else {
                    const P = O.total,
                        N = O.vertices;
                    for (let W = P * 4 * 2; W < N.length; W++) N[W] = 0
                }
                O.mesh.size = 6 * K
            }
            for (let D = 0; D < k; D++) {
                const O = n[D];
                let K = O.position.x + C[O.line] * (this._align === "justify" ? O.prevSpaces : 1);
                this._roundPixels && (K = Math.round(K));
                const P = K * i,
                    N = O.position.y * i,
                    W = O.texture,
                    V = S[W.baseTexture.uid],
                    Q = W.frame,
                    pt = W._uvs,
                    bt = V.index++;
                V.indices[bt * 6 + 0] = 0 + bt * 4, V.indices[bt * 6 + 1] = 1 + bt * 4, V.indices[bt * 6 + 2] = 2 + bt * 4, V.indices[bt * 6 + 3] = 0 + bt * 4, V.indices[bt * 6 + 4] = 2 + bt * 4, V.indices[bt * 6 + 5] = 3 + bt * 4, V.vertices[bt * 8 + 0] = P, V.vertices[bt * 8 + 1] = N, V.vertices[bt * 8 + 2] = P + Q.width * i, V.vertices[bt * 8 + 3] = N, V.vertices[bt * 8 + 4] = P + Q.width * i, V.vertices[bt * 8 + 5] = N + Q.height * i, V.vertices[bt * 8 + 6] = P, V.vertices[bt * 8 + 7] = N + Q.height * i, V.uvs[bt * 8 + 0] = pt.x0, V.uvs[bt * 8 + 1] = pt.y0, V.uvs[bt * 8 + 2] = pt.x1, V.uvs[bt * 8 + 3] = pt.y1, V.uvs[bt * 8 + 4] = pt.x2, V.uvs[bt * 8 + 5] = pt.y2, V.uvs[bt * 8 + 6] = pt.x3, V.uvs[bt * 8 + 7] = pt.y3
            }
            this._textWidth = f * i, this._textHeight = (s.y + e.lineHeight) * i;
            for (const D in S) {
                const O = S[D];
                if (this.anchor.x !== 0 || this.anchor.y !== 0) {
                    let W = 0;
                    const V = this._textWidth * this.anchor.x,
                        Q = this._textHeight * this.anchor.y;
                    for (let pt = 0; pt < O.total; pt++) O.vertices[W++] -= V, O.vertices[W++] -= Q, O.vertices[W++] -= V, O.vertices[W++] -= Q, O.vertices[W++] -= V, O.vertices[W++] -= Q, O.vertices[W++] -= V, O.vertices[W++] -= Q
                }
                this._maxLineHeight = x * i;
                const K = O.mesh.geometry.getBuffer("aVertexPosition"),
                    P = O.mesh.geometry.getBuffer("aTextureCoord"),
                    N = O.mesh.geometry.getIndex();
                K.data = O.vertices, P.data = O.uvs, N.data = O.indices, K.update(), P.update(), N.update()
            }
            for (let D = 0; D < n.length; D++) Fg.push(n[D]);
            this._font = e, this.dirty = !1
        }
        updateTransform() {
            this.validate(), this.containerUpdateTransform()
        }
        _render(e) {
            this._autoResolution && this._resolution !== e.resolution && (this._resolution = e.resolution, this.dirty = !0);
            const {
                distanceFieldRange: t,
                distanceFieldType: i,
                size: s
            } = le.available[this._fontName];
            if (i !== "none") {
                const {
                    a: n,
                    b: r,
                    c: o,
                    d: a
                } = this.worldTransform, l = Math.sqrt(n * n + r * r), c = Math.sqrt(o * o + a * a), h = (Math.abs(l) + Math.abs(c)) / 2, u = this.fontSize / s, d = e._view.resolution;
                for (const f of this._activePagesMeshData) f.mesh.shader.uniforms.uFWidth = h * t * u * d
            }
            super._render(e)
        }
        getLocalBounds() {
            return this.validate(), super.getLocalBounds()
        }
        validate() {
            const e = le.available[this._fontName];
            if (!e) throw new Error(`Missing BitmapFont "${this._fontName}"`);
            this._font !== e && (this.dirty = !0), this.dirty && this.updateText()
        }
        get tint() {
            return this._tint
        }
        set tint(e) {
            if (this._tint !== e) {
                this._tint = e;
                for (let t = 0; t < this._activePagesMeshData.length; t++) this._activePagesMeshData[t].mesh.tint = e
            }
        }
        get align() {
            return this._align
        }
        set align(e) {
            this._align !== e && (this._align = e, this.dirty = !0)
        }
        get fontName() {
            return this._fontName
        }
        set fontName(e) {
            if (!le.available[e]) throw new Error(`Missing BitmapFont "${e}"`);
            this._fontName !== e && (this._fontName = e, this.dirty = !0)
        }
        get fontSize() {
            return this._fontSize ?? le.available[this._fontName].size
        }
        set fontSize(e) {
            this._fontSize !== e && (this._fontSize = e, this.dirty = !0)
        }
        get anchor() {
            return this._anchor
        }
        set anchor(e) {
            typeof e == "number" ? this._anchor.set(e) : this._anchor.copyFrom(e)
        }
        get text() {
            return this._text
        }
        set text(e) {
            e = String(e ?? ""), this._text !== e && (this._text = e, this.dirty = !0)
        }
        get maxWidth() {
            return this._maxWidth
        }
        set maxWidth(e) {
            this._maxWidth !== e && (this._maxWidth = e, this.dirty = !0)
        }
        get maxLineHeight() {
            return this.validate(), this._maxLineHeight
        }
        get textWidth() {
            return this.validate(), this._textWidth
        }
        get letterSpacing() {
            return this._letterSpacing
        }
        set letterSpacing(e) {
            this._letterSpacing !== e && (this._letterSpacing = e, this.dirty = !0)
        }
        get roundPixels() {
            return this._roundPixels
        }
        set roundPixels(e) {
            e !== this._roundPixels && (this._roundPixels = e, this.dirty = !0)
        }
        get textHeight() {
            return this.validate(), this._textHeight
        }
        get resolution() {
            return this._resolution
        }
        set resolution(e) {
            this._autoResolution = !1, this._resolution !== e && (this._resolution = e, this.dirty = !0)
        }
        destroy(e) {
            const {
                _textureCache: t
            } = this, s = le.available[this._fontName].distanceFieldType === "none" ? Dg : Ng;
            s.push(...this._activePagesMeshData);
            for (const n of this._activePagesMeshData) this.removeChild(n.mesh);
            this._activePagesMeshData = [], s.filter(n => t[n.mesh.texture.baseTexture.uid]).forEach(n => {
                n.mesh.texture = ht.EMPTY
            });
            for (const n in t) t[n].destroy(), delete t[n];
            this._font = null, this._textureCache = null, super.destroy(e)
        }
    };
let $e = B1;
$e.styleDefaults = {
    align: "left",
    tint: 16777215,
    maxWidth: 0,
    letterSpacing: 0
};
const VM = [".xml", ".fnt"],
    zM = {
        extension: {
            type: lt.LoadParser,
            priority: Us.Normal
        },
        test(e) {
            return VM.includes(Xe.extname(e).toLowerCase())
        },
        async testParse(e) {
            return ec.test(e) || Ad.test(e)
        },
        async parse(e, t, i) {
            const s = ec.test(e) ? ec.parse(e) : Ad.parse(e),
                {
                    src: n
                } = t,
                {
                    page: r
                } = s,
                o = [];
            for (let c = 0; c < r.length; ++c) {
                const h = r[c].file,
                    u = Xe.join(Xe.dirname(n), h);
                o.push(u)
            }
            const a = await i.load(o),
                l = o.map(c => a[c]);
            return le.install(s, l, !0)
        },
        async load(e, t) {
            return (await ut.ADAPTER.fetch(e)).text()
        },
        unload(e) {
            e.destroy()
        }
    };
vt.add(zM);

function vi(e, t, i) {
    return Math.max(Math.min((t - e) / i, 1), 0)
}

function Ze(e, t, i) {
    return e + (t - e) * i
}

function kc(e) {
    return e < 10 ? `0${e}` : e
}
const mu = () => {
    const e = new Date;
    return `${kc(e.getHours())}:${kc(e.getMinutes())}`
};

function lo(e) {
    if (!e) return "";
    const t = e.opUnits.get(0);
    return t ? `url(${t.skinImg.src})` : ""
}

function Ui(e, t, i) {
    return Math.abs(e - t) < i
}

function U1(e) {
    return e.includes("Key") ? e.substring(3, e.leading) : e.includes("Arrow") ? e.substring(5, e.leading) : e
}

function yo(e) {
    const {
        code: t
    } = e;
    let i = "",
        s = "";
    return t.includes("Shift") ? s = "Shift" : t.includes("Control") ? s = "Ctrl" : t.includes("Alt") ? s = "Alt" : (s = U1(t), i = e.shiftKey ? "Shift+" : e.ctrlKey ? "Ctrl+" : e.altKey ? "Alt+" : ""), s = i + s, s
}

function Bg(e, t, i, s, n) {
    return [e - n, t + n, i - n, s + n]
}

function Ug(e, t) {
    let i, s = [],
        n, r;
    for (let o = 0, a = e.length; o < a;) i = (247.5 + o / 2 * 45) / 180 * Math.PI, n = e[o++] + t * Math.cos(i), r = e[o++] + t * Math.sin(i), s.push(n, r);
    return s
}

function Be(e) {
    return e ? parseInt(`0x${e}`) : void 0
}

function gu(e) {
    var t = e.toString(16).toUpperCase();
    return t.length == 1 && (t = "0" + t), t
}

function Qa(e) {
    var t = e >> 16 & 255,
        i = e >> 8 & 255,
        s = 255 & e;
    return "#" + gu(t) + gu(i) + gu(s)
}

function ar(e) {
    const t = Be(e[0]);
    return lr(t, e[1])
}

function lr(e, t) {
    return `rgba(${e>>16}, ${e>>8&255}, ${e&255}, ${t})`
}

function Id(e, t) {
    return e.length != 0 ? "#" + e : Qa(t)
}

function cr(e) {
    return [e & 4095, (e & 61440) >> 12]
}

function $M(e) {
    return {
        all: e = e || new Map,
        on: function(t, i) {
            var s = e.get(t);
            s ? s.push(i) : e.set(t, [i])
        },
        off: function(t, i) {
            var s = e.get(t);
            s && (i ? s.splice(s.indexOf(i) >>> 0, 1) : e.set(t, []))
        },
        emit: function(t, i) {
            var s = e.get(t);
            s && s.slice().map(function(n) {
                n(i)
            }), (s = e.get("*")) && s.slice().map(function(n) {
                n(t, i)
            })
        }
    }
}
const A = $M(),
    Md = {
        TagType: 1,
        ShowNick: 1,
        ShowMass: 1,
        ShowSkin: 1,
        ShowFood: 1,
        VirusType: 1,
        ShowCursorLine: 1,
        ShowEnemyHint: 1,
        ShowMassMarker: 1,
        ShowSplitOrderMarker: 1,
        ShowAutosplitAlert: 1,
        ShootingHintType: 2,
        AnimationDelay: 180,
        ExtraLatency: 0,
        CameraDelay: 350,
        ZoomSpeed: 1.2,
        EnableAppearance: 1,
        EnableDisappearance: 1,
        EnableAbsorption: 0,
        Quality: 375,
        Resolution: 1,
        Antialias: 1,
        Mipmap: 1,
        CaptureTime: 0,
        AutoSwitchTab: 1,
        StopFeedingAfterSwitchingTab: 1,
        PauseAfterOpeningMenu: 0,
        ShowMenuAfterDeath: 0,
        StableSpecCamera: 0,
        ShowMinimap: 1,
        ShowLeaderboard: 1,
        ShowTeamRankings: 1,
        ShowPerfStatus: 1,
        ShowGameStatus: 1,
        ShowChatRoom: 1,
        ShowReplayBar: 1,
        MinimapSize: 1,
        LeaderboardSize: 1,
        TeamRankingsSize: 1,
        PerfStatusSize: 1,
        GameStatusSize: 1,
        AutoHideChatRoom: 0,
        HideCode: 0,
        EnableChat: 1
    },
    G1 = {
        0: "None",
        1: "Signal",
        2: "ClickMove",
        3: "None",
        4: "None"
    },
    sc = {
        FeedOnce: "W",
        MacroFeed: "Q",
        Split1X: "Space",
        Split2X: "R",
        Split3X: "T",
        Split4X: "E",
        Pause: "S",
        TogglePause: "",
        Scatter: "V",
        SwitchTab: "Tab",
        AutoSwitchTab: "",
        Toggle4TabMode: "",
        Respawn: "N",
        ShowCursorLine: "",
        ShowEnemyHint: "",
        ShowMassMarker: "",
        ShowSplitOrderMarker: "",
        ShowAutosplitAlert: "",
        IncreaseMass: "M",
        DecreaseMass: "N",
        ClearSmallCells: "C",
        QuickCapture: "",
        ShowNick: "A",
        ShowMass: "D",
        ShowSkin: "X",
        ShowFood: "Z",
        ShowMinimap: "",
        ShowLeaderboard: "",
        ShowTeamRankings: "",
        ShowPerfStatus: "",
        ShowGameStatus: "",
        ShowChatRoom: "",
        ShowReplayBar: ""
    },
    nc = {
        EjectedCell: ["", .75],
        Food: ["", 1],
        Virus: ["00ff00", .9],
        RedVirus: ["ff6699", .9],
        Text: ["FFFFFF", 1, 22.5, 7],
        TextStroke: ["222222", .75, 22.5, 1],
        CellSelf: ["", .9],
        SkinSelf: ["FFFFFF", .9],
        SkinFillSelf: ["", 1],
        CellTeam: ["", .9],
        SkinTeam: ["FFFFFF", .9],
        SkinFillTeam: ["", 1],
        CellEnemy: ["", .9],
        SkinEnemy: ["FFFFFF", .9],
        SkinFillEnemy: ["", 1],
        CellAll: ["", .9],
        SkinAll: ["FFFFFF", .9],
        SkinFillAll: ["", 1],
        CursorLine: ["FFFFFF", 1, 1.5, 0],
        MassMarker: ["", 1, 3.5, 0],
        SplitOrderMarker: ["", 1, 12.5, 0],
        AutosplitAlert: ["", 1, 3.5, 0],
        DestinationPoint: ["00FF00", 1],
        Signal: ["3090FF", null],
        CoordsFont: ["FFFFFF", .2],
        CoordsGrid: ["FFFFFF", .5],
        Border: ["0095FF", 1],
        BorderGlow: ["0095FF", 1],
        BackgroundColor: ["121418", 1],
        BackgroundImage: ["FFFFFF", .6, ""],
        CoordsFontMinimap: ["FFFFFF", .375],
        CoordsGridMinimap: ["FFFFFF", .125],
        BgcMinimap: ["252525", .5],
        LocationLine: ["FFFFFF", .35],
        ViewMinimap: ["", .1],
        EntityMinimap: ["", .8],
        EntityInfoMinimap: ["", 1],
        BgcLeaderboard: ["252525", .5],
        BgcTeamRankings: ["252525", .5],
        BgcPerfPanel: ["252525", .5]
    },
    jM = ["osa.cwal.io:8888", "tyo.cwal.io:8888", "localhost:8888"],
    WM = ["tyo.cwal.io:8888", "osa.cwal.io:8888", "na.cwal.io:8888"],
    Pc = ["zh_CN", "zh", "ja", "en"],
    XM = ["http://cwal.io/skins/ring.png", "http://cwal.io/skins/h.png", "http://cwal.io/skins/circles.png", "http://cwal.io/skins/w.png", "http://cwal.io/skins/wolf.png", "http://cwal.io/skins/dragon.png", "http://cwal.io/skins/magatama.png", "http://cwal.io/skins/ghost.png", "http://cwal.io/skins/bat.png", "http://cwal.io/skins/daemon.png"],
    YM = (() => {
        const e = [];
        for (let t = 0; t < 20; t++) {
            const i = "Profile" + (t + 1),
                s = XM[t] ?? "http://cwal.io/skins/ring.png";
            e.push([
                ["", ""],
                [
                    [i, s],
                    [i, s],
                    [i, s],
                    [i, s]
                ], ""
            ])
        }
        return e
    })(),
    KM = 1;
var H1 = {
    exports: {}
};
(function(e) {
    (function() {
        function t(w, R, z) {
            return w.call.apply(w.bind, arguments)
        }

        function i(w, R, z) {
            if (!w) throw Error();
            if (2 < arguments.length) {
                var G = Array.prototype.slice.call(arguments, 2);
                return function() {
                    var et = Array.prototype.slice.call(arguments);
                    return Array.prototype.unshift.apply(et, G), w.apply(R, et)
                }
            }
            return function() {
                return w.apply(R, arguments)
            }
        }

        function s(w, R, z) {
            return s = Function.prototype.bind && Function.prototype.bind.toString().indexOf("native code") != -1 ? t : i, s.apply(null, arguments)
        }
        var n = Date.now || function() {
            return +new Date
        };

        function r(w, R) {
            this.a = w, this.o = R || w, this.c = this.o.document
        }
        var o = !!window.FontFace;

        function a(w, R, z, G) {
            if (R = w.c.createElement(R), z)
                for (var et in z) z.hasOwnProperty(et) && (et == "style" ? R.style.cssText = z[et] : R.setAttribute(et, z[et]));
            return G && R.appendChild(w.c.createTextNode(G)), R
        }

        function l(w, R, z) {
            w = w.c.getElementsByTagName(R)[0], w || (w = document.documentElement), w.insertBefore(z, w.lastChild)
        }

        function c(w) {
            w.parentNode && w.parentNode.removeChild(w)
        }

        function h(w, R, z) {
            R = R || [], z = z || [];
            for (var G = w.className.split(/\s+/), et = 0; et < R.length; et += 1) {
                for (var _t = !1, Mt = 0; Mt < G.length; Mt += 1)
                    if (R[et] === G[Mt]) {
                        _t = !0;
                        break
                    } _t || G.push(R[et])
            }
            for (R = [], et = 0; et < G.length; et += 1) {
                for (_t = !1, Mt = 0; Mt < z.length; Mt += 1)
                    if (G[et] === z[Mt]) {
                        _t = !0;
                        break
                    } _t || R.push(G[et])
            }
            w.className = R.join(" ").replace(/\s+/g, " ").replace(/^\s+|\s+$/, "")
        }

        function u(w, R) {
            for (var z = w.className.split(/\s+/), G = 0, et = z.length; G < et; G++)
                if (z[G] == R) return !0;
            return !1
        }

        function d(w) {
            return w.o.location.hostname || w.a.location.hostname
        }

        function f(w, R, z) {
            function G() {
                de && et && _t && (de(Mt), de = null)
            }
            R = a(w, "link", {
                rel: "stylesheet",
                href: R,
                media: "all"
            });
            var et = !1,
                _t = !0,
                Mt = null,
                de = z || null;
            o ? (R.onload = function() {
                et = !0, G()
            }, R.onerror = function() {
                et = !0, Mt = Error("Stylesheet failed to load"), G()
            }) : setTimeout(function() {
                et = !0, G()
            }, 0), l(w, "head", R)
        }

        function p(w, R, z, G) {
            var et = w.c.getElementsByTagName("head")[0];
            if (et) {
                var _t = a(w, "script", {
                        src: R
                    }),
                    Mt = !1;
                return _t.onload = _t.onreadystatechange = function() {
                    Mt || this.readyState && this.readyState != "loaded" && this.readyState != "complete" || (Mt = !0, z && z(null), _t.onload = _t.onreadystatechange = null, _t.parentNode.tagName == "HEAD" && et.removeChild(_t))
                }, et.appendChild(_t), setTimeout(function() {
                    Mt || (Mt = !0, z && z(Error("Script load timeout")))
                }, G || 5e3), _t
            }
            return null
        }

        function m() {
            this.a = 0, this.c = null
        }

        function g(w) {
            return w.a++,
                function() {
                    w.a--, x(w)
                }
        }

        function y(w, R) {
            w.c = R, x(w)
        }

        function x(w) {
            w.a == 0 && w.c && (w.c(), w.c = null)
        }

        function v(w) {
            this.a = w || "-"
        }
        v.prototype.c = function(w) {
            for (var R = [], z = 0; z < arguments.length; z++) R.push(arguments[z].replace(/[\W_]+/g, "").toLowerCase());
            return R.join(this.a)
        };

        function _(w, R) {
            this.c = w, this.f = 4, this.a = "n";
            var z = (R || "n4").match(/^([nio])([1-9])$/i);
            z && (this.a = z[1], this.f = parseInt(z[2], 10))
        }

        function C(w) {
            return T(w) + " " + (w.f + "00") + " 300px " + k(w.c)
        }

        function k(w) {
            var R = [];
            w = w.split(/,\s*/);
            for (var z = 0; z < w.length; z++) {
                var G = w[z].replace(/['"]/g, "");
                G.indexOf(" ") != -1 || /^\d/.test(G) ? R.push("'" + G + "'") : R.push(G)
            }
            return R.join(",")
        }

        function S(w) {
            return w.a + w.f
        }

        function T(w) {
            var R = "normal";
            return w.a === "o" ? R = "oblique" : w.a === "i" && (R = "italic"), R
        }

        function L(w) {
            var R = 4,
                z = "n",
                G = null;
            return w && ((G = w.match(/(normal|oblique|italic)/i)) && G[1] && (z = G[1].substr(0, 1).toLowerCase()), (G = w.match(/([1-9]00|normal|bold)/i)) && G[1] && (/bold/i.test(G[1]) ? R = 7 : /[1-9]00/.test(G[1]) && (R = parseInt(G[1].substr(0, 1), 10)))), z + R
        }

        function D(w, R) {
            this.c = w, this.f = w.o.document.documentElement, this.h = R, this.a = new v("-"), this.j = R.events !== !1, this.g = R.classes !== !1
        }

        function O(w) {
            w.g && h(w.f, [w.a.c("wf", "loading")]), P(w, "loading")
        }

        function K(w) {
            if (w.g) {
                var R = u(w.f, w.a.c("wf", "active")),
                    z = [],
                    G = [w.a.c("wf", "loading")];
                R || z.push(w.a.c("wf", "inactive")), h(w.f, z, G)
            }
            P(w, "inactive")
        }

        function P(w, R, z) {
            w.j && w.h[R] && (z ? w.h[R](z.c, S(z)) : w.h[R]())
        }

        function N() {
            this.c = {}
        }

        function W(w, R, z) {
            var G = [],
                et;
            for (et in R)
                if (R.hasOwnProperty(et)) {
                    var _t = w.c[et];
                    _t && G.push(_t(R[et], z))
                } return G
        }

        function V(w, R) {
            this.c = w, this.f = R, this.a = a(this.c, "span", {
                "aria-hidden": "true"
            }, this.f)
        }

        function Q(w) {
            l(w.c, "body", w.a)
        }

        function pt(w) {
            return "display:block;position:absolute;top:-9999px;left:-9999px;font-size:300px;width:auto;height:auto;line-height:normal;margin:0;padding:0;font-variant:normal;white-space:nowrap;font-family:" + k(w.c) + ";" + ("font-style:" + T(w) + ";font-weight:" + (w.f + "00") + ";")
        }

        function bt(w, R, z, G, et, _t) {
            this.g = w, this.j = R, this.a = G, this.c = z, this.f = et || 3e3, this.h = _t || void 0
        }
        bt.prototype.start = function() {
            var w = this.c.o.document,
                R = this,
                z = n(),
                G = new Promise(function(Mt, de) {
                    function _e() {
                        n() - z >= R.f ? de() : w.fonts.load(C(R.a), R.h).then(function(Le) {
                            1 <= Le.length ? Mt() : setTimeout(_e, 25)
                        }, function() {
                            de()
                        })
                    }
                    _e()
                }),
                et = null,
                _t = new Promise(function(Mt, de) {
                    et = setTimeout(de, R.f)
                });
            Promise.race([_t, G]).then(function() {
                et && (clearTimeout(et), et = null), R.g(R.a)
            }, function() {
                R.j(R.a)
            })
        };

        function ct(w, R, z, G, et, _t, Mt) {
            this.v = w, this.B = R, this.c = z, this.a = G, this.s = Mt || "BESbswy", this.f = {}, this.w = et || 3e3, this.u = _t || null, this.m = this.j = this.h = this.g = null, this.g = new V(this.c, this.s), this.h = new V(this.c, this.s), this.j = new V(this.c, this.s), this.m = new V(this.c, this.s), w = new _(this.a.c + ",serif", S(this.a)), w = pt(w), this.g.a.style.cssText = w, w = new _(this.a.c + ",sans-serif", S(this.a)), w = pt(w), this.h.a.style.cssText = w, w = new _("serif", S(this.a)), w = pt(w), this.j.a.style.cssText = w, w = new _("sans-serif", S(this.a)), w = pt(w), this.m.a.style.cssText = w, Q(this.g), Q(this.h), Q(this.j), Q(this.m)
        }
        var gt = {
                D: "serif",
                C: "sans-serif"
            },
            xt = null;

        function It() {
            if (xt === null) {
                var w = /AppleWebKit\/([0-9]+)(?:\.([0-9]+))/.exec(window.navigator.userAgent);
                xt = !!w && (536 > parseInt(w[1], 10) || parseInt(w[1], 10) === 536 && 11 >= parseInt(w[2], 10))
            }
            return xt
        }
        ct.prototype.start = function() {
            this.f.serif = this.j.a.offsetWidth, this.f["sans-serif"] = this.m.a.offsetWidth, this.A = n(), J(this)
        };

        function St(w, R, z) {
            for (var G in gt)
                if (gt.hasOwnProperty(G) && R === w.f[gt[G]] && z === w.f[gt[G]]) return !0;
            return !1
        }

        function J(w) {
            var R = w.g.a.offsetWidth,
                z = w.h.a.offsetWidth,
                G;
            (G = R === w.f.serif && z === w.f["sans-serif"]) || (G = It() && St(w, R, z)), G ? n() - w.A >= w.w ? It() && St(w, R, z) && (w.u === null || w.u.hasOwnProperty(w.a.c)) ? Tt(w, w.v) : Tt(w, w.B) : wt(w) : Tt(w, w.v)
        }

        function wt(w) {
            setTimeout(s(function() {
                J(this)
            }, w), 50)
        }

        function Tt(w, R) {
            setTimeout(s(function() {
                c(this.g.a), c(this.h.a), c(this.j.a), c(this.m.a), R(this.a)
            }, w), 0)
        }

        function Bt(w, R, z) {
            this.c = w, this.a = R, this.f = 0, this.m = this.j = !1, this.s = z
        }
        var kt = null;
        Bt.prototype.g = function(w) {
            var R = this.a;
            R.g && h(R.f, [R.a.c("wf", w.c, S(w).toString(), "active")], [R.a.c("wf", w.c, S(w).toString(), "loading"), R.a.c("wf", w.c, S(w).toString(), "inactive")]), P(R, "fontactive", w), this.m = !0, re(this)
        }, Bt.prototype.h = function(w) {
            var R = this.a;
            if (R.g) {
                var z = u(R.f, R.a.c("wf", w.c, S(w).toString(), "active")),
                    G = [],
                    et = [R.a.c("wf", w.c, S(w).toString(), "loading")];
                z || G.push(R.a.c("wf", w.c, S(w).toString(), "inactive")), h(R.f, G, et)
            }
            P(R, "fontinactive", w), re(this)
        };

        function re(w) {
            --w.f == 0 && w.j && (w.m ? (w = w.a, w.g && h(w.f, [w.a.c("wf", "active")], [w.a.c("wf", "loading"), w.a.c("wf", "inactive")]), P(w, "active")) : K(w.a))
        }

        function Xt(w) {
            this.j = w, this.a = new N, this.h = 0, this.f = this.g = !0
        }
        Xt.prototype.load = function(w) {
            this.c = new r(this.j, w.context || this.j), this.g = w.events !== !1, this.f = w.classes !== !1, E(this, new D(this.c, w), w)
        };

        function ce(w, R, z, G, et) {
            var _t = --w.h == 0;
            (w.f || w.g) && setTimeout(function() {
                var Mt = et || null,
                    de = G || null || {};
                if (z.length === 0 && _t) K(R.a);
                else {
                    R.f += z.length, _t && (R.j = _t);
                    var _e, Le = [];
                    for (_e = 0; _e < z.length; _e++) {
                        var Oe = z[_e],
                            ei = de[Oe.c],
                            Yi = R.a,
                            Dr = Oe;
                        if (Yi.g && h(Yi.f, [Yi.a.c("wf", Dr.c, S(Dr).toString(), "loading")]), P(Yi, "fontloading", Dr), Yi = null, kt === null)
                            if (window.FontFace) {
                                var Dr = /Gecko.*Firefox\/(\d+)/.exec(window.navigator.userAgent),
                                    tb = /OS X.*Version\/10\..*Safari/.exec(window.navigator.userAgent) && /Apple/.exec(window.navigator.vendor);
                                kt = Dr ? 42 < parseInt(Dr[1], 10) : !tb
                            } else kt = !1;
                        kt ? Yi = new bt(s(R.g, R), s(R.h, R), R.c, Oe, R.s, ei) : Yi = new ct(s(R.g, R), s(R.h, R), R.c, Oe, R.s, Mt, ei), Le.push(Yi)
                    }
                    for (_e = 0; _e < Le.length; _e++) Le[_e].start()
                }
            }, 0)
        }

        function E(w, R, z) {
            var et = [],
                G = z.timeout;
            O(R);
            var et = W(w.a, z, w.c),
                _t = new Bt(w.c, R, G);
            for (w.h = et.length, R = 0, z = et.length; R < z; R++) et[R].load(function(Mt, de, _e) {
                ce(w, _t, Mt, de, _e)
            })
        }

        function M(w, R) {
            this.c = w, this.a = R
        }
        M.prototype.load = function(w) {
            function R() {
                if (_t["__mti_fntLst" + G]) {
                    var Mt = _t["__mti_fntLst" + G](),
                        de = [],
                        _e;
                    if (Mt)
                        for (var Le = 0; Le < Mt.length; Le++) {
                            var Oe = Mt[Le].fontfamily;
                            Mt[Le].fontStyle != null && Mt[Le].fontWeight != null ? (_e = Mt[Le].fontStyle + Mt[Le].fontWeight, de.push(new _(Oe, _e))) : de.push(new _(Oe))
                        }
                    w(de)
                } else setTimeout(function() {
                    R()
                }, 50)
            }
            var z = this,
                G = z.a.projectId,
                et = z.a.version;
            if (G) {
                var _t = z.c.o;
                p(this.c, (z.a.api || "https://fast.fonts.net/jsapi") + "/" + G + ".js" + (et ? "?v=" + et : ""), function(Mt) {
                    Mt ? w([]) : (_t["__MonotypeConfiguration__" + G] = function() {
                        return z.a
                    }, R())
                }).id = "__MonotypeAPIScript__" + G
            } else w([])
        };

        function F(w, R) {
            this.c = w, this.a = R
        }
        F.prototype.load = function(w) {
            var R, z, G = this.a.urls || [],
                et = this.a.families || [],
                _t = this.a.testStrings || {},
                Mt = new m;
            for (R = 0, z = G.length; R < z; R++) f(this.c, G[R], g(Mt));
            var de = [];
            for (R = 0, z = et.length; R < z; R++)
                if (G = et[R].split(":"), G[1])
                    for (var _e = G[1].split(","), Le = 0; Le < _e.length; Le += 1) de.push(new _(G[0], _e[Le]));
                else de.push(new _(G[0]));
            y(Mt, function() {
                w(de, _t)
            })
        };

        function $(w, R) {
            w ? this.c = w : this.c = Y, this.a = [], this.f = [], this.g = R || ""
        }
        var Y = "https://fonts.googleapis.com/css";

        function rt(w, R) {
            for (var z = R.length, G = 0; G < z; G++) {
                var et = R[G].split(":");
                et.length == 3 && w.f.push(et.pop());
                var _t = "";
                et.length == 2 && et[1] != "" && (_t = ":"), w.a.push(et.join(_t))
            }
        }

        function dt(w) {
            if (w.a.length == 0) throw Error("No fonts to load!");
            if (w.c.indexOf("kit=") != -1) return w.c;
            for (var R = w.a.length, z = [], G = 0; G < R; G++) z.push(w.a[G].replace(/ /g, "+"));
            return R = w.c + "?family=" + z.join("%7C"), 0 < w.f.length && (R += "&subset=" + w.f.join(",")), 0 < w.g.length && (R += "&text=" + encodeURIComponent(w.g)), R
        }

        function tt(w) {
            this.f = w, this.a = [], this.c = {}
        }
        var it = {
                latin: "BESbswy",
                "latin-ext": "\xE7\xF6\xFC\u011F\u015F",
                cyrillic: "\u0439\u044F\u0416",
                greek: "\u03B1\u03B2\u03A3",
                khmer: "\u1780\u1781\u1782",
                Hanuman: "\u1780\u1781\u1782"
            },
            Z = {
                thin: "1",
                extralight: "2",
                "extra-light": "2",
                ultralight: "2",
                "ultra-light": "2",
                light: "3",
                regular: "4",
                book: "4",
                medium: "5",
                "semi-bold": "6",
                semibold: "6",
                "demi-bold": "6",
                demibold: "6",
                bold: "7",
                "extra-bold": "8",
                extrabold: "8",
                "ultra-bold": "8",
                ultrabold: "8",
                black: "9",
                heavy: "9",
                l: "3",
                r: "4",
                b: "7"
            },
            Ct = {
                i: "i",
                italic: "i",
                n: "n",
                normal: "n"
            },
            yt = /^(thin|(?:(?:extra|ultra)-?)?light|regular|book|medium|(?:(?:semi|demi|extra|ultra)-?)?bold|black|heavy|l|r|b|[1-9]00)?(n|i|normal|italic)?$/;

        function At(w) {
            for (var R = w.f.length, z = 0; z < R; z++) {
                var G = w.f[z].split(":"),
                    et = G[0].replace(/\+/g, " "),
                    _t = ["n4"];
                if (2 <= G.length) {
                    var Mt, de = G[1];
                    if (Mt = [], de)
                        for (var de = de.split(","), _e = de.length, Le = 0; Le < _e; Le++) {
                            var Oe;
                            if (Oe = de[Le], Oe.match(/^[\w-]+$/)) {
                                var ei = yt.exec(Oe.toLowerCase());
                                if (ei == null) Oe = "";
                                else {
                                    if (Oe = ei[2], Oe = Oe == null || Oe == "" ? "n" : Ct[Oe], ei = ei[1], ei == null || ei == "") ei = "4";
                                    else var Yi = Z[ei],
                                        ei = Yi || (isNaN(ei) ? "4" : ei.substr(0, 1));
                                    Oe = [Oe, ei].join("")
                                }
                            } else Oe = "";
                            Oe && Mt.push(Oe)
                        }
                    0 < Mt.length && (_t = Mt), G.length == 3 && (G = G[2], Mt = [], G = G ? G.split(",") : Mt, 0 < G.length && (G = it[G[0]]) && (w.c[et] = G))
                }
                for (w.c[et] || (G = it[et]) && (w.c[et] = G), G = 0; G < _t.length; G += 1) w.a.push(new _(et, _t[G]))
            }
        }

        function Pt(w, R) {
            this.c = w, this.a = R
        }
        var Kt = {
            Arimo: !0,
            Cousine: !0,
            Tinos: !0
        };
        Pt.prototype.load = function(w) {
            var R = new m,
                z = this.c,
                G = new $(this.a.api, this.a.text),
                et = this.a.families;
            rt(G, et);
            var _t = new tt(et);
            At(_t), f(z, dt(G), g(R)), y(R, function() {
                w(_t.a, _t.c, Kt)
            })
        };

        function me(w, R) {
            this.c = w, this.a = R
        }
        me.prototype.load = function(w) {
            var R = this.a.id,
                z = this.c.o;
            R ? p(this.c, (this.a.api || "https://use.typekit.net") + "/" + R + ".js", function(G) {
                if (G) w([]);
                else if (z.Typekit && z.Typekit.config && z.Typekit.config.fn) {
                    G = z.Typekit.config.fn;
                    for (var et = [], _t = 0; _t < G.length; _t += 2)
                        for (var Mt = G[_t], de = G[_t + 1], _e = 0; _e < de.length; _e++) et.push(new _(Mt, de[_e]));
                    try {
                        z.Typekit.load({
                            events: !1,
                            classes: !1,
                            async: !0
                        })
                    } catch {}
                    w(et)
                }
            }, 2e3) : w([])
        };

        function ge(w, R) {
            this.c = w, this.f = R, this.a = []
        }
        ge.prototype.load = function(w) {
            var R = this.f.id,
                z = this.c.o,
                G = this;
            R ? (z.__webfontfontdeckmodule__ || (z.__webfontfontdeckmodule__ = {}), z.__webfontfontdeckmodule__[R] = function(et, _t) {
                for (var Mt = 0, de = _t.fonts.length; Mt < de; ++Mt) {
                    var _e = _t.fonts[Mt];
                    G.a.push(new _(_e.name, L("font-weight:" + _e.weight + ";font-style:" + _e.style)))
                }
                w(G.a)
            }, p(this.c, (this.f.api || "https://f.fontdeck.com/s/css/js/") + d(this.c) + "/" + R + ".js", function(et) {
                et && w([])
            })) : w([])
        };
        var oe = new Xt(window);
        oe.a.c.custom = function(w, R) {
            return new F(R, w)
        }, oe.a.c.fontdeck = function(w, R) {
            return new ge(R, w)
        }, oe.a.c.monotype = function(w, R) {
            return new M(R, w)
        }, oe.a.c.typekit = function(w, R) {
            return new me(R, w)
        }, oe.a.c.google = function(w, R) {
            return new Pt(R, w)
        };
        var ui = {
            load: s(oe.load, oe)
        };
        e.exports ? e.exports = ui : (window.WebFont = ui, window.WebFontConfig && oe.load(window.WebFontConfig))
    })()
})(H1);
var ZM = H1.exports;
console.log("[Client info] Cwal-230119A");
const Gg = navigator.language,
    qM = "1.7.0";
localStorage.getItem("settings_version");
const V1 = e => {
    const t = {
        ...e
    };
    return Object.keys(t).forEach(i => t[i] = Symbol()), t
};
let H, tl, bi, B, xn, Kf, Zf, qf, Jf, Vs;

function yh(e, t) {
    const i = {
            ...t
        },
        s = JSON.parse(localStorage.getItem(e));
    return s && Object.keys(i).forEach(n => {
        i[n] = s[n] ?? i[n]
    }), i
}

function z1(e, t) {
    return JSON.parse(localStorage.getItem(e)) ?? [...t]
}

function Qf(e, t) {
    return JSON.parse(localStorage.getItem(e)) ?? t
}
H = _i(yh("gconfig", Md));
tl = yh("mouse_map", G1);
bi = yh("key_map", sc);
B = yh("theme_data", nc);
xn = z1("blocked_users", []);
Zf = z1("profile_data", YM);
qf = Qf("profile_index", 0);
Jf = Qf("server", 0);
Kf = Qf("unit_num", KM); {
    const e = localStorage.getItem("locale");
    e ? Vs = JSON.parse(e) : (Vs = Pc.indexOf(Gg.replace("-", "_")), Vs === -1 && (Vs = Pc.indexOf(Gg.substring(0, 2)), Vs === -1 && (Vs = 3)))
}
localStorage.clear();
localStorage.setItem("gconfig", JSON.stringify(H));
localStorage.setItem("mouse_map", JSON.stringify(tl));
localStorage.setItem("key_map", JSON.stringify(bi));
localStorage.setItem("theme_data", JSON.stringify(B));
localStorage.setItem("blocked_users", JSON.stringify(xn));
localStorage.setItem("profile_data", JSON.stringify(Zf));
localStorage.setItem("profile_index", qf);
localStorage.setItem("server", Jf);
localStorage.setItem("locale", Vs);
localStorage.setItem("unit_num", Kf);
localStorage.setItem("settings_version", qM);
const Ut = V1(H),
    Ht = V1(B),
    JM = Pc[Vs],
    Gt = {
        packetCount: 0,
        mouseX: 0,
        mouseY: 0,
        svrMouseX: 0,
        svrMouseY: 0,
        syncStamp: performance.now(),
        lastSync: performance.now(),
        fps: 60,
        load: [],
        statistics: [],
        eventReaction: !1,
        renderer: null,
        subRenderer: null
    };

function Er() {
    return parseInt(H.AnimationDelay) - 1
}

function QM() {
    return H.CameraDelay
}
const $1 = parseInt(H.Quality);

function Lc() {
    return (B.Text[2] + 2) / 100 * $1
}

function Oc() {
    return B.TextStroke[2] / 1e3 * $1 * 1.1
}
const us = "Sawarabi Mincho, Shippori Mincho, Kiwi Maru, IBM Plex Sans KR, Do Hyeon, Open Sans, Noto Sans, Noto Sans JP, Titillium Web, Noto Sans TC, Noto Sans SC, Noto Sans KR",
    tR = "\u2039\u203A\xAB\xBB><\u25CA\u25B0\u25B1\u25C6\u25C7\u25CB\u25CE\u25CC\u25CD\u25CF\u25A0\u25A1\u25A2\u25A4\u25A5\u25A6\u25A7\u25A8\u25A9\u201C\u201D\u2018\u2019",
    eR = "\u3001_\u2013\u2014",
    iR = "+-\u25C8\u25A3\u25C9\u25AA\u25AB\u25AC\u25AD\u25AE\u25AF",
    sR = "=*\u2189\u215F\xBD\u2153\u2155\xBC\u2159\u2150\u215B\u2151\u2152\u2154\xBE\u2156\u2157\u2158\u215A\u215C\u215D\u215E\u2105\xD7\u035C",
    nR = ".\u2026\xB7'\"\u2018\u2019,\u201E[]{}/|\\1234567890a\xE1\xE0\u0103\xE2\xE5\u01FB\xE4\xE3\u0105\u0101\xE6\u01FDbc\u0107\u0109\u010D\u010B\xE7d\u010F\u0111\xF0e\xE9\xE8\u0115\xEA\u011B\xEB\u0117\u0119\u0113f\u0192g\u011F\u011D\u0121\u0123h\u0125\u0127i\xED\xEC\u012D\xEE\xEF\u0129\u012F\u012B\u0131j\u0135k\u0137l\u013A\u013E\u013C\u0142mn\u0144\u0148\xF1\u0146\u014Bo\xF3\xF2\u014F\xF4\xF6\u0151\xF5\xF8\u01FF\u014D\u0153pqr\u0155\u0159\u0157s\u015B\u015D\u0161\u015F\u0219\xDFt\u0165\u0163\u021B\u0167u\xFA\xF9\u016D\xFB\u016F\xFC\u0171\u0169\u0173\u016Bvw\u1E83\u1E81\u0175\u1E85xy\xFD\u1EF3\u0177\xFF\u1EF9z\u017A\u017E\u017C\xFEA\xC1\xC0\u0102\xC2\xC5\u01FA\xC4\xC3\u0104\u0100\xC6\u01FCBC\u0106\u0108\u010C\u010A\xC7D\u010E\u0110\xD0E\xC9\xC8\u0114\xCA\u011A\xCB\u0116\u0118\u0112FG\u011E\u011C\u0120\u0122H\u0124\u0126I\xCD\xCC\u012C\xCE\xCF\u0128\u0130\u012E\u012AJ\u0134K\u0136L\u0139\u013D\u013B\u0141MN\u0143\u0147\xD1\u0145\u014AO\xD3\xD2\u014E\xD4\xD6\u0150\xD5\xD8\u01FE\u014C\u0152PQR\u0154\u0158\u0156S\u015A\u015C\u0160\u015E\u0218T\u0164\u0162\u021A\u0166U\xDA\xD9\u016C\xDB\u016E\xDC\u0170\u0168\u0172\u016AVW\u1E82\u1E80\u0174\u1E84XY\xDD\u1EF2\u0176\u0178\u1EF8Z\u0179\u017D\u017B\xDE`\xB4^\xAF\xA8\xB8\xB0\xA9\xAE+\xB1\xF7\xD7<=>\xAC|\xA6~\xA4\xA2$\xA3\xA5!\xA1?\xBF@#&";
ZM.load({
    custom: {
        families: ["Sawarabi Mincho", "Shippori Mincho", "Kiwi Maru", "IBM Plex Sans KR", "Do Hyeon", "Open Sans", "Noto Sans", "Noto Sans JP"],
        urls: ["https://fonts.googleapis.com/css2?family=Sawarabi+Mincho&text=" + tR, "https://fonts.googleapis.com/css2?family=Shippori+Mincho&text=\u300E\u300F\u300C\u300D", "https://fonts.googleapis.com/css2?family=Kiwi+Maru&text=:;\uFF1A\uFF1B\uFF0C\u3002\u201A", "https://fonts.googleapis.com/css2?family=IBM+Plex+Sans+KR&text=" + eR, "https://fonts.googleapis.com/css2?family=Do+Hyeon&text=" + iR, "https://fonts.googleapis.com/css2?family=Open+Sans&text=\u20AA", "https://fonts.googleapis.com/css2?family=Noto+Sans&text=%", "https://fonts.googleapis.com/css2?family=Noto+Sans+JP&text=" + sR, "https://fonts.googleapis.com/css2?family=Titillium+Web&text=" + nR + ":wght@400..700"]
    },
    google: {
        families: ["Barlow Semi Condensed:200", "Noto Sans TC", "Noto Sans SC", "Noto Sans KR"]
    },
    active() {
        setTimeout(() => {
            A.emit("initFonts"), setTimeout(() => {
                A.emit("initFonts"), setTimeout(() => {
                    A.emit("initFonts")
                }, 3200)
            }, 800)
        }, 40), A.emit("startClient")
    }
});
class Vt {
    constructor(t, i, s) {
        I(this, "_func");
        I(this, "_interval");
        I(this, "_intervalFunc");
        I(this, "_endFunc");
        I(this, "executed", !1);
        this._func = t, this._intervalFunc = i, this._endFunc = s
    }
    execute(t) {
        return this._func(t), this._intervalFunc && !this.executed && (this._interval = setInterval(this._intervalFunc, 15)), this.executed = !0, this
    }
    end() {
        this.executed = !1, this._intervalFunc && clearInterval(this._interval), this._endFunc && this._endFunc()
    }
}
class rR {
    constructor(t, i, s) {
        this.view = t, this._o = i || 0, this._e = s
    }
    readUint8() {
        return this.view.getUint8(this._o++, this._e)
    }
    readInt8() {
        return this.view.getInt8(this._o++, this._e)
    }
    readUint16() {
        return this.view.getUint16((this._o += 2) - 2, this._e)
    }
    readInt16() {
        return this.view.getInt16((this._o += 2) - 2, this._e)
    }
    readUint24() {
        const t = this.readUint16();
        return this.readUint8() << 16 | t
    }
    readUint32() {
        return this.view.getUint32((this._o += 4) - 4, this._e)
    }
    readInt32() {
        return this.view.getInt32((this._o += 4) - 4, this._e)
    }
    readFloat32() {
        return this.view.getFloat32((this._o += 4) - 4, this._e)
    }
    readFloat64() {
        return this.view.getFloat64((this._o += 8) - 8, this._e)
    }
    readStringUTF8() {
        let t = "",
            i;
        for (;
            (i = this.readUint8()) !== 0;) t += String.fromCharCode(i);
        return decodeURIComponent(escape(t))
    }
}
class oR {
    constructor(t) {
        this.__buf = new DataView(new ArrayBuffer(8)), this._b = [], this._e = t
    }
    writeUint8(t) {
        return t >= 0 && t < 256 && this._b.push(t), this
    }
    writeInt8(t) {
        return t >= -128 && t < 128 && this._b.push(t), this
    }
    writeUint16(t) {
        return this.__buf.setUint16(0, t, this._e), this._move(2), this
    }
    writeInt16(t) {
        return this.__buf.setInt16(0, t, this._e), this._move(2), this
    }
    writeUint32(t) {
        return this.__buf.setUint32(0, t, this._e), this._move(4), this
    }
    writeUint64(t) {
        let i = t / 4294967296 >> 0,
            s = t - i * 2 ** 32;
        return this.writeUint32(i), this.writeUint32(s), this
    }
    writeInt32(t) {
        return this.__buf.setInt32(0, t, this._e), this._move(4), this
    }
    writeFloat32(t) {
        return this.__buf.setFloat32(0, t, this._e), this._move(4), this
    }
    writeFloat64(t) {
        return this.__buf.setFloat64(0, t, this._e), this._move(8), this
    }
    writeStringUTF8(t) {
        return this._b.push(...new TextEncoder("utf-8").encode(t)), this._b.push(0), this
    }
    _move(t) {
        for (var i = 0; i < t; i++) this._b.push(this.__buf.getUint8(i))
    }
}
class wi {
    constructor(t, i) {
        I(this, "capacity");
        I(this, "pool");
        I(this, "Type");
        this.Type = t, this.pool = new Array(i), this.capacity = i;
        for (let s = 0; s < i; s++) this.pool[s] = new t
    }
    expand(t) {
        for (let i = 0; i < t; i++) this.pool.push(new Type)
    }
    allocate() {
        return this.pool.length <= 0 ? new this.Type : this.pool.pop()
    }
    release(t) {
        this.pool.length <= this.capacity * 1.125 && this.pool.push(t)
    }
}
const We = parseInt(H.Quality),
    on = Math.max(parseInt(H.Resolution), 1),
    rc = .01,
    aR = Hi.LINEAR;
He._experimentalLetterSpacingSupported = !0;
He.experimentalLetterSpacing = !0;
Nt.defaultOptions.scaleMode = aR;
Nt.defaultOptions.mipmap = H.Mipmap * 2;
A.on(Ut.Mipmap, () => {
    Nt.defaultOptions.mipmap = H.Mipmap * 2, Object.values(mi).forEach(e => {
        e.mipmap = H.Mipmap * 2
    }), A.emit(Ht.Text)
});
const bh = 16,
    As = new wi(hi, bh),
    Rd = new wi(ae, bh),
    j1 = new wi(ke, bh),
    W1 = new wi(ys, bh),
    ie = new Map,
    mt = We * on,
    el = (e, t, i) => {
        const s = document.createElement("canvas"),
            n = s.getContext("2d");
        s.width = mt * 2, s.height = mt * 2, n.fillStyle = "#ffffff", n.beginPath(), t ? (n.arc(mt, mt, mt, 0, Math.PI * 2, !1), n.arc(mt, mt, mt * t, 0, Math.PI * 2, !0), n.fill()) : (n.arc(mt, mt, mt, 0, Math.PI * 2, !1), n.fill()), i && (n.beginPath(), n.arc(mt, mt, mt * ((1 - t) / 2 + t), 0, Math.PI * 2), n.globalAlpha = i, n.fill());
        const r = ht.from(s, {
                resolution: on
            }),
            o = ie.get(e);
        o ? (o.baseTexture = r.baseTexture, r.destroy()) : ie.set(e, r)
    };
el("BASE");
el("ROUND_VIRUS", .865, .2);
const X1 = (e, t, i, s) => {
    const n = document.createElement("canvas"),
        r = n.getContext("2d"),
        o = mt * .0625;
    n.width = (mt + o) * 2, n.height = (mt + o) * 2, r.fillStyle = "#ffffff", r.strokeStyle = "#ffffff", r.lineWidth = mt * i, r.lineJoin = "round";
    const a = mt + o,
        l = 360 / t / 180 * Math.PI,
        c = l / 2,
        h = mt * (1 - i / 2) + o,
        u = mt * (1 - i / 2) - o;
    for (let p = 0; p <= t; p++) r.lineTo(Math.cos(p * l) * h + a, -Math.sin(p * l) * h + a), r.lineTo(Math.cos(p * l + c) * u + a, -Math.sin(p * l + c) * u + a);
    r.closePath(), r.stroke(), r.globalAlpha = s, r.fill();
    const d = ht.from(n, {
            resolution: on
        }),
        f = ie.get(e);
    f ? (f.baseTexture = d.baseTexture, d.destroy()) : ie.set(e, d)
};
X1("VIRUS", 25, .08, .2);
X1("CVIRUS", 30, .0625, .2);
const lR = (e, t, i, s, n) => {
    const r = document.createElement("canvas"),
        o = r.getContext("2d");
    r.width = mt * 2, r.height = mt * 2, o.fillStyle = "#ffffff", o.strokeStyle = "#ffffff", o.lineWidth = mt * i, o.lineJoin = "round";
    const a = 360 / t / 180 * Math.PI,
        l = mt * (1 - i / 2);
    for (let u = 0; u <= t; u++) o.lineTo(Math.cos(u * a) * l + mt, -Math.sin(u * a) * l + mt);
    o.closePath(), o.stroke(), o.globalAlpha = s, o.fill();
    const c = ht.from(r, {
            resolution: on
        }),
        h = ie.get(e);
    h ? (h.baseTexture = c.baseTexture, c.destroy()) : ie.set(e, c)
};
lR("BLASTER_SPORE", 8, .2, .2);
const Y1 = () => {
        const e = 1 - B.MassMarker[2] / 100;
        el("MASS_MARKER", e)
    },
    K1 = () => {
        const e = 1 - B.SplitOrderMarker[2] / 100;
        el("SPLIT_ORDER_MARKER", e)
    },
    Z1 = () => {
        const e = 1 - B.AutosplitAlert[2] / 100;
        el("AUTOSPLIT_ALERT1", e)
    },
    q1 = () => {
        const e = document.createElement("canvas"),
            t = e.getContext("2d");
        e.width = mt * 2, e.height = mt * 2, t.fillStyle = "#ffffff";
        let s = B.AutosplitAlert[2] / 100 * .618;
        t.beginPath(), t.arc(mt, mt, mt, 0, Math.PI * 2, !1), t.arc(mt, mt, mt * (1 - s), 0, Math.PI * 2, !0), t.fill(), s *= .618, t.beginPath(), t.arc(mt, mt, mt * (1 - s * 2.35), 0, Math.PI * 2, !1), t.arc(mt, mt, mt * (1 - s * 3.35), 0, Math.PI * 2, !0), t.fill();
        const n = ht.from(e, {
                resolution: on
            }),
            r = "AUTOSPLIT_ALERT2",
            o = ie.get(r);
        o ? (o.baseTexture = n.baseTexture, n.destroy()) : ie.set(r, n)
    },
    cR = () => {
        const e = document.createElement("canvas"),
            t = e.getContext("2d");
        e.width = mt * 2, e.height = mt * 2, t.lineJoin = "round", t.fillStyle = "#000000", t.globalAlpha = .3, t.beginPath(), t.arc(mt, mt, mt, 0, Math.PI * 2, !1), t.fill(), t.globalAlpha = .8, t.fillStyle = "#ffffff", t.beginPath(), t.arc(mt, mt, mt * .935, 0, Math.PI * 2, !1), t.arc(mt, mt, mt * .8, 0, Math.PI * 2, !0), t.fill(), t.strokeStyle = "#ffffff", t.lineWidth = mt * .1;
        const i = (.707 - .14) * mt;
        t.beginPath(), t.moveTo(mt + i, mt - i), t.lineTo(mt - i, mt + i), t.stroke();
        const s = ht.from(e, {
                resolution: on
            }),
            n = "ENEMY_HINT",
            r = ie.get(n);
        r ? (r.baseTexture = s.baseTexture, s.destroy()) : ie.set(n, s)
    },
    hR = () => {
        const e = document.createElement("canvas"),
            t = e.getContext("2d");
        e.width = mt * 2, e.height = mt * 2;
        const i = t.createRadialGradient(mt, mt, mt * .75, mt, mt, mt);
        i.addColorStop(0, "transparent"), i.addColorStop(1, "white"), t.fillStyle = i, t.beginPath(), t.arc(mt, mt, mt, 0, Math.PI * 2, !1), t.fill();
        const s = ht.from(e, {
                resolution: on
            }),
            n = "WAVE",
            r = ie.get(n);
        r ? (r.baseTexture = s.baseTexture, s.destroy()) : ie.set(n, s)
    },
    uR = () => {
        const e = document.createElement("canvas"),
            t = e.getContext("2d"),
            i = mt / 4,
            s = i * .5,
            n = i * .2;
        e.width = i, e.height = i, t.fillStyle = "#ffffff", t.moveTo(n, 0), t.lineTo(0, n), t.lineTo(s, s), t.closePath(), t.moveTo(i - n, 0), t.lineTo(i, n), t.lineTo(s, s), t.closePath(), t.moveTo(i - n, i), t.lineTo(i, i - n), t.lineTo(s, s), t.closePath(), t.moveTo(n, i), t.lineTo(0, i - n), t.lineTo(s, s), t.closePath(), t.fill();
        const r = ht.from(e, {
                resolution: on
            }),
            o = "MOVE_POINT",
            a = ie.get(o);
        a ? (a.baseTexture = r.baseTexture, r.destroy()) : ie.set(o, r)
    };
cR();
Y1();
K1();
Z1();
q1();
hR();
uR();
A.on(Ht.MassMarker, Y1);
A.on(Ht.SplitOrderMarker, K1);
A.on(Ht.AutosplitAlert, () => {
    Z1(), q1()
});
const J1 = [14483642, 16711680, 16737792, 16776960, 65535, 2003199, 2088735, 32e3, 204],
    Hg = new ki({
        fontFamily: "Barlow Semi Condensed",
        fontWeight: "200",
        fill: 16777215,
        fontSize: 400
    });
class dR extends ae {
    constructor() {
        super();
        I(this, "canvas", document.createElement("canvas"));
        I(this, "background", new hi);
        I(this, "mask", new ke);
        I(this, "border", new ke);
        I(this, "borderGlow", new hi);
        I(this, "borderGlowMask", new ke);
        I(this, "innerWidth", 0);
        I(this, "innerHeight", 0);
        I(this, "edge", new ke);
        I(this, "coords", new ke);
        I(this, "coordsText", new ae)
    }
    get coordsFontTint() {
        return parseInt(`0x${B.CoordsFont[0]}`)
    }
    get coordsFontAlpha() {
        return B.CoordsFont[1]
    }
    get coordsGridTint() {
        return parseInt(`0x${B.CoordsGrid[0]}`)
    }
    get coordsGridAlpha() {
        return B.CoordsGrid[1]
    }
    get borderTint() {
        return parseInt(`0x${B.Border[0]}`)
    }
    get borderAlpha() {
        return B.Border[1]
    }
    get borderGlowTint() {
        return parseInt(`0x${B.BorderGlow[0]}`)
    }
    get borderGlowAlpha() {
        return B.BorderGlow[1]
    }
    get backgroundTint() {
        return parseInt(`0x${B.BackgroundImage[0]}`)
    }
    get backgroundAlpha() {
        return B.BackgroundImage[1]
    }
    get url() {
        return B.BackgroundImage[2]
    }
    init() {
        this.background.mask = this.mask, this.coords.mask = this.mask, this.coordsText.mask = this.mask, this.borderGlow.mask = this.borderGlowMask, this.coords.blendMode = j.NONE, this.edge.blendMode = j.NONE, this.borderGlow.texture = ht.from(this.canvas, {
            mipmap: ds.ON
        }), this.borderGlow.blendMode = j.LIGHTEN;
        let i;
        for (let s = 0; s < 25; s++) i = new ys("", Hg), i.scale.set(4), this.coordsText.addChild(i)
    }
    deploy() {
        this.deployBackgroundStyle(), this.deployBorderStyle(), this.deployCoordsStyle()
    }
    deployBackgroundStyle() {
        this.background.tint = this.backgroundTint, this.background.alpha = this.backgroundAlpha
    }
    deployBorderStyle() {
        this.border.tint = this.borderTint, this.border.alpha = this.borderAlpha, this.borderGlow.tint = this.borderGlowTint, this.borderGlow.alpha = this.borderGlowAlpha
    }
    deployCoordsStyle() {
        const i = this.coordsGridTint,
            s = this.coordsGridAlpha;
        this.edge.tint = i, this.edge.alpha = s, this.coords.tint = i, this.coords.alpha = s, this.coordsText.tint = this.coordsFontTint, this.coordsText.alpha = this.coordsFontAlpha
    }
    assembly() {
        this.addChild(this.background, this.mask, this.borderGlowMask, this.coords, this.coordsText, this.edge, this.borderGlow, this.border)
    }
    setup() {
        return this.init(), this.deploy(), this.assembly(), this
    }
    drawRectBorderGlow(i, s, n, r) {
        const [a, l, c, h] = Bg(i, s, n, r, 37.5), u = 3250, d = l - a, f = h - c;
        this.innerWidth = d, this.innerHeight = f;
        const p = u / d,
            m = f / d * u / d,
            g = this.canvas,
            y = g.getContext("2d"),
            x = 325 * p + 5,
            v = 50 * p >> 0;
        g.width = u + x * 2, g.height = f / d * u + x * 2, y.lineWidth = v, y.strokeStyle = "#ffffff", y.globalAlpha = 1, y.shadowBlur = 0, y.shadowColor = "#ffffff", y.beginPath();
        const _ = (a - i) * p + x + v,
            C = (c - n) * m + x + v,
            k = u,
            S = u * f / d;
        y.rect(_, C, k, S), y.save(), y.clip(), y.globalAlpha = .75, y.shadowBlur = x, y.stroke(), y.restore(), y.globalAlpha = 1, y.shadowBlur = x * .625, y.stroke(), y.globalAlpha = .75, y.stroke(), y.shadowBlur = x * .5, y.stroke(), this.borderGlow.texture.update();
        const T = 37.5 * p,
            L = 37.5 * m;
        this.borderGlow.position.set(a - (x + v + 1 - T) / p, c - (x + v + 1 - L) / p), this.borderGlow.scale.set(1 / p);
        const [D, O, K, P] = Bg(i, s, n, r, 75);
        this.borderGlowMask.beginFill(16777215, 1).drawRect(i, n, s - i, r - n).endFill().lineStyle({
            width: 500,
            color: 16777215,
            alignment: 1,
            alpha: 1
        }).drawRect(D, K, O - D, P - K)
    }
    drawOctaBorderGlow(i) {
        const n = Ug(i, 37.5),
            r = 3250,
            [o, a, l, c] = [n[14], n[1], n[6], n[9]],
            h = l - o,
            u = c - a;
        this.innerWidth = h, this.innerHeight = u;
        const d = r / h,
            f = u / h * r / h,
            p = this.canvas,
            m = p.getContext("2d"),
            g = 325 * d + 5,
            y = 50 * d >> 0;
        p.width = r + g * 2 + y, p.height = u / h * r + g * 2 + y, m.lineWidth = y, m.strokeStyle = "#ffffff", m.globalAlpha = 1, m.shadowBlur = 0, m.shadowColor = "#ffffff";
        let x, v, _ = n.length;
        m.beginPath();
        for (let T = 0; T < _;) x = (n[T++] - (o + 37.5)) * d + g + y, v = (n[T++] - (a + 37.5)) * f + g + y, m.lineTo(x, v);
        m.closePath(), m.save(), m.clip(), m.globalAlpha = .75, m.shadowBlur = g, m.stroke(), m.restore(), m.globalAlpha = 1, m.shadowBlur = g * .625, m.stroke(), m.globalAlpha = .75, m.stroke(), m.shadowBlur = g * .5, m.stroke(), this.borderGlow.texture.update();
        const C = 37.5 * d,
            k = 37.5 * f;
        this.borderGlow.position.set(o - (g + y + 1 - C) / d, a - (g + y + 1 - k) / d), this.borderGlow.scale.set(1 / d);
        const S = Ug(i, 75);
        this.borderGlowMask.beginFill(16777215, 1).drawPolygon(i).endFill().lineStyle({
            width: 500,
            color: 16777215,
            alignment: 1,
            alpha: 1
        }).drawPolygon(S)
    }
    drawCoords(i, s, n, r, o) {
        const a = (n - i) / 5,
            l = (r - s) / 5,
            c = this.coords;
        c.lineStyle(o, 16777215, .5);
        var h, u;
        for (let g = 1; g < 5; g++) h = g * a + i, u = g * l + s, c.moveTo(h, s).lineTo(h, r).moveTo(i, u).lineTo(n, u);
        let d, f, p;
        Hg.fontSize = 155 * o / 10;
        const m = this.coordsText.children;
        for (let g = m.length - 1; g >= 0; g--) p = m[g], p.visible = !0, f = g % 5, d = g / 5 >> 0, p.text = String.fromCharCode(65 + d) + (f + 1), p.x = f * a + a / 2 - p.width / 2 + i, p.y = d * l + l / 2 - p.height / 2 + s
    }
    drawRectMap(i, s, n, r) {
        this.clear(), this.mask.beginFill(16777215).drawRect(i, n, s - i, r - n).endFill(), this.border.lineStyle({
            width: 75,
            color: 16777215,
            alignment: 1,
            alpha: 1
        }).drawRect(i, n, s - i, r - n).endFill(), this.drawRectBorderGlow(i, s, n, r);
        const [o, a, l, c] = [i, n, s, r], h = (l - o + c - a) / 14142 * 10;
        this.edge.lineStyle({
            width: h,
            color: 16777215,
            alignment: .5,
            alpha: .5
        }).drawRect(i, n, s - i, r - n).endFill(), this.drawCoords(o, a, l, c, h), this.background.position.set(o, a)
    }
    drawOctagonMap(i) {
        this.clear(), this.mask.beginFill(16777215).drawPolygon(i).endFill(), this.border.lineStyle({
            width: 75,
            color: 16777215,
            alignment: 1,
            alpha: 1
        }).drawPolygon(i).endFill(), this.drawOctaBorderGlow(i);
        const [s, n, r, o] = [i[14], i[1], i[6], i[9]], a = r - s, l = o - n, c = (a + l) / 14142 * 10;
        this.edge.lineStyle({
            width: c,
            color: 16777215,
            alignment: .5,
            alpha: .5
        }).drawPolygon(i).endFill(), this.drawCoords(s, n, r, o, c), this.background.position.set(s, n)
    }
    async drawBackground() {
        const {
            url: i
        } = this;
        this._url = i, i ? this.background.texture = await fR(i, this.innerWidth, this.innerHeight).catch(s => null) : this.background.texture = null
    }
    clear() {
        this.mask.clear(), this.border.clear(), this.borderGlowMask.clear(), this.coords.clear();
        const i = this.coordsText.children;
        for (let s = i.length - 1; s >= 0; s--) i[s].visible = !1;
        this.edge.clear(), this.canvas.width = 0, this.canvas.height = 0, this.borderGlow.texture.update()
    }
    reset() {
        this.clear()
    }
}
async function fR(e, t, i) {
    const s = new Image;
    s.crossOrigin = "Anonymous", s.src = e;
    let n = null;
    if (!(await s.decode().catch(r => r) instanceof Error)) {
        const r = Math.min(t, i),
            o = Math.min(s.width, s.height),
            a = r / o;
        s.width *= a, s.height *= a, n = ht.from(s)
    }
    return n
}
var ue = (e, t) => {
    const i = e.__vccOpts || e;
    for (const [s, n] of t) i[s] = n;
    return i
};
const pR = {
        props: {
            max: String,
            val: Number
        },
        setup(e, {
            emit: t
        }) {
            const i = ft(null),
                s = ft(null),
                n = ft(null),
                r = Ft(() => o(e.max));

            function o(u) {
                const d = u % 25,
                    f = (u - d) / 25 % 60;
                return (u - d - f * 25) / 60 + ":" + kc(f) + "." + kc(d)
            }

            function a(u) {
                const [d, f] = u.split(":"), [p, m] = f.split(".");
                return d * 60 * 25 + p * 25 + m * 1
            }

            function l(u) {
                let d = (u - 0) / (e.max - 0);
                isNaN(d) && (d = 0);
                const f = `${d*92.5}%`;
                i.value.style.width = f, n.value.value = o(u)
            }

            function c() {
                if (/^\d{1,2}:\d\d\.\d\d$/.test(n.value.value)) {
                    let d = a(n.value.value);
                    d = d < 0 ? 0 : d > e.max ? e.max : d, h(d)
                } else h(s.value.value)
            }

            function h(u) {
                n.value.value = o(u), t("changeVal", Number(u))
            }
            return Aa(() => e.val, (u, d) => l(u)), Ve(() => {
                l(e.val)
            }), Pr(() => {
                l(e.val)
            }), {
                selection: i,
                slider: s,
                valEl: n,
                duration: r,
                checkStyle: l,
                checkVal: c,
                change: h
            }
        }
    },
    mR = {
        class: "slider-row"
    },
    gR = {
        class: "slider-name"
    },
    vR = {
        class: "slider-input"
    },
    _R = ["value"],
    yR = {
        class: "slider-box"
    },
    bR = {
        ref: "selection",
        class: "slider-selection"
    },
    xR = {
        class: "slider-track"
    },
    wR = ["max", "value"];

function TR(e, t, i, s, n, r) {
    return st(), nt("div", mR, [b("label", gR, Ot(" / " + s.duration), 1), b("div", vR, [b("input", {
        ref: "valEl",
        type: "text",
        class: "rounded-0 form-control",
        tabindex: "-1",
        value: "0:00.00",
        onBlur: t[0] || (t[0] = (...o) => s.checkVal && s.checkVal(...o))
    }, null, 40, _R)]), b("div", yR, [b("div", bR, null, 512), b("div", xR, [b("input", {
        ref: "slider",
        class: "slider",
        type: "range",
        min: 0,
        max: i.max,
        step: 1,
        value: i.val,
        onInput: t[1] || (t[1] = o => s.change(o.target.value))
    }, null, 40, wR)])])])
}
var ER = ue(pR, [
    ["render", TR],
    ["__scopeId", "data-v-bf5f766c"]
]);
let SR = 0;
class xh {
    constructor() {
        I(this, "id");
        I(this, "ox");
        I(this, "oy");
        I(this, "or");
        I(this, "nx");
        I(this, "ny");
        I(this, "nr");
        I(this, "massValue");
        I(this, "finalAlpha");
        I(this, "lastSync");
        I(this, "floatTime");
        I(this, "uSig");
        I(this, "state");
        I(this, "baseLayer", new hi)
    }
    get displayObject() {
        return this.baseLayer
    }
    get x() {
        return this.displayObject.x
    }
    get y() {
        return this.displayObject.y
    }
    get r() {
        return this.displayObject.scale.x * We
    }
    get globalScale() {
        return this.r * ba.scale.x
    }
    get baseLayerTint() {
        return 16777215
    }
    get baseLayerAlpha() {
        return 1
    }
    get textVisibility() {
        return this.globalScale > 35
    }
    get moved() {
        return Ui(this.ox, this.nx, rc) && Ui(this.oy, this.ny, rc)
    }
    get resized() {
        return Ui(this.or, this.nr, rc)
    }
    get dead() {
        return Ui(0, .9 * Er(), performance.now() - this.floatTime)
    }
    get transparencyStatus() {
        return Ui(this.displayObject.alpha, this.finalAlpha, .05)
    }
    setPosition(t, i) {
        this.displayObject.position.set(t, i)
    }
    setSize(t) {
        this.displayObject.zIndex = t >> 0, this.displayObject.scale.set(t / We)
    }
    setAlpha(t) {
        this.displayObject.alpha = t
    }
    updateText() {}
    sync() {
        this.ox = this.x, this.oy = this.y, this.or = this.r
    }
    preUpdate(t, i, s) {
        s && (this.nr = s ** .5 * 10), this.nx = t ?? this.nx, this.ny = i ?? this.ny, this.massValue = s ?? this.massValue
    }
    preDeath(t) {
        this.floatTime = t, this.update_linear(vi(Gt.syncStamp, t, Er() * 1.08)), this.sync()
    }
    preDisappear(t) {
        this.floatTime = t, this.finalAlpha = 0
    }
    preAppear(t) {
        this.floatTime = t, this.setAlpha(0)
    }
    fixPosition() {
        const t = this.moved;
        return t && (this.ox = this.nx, this.oy = this.ny, this.setPosition(this.nx, this.ny)), t
    }
    fixSize() {
        const t = this.resized;
        return t && (this.or = this.nr, this.setSize(this.nr)), t
    }
    fixUpdate() {
        const t = this.fixPosition(),
            i = this.fixSize();
        return t && i
    }
    fixDeath() {
        const t = this.dead;
        return t && this.release(), t
    }
    fixDisappear() {
        const t = this.transparencyStatus;
        return t && this.release(), t
    }
    fixAppear() {
        const t = this.transparencyStatus;
        return t && this.setAlpha(this.finalAlpha), t
    }
    move(t, i, s, n, r) {
        this.setPosition(Ze(t, s, r), Ze(i, n, r))
    }
    resize(t, i, s) {
        this.setSize(Ze(t, i, s))
    }
    update(t, i, s, n, r, o, a) {
        return this.moved || this.move(t, i, n, r, a), this.resized || this.resize(s, o, a), this.fixUpdate()
    }
    update_linear(t) {
        return this.update(this.ox, this.oy, this.or, this.nx, this.ny, this.nr, t)
    }
    update_gradually(t) {
        return this.update(this.x, this.y, this.r, this.nx, this.ny, this.nr, t)
    }
    death(t) {
        return this.update(this.ox, this.oy, this.or, this.nx, this.ny, this.nr, vi(this.floatTime, t, Er() * 1.08) ** 2), this.fixDeath()
    }
    disappear(t) {
        return this.setAlpha(Ze(this.displayObject.alpha, this.finalAlpha, vi(this.floatTime, t, 400))), this.fixDisappear()
    }
    appear(t) {
        return this.setAlpha(Ze(this.displayObject.alpha, this.finalAlpha, vi(this.floatTime, t, 400))), this.fixAppear()
    }
    init(t, i, s, n, r) {
        return this.id = i, this._init(t, s, n, r), this.displayObject.interactive = !1, ci.state || (this.uSig = SR++), this
    }
    _init(t, i, s, n) {
        const r = n ** .5 * 10;
        this.massValue = n, this.ox = this.nx = i, this.oy = this.ny = s, this.or = this.nr = r, this.lastSync = t, this.setPosition(this.ox, this.oy), this.setSize(this.or)
    }
    deploy() {
        return this.deployBaseLayerStyle(), this
    }
    deployBaseLayerStyle() {
        this.baseLayer.tint = this.baseLayerTint, this.finalAlpha = this.baseLayerAlpha, this.setAlpha(this.baseLayerAlpha)
    }
    assembly() {}
    release() {}
}
class tp extends xh {
    constructor() {
        super(...arguments);
        I(this, "box", new ae);
        I(this, "mass", new $e("", {
            fontName: "ENTITY_TEXT"
        }))
    }
    get displayObject() {
        return this.box
    }
    get massVisibility() {
        return this.textVisibility
    }
    get massTint() {
        return 16777215
    }
    get massAlpha() {
        return 1
    }
    setSize(i) {
        super.setSize(i), this.updateMass(i), this.checkTextScale()
    }
    updateText() {
        this.mass.updateText()
    }
    fixSize() {
        const i = this.resized;
        return i && (this.or = this.nr, this.setSize(this.nr), this.mass.text = this.massValue >> 0), i
    }
    updateMass(i) {
        this.mass.text = (this.massValue + i ** 2 / 100) / 2 >> 0
    }
    init(i, s, n, r, o) {
        return super.init(i, s, n, r, o), this.mass.position.set(0), this.mass.anchor.set(.5), this.mass.letterSpacing = 4, this.fixSize(this.r), this
    }
    checkTextScale() {
        this.deployMassVisibility()
    }
    deploy() {
        return super.deploy(), this.deployMassStyle(), this.deployMassVisibility(), this
    }
    deployMassVisibility() {
        this.mass.visible = this.massVisibility
    }
    deployMassStyle() {
        this.mass.tint = this.massTint, this.mass.alpha = this.massAlpha
    }
    assembly() {
        this.box.addChild(this.baseLayer, this.mass)
    }
}
class ep extends tp {
    constructor(i = !1) {
        super();
        I(this, "massLevel", -1);
        I(this, "asaColor", -1);
        I(this, "assistance", Rd.allocate());
        I(this, "tag", As.allocate());
        I(this, "nick", As.allocate());
        I(this, "color");
        I(this, "player");
        I(this, "opUnit");
        I(this, "MassMarker", As.allocate());
        I(this, "AutosplitAlert", As.allocate());
        I(this, "EnemyHint", As.allocate());
        this.box.on("mousedown", s => this.onDown(s)), this.box.on("pointerdown", s => this.onDown(s)), this.baseLayer.texture = ie.get("BASE"), this.baseLayer.position.set(0), this.baseLayer.scale.set(1), this.baseLayer.anchor.set(.5), this.tag.position.set(0), this.tag.scale.set(1), this.tag.anchor.set(.5), this.nick.position.set(0), this.nick.scale.set(1), this.nick.anchor.set(.5), this.mass.position.set(0, We * .45), this.assistance.position.set(-We), this.assistance.scale.set(1), this.MassMarker.texture = ie.get("MASS_MARKER"), this.EnemyHint.texture = ie.get("ENEMY_HINT"), this.AutosplitAlert.texture = ie.get("AUTOSPLIT_ALERT1"), i || this.assembly()
    }
    get type() {
        return this.state == 1 ? 110 : 111
    }
    get inSelfTeam() {
        return U.team == this.player.team
    }
    get skinVisibility() {
        return H.ShowSkin && this.skinAlpha
    }
    get nickVisibility() {
        return this.textVisibility && H.ShowNick
    }
    get massVisibility() {
        return this.textVisibility && H.ShowMass
    }
    get entityTint() {
        return this.inSelfTeam ? Be(B.CellTeam[0]) ?? this.color : Be(B.CellEnemy[0]) ?? this.color
    }
    get entityAlpha() {
        return this.inSelfTeam ? B.CellTeam[1] : B.CellEnemy[1]
    }
    get skinTint() {
        return this.inSelfTeam ? Be(B.SkinTeam[0]) : Be(B.SkinEnemy[0])
    }
    get skinAlpha() {
        return this.inSelfTeam ? B.SkinTeam[1] : B.SkinEnemy[1]
    }
    get MassMarkerAlpha() {
        return B.MassMarker[1]
    }
    get MassMarkerSize() {
        return B.MassMarker[2]
    }
    get AutosplitAlertAlpha() {
        return B.AutosplitAlert[1]
    }
    get AutosplitAlertSize() {
        return B.AutosplitAlert[2]
    }
    get EnemyHintVisibility() {
        return U.state % 2 && H.ShowEnemyHint && !this.opUnit.isBot && !this.inSelfTeam
    }
    get interactive() {
        return U.state >= 2
    }
    set interactive(i) {
        this.box.interactive = i
    }
    get viewport() {
        const i = this.nr * 1.125 + 256,
            s = this.nr * 1.125 + 154;
        return {
            x: this.nx - i,
            y: this.ny - s,
            w: i,
            h: s,
            color: U.state === 2 ? 16777215 : this.color
        }
    }
    setNick() {
        const i = this.player.team.tagText;
        this.tag.texture = i ? i.texture : null, this.nick.texture = this.opUnit.nickText.texture
    }
    preDeath(i) {
        super.preDeath(i), this.unbindOpUnit()
    }
    preDisappear(i) {
        super.preDisappear(i), this.unbindOpUnit()
    }
    resize(i, s, n) {
        super.resize(i, s, n)
    }
    syncUpdate() {
        this.updateMassLevel()
    }
    frameUpdate() {
        this.updateAutosplitAlert(), this.drawAssistance(), this.EnemyHint.visible = this.EnemyHintVisibility, this.EnemyHint.tint = this.player.team.color
    }
    updateMassLevel() {
        if (!U.largest) {
            this.massLevel != -1 && (this.massLevel = -1, this.assistance.needUpdate = !0);
            return
        }
        let s = this.massValue,
            n = U.largest.massValue,
            r = 4 * n * 1.3,
            o = 2 * n * 1.3,
            a = n * 1.3,
            l = n / 1.3,
            c = n / 2 * 1.3,
            h = n / 2 / 1.3,
            u = n / 4 / 1.3,
            d = n / 8 * 1.3,
            f = n / 8 / 1.3,
            p = s > r ? 0 : s > o ? 1 : s > a ? 2 : s > l ? 3 : s > c ? 4 : s > h ? 5 : s > u ? 6 : s > d ? 7 : s > f ? 8 : -1;
        this.massLevel != p && (this.massLevel = p, this.assistance.needUpdate = !0)
    }
    updateAutosplitAlert() {
        if (this.massValue < 17188.5) {
            this.asaColor != -1 && (this.asaColor = -1, this.assistance.needUpdate = !0);
            return
        }
        let i = Gt.lastFrame / (16 * 25) * .5 % 1 * 2;
        i > 1 && (i = 2 - i);
        let s = i * (.33 - 0) + 0;
        this.asaColor = 16777215 & function(n, r, o, a) {
            let l = (1 - r) * o,
                c = o - l,
                h = 6 * n,
                u = 0,
                d = 0,
                f = 0;
            return h < 1 ? (u = o, d = h * c + l, f = l) : h < 2 ? (u = (2 - h) * c + l, d = o, f = l) : h < 3 ? (u = l, d = o, f = (h - 2) * c + l) : h < 4 ? (u = l, d = (4 - h) * c + l, f = o) : h < 5 ? (u = (h - 4) * c + l, d = l, f = o) : (u = o, d = l, f = (6 - h) * c + l), 255 * a >> 0 << 24 | 255 * u >> 0 << 16 | 255 * d >> 0 << 8 | 255 * f >> 0
        }(s, 1, 1, 1), this.assistance.needUpdate = !0
    }
    drawAssistance() {
        if (!this.assistance.needUpdate) return;
        const i = this.MassMarker,
            s = this.AutosplitAlert;
        i.visible = !1, s.visible = !1, this.assistance.needUpdate = !1;
        let n, r;
        if (H.ShowAutosplitAlert && this.asaColor != -1) {
            n = this.asaColor, r = this.AutosplitAlertAlpha, s.visible = !0, s.tint = n, s.alpha = r, this.massValue < 2e4 ? s.texture = ie.get("AUTOSPLIT_ALERT1") : s.texture = ie.get("AUTOSPLIT_ALERT2");
            return
        }
        H.ShowMassMarker && this.massLevel != -1 && (n = J1[this.massLevel], r = this.MassMarkerAlpha, i.visible = !0, i.tint = n, i.alpha = r)
    }
    onDown(i) {
        if (i.button != 0) return;
        i.stopImmediatePropagation(), Gt.eventReaction = !0;
        const s = this.opUnit.id != 15 ? this.player.id : 0;
        A.emit("selectSpectate", s)
    }
    init(i, s, n, r, o, a, l, c) {
        return super.init(i, s, n, r, o), this.color = a, this.player = l, this.opUnit = c, this.assistance.needUpdate = !0, this.bindOpUnit(), this
    }
    bindOpUnit() {
        this.opUnit.bindPlayerCell(this)
    }
    unbindOpUnit() {
        this.opUnit.unbindPlayerCell(this)
    }
    checkTextScale() {
        this.deployNickVisibility(), this.deployMassVisibility()
    }
    deploy() {
        return super.deploy(), this.box.interactive = this.interactive, this.deployEntityTexture(), this.deployTextStyle(), this.deployNickVisibility(), this.deployMassVisibility(), this.drawAssistance(), this
    }
    deployEntityTexture() {
        this.opUnit.hasSkin && this.skinVisibility ? (this.baseLayer.texture = this.opUnit.skinTexture, this.deploySkinStyle()) : (this.baseLayer.texture = ie.get("BASE"), this.deployEntityStyle())
    }
    deployNickVisibility() {
        !this.opUnit || (this.tag.visible = this.player.team.tagText && this.nickVisibility && H.TagType == 2, this.nick.visible = this.opUnit.nickText.text && this.nickVisibility, this.mass.position.set(0, this.nick.visible ? We * .45 : 0), this.nick.position.set(0, this.tag.visible ? We * .05 : 0))
    }
    deployEntityStyle() {
        this.baseLayer.tint = this.entityTint, this.baseLayer.alpha = this.entityAlpha
    }
    deploySkinStyle() {
        this.baseLayer.tint = this.skinTint, this.baseLayer.alpha = this.skinAlpha
    }
    deployTextStyle() {
        const i = this.tag;
        this.mass.fontName = `${this.player.team.uSig}`, this.mass.tint = 16777215, i.position.set(0, -We * .0125 - this.mass.textHeight * .72)
    }
    assembly() {
        this.assistance.addChild(this.EnemyHint, this.MassMarker, this.AutosplitAlert), this.box.addChild(this.baseLayer, this.assistance, this.tag, this.nick, this.mass)
    }
    copySpecific() {
        return [this.color, this.player.uSig, this.opUnit.id]
    }
    release() {
        this.tag.texture = ht.EMPTY, this.nick.texture = ht.EMPTY, this.mass.fontName = "0", this.baseLayer.texture = ie.get("BASE"), this.assistance.needUpdate = !0, this.massLevel = -1, this.MassMarker.visible = !1, this.AutosplitAlert.visible = !1, this.unbindOpUnit(), lp.release(this)
    }
}
class Q1 {
    constructor(t, i, s, n) {
        I(this, "id");
        I(this, "owner");
        I(this, "_nick");
        I(this, "nickText", Ws(new ys));
        I(this, "skinUrl");
        I(this, "skinImg");
        I(this, "skinTexture");
        I(this, "canvas", Ws(document.createElement("canvas")));
        I(this, "pcells", Ws(new Set));
        this.id = t, this.owner = i, this.nick = s, this.skin = n, this.skinTexture = Ws(ht.from(this.canvas))
    }
    get isBot() {
        return this.id == 15
    }
    get inSelfTeam() {
        return U.teamPlayers.size && U.team == this.owner.team
    }
    get nick() { return this.owner._tripkey ? this._nick+" ["+this.owner._tripkey.substr(0,4)+"]" : this._nick }
    set nick(t) {
        this._nick !== t && (this._nick = t, this.updateText(), this.pcells.forEach(i => i.setNick()))
        console.log(this.owner._tripkey.substr(0,4))
    }
    get tag() {
        return this.owner.isBot ? "" : this.owner.tag
    }
    get tagNick() {
        return this.tag + this.nick
    }
    get skin() {
        return this.skinUrl
    }
    set skin(t) {
        (this.skinUrl !== t || !this.skinImg) && (this.skinUrl = t, this.loadSkin())
    }
    get cellCount() {
        return this.pcells.size
    }
    get color() {
        return this._color
    }
    set color(t) {
        this._color != t && (this._color = t, this.skinImg && this.updateSkin())
    }
    get teamColor() {
        return Qa(this.owner.team.color)
    }
    get skinFillColor() {
        return this.inSelfTeam ? Id(B.SkinFillTeam[0], this.color) : Id(B.SkinFillEnemy[0], this.color)
    }
    get skinFillAlpha() {
        return this.inSelfTeam ? B.SkinFillTeam[1] : B.SkinFillEnemy[1]
    }
    updateText() {
        const t = dr.clone();
        B.Text[3] & 4 ? t.fill = lr(this.owner.teamColor, B.Text[1]) : t.fill = ar(B.Text), B.TextStroke[3] & 4 ? t.stroke = lr(this.owner.teamColor, B.TextStroke[1]) : t.stroke = ar(B.TextStroke), t.fontSize = Lc(), t.strokeThickness = Oc(), this.nickText.style = t, this.nickText.text = H.TagType == 1 ? this.tagNick : this.nick, this.nickText.updateText()
    }
    loadSkin() {
        if (this.isBot && !this.skinUrl) return;
        this.skinImg = null;
        const t = new Image;
        t.crossOrigin = "Anonymous", t.src = this.skinUrl ? this.skinUrl : location.href + "skins/noskin5.png", this.skinImg = t, t.onload = () => {
            this.skinImg == t && this.updateSkin()
        }, t.onerror = () => {
            t.src != location.href + "skins/error.png" && (t.src = location.href + "skins/error.png")
        }
    }
    updateSkin() {
        !this.pcells.size || !this.skinImg || (this.owner.isHuman || this.skinUrl ? this.drawSkin() && (this.hasSkin = !0) : this.hasSkin = !1, this.pcells.forEach(t => t.deployEntityTexture()))
    }
    drawSkin() {
        const t = this.skinImg,
            i = this.skinFillColor,
            s = this.skinFillAlpha,
            n = We * on,
            r = Math.min(t.width, t.height);
        if (!r) return !1;
        const o = this.canvas;
        o.width = o.height = n * 2;
        const a = o.getContext("2d");
        return a.lineJoin = "round", a.globalAlpha = s, a.beginPath(), a.arc(n, n, n, 0, Math.PI * 2), a.clip(), a.fillStyle = i, a.fill(), a.globalAlpha = 1, a.drawImage(t, 0, 0, r, r, 0, 0, n * 2, n * 2), this.skinTexture.update(), !0
    }
    bindPlayerCell(t) {
        const i = this.cellCount == 0;
        this.pcells.add(t), t.setNick(), i && (this.color = t.color)
    }
    unbindPlayerCell(t) {
        this.pcells.delete(t)
    }
    updateInfo(t, i) {
        this.nick = t, this.skin = i
    }
    deployNickStyle() {
        this.pcells.forEach(t => {
            t.deployNickStyle()
        })
    }
    clearPlayerCells() {
        this.pcells.clear()
    }
    calcViewRange() {
        let t = 0,
            i = 0,
            s = 0,
            n = 0;
        this.pcells.forEach(l => {
            const c = l.massValue;
            t += l.nx * c, i += l.ny * c, s += c, n += l.nr
        }), t /= s, i /= s;
        const r = Math.min(64 / n, 1) ** .4,
            o = 1200 / r,
            a = 768 / r;
        return [t, i, o, a]
    }
}
let CR = 0;
class ip {
    constructor(t) {
        I(this, "id");
        I(this, "uSig");
        I(this, "_bfp");
        I(this, "_team");
        I(this, "block", !1);
        I(this, "enableChat", !1);
        I(this, "activity", 0);
        I(this, "latency", 0);
        I(this, "msg", []);
        I(this, "opUnits", new Map);
        this.id = t, this.uSig = ++CR
    }
    get bfp() {
        return this._bfp
    }
    set bfp(t) {
        xn.indexOf(t) >= 0 && (this.block = !0), this._bfp = t
    }
    get tag() {
        return this.team ? this.team.name : ""
    }
    get nick() {
        return this.opUnits.values().next().value.nick
    }
    get tagNick() {
        return this.tag + this.nick
    }
    get skin() {
        return this.opUnits.values().next().value.skin
    }
    get team() {
        return this._team
    }
    set team(t) {
        this._team && this._team.quitPlayer(this), this._team = Ws(t), this.opUnits.forEach(i => i.deployNickStyle())
    }
    get cellCount() {
        let t = 0;
        return this.opUnits.forEach(i => t += i.cellCount), t
    }
    get teamPlayers() {
        return this._team ? this.team.players : []
    }
    get teamColor() {
        return this._team ? this._team.color : 16777215
    }
    get isTeammate() {
        return this.team && this.team.id == U.team.id
    }
    get isBot() {
        return this.opUnits.get(15)
    }
    get isHuman() {
        return !this.isBot
    }
    get totalMass() {
        let t = 0;
        return this.opUnits.forEach(i => {
            i.pcells.forEach(s => {
                t += s.massValue
            })
        }), t
    }
    createOpUnit(t, i, s) {
        const n = new Q1(t, this, i, s);
        return this.opUnits.set(t, n), n
    }
    joinOpUnit(t, i, s) {
        this.opUnits.has(t) ? this.opUnits.get(t).updateInfo(i, s) : this.createOpUnit(t, i, s)
    }
    clearPlayerCells() {
        this.opUnits.forEach(t => t.clearPlayerCells())
    }
    leaveTeam() {
        const t = this.team;
        t && t.quitPlayer(this)
    }
    destroy() {
        setTimeout(() => {
            this.opUnits.forEach(t => {
                t._texture && t._texture.destroy(!0), t.nickText.removeFromParent(), t.nickText.destroy({
                    texture: !0,
                    baseTexture: !0
                })
            })
        }, 1e3)
    }
}
const Vg = ft(H.ShowReplayBar),
    qn = [],
    ya = _i(qn),
    mn = ft(!0),
    Di = ft(0),
    Ts = ft(0),
    Jn = ft(null),
    no = ft(1);
let un = null,
    Hr = [],
    Ul = null,
    Gl = 0,
    kd = [],
    na = new Map,
    Vr = new Map;
A.on("recordTempCell", e => kd.push(e));
const Ie = class {
    static tick() {
        if (!Ie.state) return;
        !mn.value && un && (Ts.value < un.length - 1 ? (Ts.value += 1, Ie.decodeFrame()) : mn.value = !0), Ul && (Gt.mouseX = jt.toScreenX(Ul.mouseX), Gt.mouseY = jt.toScreenY(Ul.mouseY));
        const t = performance.now(),
            i = 40 / no.value;
        Gl += i;
        let s = 0;
        Gl + i < t ? Gl = t - i : s = Gl + i - t, setTimeout(Ie.tick, s)
    }
    static decodeFrame() {
        const t = un[Ts.value];
        if (t) Ul = t;
        else return;
        jt.currMapData != t.map && (A.emit("clearMap"), jt.drawMap(t.map)), t.teams.forEach(([n, r, o]) => {
            Vr.has(n) || Vr.set(n, new py(n, r, o))
        }), t.players.forEach(([n, r, o]) => {
            let a = n == 0 ? U : na.get(n);
            if (a) {
                o.forEach(([c, h, u]) => {
                    a.joinOpUnit(c, h, u)
                });
                const l = Vr.get(r);
                a.team.uSig != l.uSig && l.joinPlayer([a])
            } else {
                const l = new ip(n);
                o.forEach(([c, h, u]) => {
                    l.joinOpUnit(c, h, u)
                }), Vr.get(r).joinPlayer([l]), na.set(n, l)
            }
        });
        const i = performance.now(),
            s = vi(Gt.syncStamp, i, Er());
        t.data.forEach(([n, r, o, a, l, c, h]) => {
            let u;
            (u = ze.get(r)) ? c == 2 ? (u.preDeath(i), u.preUpdate(o, a, l ** .5 * 10), _n.add(u), gn.delete(u), ze.delete(r)) : Me.preUpdate({
                coef: s,
                time: i,
                id: r,
                x: o,
                y: a,
                mass: l
            }): c != 2 && Ie.replayCreate({
                time: i,
                type: n,
                id: r,
                x: o,
                y: a,
                mass: l,
                specific: h,
                state: c
            })
        }), Cn.preUpdate(t.viewX, t.viewY, i), U.toggleOpUnit(t.opUnitIndex), jt.miniMap.drawViewport(), Gt.syncStamp = i, Me.sync(i)
    }
    static replayCreate({
        time: t,
        type: i,
        id: s,
        x: n,
        y: r,
        mass: o,
        specific: a,
        state: l
    }) {
        let c;
        const h = a ? a[0] : null;
        switch (i) {
            case 110:
            case 111:
                if (a[1] == 0) {
                    const u = U,
                        d = u.opUnits.get(a[2]);
                    c = cp.allocate().init(t, s, n, r, o, h, u, d).deploy()
                } else {
                    const u = na.get(a[1]),
                        d = u.opUnits.get(a[2]);
                    c = lp.allocate().init(t, s, n, r, o, h, u, d).deploy()
                }
                Ce.add(c), is.addChild(c.displayObject);
                break;
            case 120:
            case 121:
                c = rp.allocate().init(t, s, n, r, o, h).deploy(), Ia.add(c), Fd.addChild(c.displayObject);
                break;
            case 131:
                c = np.allocate().init(t, s, n, r, o, h).deploy(), Ma.add(c), Nd.addChild(c.displayObject);
                break;
            case 141:
                c = op.allocate().init(t, s, n, r, o).deploy(), Tn.add(c), is.addChild(c.displayObject);
                break;
            case 142:
                c = ap.allocate().init(t, s, n, r, o).deploy(), ur.add(c), is.addChild(c.displayObject);
                break
        }
        ze.set(s, c), l != 1 && H.EnableAppearance && (c.preAppear(t), Qn.add(c))
    }
    static replayOrPause() {
        !qn.length || (mn.value ^= 1, !mn.value && un && Ts.value == un.length - 1 && (Ts.value = 0), Ie.state || Ie.enterRecordMode())
    }
    static loadRecord() {
        Hr = [], un = qn[Di.value], mn.value = !0, Ts.value = 0, A.emit("refreshGame"), Ie.decodeFrame()
    }
    static startRecording() {
        Ie.state || (Jn.value = [])
    }
    static endRecording() {
        ya.push(Jn.value), Jn.value = null
    }
    static updateRecording() {
        if (Jn.value || H.CaptureTime) {
            let t = {
                map: jt.currMapData,
                opUnitIndex: U.opUnitQueue.currIndex,
                viewX: Cn.realCameraX,
                viewY: Cn.realCameraY,
                mouseX: Gt.svrMouseX,
                mouseY: Gt.svrMouseY,
                data: [],
                players: [],
                teams: []
            };
            const i = s => {
                const n = [s.type, s.uSig, s.nx, s.ny, s.massValue, s.state];
                s.copySpecific && n.push(s.copySpecific()), t.data.push(n)
            };
            ze.forEach(i), _n.forEach(i), kd.forEach(i), zt.forEach(s => {
                const n = [s.uSig, s.team.uSig, []];
                s.opUnits.forEach(r => {
                    n[2].push([r.id, r.nick, r.skin])
                }), t.players.push(n)
            }), Ms.forEach(s => {
                const n = [s.uSig, s.name, s.color];
                t.teams.push(n)
            }), Hr.push(t), Jn.value && Jn.value.push(t), Hr.length > H.CaptureTime * 1e3 / 40 && Hr.shift()
        }
        kd.length = 0
    }
    static storeQuickCapture() {
        Hr.length && ya.push([...Hr])
    }
    static speedUp() {
        no.value >= 2 || (no.value += .25)
    }
    static slowDown() {
        no.value <= .25 || (no.value -= .25)
    }
    static setProcess(t) {
        Ie.state && Ie.decodeFrame(), Ts.value = t
    }
    static enterRecordMode() {
        at.PAUSE = !0, Ie.state = 1, Ie.loadRecord(), mn.value = !1, Ie.tick(), at.writer.writeUint8(10).writeUint8(1), at.send()
    }
    static quitReplayMode() {
        Ie.state == 1 && (U.state = 0, mn.value = !0, Ie.state = 2, un = null, Ts.value = 0, A.emit("refreshGame"), at.writer.writeUint8(10).writeUint8(0), at.send(), na.forEach(t => t.destroy()), na.clear(), Vr.forEach(t => t.destroy()), Vr.clear())
    }
    static destroyRecord() {
        if (ya.splice(Di.value, 1), Ts.value = 0, ya.length == 0 && Ie.state) {
            Ie.quitReplayMode();
            return
        }
        Di.value = Math.min(Di.value, Math.max(qn.length - 1, 0)), un = qn[Di.value]
    }
    static nextRecord() {
        Di.value++, Di.value >= qn.length && (Di.value = 0), Ie.state && Ie.loadRecord()
    }
    static prevRecord() {
        Di.value--, Di.value < 0 && (Di.value = qn.length - 1), Ie.state && Ie.loadRecord()
    }
};
let ci = Ie;
I(ci, "state", 0);
A.on("quickCapture", ci.storeQuickCapture());
const AR = {
        name: "replay-bar",
        components: {
            "process-slider": ER
        },
        setup() {
            return A.on(Ut.ShowReplayBar, () => Vg.value = H.ShowReplayBar), Ve(() => {
                document.getElementById("replay-bar").addEventListener("click", () => {
                    A.emit("focusGameCanvas")
                })
            }), {
                showReplayBar: Vg,
                pause: mn,
                records: ya,
                currIndex: Di,
                currProcess: Ts,
                currRecord: Jn,
                speed: no,
                Recorder: ci
            }
        }
    },
    Xi = e => (gs("data-v-67e87b78"), e = e(), vs(), e),
    IR = {
        id: "replay-bar"
    },
    MR = Xi(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        fill: "var(--main-theme-color)",
        transform: "translate(4,3)"
    }, [b("path", {
        d: "M434.897971 962.214818c-2.485611 0-4.357238-0.661056-5.599532-1.871627-8.714476-2.52552-11.821233-7.463995-9.335622-14.935154l57.877175-341.637937L225.804792 603.7701c-6.220678 0-10.577916-2.492774-13.071713-7.471159-3.727904-4.938476-3.106758-10.538007 1.871627-16.799618L602.920756 71.702042c4.978385-7.471159 10.577916-8.674567 16.799618-3.736091 6.220678 1.242294 9.335622 6.260587 9.335622 14.935154l-57.877175 341.646124L793.34269 424.547229c6.220678 0 10.577916 2.52552 13.071713 7.463995 1.242294 4.978385 1.242294 10.577916 0 16.806781L447.969685 956.615287C444.233594 960.343191 439.876356 962.214818 434.897971 962.214818z"
    })], -1)),
    RR = [MR],
    kR = Xi(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "20",
        height: "20",
        fill: "var(--main-theme-color)",
        transform: "translate(6,3)"
    }, [b("path", {
        d: "M647.725 840.897s93.091 0 93.091-93.091V282.353c0-93.091-93.091-93.091-93.091-93.091H93.091S0 189.262 0 282.353v465.453c0 93.091 93.091 93.091 93.091 93.091h554.634z m147.316-469.782V660.72l228.956 180.177V189.263L795.041 371.115z"
    })], -1)),
    PR = [kR],
    LR = Xi(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "18.5",
        height: "18.5",
        fill: "var(--main-theme-color)",
        transform: "translate(6.5,3)"
    }, [b("path", {
        d: "M128 128m53.333333 0l661.333334 0q53.333333 0 53.333333 53.333333l0 661.333334q0 53.333333-53.333333 53.333333l-661.333334 0q-53.333333 0-53.333333-53.333333l0-661.333334q0-53.333333 53.333333-53.333333Z"
    })], -1)),
    OR = [LR],
    DR = {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "17",
        height: "17",
        fill: "var(--main-theme-color)",
        transform: "translate(8,2.75)"
    },
    NR = Xi(() => b("path", {
        d: "M92.59163 7.124244v175.409681l588.077547 329.465052-460.111316 245.981852V402.176952l-127.966231-71.344766v686.04357l838.81674-504.876779z"
    }, null, -1)),
    FR = [NR],
    BR = {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "15",
        height: "15",
        fill: "var(--main-theme-color)",
        transform: "translate(8.5,2.5)"
    },
    UR = Xi(() => b("path", {
        d: "M128 0h253.155556v1024H128V0z m512 0h256v1024h-256V0z"
    }, null, -1)),
    GR = [UR],
    HR = Xi(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "20",
        height: "20",
        fill: "var(--main-theme-color)",
        transform: "translate(3,-5.5)"
    }, [b("path", {
        d: "M704 304.2v415.6c0 37.4-30.7 64.1-64.1 64.1-10.8 0-22-2.8-32.4-9l-352-207.8c-41.9-24.8-41.9-85.5 0-110.2l351.9-207.8c10.5-6.2 21.6-9 32.4-9 33.5 0 64.2 26.7 64.2 64.1z"
    })], -1)),
    VR = [HR],
    zR = Xi(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "20",
        height: "20",
        fill: "var(--main-theme-color)",
        transform: "translate(0.5,-5)"
    }, [b("path", {
        d: "M768.5 567.1l-352 207.8c-10.4 6.2-21.6 9-32.4 9-33.4 0-64.1-26.7-64.1-64.1V304.2c0-37.4 30.7-64.1 64.1-64.1 10.8 0 22 2.8 32.4 9l351.9 207.8c42 24.8 42 85.4 0.1 110.2z"
    })], -1)),
    $R = [zR],
    jR = Xi(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "12",
        height: "12",
        fill: "var(--main-theme-color)",
        transform: "translate(6,-5)"
    }, [b("path", {
        d: "M426.666667 426.666667H85.546667A85.418667 85.418667 0 0 0 0 512c0 47.445333 38.314667 85.333333 85.546667 85.333333H426.666667v341.12c0 47.274667 38.186667 85.546667 85.333333 85.546667 47.445333 0 85.333333-38.314667 85.333333-85.546667V597.333333h341.12A85.418667 85.418667 0 0 0 1024 512c0-47.445333-38.314667-85.333333-85.546667-85.333333H597.333333V85.546667A85.418667 85.418667 0 0 0 512 0c-47.445333 0-85.333333 38.314667-85.333333 85.546667V426.666667z"
    })], -1)),
    WR = [jR],
    XR = Xi(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "14",
        height: "14",
        fill: "var(--main-theme-color)",
        transform: "translate(5,-5)"
    }, [b("path", {
        d: "M587.229378 437.990403 580.722174 437.990403 76.975139 437.990403 76.975139 581.918419 580.722174 581.918419 587.229378 581.918419 940.542216 581.918419 940.542216 437.990403Z"
    })], -1)),
    YR = [XR],
    KR = {
        id: "speed"
    },
    ZR = Xi(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "18",
        height: "18",
        fill: "var(--main-theme-color)",
        transform: "translate(7.5,3)"
    }, [b("path", {
        d: "M930.248779 51.421136c-17.382902-8.393157-38.056758-6.107091-53.191456 5.929036l-522.479679 415.249469c-12.010545 9.54847-19.016099 24.054859-19.016099 39.402405 0 15.347546 7.005554 29.853935 19.016099 39.402405l522.479679 415.249469c9.081843 7.219425 20.154016 10.929934 31.323403 10.929934 7.43432 0 14.917758-1.645476 21.86703-5.000897 17.400299-8.399297 28.460192-26.01449 28.460192-45.331441L958.707948 96.752578C958.708971 77.435627 947.649078 59.820434 930.248779 51.421136zM858.042247 822.953078 466.790332 512.002047l391.251915-310.951031L858.042247 822.953078zM178.540326 117.206422 178.540326 916.731928c0 31.274284-25.350364 56.624648-56.624648 56.624648-31.275307 0-56.624648-25.350364-56.624648-56.624648L65.291029 117.206422c0-31.273261 25.350364-56.624648 56.624648-56.624648C153.189961 60.581774 178.540326 85.933161 178.540326 117.206422z"
    })], -1)),
    qR = [ZR],
    JR = Xi(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "18",
        height: "18",
        fill: "var(--main-theme-color)",
        transform: "translate(6,3)"
    }, [b("path", {
        d: "M683.816181 471.854675 147.889235 50.679239c-15.374152-12.084223-36.276205-14.32117-53.862745-5.776563C76.451206 53.446259 65.290005 71.276347 65.290005 90.819448l0 842.364173c0 19.543102 11.161201 37.373189 28.735461 45.916772 7.091512 3.447519 14.719236 5.135974 22.310122 5.135974 11.236925 0 22.378683-3.707438 31.552623-10.912537l535.926946-421.188738c12.31549-9.67843 19.506263-24.478508 19.506263-40.140209C703.32142 496.328066 696.130647 481.533105 683.816181 471.854675zM167.395498 828.131007l0-632.259968 402.25041 316.123844L167.395498 828.131007zM958.708971 111.565958l0 810.942533c0 31.720446-25.712615 57.434084-57.434084 57.434084-31.721469 0-57.434084-25.713638-57.434084-57.434084L843.840804 111.565958c0-31.721469 25.712615-57.434084 57.434084-57.434084C932.996356 54.131875 958.708971 79.844489 958.708971 111.565958z"
    })], -1)),
    QR = [JR],
    tk = {
        id: "number"
    },
    ek = Xi(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "23",
        height: "23",
        fill: "var(--main-theme-color)",
        transform: "translate(4,2.5)"
    }, [b("path", {
        d: "M847.743 223.953H640.639c-3.132-68.921-60.177-124.029-129.858-124.029s-126.726 55.108-129.858 124.029H173.256c-17.673 0-32 14.327-32 32s14.327 32 32 32h674.487c17.673 0 32-14.327 32-32s-14.327-32-32-32z m-336.962-60.03c34.379 0 62.689 26.426 65.718 60.029H445.064c3.029-33.603 31.338-60.029 65.717-60.029zM767.743 351.79c-17.673 0-32 14.327-32 32v478.173H288.256V383.79c0-17.673-14.327-32-32-32s-32 14.327-32 32v510.173c0 17.673 14.327 32 32 32h511.487c17.673 0 32-14.327 32-32V383.79c0-17.673-14.327-32-32-32z"
    }), b("path", {
        d: "M449.306 732.802V448.208c0-17.673-14.327-32-32-32s-32 14.327-32 32v284.593c0 17.673 14.327 32 32 32s32-14.326 32-31.999zM640.84 732.802V448.208c0-17.673-14.327-32-32-32s-32 14.327-32 32v284.593c0 17.673 14.327 32 32 32s32-14.326 32-31.999z"
    })], -1)),
    ik = [ek];

function sk(e, t, i, s, n, r) {
    const o = se("process-slider");
    return ee((st(), nt("div", IR, [b("div", {
        id: "quick-capture",
        class: "replay-bar-btn",
        onClick: t[0] || (t[0] = (...a) => s.Recorder.storeQuickCapture && s.Recorder.storeQuickCapture(...a))
    }, RR), b("div", {
        id: "record",
        class: "replay-bar-btn",
        style: $t({
            backgroundColor: s.currRecord ? "rgba(64, 64, 64, 0.6)" : null
        }),
        onClick: t[1] || (t[1] = a => s.currRecord ? s.Recorder.endRecording() : s.Recorder.startRecording())
    }, PR, 4), b("div", {
        id: "stop",
        class: "replay-bar-btn",
        onClick: t[2] || (t[2] = (...a) => s.Recorder.quitReplayMode && s.Recorder.quitReplayMode(...a))
    }, OR), b("div", {
        id: "play",
        class: "replay-bar-btn",
        onClick: t[3] || (t[3] = (...a) => s.Recorder.replayOrPause && s.Recorder.replayOrPause(...a))
    }, [ee((st(), nt("svg", DR, FR, 512)), [
        [ye, s.pause]
    ]), ee((st(), nt("svg", BR, GR, 512)), [
        [ye, !s.pause]
    ])]), X(o, {
        id: "process",
        max: `${s.records[s.currIndex]?s.records[s.currIndex].length-1:0}`,
        step: "1",
        val: s.currProcess,
        onChangeVal: s.Recorder.setProcess
    }, null, 8, ["max", "val", "onChangeVal"]), b("div", {
        id: "prev-frame",
        class: "replay-bar-btn-tiny",
        onClick: t[4] || (t[4] = a => s.Recorder.setProcess(--s.currProcess))
    }, VR), b("div", {
        id: "next-frame",
        class: "replay-bar-btn-tiny",
        onClick: t[5] || (t[5] = a => s.Recorder.setProcess(++s.currProcess))
    }, $R), b("div", {
        id: "speed-up",
        class: "replay-bar-btn-tiny",
        onClick: t[6] || (t[6] = (...a) => s.Recorder.speedUp && s.Recorder.speedUp(...a))
    }, WR), b("div", {
        id: "slow-down",
        class: "replay-bar-btn-tiny",
        onClick: t[7] || (t[7] = (...a) => s.Recorder.slowDown && s.Recorder.slowDown(...a))
    }, YR), b("div", KR, Ot("x" + s.speed.toFixed(2)), 1), b("div", {
        id: "prev-record",
        class: "replay-bar-btn",
        onClick: t[8] || (t[8] = (...a) => s.Recorder.prevRecord && s.Recorder.prevRecord(...a))
    }, qR), b("div", {
        id: "next-record",
        class: "replay-bar-btn",
        onClick: t[9] || (t[9] = (...a) => s.Recorder.nextRecord && s.Recorder.nextRecord(...a))
    }, QR), b("div", tk, Ot(s.records.length ? s.currIndex + 1 + "/" + s.records.length : "0/0"), 1), b("div", {
        id: "delete",
        class: "replay-bar-btn",
        onClick: t[10] || (t[10] = (...a) => s.Recorder.destroyRecord && s.Recorder.destroyRecord(...a))
    }, ik)], 512)), [
        [ye, s.showReplayBar]
    ])
}
var wh = ue(AR, [
    ["render", sk],
    ["__scopeId", "data-v-67e87b78"]
]);
class nk extends ae {
    constructor() {
        super();
        I(this, "initialized", !1);
        I(this, "ox");
        I(this, "oy");
        I(this, "nx");
        I(this, "ny");
        I(this, "gameMap", new dR().setup());
        I(this, "fcellContainer", new Td(10240, {
            tint: !0
        }));
        I(this, "ecellContainer", new Td(10240, {
            tint: !0
        }));
        I(this, "entityContainer", new ae);
        I(this, "realCameraX", 0);
        I(this, "realCameraY", 0);
        this.ox = this.nx = this.x, this.oy = this.ny = this.y
    }
    get fcellContainerVisibility() {
        return H.ShowFood
    }
    get currCameraPos() {
        return [-this.position.x, -this.position.y]
    }
    get realCameraPos() {
        return U.state === 2 ? [this.realCameraX, this.realCameraY] : [-this.nx, -this.ny]
    }
    computeOctagonPos(i) {
        return -i * 2.4142135623731 / 2
    }
    drawRectMap(i, s, n, r) {
        if (this.gameMap.drawRectMap(i, s, n, r), !this.initialized) {
            let o = (i + s) / 2,
                a = (n + r) / 2;
            this.setCamera(o, a), this.initialized = !0
        }
    }
    drawOctagonMap(i) {
        const s = i[4] - i[12],
            n = i[9] - i[1];
        let r = s / 2,
            o = n / 2;
        this.position.set(-r, -o), this.gameMap.drawOctagonMap(i), this.initialized || (this.setCamera(r, o), this.initialized = !0)
    }
    preUpdate(i, s, n) {
        this.update_linear(n), this.ox = this.x, this.oy = this.y;
        const r = U.pause && this.realCameraX == i && this.realCameraY == s;
        this.realCameraX = i, this.realCameraY = s;
        let o, a;
        if (U.state === 1 && !ci.state)[o, a] = U.calcViewCenter();
        else if (U.state >= 2 && !r && qe.jumping != 2 && !ci.state) {
            let l = jt.mouseX,
                c = jt.mouseY,
                h = this.realCameraX,
                u = this.realCameraY,
                d = ((l - h) ** 2 + (c - u) ** 2) ** .5,
                f = 1;
            U.specMode != 1 && (f = 0, U.specTarget && U.specTarget.cellCount == 0 && (f = 1));
            let p = Math.min(1920 / d, f, H.StableSpecCamera ^ 1) ** .5;
            o = h + (l - h) * p, a = u + (c - u) * p
        } else o = this.realCameraX, a = this.realCameraY;
        !isNaN(o) && !isNaN(a) && (this.nx = -o, this.ny = -a)
    }
    setCamera(i, s) {
        this.ox = -i, this.oy = -s, this.position.set(-i, -s), this.nx = -i, this.ny = -s
    }
    update(i, s, n, r, o) {
        this.position.set(Ze(i, n, o), Ze(s, r, o)), this.entityContainer.sortChildren()
    }
    update_linear(i) {
        this.update(this.ox, this.oy, this.nx, this.ny, vi(Gt.syncStamp, i, QM()))
    }
    init() {}
    deploy() {
        this.deployFoodCellContainerVisibility()
    }
    deployFoodCellContainerVisibility() {
        this.fcellContainer.visible = this.fcellContainerVisibility
    }
    assembly() {
        this.addChild(this.gameMap, this.fcellContainer, this.ecellContainer, this.entityContainer)
    }
    setup() {
        return this.init(), this.deploy(), this.assembly(), this
    }
    reset() {
        this.initialized = !1, this.entityContainer.removeChildren(), this.fcellContainer.removeChildren(), this.ecellContainer.removeChildren()
    }
}
class rk extends ae {
    constructor() {
        super();
        I(this, "mainContainer", new nk().setup());
        this.interactive = !0, this.on("pointerdown", i => {
            i.button == 0 && U.state >= 2 && (i.stopImmediatePropagation(), Gt.eventReaction = !0, A.emit("selectSpectate", 0))
        })
    }
    init() {
        this.scale.set(.15)
    }
    assembly() {
        this.addChild(this.mainContainer)
    }
    setup() {
        return this.init(), this.assembly(), this
    }
    reset() {
        this.mainContainer.reset()
    }
}
const dn = 240,
    ok = 5,
    ak = 5,
    hr = rc,
    lk = new ki({
        fontFamily: "Barlow Semi Condensed",
        fontWeight: "200",
        fill: 16777215,
        fontSize: 22
    }),
    ck = new ki({
        fontFamily: us,
        fontWeight: "500",
        fill: 16777215,
        fontSize: 12.5
    });
class hk {
    constructor(t, i, s, n, r, o) {
        I(this, "displayObject", Rd.allocate());
        I(this, "sprite", As.allocate());
        I(this, "exist", !0);
        I(this, "id");
        I(this, "nx");
        I(this, "ny");
        I(this, "nw");
        I(this, "nh");
        I(this, "color");
        this.id = t, this.nx = i, this.ny = s, this.nw = n, this.nh = r, this.color = o ?? 16777215
    }
    get x() {
        return this.displayObject.x
    }
    get y() {
        return this.displayObject.y
    }
    get w() {
        return this.displayObject.scale.x
    }
    get h() {
        return this.displayObject.scale.y
    }
    get width() {
        return this.w * this.sprite.width
    }
    get height() {
        return this.h * this.sprite.height
    }
    get spriteTint() {
        return Be(B.ViewMinimap[0]) ?? this.color
    }
    get spriteAlpha() {
        return B.ViewMinimap[1]
    }
    get moved() {
        return Ui(this.x, this.nx, hr) && Ui(this.y, this.ny, hr)
    }
    get resized() {
        return Ui(this.w, this.nw, hr) && Ui(this.h, this.nh, hr)
    }
    get inControl() {
        return U.state === 2 || -this.id === U.currentOpUnit?.id
    }
    setPosition(t, i) {
        this.displayObject.position.set(t, i)
    }
    setSize(t, i) {
        this.displayObject.zIndex = t * i >> 0, this.displayObject.scale.set(t, i)
    }
    preUpdate(t, i, s, n, r) {
        this.exist = !0, this.nx = t, this.ny = i, this.nw = s, this.nh = n, this.color = r ?? this.color, this.deploySpriteStyle()
    }
    fixPosition() {
        this.moved && this.setPosition(this.nx, this.ny)
    }
    fixSize() {
        this.resized && this.setSize(this.nw, this.nh)
    }
    move(t) {
        this.setPosition(Ze(this.x, this.nx, t), Ze(this.y, this.ny, t)), this.fixPosition()
    }
    resize(t) {
        this.setSize(Ze(this.w, this.nw, t), Ze(this.h, this.nh, t)), this.fixSize()
    }
    update(t) {
        this.move(t), this.resize(t)
    }
    init() {
        this.setPosition(this.nx, this.ny), this.setSize(this.nw, this.nh), this.sprite.texture = ht.WHITE, this.sprite.anchor.set(.5), this.sprite.position.set(0), this.sprite.scale.set(1 / 13)
    }
    deploy() {
        this.deploySpriteStyle()
    }
    deploySpriteStyle() {
        this.sprite.tint = this.spriteTint, this.sprite.alpha = this.spriteAlpha
    }
    assembly() {
        this.displayObject.addChild(this.sprite)
    }
    setup() {
        return this.init(), this.deploy(), this.assembly(), this
    }
    release() {
        this.displayObject.zIndex = 0, this.displayObject.removeChildren(), this.sprite.texture = null, this.sprite.tint = 16777215, this.sprite.alpha = 1, this.sprite.zIndex = 0, Rd.release(this.displayObject), As.release(this.sprite)
    }
}
class uk {
    constructor() {
        I(this, "sprite", As.allocate());
        I(this, "nick", new ys("", ck.clone()));
        I(this, "exist", !0);
        I(this, "nx");
        I(this, "ny");
        I(this, "nr");
        I(this, "player");
        I(this, "opUnit")
    }
    init(t, i, s, n, r) {
        return this.nx = t, this.ny = i, this.nr = s, this.player = n, this.opUnit = r, this.setPosition(this.nx, this.ny), this.setSize(this.nr), this.sprite.anchor.set(.5), this.setNick(), this.nick.anchor.set(.5), this
    }
    get x() {
        return this.sprite.x
    }
    get y() {
        return this.sprite.y
    }
    get r() {
        return this.sprite.scale.x * We
    }
    get moved() {
        return Ui(this.x, this.nx, hr) && Ui(this.y, this.ny, hr)
    }
    get resized() {
        return Ui(this.r, this.nr, hr)
    }
    get spriteTint() {
        return Be(B.EntityMinimap[0]) ?? this.player.teamColor
    }
    get spriteAlpha() {
        return B.EntityMinimap[1]
    }
    get nickColor() {
        return Qa(this.player.teamColor)
    }
    get nickAlpha() {
        return B.EntityInfoMinimap[1]
    }
    setPosition(t, i) {
        this.sprite.position.set(t, i), this.nick.position.set(t, i - this.r - 8)
    }
    setSize(t) {
        this.sprite.zIndex = t >> 0, this.sprite.scale.set(t / We), this.nick.zIndex = t >> 0
    }
    setNick() {
        this.player.isBot || (this.nick.text = this.opUnit.tagNick)
    }
    updateText() {}
    preUpdate(t, i, s) {
        this.exist = !0, this.nx = t, this.ny = i, this.nr = s
    }
    fixPosition() {
        this.moved && this.setPosition(this.nx, this.ny)
    }
    fixSize() {
        this.resized && this.setSize(this.nr)
    }
    move(t) {
        this.setPosition(Ze(this.x, this.nx, t), Ze(this.y, this.ny, t)), this.fixPosition()
    }
    resize(t) {
        this.setSize(Ze(this.r, this.nr, t)), this.fixSize()
    }
    update(t) {
        this.setNick(), this.move(t), this.resize(t)
    }
    deploy() {
        return this.deploySpriteStyle(), this.deployNickStyle(), this
    }
    deploySpriteStyle() {
        this.player.team == U.team ? (this.sprite.texture = ie.get("BASE"), this.sprite.alpha = this.spriteAlpha) : this.player.isBot ? (this.sprite.texture = ie.get("BASE"), this.sprite.alpha = .75 * this.spriteAlpha) : (this.sprite.texture = ie.get("BASE"), this.sprite.alpha = .75 * this.spriteAlpha), this.sprite.tint = this.spriteTint
    }
    deployNickStyle() {
        this.nick.style.fill = this.nickColor, this.nick.alpha = this.nickAlpha
    }
    setup() {
        return this.deploy(), this
    }
    release() {
        this.exist = !0, this.nick.text = "", Pd.release(this)
    }
    recycle() {
        As.release(this.sprite), W1.release(this.text)
    }
}
const Pd = new wi(uk, 128);
class dk extends ae {
    constructor() {
        super();
        I(this, "graphics", new ke);
        I(this, "mask", new ke);
        I(this, "borderMask", new ke);
        I(this, "viewportContainer", new ae);
        I(this, "locationLine", new ke);
        I(this, "spriteContainer", new ae);
        I(this, "textContainer", new ae);
        I(this, "entityList", new Map);
        I(this, "viewportList", new Map);
        I(this, "updateStamp", performance.now());
        I(this, "zoom");
        I(this, "pointerIn");
        I(this, "jumping", 0);
        I(this, "coords", new ke);
        I(this, "coordsText", new ae);
        I(this, "offsetX", 0);
        I(this, "offsetY", 0);
        this.interactive = !0, this.on("pointerdown", i => this.onDown(i)), this.on("pointerenter", () => this.pointerIn = !0), this.on("pointerleave", () => {
            this.pointerIn = this.jumping = 0
        })
    }
    get visibility() {
        return H.ShowMinimap
    }
    get size() {
        return H.MinimapSize
    }
    get coordsFontTint() {
        return parseInt(`0x${B.CoordsFontMinimap[0]}`)
    }
    get coordsFontAlpha() {
        return B.CoordsFontMinimap[1]
    }
    get coordsGridTint() {
        return parseInt(`0x${B.CoordsGridMinimap[0]}`)
    }
    get coordsGridAlpha() {
        return B.CoordsGridMinimap[1]
    }
    get graphicsTint() {
        return Be(B.BgcMinimap[0])
    }
    get graphicsAlpha() {
        return B.BgcMinimap[1]
    }
    get locationLineTint() {
        return Be(B.LocationLine[0])
    }
    get locationLineAlpha() {
        return B.LocationLine[1]
    }
    onDown(i) {
        i.preventDefault(), i.stopImmediatePropagation();
        let s = (i.clientX - this.position.x) * this.zoom + this.offsetX >> 0,
            n = (i.clientY - this.position.y) * this.zoom + this.offsetY >> 0;
        U.state == 1 ? U.tp && (at.writer.writeUint8(25).writeStringUTF8(`/tp ${s} ${n}`), at.send()) : (this.pointerIn = !0, this.jumping == 0 && (this.jumping = 1), A.emit("moveCameraTo", {
            x: s,
            y: n
        }))
    }
    positioning() {
        this.position.set(innerWidth - this.width - ok, innerHeight - this.height - ak)
    }
    resize() {
        this.scale.set(this.size), this.positioning()
    }
    drawRectMap(i, s, n, r) {
        this.offsetX = i, this.offsetY = n, this.zoom = (s - i) / dn;
        const o = dn,
            a = dn * (r - n) / (s - i);
        this.clear(), this.borderMask.beginFill(16777215).drawRect(0, 0, o, a).endFill(), this.mask.beginFill(16777215).drawRect(0, 0, o, a).endFill(), this.graphics.beginFill(16777215).drawRect(0, 0, o, a).endFill();
        const l = (o + a) / 14142 * 20;
        this.drawCoords(0, 0, o, a, l)
    }
    drawOctagonMap(i) {
        this.offsetX = i[14], this.offsetY = i[1];
        let s = i[6] - i[14],
            n = i[9] - i[1];
        this.zoom = s / dn;
        const r = [];
        for (let u = 0; u < i.length;) r[u] = (i[u++] - this.offsetX) / s * dn, r[u] = (i[u++] - this.offsetY) / s * dn;
        const [o, a, l, c] = [r[14], r[1], r[6], r[9]];
        s = l - o, n = c - a, this.clear(), this.borderMask.beginFill(16777215).drawRect(0, 0, dn, dn * n / s).endFill(), this.mask.beginFill(16777215).drawPolygon(r).endFill(), this.graphics.beginFill(16777215).drawPolygon(r).endFill();
        const h = (s + n) / 14142 * 20;
        this.drawCoords(o, a, l, c, h)
    }
    drawCoords(i, s, n, r, o) {
        const a = (n - i) / 5,
            l = (r - s) / 5,
            c = this.coords;
        c.lineStyle(o, 16777215);
        var h, u;
        for (let g = 1; g < 5; g++) h = g * a, u = g * l, c.moveTo(h, 0).lineTo(h, r).moveTo(0, u).lineTo(n, u);
        let d, f, p;
        const m = this.coordsText.children;
        for (let g = m.length - 1; g >= 0; g--) p = m[g], p.visible = !0, f = g % 5, d = g / 5 >> 0, p.text = String.fromCharCode(65 + d) + (f + 1), p.x = f * a + a / 2 - p.width / 2 + i, p.y = d * l + l / 2 - p.height / 2 + s
    }
    drawEntity(i) {
        i.forEach(([s, n, r, o, a]) => {
            if (r = (r - this.offsetX) / this.zoom, o = (o - this.offsetY) / this.zoom, a /= this.zoom / 8, this.entityList.has(s)) {
                const l = this.entityList.get(s);
                let c = l[n];
                if (c) c.preUpdate(r, o, a);
                else {
                    const h = Pi.getPlayer(s),
                        u = h.opUnits.get(n);
                    c = Pd.allocate().init(r, o, a, h, u).setup(), this.spriteContainer.addChild(c.sprite), this.textContainer.addChild(c.nick), l[n] = c
                }
            } else {
                const l = Pi.getPlayer(s),
                    c = l.opUnits.get(n),
                    h = Pd.allocate().init(r, o, a, l, c).setup();
                this.spriteContainer.addChild(h.sprite), this.textContainer.addChild(h.nick);
                const u = [];
                u[n] = h, this.entityList.set(s, u)
            }
        }), this.detectEntity()
    }
    calcViewportData() {
        const i = [];
        if (U.state !== 1) {
            const [n, r] = Cn.realCameraPos, o = 1 + U.state / 2 * 2.236, [a, l] = [1200 * o, 768 * o];
            i.push([0, n, r, a, l, 16777215])
        } else U.opUnits.forEach(s => {
            if (s.pcells.size != 0) {
                const [n, r, o, a] = s.calcViewRange();
                i.push([s.id, n, r, o, a, 16777215])
            }
        });
        return i
    }
    drawViewport() {
        this.calcViewportData().forEach(([s, n, r, o, a, l]) => {
            if (n /= this.zoom, r /= this.zoom, o /= this.zoom / 2, a /= this.zoom / 2, this.viewportList.has(s)) this.viewportList.get(s).preUpdate(n, r, o, a, l);
            else {
                const c = new hk(s, n, r, o, a, l).setup();
                this.viewportContainer.addChild(c.displayObject), this.viewportList.set(s, c)
            }
        }), this.detectViewport()
    }
    drawLocationLine() {
        let [i, s] = Cn.currCameraPos;
        i = (i - this.offsetX) / this.zoom, s = (s - this.offsetY) / this.zoom, this.locationLine.clear().lineStyle(1, 16777215).moveTo(0, s).lineTo(this.graphics.width, s).closePath().moveTo(i, 0).lineTo(i, this.graphics.height).closePath()
    }
    detectEntity() {
        this.entityList.forEach(i => {
            let s = i.length;
            for (; s--;) {
                const n = i[s];
                n && (n.exist ? n.exist = !1 : (n.release(), i.splice(s, 1, Array.EMPTY), this.spriteContainer.removeChild(n.sprite), this.textContainer.removeChild(n.nick)))
            }
        })
    }
    detectViewport() {
        this.viewportList.forEach(i => {
            i.exist ? i.exist = !1 : (i.release(), this.viewportContainer.removeChild(i.displayObject), this.viewportList.delete(i.id))
        })
    }
    update(i) {
        const s = vi(this.updateStamp, i, 400);
        this.entityList.forEach(n => n.forEach(r => {
            r && r.update(s)
        })), this.viewportList.forEach(n => n.update(s)), this.updateStamp = performance.now(), this.drawLocationLine()
    }
    init() {
        this.viewportContainer.mask = this.mask, this.viewportContainer.position.set(0), this.locationLine.mask = this.mask, this.spriteContainer.mask = this.mask, this.spriteContainer.position.set(0), this.textContainer.mask = this.borderMask, this.textContainer.position.set(0), this.coords.mask = this.mask, this.coordsText.mask = this.mask;
        let i;
        for (let s = 0; s < 25; s++) i = new ys("", lk), this.coordsText.addChild(i)
    }
    deploy() {
        this.resize(), this.deployCoordsStyle(), this.deployVisibility(), this.deployGraphicsStyle(), this.deployLocationLineStyle()
    }
    deployCoordsStyle() {
        this.coords.tint = this.coordsGridTint, this.coords.alpha = this.coordsGridAlpha, this.coordsText.tint = this.coordsFontTint, this.coordsText.alpha = this.coordsFontAlpha
    }
    deployVisibility() {
        this.visible = this.visibility
    }
    deployGraphicsStyle() {
        this.graphics.tint = this.graphicsTint, this.graphics.alpha = this.graphicsAlpha
    }
    deployLocationLineStyle() {
        this.locationLine.tint = this.locationLineTint, this.locationLine.alpha = this.locationLineAlpha
    }
    assembly() {
        this.addChild(this.graphics, this.mask, this.borderMask, this.coords, this.coordsText, this.viewportContainer, this.locationLine, this.spriteContainer, this.textContainer)
    }
    setup() {
        return this.init(), this.deploy(), this.assembly(), this
    }
    clear() {
        this.mask.clear(), this.graphics.clear(), this.locationLine.clear(), this.coords.clear();
        const i = this.coords.children;
        for (let s = i.length - 1; s >= 0; s--) i[s].visible = !1
    }
    reset() {
        this.clear(), this.viewportContainer.removeChildren(), this.spriteContainer.removeChildren(), this.textContainer.removeChildren(), this.entityList.clear(), this.viewportList.clear()
    }
}
const vu = 200,
    fk = -3,
    Ld = 5,
    ty = 8,
    oc = 12.5,
    ey = () => {
        le.from("LEADERBOARD_TITLE", {
            fontFamily: us,
            fontWeight: "500",
            fill: 3182847,
            fontSize: oc * 1.5 >> 0
        }, {
            chars: "LEADRBO",
            resolution: 2,
            textureWidth: 256,
            textureHeight: 256,
            mipmap: 0
        }), le.from("LEADERBOARD_MASS", {
            fontFamily: us,
            fontWeight: "300",
            fill: 16777215,
            fontSize: oc
        }, {
            chars: [...le.NUMERIC, ".k[]"],
            resolution: 2,
            textureWidth: 256,
            textureHeight: 256,
            mipmap: 0
        }), le.from("LEADERBOARD_RANK", {
            fontFamily: us,
            fontWeight: "300",
            fill: 16777215,
            fontSize: oc
        }, {
            chars: [...le.NUMERIC, "."],
            resolution: 2,
            textureWidth: 256,
            textureHeight: 256,
            mipmap: 0
        })
    };
ey();
A.on("initFonts", ey);
const pk = new ki({
    fontFamily: us,
    fontWeight: "500",
    fill: 16252927,
    fontSize: oc
});
class mk {
    constructor() {
        I(this, "displayObject", j1.allocate());
        I(this, "mass", new $e("", {
            fontName: "LEADERBOARD_MASS"
        }));
        I(this, "rank", new $e("", {
            fontName: "LEADERBOARD_RANK"
        }));
        I(this, "nick", W1.allocate());
        I(this, "_massText");
        I(this, "nickText");
        this.assembly()
    }
    get color() {
        return zt.get(this.id).teamColor
    }
    get graphicsTint() {
        return Be(B.BgcLeaderboard[0])
    }
    get graphicsAlpha() {
        return B.BgcLeaderboard[1]
    }
    get height() {
        return this.nick.height
    }
    get rankText() {
        return `${this.index+1}`
    }
    set massText(t) {
        this._massText = `[${t>=1e3?(t/1e3).toFixed(1)+"k":t>>0}]`
    }
    get massText() {
        return this._massText
    }
    get interactive() {
        return U.state >= 2
    }
    set interactive(t) {
        this.displayObject.interactive = t
    }
    setTop(t) {
        this.displayObject.position.set(0, (this.height + ty) * this.index + t + Ld * 2)
    }
    onDown(t) {
        t.preventDefault(), t.stopImmediatePropagation(), this.displayObject.alpha = .5, A.emit("selectSpectate", this.id), setTimeout(() => this.displayObject.alpha = 1, 120)
    }
    init(t, i, s, n) {
        return this.id = t, this.index = i, this.nickText = s, this.massText = n, this.setup(), this
    }
    draw() {
        this.displayObject.interactive = this.interactive, this.displayObject.roundPixels = !0, this.displayObject.on("pointerdown", i => this.onDown(i));
        let t = this.index === 9 ? 7.5 : 2;
        for (this.rank.text = this.rankText, this.rank.roundPixels = !0, this.rank.position.set(182.5 - t, 0), this.mass.text = this.massText, this.mass.roundPixels = !0, this.mass.position.set(172.5 - this.mass.textWidth, 0), this.nick.text = this.nickText, this.nick.roundPixels = !0, this.nick.style = pk.clone(); this.nick.width > 250;) {
            const i = this.nick.text,
                s = i.length - 1;
            this.nick.text = i.substr(0, s)
        }
        this.nick.position.set(165 - this.nick.width - this.mass.textWidth, -.5)
    }
    setup() {
        return this.draw(), this.deployColorStyle(), this
    }
    deployColorStyle() {
        this.nick.style.fill = this.color, this.mass.tint = this.color, this.rank.tint = this.color, this.displayObject.clear().beginFill(this.graphicsTint, this.graphicsAlpha).drawRect(160 - this.nick.width - this.mass.textWidth, -2, this.nick.width + this.mass.textWidth + 32.5, this.height + 3)
    }
    assembly() {
        this.displayObject.addChild(this.mass, this.rank, this.nick)
    }
    release() {
        this.displayObject.clear(), this.displayObject.removeFromParent(), iy.release(this)
    }
}
const iy = new wi(mk, 10);
class gk extends ae {
    constructor() {
        super();
        I(this, "graphics", new ke);
        I(this, "container", new ae);
        I(this, "title", new $e("LEADERBOARD", {
            fontName: "LEADERBOARD_TITLE"
        }));
        I(this, "nodeList", new Set)
    }
    get visibility() {
        return H.ShowLeaderboard
    }
    get size() {
        return H.LeaderboardSize
    }
    get graphicsTint() {
        return Be(B.BgcLeaderboard[0])
    }
    get graphicsAlpha() {
        return B.BgcLeaderboard[1]
    }
    positioning() {
        this.position.set(innerWidth - vu * this.size - fk, 0)
    }
    resize() {
        this.scale.set(this.size), this.positioning()
    }
    detectText(i) {
        i.forEach(s => {
            const [n, r] = s;
            let o;
            n ? (Pi.getPlayer(n) || console.log(n, zt.size), o = Pi.getPlayer(n).opUnits.get(r).tagNick) : o = "Bot", s[1] = o
        })
    }
    draw(i) {
        this.clear(), this.detectText(i);
        let s = 0;
        i.forEach(([n, r, o], a) => {
            const l = iy.allocate().init(n, a, r, o);
            l.setTop(this.title.height), this.container.addChild(l.displayObject), this.nodeList.add(l), s += l.height + ty
        }), this.graphics.beginFill(16777215, 1).drawRect(0, 0, vu, s + this.title.height + Ld * 2.5).endFill()
    }
    init() {
        this.title.roundPixels = !1, this.title.alpha = .85, this.title.position.set((vu - this.title.width) / 2 + 32, Ld)
    }
    deploy() {
        this.resize(), this.deployVisibility(), this.deployGraphicsStyle()
    }
    deployVisibility() {
        this.visible = this.visibility
    }
    deployGraphicsStyle() {
        this.graphics.tint = this.graphicsTint, this.graphics.alpha = this.graphicsAlpha, this.nodeList.forEach(i => {
            i.deployColorStyle()
        })
    }
    assembly() {
        this.addChild(this.container, this.title)
    }
    setup() {
        return this.init(), this.deploy(), this.assembly(), this
    }
    clear() {
        this.nodeList.forEach(i => i.release()), this.nodeList.clear(), this.graphics.clear()
    }
    reset() {
        this.clear()
    }
}
const _u = 160,
    vk = -3,
    _k = 12,
    Od = 4,
    Dd = 2,
    sy = 7.5,
    ac = 13,
    ny = () => {
        le.from("TEAMRANKINGS_TITLE", {
            fontFamily: us,
            fontWeight: "500",
            fill: 3182847,
            fontSize: ac * 1.4 >> 0
        }, {
            chars: "TEAM RNKIGS",
            resolution: 2,
            textureWidth: 256,
            textureHeight: 256,
            mipmap: 0
        }), le.from("TEAMRANKINGS_RANK", {
            fontFamily: us,
            fontWeight: "300",
            fill: 16777215,
            fontSize: ac
        }, {
            chars: [...le.NUMERIC, "."],
            resolution: 2,
            textureWidth: 256,
            textureHeight: 256,
            mipmap: 0
        }), le.from("TEAMRANKINGS_PERCENTAGE", {
            fontFamily: us,
            fontWeight: "300",
            fill: 16777215,
            fontSize: ac
        }, {
            chars: [...le.NUMERIC, ".%[]"],
            resolution: 2,
            textureWidth: 256,
            textureHeight: 256,
            mipmap: 0
        })
    };
ny();
A.on("initFonts", ny);
const yk = new ki({
    fontFamily: us,
    fontWeight: "500",
    fill: 16252927,
    fontSize: ac
});
class bk {
    constructor() {
        I(this, "displayObject", j1.allocate());
        I(this, "rank", new $e("", {
            fontName: "TEAMRANKINGS_RANK"
        }));
        I(this, "name", new ys("", yk.clone()));
        I(this, "percentage", new $e("", {
            fontName: "TEAMRANKINGS_PERCENTAGE"
        }));
        I(this, "id");
        I(this, "index");
        I(this, "nameText");
        I(this, "percentageValue");
        I(this, "color");
        this.assembly()
    }
    init(t, i, s, n, r) {
        return this.id = t, this.index = i, this.nameText = s, this.percentageValue = n, this.color = r, this.setup(), this
    }
    get graphicsTint() {
        return Be(B.BgcTeamRankings[0])
    }
    get graphicsAlpha() {
        return B.BgcTeamRankings[1]
    }
    get height() {
        return this.name.height
    }
    get rankText() {
        return `${this.index+1}`
    }
    get percentageText() {
        return `[${this.percentageValue.toFixed(1)}%]`
    }
    setTop(t) {
        this.displayObject.position.set(0, t + (this.height + Dd + sy) * this.index + Dd + Od * 2)
    }
    draw() {
        this.displayObject.scale.set(1), this.displayObject.roundPixels = !0;
        let t = this.index === 9 ? 7.5 : 2;
        this.rank.text = this.rankText, this.rank.roundPixels = !0, this.rank.position.set(142 - t, 0), this.percentage.text = this.percentageText, this.percentage.roundPixels = !0, this.percentage.position.set(132.5 - this.percentage.width, 0), this.name.text = this.nameText, this.name.roundPixels = !0, this.name.position.set(125 - this.name.width - this.percentage.width, -1)
    }
    deploy() {
        this.deployColorStyle()
    }
    deployColorStyle() {
        this.name.style.fill = this.color, this.percentage.tint = this.color, this.rank.tint = this.color, this.displayObject.clear().beginFill(this.graphicsTint, this.graphicsAlpha).drawRect(120 - this.name.width - this.percentage.width, -3, this.name.width + this.percentage.width + 32.5, this.height + 4.5)
    }
    assembly() {
        this.displayObject.addChild(this.rank, this.name, this.percentage)
    }
    setup() {
        return this.draw(), this.deploy(), this
    }
    release() {
        this.displayObject.clear(), this.displayObject.removeFromParent(), ry.release(this)
    }
}
const ry = new wi(bk, 8);
class xk extends ae {
    constructor() {
        super();
        I(this, "graphics", new ke);
        I(this, "container", new ae);
        I(this, "title", new $e("TEAM RANKINGS", {
            fontName: "TEAMRANKINGS_TITLE"
        }));
        I(this, "nodeList", new Set)
    }
    get visibility() {
        return H.ShowTeamRankings && this.nodeList.size
    }
    get size() {
        return H.TeamRankingsSize
    }
    get graphicsTint() {
        return Be(B.BgcTeamRankings[0])
    }
    get graphicsAlpha() {
        return B.BgcTeamRankings[1]
    }
    positioning(i) {
        this.position.set(innerWidth - _u * this.size - vk, i + _k)
    }
    resize() {
        this.scale.set(this.size)
    }
    detectText(i) {
        i.forEach(s => {
            const {
                name: n,
                color: r
            } = Pi.getTeam(s[0]);
            s.push(n, r)
        })
    }
    draw(i) {
        this.deployVisibility(), this.clear(), this.detectText(i);
        let s = 0;
        i.forEach(([n, r, o, a], l) => {
            const c = ry.allocate().init(n, l, o, r / 10, a);
            c.setTop(this.title.height), this.container.addChild(c.displayObject), this.nodeList.add(c), s += c.height + Dd + sy
        }), this.graphics.beginFill(16777215, 1).drawRect(0, 0, _u, s + this.title.height + Od * 2.5).endFill()
    }
    init() {
        this.title.roundPixels = !0, this.title.alpha = .85, this.title.position.set((_u - this.title.width) / 2 + 7, Od)
    }
    deploy() {
        this.resize(), this.deployVisibility(), this.deployGraphicsStyle()
    }
    deployVisibility() {
        this.visible = this.visibility
    }
    deployGraphicsStyle() {
        this.graphics.tint = this.graphicsTint, this.graphics.alpha = this.graphicsAlpha, this.nodeList.forEach(i => {
            i.deployColorStyle()
        })
    }
    assembly() {
        this.addChild(this.container, this.title)
    }
    setup() {
        return this.init(), this.deploy(), this.assembly(), this
    }
    clear() {
        this.nodeList.forEach(i => i.release()), this.nodeList.clear(), this.graphics.clear()
    }
    reset() {
        this.clear(), this.visible = !1
    }
}
const zg = 240,
    wk = 5,
    Tk = 8,
    zr = 12,
    zn = 6,
    oy = () => {
        le.from("PERFORMANCE_TEXT", {
            fontFamily: us,
            fontWeight: "600",
            fill: 3182847,
            fontSize: 12.5
        }, {
            chars: [...le.NUMERIC, "RDRPINGFSETYms: .+MAaXVOL%"],
            resolution: 2,
            textureWidth: 256,
            textureHeight: 256,
            mipmap: 0
        })
    };
oy();
A.on("initFonts", oy);
class Ek extends ae {
    constructor() {
        super();
        I(this, "graphics", new ke);
        I(this, "FPS", new $e("", {
            fontName: "PERFORMANCE_TEXT"
        }));
        I(this, "PING", new $e("", {
            fontName: "PERFORMANCE_TEXT"
        }));
        I(this, "RENDER", new $e("", {
            fontName: "PERFORMANCE_TEXT"
        }));
        I(this, "ENTITY", new $e("", {
            fontName: "PERFORMANCE_TEXT"
        }));
        I(this, "AVGLOAD", new $e("", {
            fontName: "PERFORMANCE_TEXT"
        }));
        I(this, "MAXLOAD", new $e("", {
            fontName: "PERFORMANCE_TEXT"
        }));
        I(this, "_ping", !1);
        I(this, "_pingTime");
        I(this, "_pongTime");
        I(this, "_pingTimeout");
        I(this, "lastUpdate", 0);
        this.updatePerf()
    }
    get lineHeight() {
        return this.PING.height
    }
    get visibility() {
        return H.ShowPerfStatus
    }
    get size() {
        return H.PerfStatusSize
    }
    get graphicsTint() {
        return Be(B.BgcPerfPanel[0])
    }
    get graphicsAlpha() {
        return B.BgcPerfPanel[1]
    }
    positioning(i) {
        this.position.set(innerWidth - zg * this.size - wk >> 0, i - this.height - Tk)
    }
    resize() {
        this.scale.set(this.size)
    }
    init() {
        this.FPS.roundPixels = !0, this.FPS.alpha = .85, this.FPS.position.set(zr, zn), this.PING.roundPixels = !0, this.PING.alpha = .85, this.PING.position.set(zr + 115, zn), this.RENDER.roundPixels = !0, this.RENDER.alpha = .85, this.RENDER.position.set(zr, this.lineHeight + zn * 2), this.ENTITY.roundPixels = !0, this.ENTITY.alpha = .85, this.ENTITY.position.set(zr + 115, this.lineHeight + zn * 2), this.AVGLOAD.roundPixels = !0, this.AVGLOAD.alpha = .85, this.AVGLOAD.position.set(zr, this.lineHeight * 2 + zn * 3), this.MAXLOAD.roundPixels = !0, this.MAXLOAD.alpha = .85, this.MAXLOAD.position.set(zr + 115, this.lineHeight * 2 + zn * 3), this.graphics.roundPixels = !0, this.graphics.beginFill(16777215).drawRect(0, 0, zg, this.lineHeight * 3 + zn * 4).endFill()
    }
    deploy() {
        this.resize(), this.deployVisibility(), this.deployGraphicsStyle()
    }
    deployVisibility() {
        this.visible = this.visibility
    }
    deployGraphicsStyle() {
        this.graphics.tint = this.graphicsTint, this.graphics.alpha = this.graphicsAlpha
    }
    assembly() {
        this.addChild(this.graphics, this.FPS, this.PING, this.RENDER, this.ENTITY, this.AVGLOAD, this.MAXLOAD)
    }
    setup() {
        return this.init(), this.deploy(), this.assembly(), this
    }
    ping() {
        this._ping || (at.send(), this._pingTime = performance.now(), this._ping = !0)
    }
    pong() {
        this._pongTime = performance.now(), H.ExtraLatency > 0 ? this.PING.text = `PING: ${this._pongTime-this._pingTime>>0}+${H.ExtraLatency} ms` : this.PING.text = `PING: ${this._pongTime-this._pingTime>>0} ms`, this._ping = !1, this._pingTimeout = setTimeout(() => this.ping(), 1e3)
    }
    updatePerf(i) {
        if (i - this.lastUpdate < 1e3) return;
        const s = Gt.statistics;
        if (!s.length) return;
        let n = 0;
        s.forEach(l => n += l);
        const r = (s.length / (i - this.lastUpdate) * 1e3).toFixed(1);
        Gt.fps = Number(r), n /= r, s.length = 0, n = (n * 100 >> 0) / 100, this.FPS.text = `FPS: ${r}`, this.RENDER.text = `RENDER: ${n}ms`, this.ENTITY.text = `ENTITY: ${Me.getVisibleEntitySize()}`;
        const o = Gt.load;
        let a = 0;
        n = 0, o.forEach(l => {
            n += l, l > a && (a = l)
        }), n /= o.length * 10, n = (n / 40 * 100).toFixed(1), a /= 10, a = (a / 40 * 100).toFixed(1), o.length = 0, this.AVGLOAD.text = `SVR LOAD: ${n}%`, this.MAXLOAD.text = `MAX LOAD: ${a}%`, this.lastUpdate = i
    }
    reset() {
        clearInterval(this._pingTimeout), this._ping = !1
    }
}
const $g = 24,
    ra = 12,
    Hl = .5,
    ay = () => {
        le.from("CWAL_GAME_STATUS_TEXT", {
            fontFamily: "Titillium Web",
            fontWeight: "500",
            fill: 3182847,
            fontSize: 16,
            stroke: 3182847,
            strokeThickness: .5
        }, {
            chars: [...le.NUMERIC, "MascoreSTE/:. k"],
            resolution: 2,
            textureWidth: 128,
            textureHeight: 128
        })
    };
ay();
A.on("initFonts", ay);
class Sk extends ae {
    constructor() {
        super();
        I(this, "graphics", new ke);
        I(this, "MASS", new $e("Mass: 0", {
            fontName: "CWAL_GAME_STATUS_TEXT"
        }));
        I(this, "SCORE", new $e("Score: 0", {
            fontName: "CWAL_GAME_STATUS_TEXT"
        }));
        I(this, "STE", new $e("STE: 0", {
            fontName: "CWAL_GAME_STATUS_TEXT"
        }));
        I(this, "DIV", new $e("0/16", {
            fontName: "CWAL_GAME_STATUS_TEXT"
        }))
    }
    get visibility() {
        return H.ShowGameStatus
    }
    get size() {
        return H.GameStatusSize
    }
    get graphicsTint() {
        return 3815994
    }
    get graphicsAlpha() {
        return .25
    }
    positioning() {
        let i = ra;
        this.SCORE.roundPixels = !0, this.SCORE.alpha = .85, this.SCORE.position.set(i, Hl), i += ra + this.SCORE.width, this.MASS.roundPixels = !0, this.MASS.alpha = .85, this.MASS.position.set(i, Hl), i += ra + this.MASS.width, this.STE.roundPixels = !0, this.STE.alpha = .85, this.STE.position.set(i, Hl), i += ra + this.STE.width, this.DIV.roundPixels = !0, this.DIV.alpha = .85, this.DIV.position.set(i, Hl);
        const s = i + ra + this.DIV.width;
        this.graphics.width = s, this.graphics.roundPixels = !0, this.position.set(innerWidth / 2 - s / 2 * this.size >> 0, innerHeight - $g * this.size)
    }
    resize() {
        this.scale.set(this.size)
    }
    init() {
        this.graphics.beginFill(16777215).drawRect(0, 0, 320, $g).endFill()
    }
    deploy() {
        this.resize(), this.deployVisibility(), this.deployGraphicsStyle()
    }
    deployVisibility() {
        this.visible = this.visibility
    }
    deployGraphicsStyle() {
        this.graphics.tint = this.graphicsTint, this.graphics.alpha = this.graphicsAlpha
    }
    assembly() {
        this.addChild(this.graphics, this.SCORE, this.MASS, this.STE, this.DIV)
    }
    setup() {
        return this.init(), this.deploy(), this.assembly(), this
    }
    updateStatus() {
        let i = U.score ? U.score : 0,
            s = U.totalMass ? U.totalMass : 0;
        i > 1e3 && (i = ((i / 100 >> 0) / 10).toFixed(1) + "k"), s > 1e3 && (s = ((s / 100 >> 0) / 10).toFixed(1) + "k");
        let n = 0;
        U.largest && (n = U.largest.massValue / 1.31 >> 0, n > 1e3 && (n = ((n / 100 >> 0) / 10).toFixed(1) + "k"));
        let r = 0,
            o = U.currentOpUnit;
        o && (r = o.pcells.size), this.SCORE.text = `Score: ${i}`, this.MASS.text = `Mass: ${s}`, this.STE.text = `STE: ${n}`, this.DIV.text = `${r}/16`, this.positioning()
    }
    reset() {
        this.SCORE.text = "Score: 0", this.MASS.text = "Mass: 0", this.STE.text = "STE: 0", this.DIV.text = "0/16", this.positioning()
    }
}
class Ck extends ae {
    constructor() {
        super();
        I(this, "bottomContainer", new rk().setup());
        I(this, "miniMap", new dk().setup());
        I(this, "leaderboard", new gk().setup());
        I(this, "teamRankings", new xk().setup());
        I(this, "performancePanel", new Ek().setup());
        I(this, "gameStatus", new Sk().setup());
        I(this, "currMapData");
        I(this, "currLBData");
        I(this, "currTRData")
    }
    get mouseX() {
        return -this.bottomContainer.mainContainer.x + Gt.mouseX / this.bottomContainer.scale.x - this.bottomContainer.x / this.bottomContainer.scale.x
    }
    get mouseY() {
        return -this.bottomContainer.mainContainer.y + Gt.mouseY / this.bottomContainer.scale.y - this.bottomContainer.y / this.bottomContainer.scale.y
    }
    get centerX() {
        return -this.bottomContainer.mainContainer.x + innerWidth / 2 / this.bottomContainer.scale.x - this.bottomContainer.x / this.bottomContainer.scale.x
    }
    get centerY() {
        return -this.bottomContainer.mainContainer.y + innerHeight / 2 / this.bottomContainer.scale.y - this.bottomContainer.y / this.bottomContainer.scale.y
    }
    toScreenX(i) {
        return (i + this.bottomContainer.x / this.bottomContainer.scale.x + this.bottomContainer.mainContainer.x) * this.bottomContainer.scale.x
    }
    toScreenY(i) {
        return (i + this.bottomContainer.y / this.bottomContainer.scale.y + this.bottomContainer.mainContainer.y) * this.bottomContainer.scale.y
    }
    resize(i, s) {
        this.bottomContainer.position.set(i, s), this.positioningComponents()
    }
    positioningComponents() {
        this.miniMap.positioning(), this.leaderboard.positioning(), this.teamRankings.positioning(this.leaderboard.height), this.performancePanel.positioning(this.miniMap.position.y), this.gameStatus.positioning()
    }
    drawLeaderboard(i) {
        this.currLBData = i, this.leaderboard.draw(i)
    }
    drawTeamRankings(i) {
        this.currTRData = i, this.teamRankings.draw(i), this.positioningComponents()
    }
    drawMap(i) {
        switch (this.currMapData = i, i.type) {
            case "Rect":
                const {
                    borderLeft: s, borderRight: n, borderTop: r, borderBottom: o
                } = i;
                this.bottomContainer.mainContainer.drawRectMap(s, n, r, o), this.miniMap.drawRectMap(s, n, r, o), A.emit(Ht.BackgroundImage);
                break;
            case "Octa":
                this.bottomContainer.mainContainer.drawOctagonMap(i), this.miniMap.drawOctagonMap(i), A.emit(Ht.BackgroundImage);
                break
        }
        this.positioningComponents()
    }
    init() {
        this.positioningComponents()
    }
    assembly() {
        this.addChild(this.miniMap, this.leaderboard, this.teamRankings, this.performancePanel, this.gameStatus)
    }
    setup() {
        return this.init(), this.assembly(), this
    }
    reset() {
        this.bottomContainer.reset(), this.leaderboard.reset(), this.teamRankings.reset(), this.gameStatus.reset()
    }
}
const jt = new Ck().setup(),
    {
        bottomContainer: ba,
        bottomContainer: {
            mainContainer: Cn,
            mainContainer: {
                gameMap: Nn,
                fcellContainer: Nd,
                ecellContainer: Fd,
                entityContainer: is
            }
        },
        miniMap: qe,
        leaderboard: Wo,
        teamRankings: sp,
        performancePanel: Ar,
        gameStatus: ly
    } = jt;
A.on(Ut.ShowMinimap, () => qe.deployVisibility());
A.on(Ut.ShowLeaderboard, () => Wo.deployVisibility());
A.on(Ut.ShowTeamRankings, () => sp.deployVisibility());
A.on(Ut.ShowPerfStatus, () => Ar.deployVisibility());
A.on(Ut.ShowGameStatus, () => ly.deployVisibility());
A.on(Ut.MinimapSize, () => {
    qe.resize(), jt.positioningComponents()
});
A.on(Ut.LeaderboardSize, () => {
    Wo.resize(), jt.positioningComponents()
});
A.on(Ut.TeamRankingsSize, () => {
    sp.resize(), jt.positioningComponents()
});
A.on(Ut.PerfStatusSize, () => {
    Ar.resize(), jt.positioningComponents()
});
A.on(Ut.GameStatusSize, () => {
    ly.resize(), jt.positioningComponents()
});
A.on(Ht.CoordsFont, () => Nn.deployCoordsStyle());
A.on(Ht.CoordsGrid, () => Nn.deployCoordsStyle());
A.on(Ht.Border, () => {
    B.BorderGlow[0] = B.Border[0], B.BorderGlow[1] = (B.Border[1] ** .5 * 100 >> 0) / 100, Nn.deployBorderStyle()
});
A.on(Ht.BorderGlow, () => Nn.deployBorderStyle());
document.body.style.backgroundColor = "#" + B.BackgroundColor[0];
A.on(Ht.BackgroundColor, () => document.body.style.backgroundColor = "#" + B.BackgroundColor[0]);
A.on(Ht.BackgroundImage, () => {
    Nn.deployBackgroundStyle(), Nn.drawBackground()
});
A.on(Ht.CoordsFontMinimap, () => qe.deployCoordsStyle());
A.on(Ht.CoordsGridMinimap, () => qe.deployCoordsStyle());
A.on(Ht.BgcMinimap, () => qe.deployGraphicsStyle());
A.on(Ht.LocationLine, () => qe.deployLocationLineStyle());
A.on(Ht.ViewMinimap, () => qe.viewportList.forEach(e => e.deploySpriteStyle()));
A.on(Ht.EntityMinimap, () => qe.entityList.forEach(e => e.forEach(t => {
    t && t.deploySpriteStyle()
})));
A.on(Ht.EntityInfoMinimap, () => {
    qe.entityList.forEach(e => e.forEach(t => {
        t && t.deployNickStyle()
    }))
});
A.on(Ht.BgcLeaderboard, () => Wo.deployGraphicsStyle());
A.on(Ht.BgcTeamRankings, () => sp.deployGraphicsStyle());
A.on(Ht.BgcPerfPanel, () => Ar.deployGraphicsStyle());
let jg = performance.now();
A.on("sendMousePos", e => {
    U.state != 1 && qe.pointerIn && qe.jumping || e - jg > 15 && (Gt.svrMouseX = jt.mouseX, Gt.svrMouseY = jt.mouseY, at.writer.writeUint8(0).writeFloat32(jt.mouseX).writeFloat32(jt.mouseY), at.send(), jg = e)
});
A.on("play", () => Wo.nodeList.forEach(e => e.interactive = !1));
A.on("spectate", () => Wo.nodeList.forEach(e => e.interactive = !0));
A.on("death", () => Wo.nodeList.forEach(e => e.interactive = !0));
const Ak = () => {
    Me.reset(), Ms.forEach(e => e.destroy()), Ms.clear(), zt.forEach(e => e.id != U.id && e.destroy()), zt.clear(), U.reset(), jt.reset(), qe.reset(), Nn.reset(), Ar.reset(), A.emit("sendProfile"), A.emit("sendNotice"), setTimeout(() => Ar.ping(), 100)
};
A.on("initGame", Ak);
A.on("clearMap", () => {
    qe.reset(), Nn.reset()
});
A.on("refreshGame", () => {
    Me.reset(), jt.reset()
});
A.on("changeServer", e => {
    at.PAUSE = !0, at.close(1e3), setTimeout(() => {
        at.connect(e)
    }, 40)
});
class Ik extends ep {
    constructor() {
        super(!0);
        I(this, "cursorLine", new ke);
        I(this, "SplitOrderMarker", As.allocate());
        I(this, "_SplitOrderMarkerTint", 38655);
        this.cursorLine.zIndex = -1, this.cursorLine.position.set(0), this.cursorLine.scale.set(1), this.SplitOrderMarker.texture = ie.get("SPLIT_ORDER_MARKER"), this.assembly()
    }
    get inControl() {
        return this.player.currentOpUnit === this.opUnit
    }
    get nickVisibility() {
        return this.textVisibility && H.ShowNick
    }
    get cursorLineVisibility() {
        return this.inControl && H.ShowCursorLine
    }
    get SplitOrderMarkerVisibility() {
        return this.inControl && H.ShowSplitOrderMarker
    }
    get entityTint() {
        return Be(B.CellSelf[0]) ?? this.color
    }
    get entityAlpha() {
        return B.CellSelf[1]
    }
    get skinTint() {
        return Be(B.SkinSelf[0])
    }
    get skinAlpha() {
        return B.SkinSelf[1]
    }
    get cursorLineTint() {
        return Be(B.CursorLine[0])
    }
    get cursorLineAlpha() {
        return B.CursorLine[1]
    }
    get cursorLineSize() {
        return Number(B.CursorLine[2])
    }
    set SplitOrderMarkerWeight(i) {
        this._SplitOrderMarkerTint = 255 * (1 - i) << 16 | 55 * i ** 2 << 8 | 150 + 105 * i
    }
    get SplitOrderMarkerTint() {
        return Be(B.SplitOrderMarker[0]) ?? this._SplitOrderMarkerTint
    }
    get SplitOrderMarkerAlpha() {
        return B.SplitOrderMarker[1]
    }
    get SplitOrderMarkerSize() {
        return B.SplitOrderMarker[2]
    }
    preDeath(i) {
        super.preDeath(i), this.player.detectDeath(this.opUnit)
    }
    preDisappear(i) {
        super.preDisappear(i), this.player.detectDeath(this.opUnit)
    }
    drawCursorLine() {
        if (this.cursorLine.clear(), this.deployCursorLineVisibility(), this.cursorLineVisibility) {
            const {
                x: i,
                y: s
            } = this.baseLayer.getGlobalPosition();
            this.cursorLine.lineStyle(this.cursorLineSize, this.cursorLineTint, this.cursorLineAlpha).moveTo(i, s).lineTo(Gt.mouseX, Gt.mouseY).closePath()
        }
    }
    updateMassLevel() {
        this.inControl ? this.massLevel != -1 && (this.massLevel = -1, this.assistance.needUpdate = !0) : super.updateMassLevel()
    }
    drawAssistance() {
        if (!this.assistance.needUpdate) return;
        const i = this.SplitOrderMarker,
            s = this.MassMarker,
            n = this.AutosplitAlert;
        i.visible = !1, s.visible = !1, n.visible = !1, this.assistance.needUpdate = !1;
        let r, o;
        if (this.SplitOrderMarkerVisibility && (r = this.SplitOrderMarkerTint, o = this.SplitOrderMarkerAlpha, i.visible = !0, i.tint = r, i.alpha = o), H.ShowAutosplitAlert && this.asaColor != -1) {
            r = this.asaColor, o = this.AutosplitAlertAlpha, n.visible = !0, n.tint = r, n.alpha = o, this.massValue < 2e4 ? n.texture = ie.get("AUTOSPLIT_ALERT1") : n.texture = ie.get("AUTOSPLIT_ALERT2");
            return
        }!this.SplitOrderMarkerVisibility && H.ShowMassMarker && this.massLevel != -1 && (r = J1[this.massLevel], o = this.MassMarkerAlpha, s.visible = !0, s.tint = r, s.alpha = o)
    }
    update(i, s, n, r, o, a, l) {
        const c = super.update(i, s, n, r, o, a, l);
        return this.drawCursorLine(), (n ** 2 / 100 >= 42 && a ** 2 / 100 < 42 || a ** 2 / 100 >= 42 && n ** 2 / 100 < 42) && (U.needUpdate = !0), c
    }
    init(i, s, n, r, o, a, l, c) {
        return super.init(i, s, n, r, o, a, l, c), jt.addChild(this.cursorLine), this
    }
    deploy() {
        return super.deploy(), this.deployCursorLineVisibility(), this.drawAssistance(), this
    }
    deployCursorLineVisibility() {
        this.cursorLine.visible = this.cursorLineVisibility
    }
    assembly() {
        this.assistance.addChild(this.SplitOrderMarker, this.MassMarker, this.AutosplitAlert), this.box.addChild(this.baseLayer, this.assistance, this.tag, this.nick, this.mass)
    }
    release() {
        this.assistance.needUpdate = !0, this.massLevel = -1, this.SplitOrderMarker.visible = !1, this.MassMarker.visible = !1, this.AutosplitAlert.visible = !1, this.unbindOpUnit(), this.cursorLine.clear(), this.cursorLine.removeFromParent(), cp.release(this)
    }
}
class cy extends xh {
    constructor() {
        super();
        I(this, "color");
        this.baseLayer.anchor.set(.5), this.baseLayer.texture = ie.get("BASE"), this.assembly()
    }
    get type() {
        return this.state == 1 ? 120 : 121
    }
    get baseLayerTint() {
        return parseInt(`0x${B.EjectedCell[0]}`) || this.color
    }
    get baseLayerAlpha() {
        return B.EjectedCell[1]
    }
    init(i, s, n, r, o, a) {
        return super.init(i, s, n, r, o), this.color = a, this
    }
    copySpecific() {
        return [this.color]
    }
    release() {
        rp.release(this)
    }
}
class hy extends xh {
    constructor() {
        super();
        I(this, "color");
        this.baseLayer.anchor.set(.5), this.baseLayer.texture = ie.get("BLASTER_SPORE"), this.assembly()
    }
    get type() {
        return 131
    }
    get baseLayerTint() {
        return parseInt(`0x${B.Food[0]}`) || this.color
    }
    get baseLayerAlpha() {
        return B.Food[1]
    }
    init(i, s, n, r, o, a) {
        return super.init(i, s, n, r, o), this.color = a, this
    }
    copySpecific() {
        return [this.color]
    }
    release() {
        np.release(this)
    }
}
class uy extends tp {
    constructor() {
        super();
        I(this, "shootingHint", new hi);
        this.baseLayer.anchor.set(.5), this.shootingHint.texture = ie.get("BASE"), this.shootingHint.position.set(0), this.shootingHint.scale.set(1), this.shootingHint.anchor.set(.5), this.assembly()
    }
    get type() {
        return 141
    }
    get baseLayerTint() {
        return parseInt(`0x${B.Virus[0]}`)
    }
    get baseLayerAlpha() {
        return B.Virus[1]
    }
    get massVisibility() {
        return this.textVisibility && H.ShowMass && H.ShootingHintType != 2
    }
    get textVisibility() {
        return H.ShootingHintType ? this.globalScale > 12 : this.globalScale > 25 && H.ShootingHintType < 2
    }
    deploy() {
        return super.deploy(), this.deployVirusStyle(), this
    }
    deployVirusStyle() {
        const i = H.VirusType ? "ROUND_VIRUS" : "VIRUS";
        this.baseLayer.texture = ie.get(i)
    }
    deploybaseLayerStyle() {
        this.baseLayer.tint = this.baseLayerTint, this.shootingHint.tint = 16777215, this.finalAlpha = this.baseLayerAlpha, this.setAlpha(this.baseLayerAlpha)
    }
    fixSize() {
        const i = this.resized;
        return i && (this.or = this.nr, this.setSize(this.nr), H.ShootingHintType == 0 && (this.mass.text = this.massValue >> 0)), i
    }
    updateMass(i) {
        let s = 16,
            n = 212;
        at.WORLD.includes("Caffe") && (n = 180);
        let r = (n - 100) / s;
        if (H.ShootingHintType == 2) {
            this.mass.visible = !1, this.shootingHint.visible = !0;
            const o = i ** 2 / 100,
                a = (n - o) / s,
                l = Math.max(r - a, 0) / r;
            this.shootingHint.scale.set(l)
        } else if (H.ShootingHintType == 1) {
            if (this.mass.visible = !0, this.shootingHint.visible = !1, this.massValue < 100) return;
            this.mass.text = (n - this.massValue) / s >> 0, this.mass.scale.set(4), this.mass.y = -We * .15
        } else this.mass.visible = !0, this.shootingHint.visible = !1, this.mass.text = (this.nr ** 2 + i ** 2) / 200 >> 0, this.mass.scale.set(2), this.mass.y = -We * .05
    }
    assembly() {
        this.box.addChild(this.baseLayer, this.mass, this.shootingHint)
    }
    release() {
        op.release(this)
    }
}
class dy extends tp {
    constructor() {
        super(), this.baseLayer.anchor.set(.5), this.assembly()
    }
    get baseLayerTint() {
        return parseInt(`0x${B.RedVirus[0]}`)
    }
    get baseLayerAlpha() {
        return B.RedVirus[1]
    }
    get massVisibility() {
        return this.textVisibility && H.ShowMass
    }
    get textVisibility() {
        return this.globalScale > 25
    }
    get type() {
        return 142
    }
    deploy() {
        return super.deploy(), this.deployVirusStyle(), this
    }
    deployVirusStyle() {
        const t = H.VirusType ? "ROUND_VIRUS" : "CVIRUS";
        this.baseLayer.texture = ie.get(t)
    }
    updateMass(t) {
        this.mass.text = (this.nr ** 2 + t ** 2) / 200 >> 0, this.mass.scale.set(2), this.mass.y = -We * .05
    }
    release() {
        ap.release(this)
    }
}
class Mk extends xh {
    constructor() {
        super();
        I(this, "color");
        this.baseLayer.anchor.set(.5), this.baseLayer.texture = ie.get("WAVE"), this.assembly()
    }
    get type() {
        return 9
    }
    init(i, s, n, r) {
        return super.init(i, 0, s, n, 64), this.color = r, this
    }
    copySpecific() {
        return [this.color]
    }
    disappear(i) {
        return this.setAlpha(Ze(this.displayObject.alpha, this.finalAlpha, vi(this.floatTime, i, 1200))), this.fixDisappear()
    }
    setSize(i) {
        this.displayObject.zIndex = (i >> 0) + 1e11, this.displayObject.scale.set(i / We)
    }
    get baseLayerTint() {
        return this.color
    }
    release() {
        this.finalAlpha = 1, fy.release(this)
    }
}
const Ce = new Set,
    Ia = new Set,
    Ma = new Set,
    Tn = new Set,
    ur = new Set,
    oa = new Set,
    ze = new Map,
    gn = new Set,
    _n = new Set,
    Qn = new Set,
    $r = new Set,
    dr = new ki({
        fontFamily: us,
        fontWeight: "600",
        fill: 16777215,
        fontSize: .225 * We,
        lineJoin: "round",
        letterSpacing: 4
    });

function Th() {
    Ce.forEach(t => t.deployTextStyle()), dr.fontSize = Lc(), dr.stroke = ar(B.TextStroke), dr.strokeThickness = Oc();
    const e = We / 400;
    le.from("ENTITY_TEXT", dr, {
        chars: [...le.NUMERIC, ".Kk"],
        textureWidth: 256 * e,
        textureHeight: 276 * e,
        mipmap: H.Mipmap * 2
    })
}
Th();
A.on("initFonts", () => {
    zt.forEach(e => e.opUnits.forEach(t => t.updateText())), Ms.forEach(e => e.updateText()), Th()
});
const np = new wi(hy, 512),
    rp = new wi(cy, 512),
    op = new wi(uy, 32),
    ap = new wi(dy, 32),
    lp = new wi(ep, 2048),
    cp = new wi(Ik, 512),
    fy = new wi(Mk, 16);
class Me {
    static getEntity(t) {
        return ze.get(t)
    }
    static getVisibleEntitySize() {
        return Ce.size + Ia.size + Tn.size + ur.size + (H.ShowFood ? Ma.size : 0)
    }
    static getViewport(t) {
        return ze.get(t).viewport
    }
    static deploy() {
        Ce.forEach(t => {
            t.deployNickVisibility(), t.deployMassVisibility()
        }), Tn.forEach(t => t.deployMassVisibility()), ur.forEach(t => t.deployMassVisibility())
    }
    static create({
        time: t,
        type: i,
        id: s,
        x: n,
        y: r,
        mass: o,
        color: a,
        pid: l,
        cid: c
    }) {
        let h;
        switch (i) {
            case 9:
                h = fy.allocate().init(t, n, r, a).deploy(), is.addChild(h.displayObject);
                break;
            case 110:
            case 111:
                const u = Pi.getPlayer(l),
                    d = u.opUnits.get(c);
                u === U ? h = cp.allocate().init(t, s, n, r, o, a, u, d).deploy() : h = lp.allocate().init(t, s, n, r, o, a, u, d).deploy(), Ce.add(h), is.addChild(h.displayObject);
                break;
            case 120:
            case 121:
                h = rp.allocate().init(t, s, n, r, o, a).deploy(), Ia.add(h), Fd.addChild(h.displayObject);
                break;
            case 131:
                h = np.allocate().init(t, s, n, r, o, a).deploy(), Ma.add(h), Nd.addChild(h.displayObject);
                break;
            case 141:
                h = op.allocate().init(t, s, n, r, o).deploy(), Tn.add(h), is.addChild(h.displayObject);
                break;
            case 142:
                h = ap.allocate().init(t, s, n, r, o).deploy(), ur.add(h), is.addChild(h.displayObject);
                break
        }
        if (s) ze.set(s, h);
        else {
            oa.add(h);
            return
        }
        i % 10 != 0 && i < 140 ? (h.state = 0, H.EnableAppearance && (h.preAppear(t), Qn.add(h))) : h.state = 1
    }
    static preUpdate({
        coef: t,
        time: i,
        id: s,
        x: n,
        y: r,
        mass: o
    }) {
        const a = ze.get(s);
        a.update_linear(t), a.sync(), a.lastSync = i, a.preUpdate(n, r, o), gn.add(a)
    }
    static sync(t) {
        U.opUnits.forEach(s => s.sortPlayerCell()), U.update(), ci.state ? ze.forEach(s => {
            s.lastSync < Gt.syncStamp && Me.remove(t, s.id), s.syncUpdate && s.syncUpdate()
        }) : (gn.forEach(s => {
            let n;
            s.lastSync < Gt.syncStamp && (n = vi(s.lastSync, Gt.syncStamp, Er()), s.update_linear(n), s.sync(), s.lastSync = Gt.syncStamp)
        }), Ce.forEach(s => s.syncUpdate()));
        const i = vi(0, 40, 200);
        oa.forEach(s => {
            s.update_linear(i), s.sync(), s.nr = s.or * 1.25 + Math.min(s.or / 2.25, 196), s.finalAlpha && s.nr > 1250 && s.preDisappear(Gt.syncStamp)
        }), A.emit("endMainPacket")
    }
    static update_base(t) {
        _n.forEach(i => {
            i.death(t) && (_n.delete(i), this.release(i))
        }), $r.forEach(i => {
            i.disappear(t) && ($r.delete(i), this.release(i))
        }), Qn.forEach(i => {
            i.appear(t) && Qn.delete(i)
        })
    }
    static update_linear(t) {
        this.update_base(t);
        const i = vi(Gt.syncStamp, t, 200);
        oa.forEach(n => {
            n.update_linear(i), n.finalAlpha == 0 && n.disappear(t) && (n.displayObject.removeFromParent(), oa.delete(n))
        });
        const s = vi(Gt.syncStamp, t, Er());
        gn.forEach(n => {
            n.update_linear(s) && gn.delete(n)
        }), ci.state ? ze.forEach(n => {
            n.frameUpdate && n.frameUpdate()
        }) : Ce.forEach(n => n.frameUpdate())
    }
    static eat(t, i, s) {
        const n = ze.get(i);
        if (n.preDeath(t), n.state = 2, H.EnableAbsorption && ze.has(s)) {
            const {
                nx: r,
                ny: o,
                nr: a
            } = ze.get(s), l = Math.max(n.nr / a - .375, 0) * 8 + 1;
            n.preUpdate(r, o, n.nr / l), _n.add(n)
        } else A.emit("recordTempCell", n), n.release(), this.release(n);
        ze.delete(i), gn.delete(n), Qn.delete(n), $r.delete(n)
    }
    static remove(t, i) {
        const s = ze.get(i);
        s.preDisappear(t), H.EnableDisappearance ? $r.add(s) : (s.release(), this.release(s)), ze.delete(i), gn.delete(s), _n.delete(s), Qn.delete(s)
    }
    static release(t) {
        t instanceof ep ? (Ce.delete(t), is.removeChild(t.displayObject)) : t instanceof cy ? (Ia.delete(t), Fd.removeChild(t.displayObject)) : t instanceof hy ? (Ma.delete(t), Nd.removeChild(t.displayObject)) : t instanceof uy ? (Tn.delete(t), is.removeChild(t.displayObject)) : t instanceof dy && (ur.delete(t), is.removeChild(t.displayObject))
    }
    static reset() {
        _n.forEach(t => {
            t.release()
        }), $r.forEach(t => {
            t.release()
        }), ze.forEach(t => {
            t.release()
        }), oa.forEach(t => {
            t.release()
        }), Ce.clear(), gn.clear(), _n.clear(), Qn.clear(), $r.clear(), ze.clear()
    }
}
A.on(Ut.TagType, () => {
    zt.forEach(e => e.opUnits.forEach(t => t.updateText())), Ce.forEach(e => e.deployNickVisibility())
});
A.on(Ut.ShowNick, () => Ce.forEach(e => e.deployNickVisibility()));
A.on(Ut.ShowMass, () => Ce.forEach(e => e.deployMassVisibility()));
A.on(Ut.ShowSkin, () => Ce.forEach(e => e.deployEntityTexture()));
A.on(Ut.ShowFood, () => Cn.deployFoodCellContainerVisibility());
A.on(Ut.VirusType, () => {
    Tn.forEach(e => e.deployVirusStyle()), ur.forEach(e => e.deployVirusStyle())
});
A.on(Ut.ShowCursorLine, () => U.opUnitQueue.current.pcells.forEach(e => e.deployCursorLineVisibility()));
A.on(Ut.ShowMassMarker, () => {
    Ce.forEach(e => {
        e.assistance.needUpdate = !0, e.drawAssistance()
    })
});
A.on(Ut.ShowSplitOrderMarker, () => {
    U.opUnits.forEach(e => e.deploySplitOrderMarkerStyle())
});
A.on(Ut.ShootingHintType, () => {
    Tn.forEach(e => e.updateMass(e.r))
});
A.on(Ht.EjectedCell, () => Ia.forEach(e => e.deployBaseLayerStyle()));
A.on(Ht.Food, () => Ma.forEach(e => e.deployBaseLayerStyle()));
A.on(Ht.Virus, () => Tn.forEach(e => e.deployBaseLayerStyle()));
A.on(Ht.RedVirus, () => ur.forEach(e => e.deployBaseLayerStyle()));
A.on(Ht.Text, () => {
    zt.forEach(e => e.opUnits.forEach(t => t.updateText())), Ms.forEach(e => e.updateText()), Th()
});
A.on(Ht.TextStroke, () => {
    zt.forEach(e => e.opUnits.forEach(t => t.updateText())), Ms.forEach(e => e.updateText()), Th()
});
A.on(Ht.CellSelf, () => {
    U.opUnits.forEach(e => e.pcells.forEach(t => t.deployEntityTexture()))
});
A.on(Ht.SkinSelf, () => {
    U.opUnits.forEach(e => e.pcells.forEach(t => t.deployEntityTexture()))
});
A.on(Ht.SkinFillSelf, () => {
    U.opUnits.forEach(e => e.updateSkin())
});
A.on(Ht.CellTeam, () => Ce.forEach(e => e.deployEntityTexture()));
A.on(Ht.SkinTeam, () => Ce.forEach(e => e.deployEntityTexture()));
A.on(Ht.SkinFillTeam, () => {
    zt.forEach(e => {
        e.opUnits.forEach(t => t.updateSkin())
    })
});
A.on(Ht.CellEnemy, () => Ce.forEach(e => e.deployEntityTexture()));
A.on(Ht.SkinEnemy, () => Ce.forEach(e => e.deployEntityTexture()));
A.on(Ht.SkinFillEnemy, () => {
    zt.forEach(e => {
        e.opUnits.forEach(t => t.updateSkin())
    })
});
A.on(Ht.CellAll, () => {
    B.CellSelf = B.CellTeam = B.CellEnemy = B.CellAll, Ce.forEach(e => e.deployEntityTexture())
});
A.on(Ht.SkinAll, () => {
    B.SkinSelf = B.SkinTeam = B.SkinEnemy = B.SkinAll, Ce.forEach(e => e.deployEntityTexture())
});
A.on(Ht.SkinFillAll, () => {
    B.SkinFillSelf = B.SkinFillTeam = B.SkinFillEnemy = B.SkinFillAll, zt.forEach(e => {
        e.opUnits.forEach(t => t.updateSkin())
    })
});
A.on(Ht.MassMarker, () => {
    Ce.forEach(e => {
        e.assistance.needUpdate = !0, e.drawAssistance()
    })
});
A.on(Ht.SplitOrderMarker, () => {
    U.opUnits.forEach(e => e.deploySplitOrderMarkerStyle())
});
A.on("play", () => Ce.forEach(e => e.interactive = !1));
A.on("spectate", () => Ce.forEach(e => e.interactive = !0));
A.on("death", () => Ce.forEach(e => e.interactive = !0));
let Rk = 0;
class py {
    constructor(t, i, s) {
        I(this, "id");
        I(this, "uSig");
        I(this, "name");
        I(this, "color");
        I(this, "tagText");
        I(this, "players", new Set);
        this.id = t, this.uSig = Rk++, this.name = i, this.color = s, this.updateText()
    }
    joinPlayer(t) {
        t.forEach(i => {
            i.leaveTeam(), i.team = this, this.players.add(i), i.opUnits.forEach(s => {
                s.updateText()
            })
        })
    }
    quitPlayer(t) {
        this.players.delete(t)
    }
    updateText() {
        this.updateTag(), this.updateBitmapFont()
    }
    updateTag() {
        if (!this.name || this.id == 0) return;
        this.tagText || (this.tagText = new ys);
        const t = dr.clone();
        B.Text[3] & 4 ? t.fill = lr(this.color, B.Text[1]) : t.fill = ar(B.Text), B.TextStroke[3] & 4 ? t.stroke = lr(this.color, B.TextStroke[1]) : t.stroke = ar(B.TextStroke), t.fontSize = Lc() * .72, t.strokeThickness = Oc() * .786, this.tagText.style = t, this.tagText.text = this.name, this.tagText.updateText()
    }
    updateBitmapFont() {
        const t = dr.clone();
        B.Text[3] & 4 ? t.fill = lr(this.color, B.Text[1]) : t.fill = ar(B.Text), B.TextStroke[3] & 4 ? t.stroke = lr(this.color, B.TextStroke[1]) : t.stroke = ar(B.TextStroke), t.fontSize = Lc(), t.strokeThickness = Oc();
        const i = We / 400;
        le.from(`${this.uSig}`, t, {
            chars: [...le.NUMERIC, ".Kk"],
            textureWidth: 256 * i,
            textureHeight: 276 * i,
            mipmap: H.Mipmap * 2
        })
    }
    destroy() {
        setTimeout(() => {
            this.tagText && (this.tagText.removeFromParent(), this.tagText.destroy({
                texture: !0,
                baseTexture: !0
            })), le.available[this.uSig].destroy()
        }, 1e3)
    }
}
class kk {
    constructor() {
        I(this, "store", []);
        I(this, "currIndex", 0);
        I(this, "targetIndex", 0)
    }
    get size() {
        return this.store.length
    }
    get first() {
        return this.store[0]
    }
    get last() {
        return this.store[this.size - 1]
    }
    get current() {
        return this.store[this.currIndex]
    }
    get target() {
        return this.store[this.targetIndex]
    }
    get nextToggleIndex() {
        let t = this.targetIndex;
        return t += 1, t >= this.size && (t = 0), this.targetIndex = t, t
    }
    push(t) {
        this.store.push(t)
    }
    remove(t) {
        const i = this.store.indexOf(t);
        this.store.slice(i, 1)
    }
    advance() {
        this.currIndex += 1, this.currIndex >= this.size && (this.currIndex = 0)
    }
    moveTo(t) {
        this.currIndex = t
    }
    clear() {
        this.targetIndex = 0, this.currIndex = 0, this.store.length = 0
    }
}
Nt.prototype.getDrawableSource = function() {
    const t = this.resource;
    return t ? t.bitmap || t.source : null
};
Vf.prototype._canvasRenderTarget = null;
ht.prototype.patternCache = null;
ht.prototype.tintCache = null;

function Wg(e) {
    const t = ut.ADAPTER.createCanvas(6, 1),
        i = t.getContext("2d");
    return i.fillStyle = e, i.fillRect(0, 0, 6, 1), t
}

function my() {
    if (typeof document > "u") return !1;
    const e = Wg("#ff00ff"),
        t = Wg("#ffff00"),
        s = ut.ADAPTER.createCanvas(6, 1).getContext("2d");
    s.globalCompositeOperation = "multiply", s.drawImage(e, 0, 0), s.drawImage(t, 2, 0);
    const n = s.getImageData(2, 0, 1, 1);
    if (!n) return !1;
    const r = n.data;
    return r[0] === 255 && r[1] === 0 && r[2] === 0
}

function Pk(e = []) {
    return my() ? (e[j.NORMAL] = "source-over", e[j.ADD] = "lighter", e[j.MULTIPLY] = "multiply", e[j.SCREEN] = "screen", e[j.OVERLAY] = "overlay", e[j.DARKEN] = "darken", e[j.LIGHTEN] = "lighten", e[j.COLOR_DODGE] = "color-dodge", e[j.COLOR_BURN] = "color-burn", e[j.HARD_LIGHT] = "hard-light", e[j.SOFT_LIGHT] = "soft-light", e[j.DIFFERENCE] = "difference", e[j.EXCLUSION] = "exclusion", e[j.HUE] = "hue", e[j.SATURATION] = "saturation", e[j.COLOR] = "color", e[j.LUMINOSITY] = "luminosity") : (e[j.NORMAL] = "source-over", e[j.ADD] = "lighter", e[j.MULTIPLY] = "source-over", e[j.SCREEN] = "source-over", e[j.OVERLAY] = "source-over", e[j.DARKEN] = "source-over", e[j.LIGHTEN] = "source-over", e[j.COLOR_DODGE] = "source-over", e[j.COLOR_BURN] = "source-over", e[j.HARD_LIGHT] = "source-over", e[j.SOFT_LIGHT] = "source-over", e[j.DIFFERENCE] = "source-over", e[j.EXCLUSION] = "source-over", e[j.HUE] = "source-over", e[j.SATURATION] = "source-over", e[j.COLOR] = "source-over", e[j.LUMINOSITY] = "source-over"), e[j.NORMAL_NPM] = e[j.NORMAL], e[j.ADD_NPM] = e[j.ADD], e[j.SCREEN_NPM] = e[j.SCREEN], e[j.SRC_IN] = "source-in", e[j.SRC_OUT] = "source-out", e[j.SRC_ATOP] = "source-atop", e[j.DST_OVER] = "destination-over", e[j.DST_IN] = "destination-in", e[j.DST_OUT] = "destination-out", e[j.DST_ATOP] = "destination-atop", e[j.XOR] = "xor", e[j.SUBTRACT] = "source-over", e
}
const Lk = new pe;
class gy {
    constructor(t) {
        this.activeResolution = 1, this.smoothProperty = "imageSmoothingEnabled", this.blendModes = Pk(), this._activeBlendMode = null, this._projTransform = null, this._outerBlend = !1, this.renderer = t
    }
    init() {
        const t = this.renderer.background.alpha < 1;
        if (this.rootContext = this.renderer.view.getContext("2d", {
                alpha: t
            }), this.activeContext = this.rootContext, !this.rootContext.imageSmoothingEnabled) {
            const i = this.rootContext;
            i.webkitImageSmoothingEnabled ? this.smoothProperty = "webkitImageSmoothingEnabled" : i.mozImageSmoothingEnabled ? this.smoothProperty = "mozImageSmoothingEnabled" : i.oImageSmoothingEnabled ? this.smoothProperty = "oImageSmoothingEnabled" : i.msImageSmoothingEnabled && (this.smoothProperty = "msImageSmoothingEnabled")
        }
    }
    setContextTransform(t, i, s) {
        let n = t;
        const r = this._projTransform,
            o = this.activeResolution;
        s = s || o, r && (n = Lk, n.copyFrom(t), n.prepend(r)), i ? this.activeContext.setTransform(n.a * s, n.b * s, n.c * s, n.d * s, n.tx * o | 0, n.ty * o | 0) : this.activeContext.setTransform(n.a * s, n.b * s, n.c * s, n.d * s, n.tx * o, n.ty * o)
    }
    clear(t, i) {
        const {
            activeContext: s,
            renderer: n
        } = this;
        t = t ?? this.renderer.background.colorString, s.clearRect(0, 0, n.width, n.height), t && (s.globalAlpha = i ?? this.renderer.background.alpha, s.fillStyle = t, s.fillRect(0, 0, n.width, n.height), s.globalAlpha = 1)
    }
    setBlendMode(t, i) {
        const s = t === j.SRC_IN || t === j.SRC_OUT || t === j.DST_IN || t === j.DST_ATOP;
        !i && s && (t = j.NORMAL), this._activeBlendMode !== t && (this._activeBlendMode = t, this._outerBlend = s, this.activeContext.globalCompositeOperation = this.blendModes[t])
    }
    resize() {
        this.smoothProperty && (this.rootContext[this.smoothProperty] = ut.SCALE_MODE === Hi.LINEAR)
    }
    invalidateBlendMode() {
        this._activeBlendMode = this.blendModes.indexOf(this.activeContext.globalCompositeOperation)
    }
    destroy() {
        this.renderer = null, this.rootContext = null, this.activeContext = null, this.smoothProperty = null
    }
}
gy.extension = {
    type: lt.CanvasRendererSystem,
    name: "canvasContext"
};
vt.add(gy);
class vy {
    constructor(t) {
        this._foundShapes = [], this.renderer = t
    }
    pushMask(t) {
        const i = this.renderer,
            s = t.maskObject || t;
        i.canvasContext.activeContext.save();
        const n = this._foundShapes;
        if (this.recursiveFindShapes(s, n), n.length > 0) {
            const r = i.canvasContext.activeContext;
            r.beginPath();
            for (let o = 0; o < n.length; o++) {
                const a = n[o],
                    l = a.transform.worldTransform;
                this.renderer.canvasContext.setContextTransform(l), this.renderGraphicsShape(a)
            }
            n.length = 0, r.clip()
        }
    }
    recursiveFindShapes(t, i) {
        t.geometry && t.geometry.graphicsData && i.push(t);
        const {
            children: s
        } = t;
        if (s)
            for (let n = 0; n < s.length; n++) this.recursiveFindShapes(s[n], i)
    }
    renderGraphicsShape(t) {
        t.finishPoly();
        const i = this.renderer.canvasContext.activeContext,
            s = t.geometry.graphicsData,
            n = s.length;
        if (n !== 0)
            for (let r = 0; r < n; r++) {
                const o = s[r],
                    a = o.shape;
                if (a.type === we.POLY) {
                    let l = a.points;
                    const c = o.holes;
                    let h, u, d, f;
                    i.moveTo(l[0], l[1]);
                    for (let p = 1; p < l.length / 2; p++) i.lineTo(l[p * 2], l[p * 2 + 1]);
                    if (c.length > 0) {
                        h = 0, d = l[0], f = l[1];
                        for (let p = 2; p + 2 < l.length; p += 2) h += (l[p] - d) * (l[p + 3] - f) - (l[p + 2] - d) * (l[p + 1] - f);
                        for (let p = 0; p < c.length; p++)
                            if (l = c[p].shape.points, !!l) {
                                u = 0, d = l[0], f = l[1];
                                for (let m = 2; m + 2 < l.length; m += 2) u += (l[m] - d) * (l[m + 3] - f) - (l[m + 2] - d) * (l[m + 1] - f);
                                if (u * h < 0) {
                                    i.moveTo(l[0], l[1]);
                                    for (let m = 2; m < l.length; m += 2) i.lineTo(l[m], l[m + 1])
                                } else {
                                    i.moveTo(l[l.length - 2], l[l.length - 1]);
                                    for (let m = l.length - 4; m >= 0; m -= 2) i.lineTo(l[m], l[m + 1])
                                }
                                c[p].shape.closeStroke && i.closePath()
                            }
                    }
                    l[0] === l[l.length - 2] && l[1] === l[l.length - 1] && i.closePath()
                } else if (a.type === we.RECT) i.rect(a.x, a.y, a.width, a.height), i.closePath();
                else if (a.type === we.CIRC) i.arc(a.x, a.y, a.radius, 0, 2 * Math.PI), i.closePath();
                else if (a.type === we.ELIP) {
                    const l = a.width * 2,
                        c = a.height * 2,
                        h = a.x - l / 2,
                        u = a.y - c / 2,
                        d = .5522848,
                        f = l / 2 * d,
                        p = c / 2 * d,
                        m = h + l,
                        g = u + c,
                        y = h + l / 2,
                        x = u + c / 2;
                    i.moveTo(h, x), i.bezierCurveTo(h, x - p, y - f, u, y, u), i.bezierCurveTo(y + f, u, m, x - p, m, x), i.bezierCurveTo(m, x + p, y + f, g, y, g), i.bezierCurveTo(y - f, g, h, x + p, h, x), i.closePath()
                } else if (a.type === we.RREC) {
                    const l = a.x,
                        c = a.y,
                        h = a.width,
                        u = a.height;
                    let d = a.radius;
                    const f = Math.min(h, u) / 2;
                    d = d > f ? f : d, i.moveTo(l, c + d), i.lineTo(l, c + u - d), i.quadraticCurveTo(l, c + u, l + d, c + u), i.lineTo(l + h - d, c + u), i.quadraticCurveTo(l + h, c + u, l + h, c + u - d), i.lineTo(l + h, c + d), i.quadraticCurveTo(l + h, c, l + h - d, c), i.lineTo(l + d, c), i.quadraticCurveTo(l, c, l, c + d), i.closePath()
                }
            }
    }
    popMask(t) {
        t.canvasContext.activeContext.restore(), t.canvasContext.invalidateBlendMode()
    }
    destroy() {}
}
vy.extension = {
    type: lt.CanvasRendererSystem,
    name: "mask"
};
vt.add(vy);
class _y {
    constructor(t) {
        this.renderer = t
    }
    render(t, i) {
        const s = this.renderer;
        if (!s.view) return;
        const n = s.canvasContext;
        let r, o, a, l;
        i && (r = i.renderTexture, o = i.clear, a = i.transform, l = i.skipUpdateTransform), this.renderingToScreen = !r, s.emit("prerender");
        const c = s.resolution;
        r ? (r = r.castToBaseTexture(), r._canvasRenderTarget || (r._canvasRenderTarget = new Po(r.width, r.height, r.resolution), r.resource = new v1(r._canvasRenderTarget.canvas), r.valid = !0), n.activeContext = r._canvasRenderTarget.context, s.canvasContext.activeResolution = r._canvasRenderTarget.resolution) : (n.activeContext = n.rootContext, n.activeResolution = c);
        const h = n.activeContext;
        if (n._projTransform = a || null, r || (this.lastObjectRendered = t), !l) {
            const d = t.enableTempParent();
            t.updateTransform(), t.disableTempParent(d)
        }
        if (h.save(), h.setTransform(1, 0, 0, 1, 0, 0), h.globalAlpha = 1, n._activeBlendMode = j.NORMAL, n._outerBlend = !1, h.globalCompositeOperation = n.blendModes[j.NORMAL], o ?? s.background.clearBeforeRender)
            if (this.renderingToScreen) {
                h.clearRect(0, 0, s.width, s.height);
                const d = s.background;
                d.alpha > 0 && (h.globalAlpha = d.alpha, h.fillStyle = d.colorString, h.fillRect(0, 0, s.width, s.height), h.globalAlpha = 1)
            } else {
                r = r, r._canvasRenderTarget.clear();
                const d = r.clearColor;
                d[3] > 0 && (h.globalAlpha = d[3] ?? 1, h.fillStyle = ah(Df(d)), h.fillRect(0, 0, r.realWidth, r.realHeight), h.globalAlpha = 1)
            } const u = n.activeContext;
        n.activeContext = h, t.renderCanvas(s), n.activeContext = u, h.restore(), n.activeResolution = c, n._projTransform = null, s.emit("postrender")
    }
    destroy() {
        this.lastObjectRendered = null, this.render = null
    }
}
_y.extension = {
    type: lt.CanvasRendererSystem,
    name: "objectRenderer"
};
vt.add(_y);
const {
    deprecation: Je
} = l4, Bd = class extends o1 {
    constructor(e) {
        super(), this.rendererLogId = "Canvas", e = Object.assign({}, ut.RENDER_OPTIONS, e);
        const t = {
            runners: ["init", "destroy", "contextChange", "resolutionChange", "reset", "update", "postrender", "prerender", "resize"],
            systems: Bd.__systems,
            priority: ["textureGenerator", "background", "_view", "_plugin", "startup", "mask", "canvasContext", "objectRenderer"]
        };
        this.setup(t), "useContextAlpha" in e && (Je("7.0.0", "options.useContextAlpha is deprecated, use options.backgroundAlpha instead"), e.backgroundAlpha = e.useContextAlpha === !1 ? 1 : e.backgroundAlpha);
        const i = {
            hello: e.hello,
            _plugin: Bd.__plugins,
            background: {
                alpha: e.backgroundAlpha,
                color: e.background ?? e.backgroundColor,
                clearBeforeRender: e.clearBeforeRender
            },
            _view: {
                height: e.height,
                width: e.width,
                autoDensity: e.autoDensity,
                resolution: e.resolution,
                view: e.view
            }
        };
        this.startup.run(i), this.options = e
    }
    static test() {
        return !0
    }
    generateTexture(e, t) {
        return this.textureGenerator.generateTexture(e, t)
    }
    reset() {}
    render(e, t) {
        this.objectRenderer.render(e, t)
    }
    clear() {
        this.canvasContext.clear()
    }
    destroy(e) {
        this.runners.destroy.items.reverse(), this.emitWithCustomOptions(this.runners.destroy, {
            _view: e
        }), super.destroy()
    }
    get plugins() {
        return this._plugin.plugins
    }
    resize(e, t) {
        this._view.resizeView(e, t)
    }
    get width() {
        return this._view.element.width
    }
    get height() {
        return this._view.element.height
    }
    get resolution() {
        return this._view.resolution
    }
    set resolution(e) {
        this._view.resolution = e, this.runners.resolutionChange.emit(e)
    }
    get autoDensity() {
        return this._view.autoDensity
    }
    get view() {
        return this._view.element
    }
    get screen() {
        return this._view.screen
    }
    get lastObjectRendered() {
        return this.objectRenderer.lastObjectRendered
    }
    get renderingToScreen() {
        return this.objectRenderer.renderingToScreen
    }
    get clearBeforeRender() {
        return this.background.clearBeforeRender
    }
    get blendModes() {
        return Je("7.0.0", "renderer.blendModes has been deprecated, please use renderer.canvasContext.blendModes instead"), this.canvasContext.blendModes
    }
    get maskManager() {
        return Je("7.0.0", "renderer.maskManager has been deprecated, please use renderer.mask instead"), this.mask
    }
    get refresh() {
        return Je("7.0.0", "renderer.refresh has been deprecated"), !0
    }
    get rootContext() {
        return Je("7.0.0", "renderer.rootContext has been deprecated, please use renderer.canvasContext.rootContext instead"), this.canvasContext.rootContext
    }
    get context() {
        return Je("7.0.0", "renderer.context has been deprecated, please use renderer.canvasContext.activeContext instead"), this.canvasContext.activeContext
    }
    get smoothProperty() {
        return Je("7.0.0", "renderer.smoothProperty has been deprecated, please use renderer.canvasContext.smoothProperty instead"), this.canvasContext.smoothProperty
    }
    setBlendMode(e, t) {
        Je("7.0.0", "renderer.setBlendMode has been deprecated, use renderer.canvasContext.setBlendMode instead"), this.canvasContext.setBlendMode(e, t)
    }
    invalidateBlendMode() {
        Je("7.0.0", "renderer.invalidateBlendMode has been deprecated, use renderer.canvasContext.invalidateBlendMode instead"), this.canvasContext.invalidateBlendMode()
    }
    setContextTransform(e, t, i) {
        Je("7.0.0", "renderer.setContextTransform has been deprecated, use renderer.canvasContext.setContextTransform instead"), this.canvasContext.setContextTransform(e, t, i)
    }
    get backgroundColor() {
        return Je("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color
    }
    set backgroundColor(e) {
        Je("7.0.0", "renderer.backgroundColor has been deprecated, use renderer.background.color instead."), this.background.color = e
    }
    get backgroundAlpha() {
        return Je("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.color
    }
    set backgroundAlpha(e) {
        Je("7.0.0", "renderer.backgroundAlpha has been deprecated, use renderer.background.alpha instead."), this.background.alpha = e
    }
    get preserveDrawingBuffer() {
        return Je("7.0.0", "renderer.preserveDrawingBuffer has been deprecated"), !1
    }
    get useContextAlpha() {
        return Je("7.0.0", "renderer.useContextAlpha has been deprecated"), !1
    }
};
let Or = Bd;
Or.extension = {
    type: lt.Renderer,
    priority: 0
};
Or.__plugins = {};
Or.__systems = {};
vt.handleByMap(lt.CanvasRendererPlugin, Or.__plugins);
vt.handleByMap(lt.CanvasRendererSystem, Or.__systems);
vt.add(Or);
const Ge = {
    canvas: null,
    getTintedCanvas: (e, t) => {
        const i = e.texture;
        t = Ge.roundColor(t);
        const s = `#${`00000${(t|0).toString(16)}`.slice(-6)}`;
        i.tintCache = i.tintCache || {};
        const n = i.tintCache[s];
        let r;
        if (n) {
            if (n.tintId === i._updateID) return i.tintCache[s];
            r = i.tintCache[s]
        } else r = ut.ADAPTER.createCanvas();
        return Ge.tintMethod(i, t, r), r.tintId = i._updateID, i.tintCache[s] = r, r
    },
    getTintedPattern: (e, t) => {
        t = Ge.roundColor(t);
        const i = `#${`00000${(t|0).toString(16)}`.slice(-6)}`;
        e.patternCache = e.patternCache || {};
        let s = e.patternCache[i];
        return s?.tintId === e._updateID || (Ge.canvas || (Ge.canvas = ut.ADAPTER.createCanvas()), Ge.tintMethod(e, t, Ge.canvas), s = Ge.canvas.getContext("2d").createPattern(Ge.canvas, "repeat"), s.tintId = e._updateID, e.patternCache[i] = s), s
    },
    tintWithMultiply: (e, t, i) => {
        const s = i.getContext("2d"),
            n = e._frame.clone(),
            r = e.baseTexture.resolution;
        n.x *= r, n.y *= r, n.width *= r, n.height *= r, i.width = Math.ceil(n.width), i.height = Math.ceil(n.height), s.save(), s.fillStyle = `#${`00000${(t|0).toString(16)}`.slice(-6)}`, s.fillRect(0, 0, n.width, n.height), s.globalCompositeOperation = "multiply";
        const o = e.baseTexture.getDrawableSource();
        s.drawImage(o, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), s.globalCompositeOperation = "destination-atop", s.drawImage(o, n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), s.restore()
    },
    tintWithOverlay: (e, t, i) => {
        const s = i.getContext("2d"),
            n = e._frame.clone(),
            r = e.baseTexture.resolution;
        n.x *= r, n.y *= r, n.width *= r, n.height *= r, i.width = Math.ceil(n.width), i.height = Math.ceil(n.height), s.save(), s.globalCompositeOperation = "copy", s.fillStyle = `#${`00000${(t|0).toString(16)}`.slice(-6)}`, s.fillRect(0, 0, n.width, n.height), s.globalCompositeOperation = "destination-atop", s.drawImage(e.baseTexture.getDrawableSource(), n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), s.restore()
    },
    tintWithPerPixel: (e, t, i) => {
        const s = i.getContext("2d"),
            n = e._frame.clone(),
            r = e.baseTexture.resolution;
        n.x *= r, n.y *= r, n.width *= r, n.height *= r, i.width = Math.ceil(n.width), i.height = Math.ceil(n.height), s.save(), s.globalCompositeOperation = "copy", s.drawImage(e.baseTexture.getDrawableSource(), n.x, n.y, n.width, n.height, 0, 0, n.width, n.height), s.restore();
        const o = tn(t),
            a = o[0],
            l = o[1],
            c = o[2],
            h = s.getImageData(0, 0, n.width, n.height),
            u = h.data;
        for (let d = 0; d < u.length; d += 4) u[d + 0] *= a, u[d + 1] *= l, u[d + 2] *= c;
        s.putImageData(h, 0, 0)
    },
    roundColor: e => {
        const t = Ge.cacheStepsPerColorChannel,
            i = tn(e);
        return i[0] = Math.min(255, i[0] / t * t), i[1] = Math.min(255, i[1] / t * t), i[2] = Math.min(255, i[2] / t * t), Df(i)
    },
    cacheStepsPerColorChannel: 8,
    convertTintToImage: !1,
    canUseMultiply: my(),
    tintMethod: null
};
Ge.tintMethod = Ge.canUseMultiply ? Ge.tintWithMultiply : Ge.tintWithPerPixel;
const Vl = new pe,
    aa = new pe,
    ws = [new Zt, new Zt, new Zt, new Zt];
Yf.prototype._renderCanvas = function(t) {
    const i = this._texture;
    if (!i.baseTexture.valid) return;
    const s = t.canvasContext.activeContext,
        n = this.worldTransform,
        r = i.baseTexture,
        o = r.getDrawableSource(),
        a = r.resolution;
    if (this._textureID !== this._texture._updateID || this._cachedTint !== this.tint) {
        this._textureID = this._texture._updateID;
        const f = new Po(i._frame.width, i._frame.height, a);
        this.tint !== 16777215 ? (this._tintedCanvas = Ge.getTintedCanvas(this, this.tint), f.context.drawImage(this._tintedCanvas, 0, 0)) : f.context.drawImage(o, -i._frame.x * a, -i._frame.y * a), this._cachedTint = this.tint, this._canvasPattern = f.context.createPattern(f.canvas, "repeat")
    }
    s.globalAlpha = this.worldAlpha, t.canvasContext.setBlendMode(this.blendMode), this.tileTransform.updateLocalTransform();
    const l = this.tileTransform.localTransform,
        c = this._width,
        h = this._height;
    Vl.identity(), aa.copyFrom(l), this.uvRespectAnchor || aa.translate(-this.anchor.x * c, -this.anchor.y * h), aa.scale(this.tileScale.x / a, this.tileScale.y / a), Vl.prepend(aa), Vl.prepend(n), t.canvasContext.setContextTransform(Vl), s.fillStyle = this._canvasPattern;
    const u = this.anchor.x * -c,
        d = this.anchor.y * -h;
    ws[0].set(u, d), ws[1].set(u + c, d), ws[2].set(u + c, d + h), ws[3].set(u, d + h);
    for (let f = 0; f < 4; f++) aa.applyInverse(ws[f], ws[f]);
    s.beginPath(), s.moveTo(ws[0].x, ws[0].y);
    for (let f = 1; f < 4; f++) s.lineTo(ws[f].x, ws[f].y);
    s.closePath(), s.fill()
};
Td.prototype.renderCanvas = function(t) {
    if (!this.visible || this.worldAlpha <= 0 || !this.children.length || !this.renderable) return;
    const i = t.canvasContext.activeContext,
        s = this.worldTransform;
    let n = !0,
        r = 0,
        o = 0,
        a = 0,
        l = 0;
    t.canvasContext.setBlendMode(this.blendMode), i.globalAlpha = this.worldAlpha, this.displayObjectUpdateTransform();
    for (let c = 0; c < this.children.length; ++c) {
        const h = this.children[c];
        if (!h.visible || !h._texture.valid) continue;
        const u = h._texture.frame;
        if (i.globalAlpha = this.worldAlpha * h.alpha, h.rotation % (Math.PI * 2) === 0) n && (t.canvasContext.setContextTransform(s, !1, 1), n = !1), r = h.anchor.x * (-u.width * h.scale.x) + h.position.x + .5, o = h.anchor.y * (-u.height * h.scale.y) + h.position.y + .5, a = u.width * h.scale.x, l = u.height * h.scale.y;
        else {
            n || (n = !0), h.displayObjectUpdateTransform();
            const p = h.worldTransform;
            t.canvasContext.setContextTransform(p, this.roundPixels, 1), r = h.anchor.x * -u.width + .5, o = h.anchor.y * -u.height + .5, a = u.width, l = u.height
        }
        const d = h._texture.baseTexture.resolution,
            f = t.canvasContext.activeResolution;
        i.drawImage(h._texture.baseTexture.getDrawableSource(), u.x * d, u.y * d, u.width * d, u.height * d, r * f, o * f, a * f, l * f)
    }
};
ae.prototype._renderCanvas = function(t) {};
ae.prototype.renderCanvas = function(t) {
    if (!(!this.visible || this.worldAlpha <= 0 || !this.renderable)) {
        this._mask && t.mask.pushMask(this._mask), this._renderCanvas(t);
        for (let i = 0, s = this.children.length; i < s; ++i) this.children[i].renderCanvas(t);
        this._mask && t.mask.popMask(t)
    }
};
Ae.prototype.renderCanvas = function(t) {};
ys.prototype._renderCanvas = function(t) {
    this._autoResolution && this._resolution !== t.resolution && (this._resolution = t.resolution, this.dirty = !0), this.updateText(!0), hi.prototype._renderCanvas.call(this, t)
};
const Xg = new qt;
class yy {
    constructor(t) {
        this.renderer = t
    }
    async image(t, i, s) {
        const n = new Image;
        return n.src = await this.base64(t, i, s), n
    }
    async base64(t, i, s) {
        const n = this.canvas(t);
        if (n.toDataURL !== void 0) return n.toDataURL(i, s);
        if (n.convertToBlob !== void 0) {
            const r = await n.convertToBlob({
                type: i,
                quality: s
            });
            return await new Promise(o => {
                const a = new FileReader;
                a.onload = () => o(a.result), a.readAsDataURL(r)
            })
        }
        throw new Error("CanvasExtract.base64() requires ICanvas.toDataURL or ICanvas.convertToBlob to be implemented")
    }
    canvas(t, i) {
        const s = this.renderer;
        let n, r, o;
        t && (t instanceof fs ? o = t : o = s.generateTexture(t)), o ? (n = o.baseTexture._canvasRenderTarget.context, r = o.baseTexture._canvasRenderTarget.resolution, i = i ?? o.frame) : (n = s.canvasContext.rootContext, r = s._view.resolution, i || (i = Xg, i.width = s.width, i.height = s.height));
        const a = Math.round(i.x * r),
            l = Math.round(i.y * r),
            c = Math.round(i.width * r),
            h = Math.round(i.height * r),
            u = new Po(c, h, 1),
            d = n.getImageData(a, l, c, h);
        return u.context.putImageData(d, 0, 0), u.canvas
    }
    pixels(t, i) {
        const s = this.renderer;
        let n, r, o;
        t && (t instanceof fs ? o = t : o = s.generateTexture(t)), o ? (n = o.baseTexture._canvasRenderTarget.context, r = o.baseTexture._canvasRenderTarget.resolution, i = i ?? o.frame) : (n = s.canvasContext.rootContext, r = s.resolution, i || (i = Xg, i.width = s.width, i.height = s.height));
        const a = Math.round(i.x * r),
            l = Math.round(i.y * r),
            c = Math.round(i.width * r),
            h = Math.round(i.height * r);
        return n.getImageData(a, l, c, h).data
    }
    destroy() {
        this.renderer = null
    }
}
yy.extension = {
    name: "extract",
    type: lt.CanvasRendererSystem
};
vt.add(yy);
let yu;
const la = new pe;
ke.prototype.generateCanvasTexture = function(t, i = 1) {
    const s = this.getLocalBounds(),
        n = fs.create({
            width: s.width,
            height: s.height,
            scaleMode: t,
            resolution: i
        });
    yu || (yu = new Or), this.transform.updateLocalTransform(), this.transform.localTransform.copyTo(la), la.invert(), la.tx -= s.x, la.ty -= s.y, yu.render(this, {
        renderTexture: n,
        clear: !0,
        transform: la
    });
    const r = ht.from(n.baseTexture._canvasRenderTarget.canvas, {
        scaleMode: t
    });
    return r.baseTexture.setResolution(i), r
};
ke.prototype.cachedGraphicsData = [];
ke.prototype._renderCanvas = function(t) {
    this.isMask !== !0 && (this.finishPoly(), t.plugins.graphics.render(this))
};
class za {
    static offsetPolygon(t, i) {
        const s = [],
            n = t.length;
        i = za.isPolygonClockwise(t) ? i : -1 * i;
        for (let r = 0; r < n; r += 2) {
            let o = r - 2;
            o < 0 && (o += n);
            const a = (r + 2) % n;
            let l = t[r] - t[o],
                c = t[r + 1] - t[o + 1],
                h = Math.sqrt(l * l + c * c);
            l /= h, c /= h, l *= i, c *= i;
            const u = -c,
                d = l,
                f = [t[o] + u, t[o + 1] + d],
                p = [t[r] + u, t[r + 1] + d];
            let m = t[a] - t[r],
                g = t[a + 1] - t[r + 1];
            h = Math.sqrt(m * m + g * g), m /= h, g /= h, m *= i, g *= i;
            const y = -g,
                x = m,
                v = [t[r] + y, t[r + 1] + x],
                _ = [t[a] + y, t[a + 1] + x],
                C = za.findIntersection(f[0], f[1], p[0], p[1], v[0], v[1], _[0], _[1]);
            C && s.push(...C)
        }
        return s
    }
    static findIntersection(t, i, s, n, r, o, a, l) {
        const c = (l - o) * (s - t) - (a - r) * (n - i),
            h = (a - r) * (i - o) - (l - o) * (t - r),
            u = (s - t) * (i - o) - (n - i) * (t - r);
        if (c === 0) return h === 0 && u === 0 ? [(t + s) / 2, (i + n) / 2] : null;
        const d = h / c;
        return [t + d * (s - t), i + d * (n - i)]
    }
    static isPolygonClockwise(t) {
        let i = 0;
        for (let s = 0, n = t.length - 2; s < t.length; n = s, s += 2) i += (t[s] - t[n]) * (t[s + 1] + t[n + 1]);
        return i > 0
    }
}
class by {
    constructor(t) {
        this._svgMatrix = null, this._tempMatrix = new pe, this.renderer = t
    }
    _calcCanvasStyle(t, i) {
        let s;
        return t.texture && t.texture.baseTexture !== ht.WHITE.baseTexture ? t.texture.valid ? (s = Ge.getTintedPattern(t.texture, i), this.setPatternTransform(s, t.matrix || pe.IDENTITY)) : s = "#808080" : s = `#${`00000${(i|0).toString(16)}`.slice(-6)}`, s
    }
    render(t) {
        const i = this.renderer,
            s = i.canvasContext.activeContext,
            n = t.worldAlpha,
            r = t.transform.worldTransform;
        i.canvasContext.setContextTransform(r), i.canvasContext.setBlendMode(t.blendMode);
        const o = t.geometry.graphicsData;
        let a, l;
        const c = (t.tint >> 16 & 255) / 255,
            h = (t.tint >> 8 & 255) / 255,
            u = (t.tint & 255) / 255;
        for (let d = 0; d < o.length; d++) {
            const f = o[d],
                p = f.shape,
                m = f.fillStyle,
                g = f.lineStyle,
                y = f.fillStyle.color | 0,
                x = f.lineStyle.color | 0;
            if (f.matrix && i.canvasContext.setContextTransform(r.copyTo(this._tempMatrix).append(f.matrix)), m.visible) {
                const v = ((y >> 16 & 255) / 255 * c * 255 << 16) + ((y >> 8 & 255) / 255 * h * 255 << 8) + (y & 255) / 255 * u * 255;
                a = this._calcCanvasStyle(m, v)
            }
            if (g.visible) {
                const v = ((x >> 16 & 255) / 255 * c * 255 << 16) + ((x >> 8 & 255) / 255 * h * 255 << 8) + (x & 255) / 255 * u * 255;
                l = this._calcCanvasStyle(g, v)
            }
            if (s.lineWidth = g.width, s.lineCap = g.cap, s.lineJoin = g.join, s.miterLimit = g.miterLimit, f.type === we.POLY) {
                s.beginPath();
                const v = p;
                let _ = v.points;
                const C = f.holes;
                let k, S, T, L, D;
                s.moveTo(_[0], _[1]);
                for (let O = 2; O < _.length; O += 2) s.lineTo(_[O], _[O + 1]);
                if (v.closeStroke && s.closePath(), C.length > 0) {
                    D = [], k = 0, T = _[0], L = _[1];
                    for (let O = 2; O + 2 < _.length; O += 2) k += (_[O] - T) * (_[O + 3] - L) - (_[O + 2] - T) * (_[O + 1] - L);
                    for (let O = 0; O < C.length; O++)
                        if (_ = C[O].shape.points, !!_) {
                            S = 0, T = _[0], L = _[1];
                            for (let K = 2; K + 2 < _.length; K += 2) S += (_[K] - T) * (_[K + 3] - L) - (_[K + 2] - T) * (_[K + 1] - L);
                            if (S * k < 0) {
                                s.moveTo(_[0], _[1]);
                                for (let K = 2; K < _.length; K += 2) s.lineTo(_[K], _[K + 1])
                            } else {
                                s.moveTo(_[_.length - 2], _[_.length - 1]);
                                for (let K = _.length - 4; K >= 0; K -= 2) s.lineTo(_[K], _[K + 1])
                            }
                            C[O].shape.closeStroke && s.closePath(), D[O] = S * k < 0
                        }
                }
                m.visible && (s.globalAlpha = m.alpha * n, s.fillStyle = a, s.fill()), g.visible && this.paintPolygonStroke(v, g, l, C, D, n, s)
            } else if (f.type === we.RECT) {
                const v = p;
                if (m.visible && (s.globalAlpha = m.alpha * n, s.fillStyle = a, s.fillRect(v.x, v.y, v.width, v.height)), g.visible) {
                    const _ = g.width * (.5 - (1 - g.alignment)),
                        C = v.width + 2 * _,
                        k = v.height + 2 * _;
                    s.globalAlpha = g.alpha * n, s.strokeStyle = l, s.strokeRect(v.x - _, v.y - _, C, k)
                }
            } else if (f.type === we.CIRC) {
                const v = p;
                if (s.beginPath(), s.arc(v.x, v.y, v.radius, 0, 2 * Math.PI), s.closePath(), m.visible && (s.globalAlpha = m.alpha * n, s.fillStyle = a, s.fill()), g.visible) {
                    if (g.alignment !== .5) {
                        const _ = g.width * (.5 - (1 - g.alignment));
                        s.beginPath(), s.arc(v.x, v.y, v.radius + _, 0, 2 * Math.PI), s.closePath()
                    }
                    s.globalAlpha = g.alpha * n, s.strokeStyle = l, s.stroke()
                }
            } else if (f.type === we.ELIP) {
                const v = p,
                    _ = g.alignment === 1;
                if (_ || this.paintEllipse(v, m, g, a, n, s), g.visible) {
                    if (g.alignment !== .5) {
                        const C = .5522848,
                            k = g.width * (.5 - (1 - g.alignment)),
                            S = (v.width + k) * 2,
                            T = (v.height + k) * 2,
                            L = v.x - S / 2,
                            D = v.y - T / 2,
                            O = S / 2 * C,
                            K = T / 2 * C,
                            P = L + S,
                            N = D + T,
                            W = L + S / 2,
                            V = D + T / 2;
                        s.beginPath(), s.moveTo(L, V), s.bezierCurveTo(L, V - K, W - O, D, W, D), s.bezierCurveTo(W + O, D, P, V - K, P, V), s.bezierCurveTo(P, V + K, W + O, N, W, N), s.bezierCurveTo(W - O, N, L, V + K, L, V), s.closePath()
                    }
                    s.globalAlpha = g.alpha * n, s.strokeStyle = l, s.stroke()
                }
                _ && this.paintEllipse(v, m, g, a, n, s)
            } else if (f.type === we.RREC) {
                const v = p,
                    _ = g.alignment === 1;
                if (_ || this.paintRoundedRectangle(v, m, g, a, n, s), g.visible) {
                    if (g.alignment !== .5) {
                        const C = v.width,
                            k = v.height,
                            S = g.width * (.5 - (1 - g.alignment)),
                            T = v.x - S,
                            L = v.y - S,
                            D = v.width + 2 * S,
                            O = v.height + 2 * S,
                            K = S * (g.alignment >= 1 ? Math.min(D / C, O / k) : Math.min(C / D, k / O));
                        let P = v.radius + K;
                        const N = Math.min(D, O) / 2;
                        P = P > N ? N : P, s.beginPath(), s.moveTo(T, L + P), s.lineTo(T, L + O - P), s.quadraticCurveTo(T, L + O, T + P, L + O), s.lineTo(T + D - P, L + O), s.quadraticCurveTo(T + D, L + O, T + D, L + O - P), s.lineTo(T + D, L + P), s.quadraticCurveTo(T + D, L, T + D - P, L), s.lineTo(T + P, L), s.quadraticCurveTo(T, L, T, L + P), s.closePath()
                    }
                    s.globalAlpha = g.alpha * n, s.strokeStyle = l, s.stroke()
                }
                _ && this.paintRoundedRectangle(v, m, g, a, n, s)
            }
        }
    }
    paintPolygonStroke(t, i, s, n, r, o, a) {
        if (i.alignment !== .5) {
            const l = i.width * (.5 - (1 - i.alignment));
            let c = za.offsetPolygon(t.points, l),
                h;
            a.beginPath(), a.moveTo(c[0], c[1]);
            for (let u = 2; u < c.length; u += 2) a.lineTo(c[u], c[u + 1]);
            t.closeStroke && a.closePath();
            for (let u = 0; u < n.length; u++) {
                if (h = n[u].shape.points, c = za.offsetPolygon(h, l), r[u]) {
                    a.moveTo(c[0], c[1]);
                    for (let d = 2; d < c.length; d += 2) a.lineTo(c[d], c[d + 1])
                } else {
                    a.moveTo(c[c.length - 2], c[c.length - 1]);
                    for (let d = c.length - 4; d >= 0; d -= 2) a.lineTo(c[d], c[d + 1])
                }
                n[u].shape.closeStroke && a.closePath()
            }
        }
        a.globalAlpha = i.alpha * o, a.strokeStyle = s, a.stroke()
    }
    paintEllipse(t, i, s, n, r, o) {
        const a = t.width * 2,
            l = t.height * 2,
            c = t.x - a / 2,
            h = t.y - l / 2,
            u = .5522848,
            d = a / 2 * u,
            f = l / 2 * u,
            p = c + a,
            m = h + l,
            g = c + a / 2,
            y = h + l / 2;
        s.alignment === 0 && o.save(), o.beginPath(), o.moveTo(c, y), o.bezierCurveTo(c, y - f, g - d, h, g, h), o.bezierCurveTo(g + d, h, p, y - f, p, y), o.bezierCurveTo(p, y + f, g + d, m, g, m), o.bezierCurveTo(g - d, m, c, y + f, c, y), o.closePath(), s.alignment === 0 && o.clip(), i.visible && (o.globalAlpha = i.alpha * r, o.fillStyle = n, o.fill()), s.alignment === 0 && o.restore()
    }
    paintRoundedRectangle(t, i, s, n, r, o) {
        const a = t.x,
            l = t.y,
            c = t.width,
            h = t.height;
        let u = t.radius;
        const d = Math.min(c, h) / 2;
        u = u > d ? d : u, s.alignment === 0 && o.save(), o.beginPath(), o.moveTo(a, l + u), o.lineTo(a, l + h - u), o.quadraticCurveTo(a, l + h, a + u, l + h), o.lineTo(a + c - u, l + h), o.quadraticCurveTo(a + c, l + h, a + c, l + h - u), o.lineTo(a + c, l + u), o.quadraticCurveTo(a + c, l, a + c - u, l), o.lineTo(a + u, l), o.quadraticCurveTo(a, l, a, l + u), o.closePath(), s.alignment === 0 && o.clip(), i.visible && (o.globalAlpha = i.alpha * r, o.fillStyle = n, o.fill()), s.alignment === 0 && o.restore()
    }
    setPatternTransform(t, i) {
        if (this._svgMatrix !== !1) {
            if (!this._svgMatrix) {
                const s = document.createElementNS("http://www.w3.org/2000/svg", "svg");
                if (s?.createSVGMatrix && (this._svgMatrix = s.createSVGMatrix()), !this._svgMatrix || !t.setTransform) {
                    this._svgMatrix = !1;
                    return
                }
            }
            this._svgMatrix.a = i.a, this._svgMatrix.b = i.b, this._svgMatrix.c = i.c, this._svgMatrix.d = i.d, this._svgMatrix.e = i.tx, this._svgMatrix.f = i.ty, t.setTransform(this._svgMatrix.inverse())
        }
    }
    destroy() {
        this.renderer = null, this._svgMatrix = null, this._tempMatrix = null
    }
}
by.extension = {
    name: "graphics",
    type: lt.CanvasRendererPlugin
};
vt.add(by);
Object.defineProperties(ut, {
    MESH_CANVAS_PADDING: {
        get() {
            return ti.defaultCanvasPadding
        },
        set(e) {
            Qt("7.1.0", "settings.MESH_CANVAS_PADDING is deprecated, use Mesh.defaultCanvasPadding"), ti.defaultCanvasPadding = e
        }
    }
});
Do.prototype._renderCanvas = function(t, i) {
    t.plugins.mesh.render(i)
};
vh.prototype._cachedTint = 16777215;
vh.prototype._tintedCanvas = null;
vh.prototype._canvasUvs = null;
vh.prototype._renderCanvas = function(t) {
    const i = t.canvasContext.activeContext,
        s = this.worldTransform,
        n = this.tint !== 16777215,
        r = this.texture;
    if (!r.valid) return;
    n && this._cachedTint !== this.tint && (this._cachedTint = this.tint, this._tintedCanvas = Ge.getTintedCanvas(this, this.tint));
    const o = n ? this._tintedCanvas : r.baseTexture.getDrawableSource();
    this._canvasUvs || (this._canvasUvs = [0, 0, 0, 0, 0, 0, 0, 0]);
    const a = this.vertices,
        l = this._canvasUvs,
        c = n ? 0 : r.frame.x,
        h = n ? 0 : r.frame.y,
        u = c + r.frame.width,
        d = h + r.frame.height;
    l[0] = c, l[1] = c + this._leftWidth, l[2] = u - this._rightWidth, l[3] = u, l[4] = h, l[5] = h + this._topHeight, l[6] = d - this._bottomHeight, l[7] = d;
    for (let f = 0; f < 8; f++) l[f] *= r.baseTexture.resolution;
    i.globalAlpha = this.worldAlpha, t.canvasContext.setBlendMode(this.blendMode), t.canvasContext.setContextTransform(s, this.roundPixels);
    for (let f = 0; f < 3; f++)
        for (let p = 0; p < 3; p++) {
            const m = p * 2 + f * 8,
                g = Math.max(1, l[p + 1] - l[p]),
                y = Math.max(1, l[f + 5] - l[f + 4]),
                x = Math.max(1, a[m + 10] - a[m]),
                v = Math.max(1, a[m + 11] - a[m + 1]);
            i.drawImage(o, l[p], l[f + 4], g, y, a[m], a[m + 1], x, v)
        }
};
let Yg = !1;
ti.prototype._cachedTint = 16777215;
ti.prototype._tintedCanvas = null;
ti.prototype._cachedTexture = null;
ti.prototype._renderCanvas = function(t) {
    this.shader.uvMatrix && (this.shader.uvMatrix.update(), this.calculateUvs()), this.material._renderCanvas ? this.material._renderCanvas(t, this) : Yg || (Yg = !0, globalThis.console.warn("Mesh with custom shaders are not supported in CanvasRenderer."))
};
ti.prototype._canvasPadding = null;
ti.defaultCanvasPadding = 0;
Object.defineProperty(ti.prototype, "canvasPadding", {
    get() {
        return this._canvasPadding ?? ti.defaultCanvasPadding
    },
    set(e) {
        this._canvasPadding = e
    }
});
fM.prototype._renderCanvas = function(t) {
    this.autoUpdate && this.geometry.getBuffer("aVertexPosition").update(), this.shader.update && this.shader.update(), this.calculateUvs(), this.material._renderCanvas(t, this)
};
pM.prototype._renderCanvas = function(t) {
    (this.autoUpdate || this.geometry._width !== this.shader.texture.height) && (this.geometry._width = this.shader.texture.height, this.geometry.update()), this.shader.update && this.shader.update(), this.calculateUvs(), this.material._renderCanvas(t, this)
};
class xy {
    constructor(t) {
        this.renderer = t
    }
    render(t) {
        const i = this.renderer,
            s = t.worldTransform;
        i.canvasContext.activeContext.globalAlpha = t.worldAlpha, i.canvasContext.setBlendMode(t.blendMode), i.canvasContext.setContextTransform(s, t.roundPixels), t.drawMode !== rs.TRIANGLES ? this._renderTriangleMesh(t) : this._renderTriangles(t)
    }
    _renderTriangleMesh(t) {
        const i = t.geometry.buffers[0].data.length;
        for (let s = 0; s < i - 2; s++) {
            const n = s * 2;
            this._renderDrawTriangle(t, n, n + 2, n + 4)
        }
    }
    _renderTriangles(t) {
        const i = t.geometry.getIndex().data,
            s = i.length;
        for (let n = 0; n < s; n += 3) {
            const r = i[n] * 2,
                o = i[n + 1] * 2,
                a = i[n + 2] * 2;
            this._renderDrawTriangle(t, r, o, a)
        }
    }
    _renderDrawTriangle(t, i, s, n) {
        const r = this.renderer.canvasContext.activeContext,
            o = t.geometry.buffers[0].data,
            {
                uvs: a,
                texture: l
            } = t;
        if (!l.valid) return;
        const c = t.tint !== 16777215,
            h = l.baseTexture,
            u = h.width,
            d = h.height;
        t._cachedTexture && t._cachedTexture.baseTexture !== h && (t._cachedTint = 16777215, t._cachedTexture?.destroy(), t._cachedTexture = null, t._tintedCanvas = null), c && t._cachedTint !== t.tint && (t._cachedTint = t.tint, t._cachedTexture = t._cachedTexture || new ht(h), t._tintedCanvas = Ge.getTintedCanvas({
            texture: t._cachedTexture
        }, t.tint));
        const f = c ? t._tintedCanvas : h.getDrawableSource(),
            p = a[i] * h.width,
            m = a[s] * h.width,
            g = a[n] * h.width,
            y = a[i + 1] * h.height,
            x = a[s + 1] * h.height,
            v = a[n + 1] * h.height;
        let _ = o[i],
            C = o[s],
            k = o[n],
            S = o[i + 1],
            T = o[s + 1],
            L = o[n + 1];
        const D = t.canvasPadding / this.renderer.canvasContext.activeResolution;
        if (D > 0) {
            const {
                a: pt,
                b: bt,
                c: ct,
                d: gt
            } = t.worldTransform, xt = (_ + C + k) / 3, It = (S + T + L) / 3;
            let St = _ - xt,
                J = S - It,
                wt = pt * St + ct * J,
                Tt = bt * St + gt * J,
                Bt = Math.sqrt(wt * wt + Tt * Tt),
                kt = 1 + D / Bt;
            _ = xt + St * kt, S = It + J * kt, St = C - xt, J = T - It, wt = pt * St + ct * J, Tt = bt * St + gt * J, Bt = Math.sqrt(wt * wt + Tt * Tt), kt = 1 + D / Bt, C = xt + St * kt, T = It + J * kt, St = k - xt, J = L - It, wt = pt * St + ct * J, Tt = bt * St + gt * J, Bt = Math.sqrt(wt * wt + Tt * Tt), kt = 1 + D / Bt, k = xt + St * kt, L = It + J * kt
        }
        r.save(), r.beginPath(), r.moveTo(_, S), r.lineTo(C, T), r.lineTo(k, L), r.closePath(), r.clip();
        const O = p * x + y * g + m * v - x * g - y * m - p * v,
            K = _ * x + y * k + C * v - x * k - y * C - _ * v,
            P = p * C + _ * g + m * k - C * g - _ * m - p * k,
            N = p * x * k + y * C * g + _ * m * v - _ * x * g - y * m * k - p * C * v,
            W = S * x + y * L + T * v - x * L - y * T - S * v,
            V = p * T + S * g + m * L - T * g - S * m - p * L,
            Q = p * x * L + y * T * g + S * m * v - S * x * g - y * m * L - p * T * v;
        r.transform(K / O, W / O, P / O, V / O, N / O, Q / O), r.drawImage(f, 0, 0, u * h.resolution, d * h.resolution, 0, 0, u, d), r.restore(), this.renderer.canvasContext.invalidateBlendMode()
    }
    renderMeshFlat(t) {
        const i = this.renderer.canvasContext.activeContext,
            s = t.geometry.getBuffer("aVertexPosition").data,
            n = s.length / 2;
        i.beginPath();
        for (let r = 1; r < n - 2; ++r) {
            const o = r * 2,
                a = s[o],
                l = s[o + 1],
                c = s[o + 2],
                h = s[o + 3],
                u = s[o + 4],
                d = s[o + 5];
            i.moveTo(a, l), i.lineTo(c, h), i.lineTo(u, d)
        }
        i.fillStyle = "#FF0000", i.fill(), i.closePath()
    }
    destroy() {
        this.renderer = null
    }
}
xy.extension = {
    name: "mesh",
    type: lt.CanvasRendererPlugin
};
vt.add(xy);
const Kg = 16;

function Ok(e, t) {
    const i = e;
    if (t instanceof Nt) {
        const s = t.source,
            n = s.width === 0 ? i.canvas.width : Math.min(i.canvas.width, s.width),
            r = s.height === 0 ? i.canvas.height : Math.min(i.canvas.height, s.height);
        return i.ctx.drawImage(s, 0, 0, n, r, 0, 0, i.canvas.width, i.canvas.height), !0
    }
    return !1
}
class wy extends Va {
    constructor(t) {
        super(t), this.uploadHookHelper = this, this.canvas = ut.ADAPTER.createCanvas(Kg, Kg), this.ctx = this.canvas.getContext("2d"), this.registerUploadHook(Ok)
    }
    destroy() {
        super.destroy(), this.ctx = null, this.canvas = null
    }
}
wy.extension = {
    name: "prepare",
    type: lt.CanvasRendererSystem
};
vt.add(wy);
hi.prototype._tintedCanvas = null;
hi.prototype._renderCanvas = function(t) {
    t.plugins.sprite.render(this)
};
const Zg = new pe;
class Ty {
    constructor(t) {
        this.renderer = t
    }
    render(t) {
        const i = t._texture,
            s = this.renderer,
            n = s.canvasContext.activeContext,
            r = s.canvasContext.activeResolution;
        if (!i.valid) return;
        const o = i._frame.width,
            a = i._frame.height;
        let l = i._frame.width,
            c = i._frame.height;
        i.trim && (l = i.trim.width, c = i.trim.height);
        let h = t.transform.worldTransform,
            u = 0,
            d = 0;
        const f = i.baseTexture.getDrawableSource();
        if (i.orig.width <= 0 || i.orig.height <= 0 || !i.valid || !f) return;
        s.canvasContext.setBlendMode(t.blendMode, !0), n.globalAlpha = t.worldAlpha;
        const p = i.baseTexture.scaleMode === Hi.LINEAR,
            m = s.canvasContext.smoothProperty;
        m && n[m] !== p && (n[m] = p), i.trim ? (u = i.trim.width / 2 + i.trim.x - t.anchor.x * i.orig.width, d = i.trim.height / 2 + i.trim.y - t.anchor.y * i.orig.height) : (u = (.5 - t.anchor.x) * i.orig.width, d = (.5 - t.anchor.y) * i.orig.height), i.rotate && (h.copyTo(Zg), h = Zg, Se.matrixAppendRotationInv(h, i.rotate, u, d), u = 0, d = 0), u -= l / 2, d -= c / 2, s.canvasContext.setContextTransform(h, t.roundPixels, 1), t.roundPixels && (u = u | 0, d = d | 0);
        const g = i.baseTexture.resolution,
            y = s.canvasContext._outerBlend;
        y && (n.save(), n.beginPath(), n.rect(u * r, d * r, l * r, c * r), n.clip()), t.tint !== 16777215 ? ((t._cachedTint !== t.tint || t._tintedCanvas.tintId !== t._texture._updateID) && (t._cachedTint = t.tint, t._tintedCanvas = Ge.getTintedCanvas(t, t.tint)), n.drawImage(t._tintedCanvas, 0, 0, Math.floor(o * g), Math.floor(a * g), Math.floor(u * r), Math.floor(d * r), Math.floor(l * r), Math.floor(c * r))) : n.drawImage(f, i._frame.x * g, i._frame.y * g, Math.floor(o * g), Math.floor(a * g), Math.floor(u * r), Math.floor(d * r), Math.floor(l * r), Math.floor(c * r)), y && n.restore(), s.canvasContext.setBlendMode(j.NORMAL)
    }
    destroy() {
        this.renderer = null
    }
}
Ty.extension = {
    name: "sprite",
    type: lt.CanvasRendererPlugin
};
vt.add(Ty);
class Dk extends Q1 {
    constructor(i, s, n, r) {
        super(i, s, n, r);
        I(this, "_pcellCapacity", 16);
        I(this, "pcellCache", Ws([]));
        I(this, "moveMode", 0);
        I(this, "DestinationPoint", Ws(new hi(ie.get("MOVE_POINT"))));
        this.DestinationPoint.anchor.set(.5), this.DestinationPoint.visible = !1, is.addChild(this.DestinationPoint)
    }
    get skinFillColor() {
        return Id(B.SkinFillSelf[0], this.color)
    }
    get skinFillAlpha() {
        return B.SkinFillSelf[1]
    }
    get DestinationPointColor() {
        return Be(B.DestinationPoint[0])
    }
    get DestinationPointAlpha() {
        return B.DestinationPoint[1]
    }
    bindPlayerCell(i) {
        this.pcellCache.push(i), U.state != 1 && (U.state = 1)
    }
    unbindPlayerCell(i) {
        super.unbindPlayerCell(i), U.needUpdate = !0
    }
    sortPlayerCell() {
        this.pcellCache.length && (this.pcellCache.sort((i, s) => i.id - s.id), this.pcellCache.forEach(i => {
            super.bindPlayerCell(i)
        }), this.pcellCache.length = 0, U.needUpdate = !0)
    }
    drawCursorLine() {
        this.pcells.forEach(i => {
            i.drawCursorLine()
        })
    }
    computeSplitOrderMarker() {
        const i = this.cellCount,
            s = this._pcellCapacity - i;
        let n = 0,
            r = 0;
        this.pcells.forEach(o => {
            let a = 0;
            n < s ? Number(o.massValue) >= 44 ? (a = 0, n++) : a = 1 : a = (r - n) * .618 / (i - s) + .382, o.SplitOrderMarkerWeight = a, r++
        })
    }
    deploySplitOrderMarkerStyle() {
        this.computeSplitOrderMarker(), this.pcells.forEach(i => {
            i.assistance.needUpdate = !0, i.drawAssistance()
        })
    }
}
class Nk extends ip {
    constructor() {
        super();
        I(this, "uSig", 0);
        I(this, "state", 0);
        I(this, "largest", null);
        I(this, "opUnitQueue", new kk);
        I(this, "totalMass", 0);
        I(this, "score", 0);
        I(this, "tp", !1);
        I(this, "pause", !1);
        I(this, "specMode", 3);
        I(this, "specTarget", null);
        I(this, "needUpdate", !1);
        I(this, "toggleCheck", !1);
        I(this, "deathCheck", !1)
    }
    get currentOpUnit() {
        return this.opUnitQueue.current
    }
    get targetOpUnit() {
        return this.opUnitQueue.target
    }
    get nextOpUnit() {
        return this.opUnitQueue.next
    }
    get nextOpUnitIndex() {
        return this.opUnitQueue.nextToggleIndex
    }
    init(i) {
        this.id = i.id, this.team = i.team, i.opUnits.forEach(s => this.joinOpUnit(s.id, s.nick, s.skin))
    }
    createOpUnit(i, s, n) {
        const r = new Dk(i, this, s, n);
        return this.opUnits.set(i, r), r
    }
    joinOpUnit(i, s, n) {
        const {
            opUnits: r,
            opUnitQueue: o
        } = this;
        r.size ? r.has(i) ? r.get(i).updateInfo(s, n) : o.push(this.createOpUnit(i, s, n)) : o.push(this.createOpUnit(i, s, n))
    }
    findLargestCell() {
        this.largest = null, !(!this.opUnitQueue.current || this.opUnitQueue.current.pcells.size == 0) && this.opUnitQueue.current.pcells.forEach(s => {
            (this.largest == null || s.nr > this.largest.nr) && (this.largest = s)
        })
    }
    calcViewCenter() {
        let i = 0,
            s = 0,
            n = 0;
        return this.opUnits.forEach(r => {
            r.pcells.forEach(o => {
                const a = o.massValue;
                i += o.nx * a, s += o.ny * a, n += a
            })
        }), this.score = Math.max(this.score, n), this.totalMass = n, [i /= n, s /= n]
    }
    clearPlayerCells() {
        this.opUnits.forEach(i => i.clearPlayerCells()), this.opUnitQueue.store.forEach(i => i.clearPlayerCells())
    }
    toggleOpUnit(i) {
        this.opUnitQueue.moveTo(i), this.opUnits.forEach(s => {
            s.pcells.forEach(n => {
                n.assistance.needUpdate = !0, n.drawAssistance()
            })
        }), U.toggleCheck = !0, U.needUpdate = !0
    }
    detectDeath(i) {
        this.cellCount ? H.AutoSwitchTab && !i.cellCount && this.currentOpUnit === i && A.emit("toggleOpUnit") : this.deathCheck = !0
    }
    die() {
        this.state = 3, this.totalMass = 0, this.toggleOpUnit(0), this.opUnitQueue.targetIndex = 0, this.specMode = 1, U.specTarget = null, A.emit("death")
    }
    setDestinationPoint(i, s) {
        const n = this.targetOpUnit;
        n.DestinationPoint.alpha = 0, n.DestinationPoint.position.set(i, s), n.moveMode = 1
    }
    drawCursorLine() {
        this.opUnits.forEach(i => i.drawCursorLine())
    }
    update() {
        this.needUpdate && (this.findLargestCell(), this.opUnits.forEach(s => s.deploySplitOrderMarkerStyle()), this.needUpdate = !1), this.toggleCheck && (H.AutoSwitchTab && this.state == 2 && !this.currentOpUnit.cellCount && A.emit("toggleOpUnit"), this.toggleCheck = !1), this.deathCheck && (this.cellCount || this.die(), this.deathCheck = !1);
        const i = vi(0, 40, 500);
        this.opUnits.forEach(s => {
            if (s.DestinationPoint.visible = s.moveMode && s.cellCount > 0 && s == this.currentOpUnit, !s.DestinationPoint.visible) return;
            const n = s.DestinationPoint.alpha,
                r = s.DestinationPointAlpha;
            Math.abs(n - r) > .001 && (s.DestinationPoint.alpha = Ze(n, r, i)), s.DestinationPoint.tint = s.DestinationPointColor
        })
    }
    reset() {
        this.state = 0, this.tp = !1, this.largest = null, this.activity = 0, this.opUnits.clear(), this.opUnitQueue.clear()
    }
}
const Ms = new Map,
    zt = _i(new Map),
    U = _i(new Nk);
class Pi {
    static getTeam(t) {
        return Ms.get(t)
    }
    static getPlayer(t) {
        return zt.get(t)
    }
    static joinTeam(t, i, s, n = []) {
        let r = Ms.get(t);
        r && r.destroy(), r = new py(t, i, s), r.joinPlayer(n.map(o => zt.get(o))), Ms.set(t, r)
    }
    static joinPlayer(t, i, s, n) {
        let r;
        return (r = zt.get(t)) ? r.joinOpUnit(i, s, n) : (r = new ip(t), zt.set(t, r), r.createOpUnit(i, s, n)), r
    }
    static joinSelf(t) {
        const i = zt.get(t);
        U.init(i), zt.set(t, U)
    }
    static bindPlayerTeam(t, i) {
        Ms.get(i).joinPlayer([zt.get(t)])
    }
    static disconnect(t) {
        const i = zt.get(t);
        !i || (i.destroy(), zt.delete(t))
    }
}
A.on("joinSelf", Pi.joinSelf);
var Ud = function() {
    return Ud = Object.assign || function(t) {
        for (var i, s = 1, n = arguments.length; s < n; s++) {
            i = arguments[s];
            for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (t[r] = i[r])
        }
        return t
    }, Ud.apply(this, arguments)
};

function an(e, t, i, s) {
    function n(r) {
        return r instanceof i ? r : new i(function(o) {
            o(r)
        })
    }
    return new(i || (i = Promise))(function(r, o) {
        function a(h) {
            try {
                c(s.next(h))
            } catch (u) {
                o(u)
            }
        }

        function l(h) {
            try {
                c(s.throw(h))
            } catch (u) {
                o(u)
            }
        }

        function c(h) {
            h.done ? r(h.value) : n(h.value).then(a, l)
        }
        c((s = s.apply(e, t || [])).next())
    })
}

function Fs(e, t) {
    var i = {
            label: 0,
            sent: function() {
                if (r[0] & 1) throw r[1];
                return r[1]
            },
            trys: [],
            ops: []
        },
        s, n, r, o;
    return o = {
        next: a(0),
        throw: a(1),
        return: a(2)
    }, typeof Symbol == "function" && (o[Symbol.iterator] = function() {
        return this
    }), o;

    function a(c) {
        return function(h) {
            return l([c, h])
        }
    }

    function l(c) {
        if (s) throw new TypeError("Generator is already executing.");
        for (; o && (o = 0, c[0] && (i = 0)), i;) try {
            if (s = 1, n && (r = c[0] & 2 ? n.return : c[0] ? n.throw || ((r = n.return) && r.call(n), 0) : n.next) && !(r = r.call(n, c[1])).done) return r;
            switch (n = 0, r && (c = [c[0] & 2, r.value]), c[0]) {
                case 0:
                case 1:
                    r = c;
                    break;
                case 4:
                    return i.label++, {
                        value: c[1],
                        done: !1
                    };
                case 5:
                    i.label++, n = c[1], c = [0];
                    continue;
                case 7:
                    c = i.ops.pop(), i.trys.pop();
                    continue;
                default:
                    if (r = i.trys, !(r = r.length > 0 && r[r.length - 1]) && (c[0] === 6 || c[0] === 2)) {
                        i = 0;
                        continue
                    }
                    if (c[0] === 3 && (!r || c[1] > r[0] && c[1] < r[3])) {
                        i.label = c[1];
                        break
                    }
                    if (c[0] === 6 && i.label < r[1]) {
                        i.label = r[1], r = c;
                        break
                    }
                    if (r && i.label < r[2]) {
                        i.label = r[2], i.ops.push(c);
                        break
                    }
                    r[2] && i.ops.pop(), i.trys.pop();
                    continue
            }
            c = t.call(e, i)
        } catch (h) {
            c = [6, h], n = 0
        } finally {
            s = r = 0
        }
        if (c[0] & 5) throw c[1];
        return {
            value: c[0] ? c[1] : void 0,
            done: !0
        }
    }
}

function Ey() {
    for (var e = 0, t = 0, i = arguments.length; t < i; t++) e += arguments[t].length;
    for (var s = Array(e), n = 0, t = 0; t < i; t++)
        for (var r = arguments[t], o = 0, a = r.length; o < a; o++, n++) s[n] = r[o];
    return s
}
var Sy = "3.3.6";

function No(e, t) {
    return new Promise(function(i) {
        return setTimeout(i, e, t)
    })
}

function Fk(e, t) {
    t === void 0 && (t = 1 / 0);
    var i = window.requestIdleCallback;
    return i ? new Promise(function(s) {
        return i.call(window, function() {
            return s()
        }, {
            timeout: t
        })
    }) : No(Math.min(e, t))
}

function Bk(e) {
    return e && typeof e.then == "function"
}

function qg(e, t) {
    try {
        var i = e();
        Bk(i) ? i.then(function(s) {
            return t(!0, s)
        }, function(s) {
            return t(!1, s)
        }) : t(!0, i)
    } catch (s) {
        t(!1, s)
    }
}

function Jg(e, t, i) {
    return i === void 0 && (i = 16), an(this, void 0, void 0, function() {
        var s, n, r;
        return Fs(this, function(o) {
            switch (o.label) {
                case 0:
                    s = Date.now(), n = 0, o.label = 1;
                case 1:
                    return n < e.length ? (t(e[n], n), r = Date.now(), r >= s + i ? (s = r, [4, No(0)]) : [3, 3]) : [3, 4];
                case 2:
                    o.sent(), o.label = 3;
                case 3:
                    return ++n, [3, 1];
                case 4:
                    return [2]
            }
        })
    })
}

function hp(e) {
    e.then(void 0, function() {})
}

function fn(e, t) {
    e = [e[0] >>> 16, e[0] & 65535, e[1] >>> 16, e[1] & 65535], t = [t[0] >>> 16, t[0] & 65535, t[1] >>> 16, t[1] & 65535];
    var i = [0, 0, 0, 0];
    return i[3] += e[3] + t[3], i[2] += i[3] >>> 16, i[3] &= 65535, i[2] += e[2] + t[2], i[1] += i[2] >>> 16, i[2] &= 65535, i[1] += e[1] + t[1], i[0] += i[1] >>> 16, i[1] &= 65535, i[0] += e[0] + t[0], i[0] &= 65535, [i[0] << 16 | i[1], i[2] << 16 | i[3]]
}

function Fi(e, t) {
    e = [e[0] >>> 16, e[0] & 65535, e[1] >>> 16, e[1] & 65535], t = [t[0] >>> 16, t[0] & 65535, t[1] >>> 16, t[1] & 65535];
    var i = [0, 0, 0, 0];
    return i[3] += e[3] * t[3], i[2] += i[3] >>> 16, i[3] &= 65535, i[2] += e[2] * t[3], i[1] += i[2] >>> 16, i[2] &= 65535, i[2] += e[3] * t[2], i[1] += i[2] >>> 16, i[2] &= 65535, i[1] += e[1] * t[3], i[0] += i[1] >>> 16, i[1] &= 65535, i[1] += e[2] * t[2], i[0] += i[1] >>> 16, i[1] &= 65535, i[1] += e[3] * t[1], i[0] += i[1] >>> 16, i[1] &= 65535, i[0] += e[0] * t[3] + e[1] * t[2] + e[2] * t[1] + e[3] * t[0], i[0] &= 65535, [i[0] << 16 | i[1], i[2] << 16 | i[3]]
}

function jr(e, t) {
    return t %= 64, t === 32 ? [e[1], e[0]] : t < 32 ? [e[0] << t | e[1] >>> 32 - t, e[1] << t | e[0] >>> 32 - t] : (t -= 32, [e[1] << t | e[0] >>> 32 - t, e[0] << t | e[1] >>> 32 - t])
}

function Ti(e, t) {
    return t %= 64, t === 0 ? e : t < 32 ? [e[0] << t | e[1] >>> 32 - t, e[1] << t] : [e[1] << t - 32, 0]
}

function Ee(e, t) {
    return [e[0] ^ t[0], e[1] ^ t[1]]
}

function Qg(e) {
    return e = Ee(e, [0, e[0] >>> 1]), e = Fi(e, [4283543511, 3981806797]), e = Ee(e, [0, e[0] >>> 1]), e = Fi(e, [3301882366, 444984403]), e = Ee(e, [0, e[0] >>> 1]), e
}

function Uk(e, t) {
    e = e || "", t = t || 0;
    var i = e.length % 16,
        s = e.length - i,
        n = [0, t],
        r = [0, t],
        o = [0, 0],
        a = [0, 0],
        l = [2277735313, 289559509],
        c = [1291169091, 658871167],
        h;
    for (h = 0; h < s; h = h + 16) o = [e.charCodeAt(h + 4) & 255 | (e.charCodeAt(h + 5) & 255) << 8 | (e.charCodeAt(h + 6) & 255) << 16 | (e.charCodeAt(h + 7) & 255) << 24, e.charCodeAt(h) & 255 | (e.charCodeAt(h + 1) & 255) << 8 | (e.charCodeAt(h + 2) & 255) << 16 | (e.charCodeAt(h + 3) & 255) << 24], a = [e.charCodeAt(h + 12) & 255 | (e.charCodeAt(h + 13) & 255) << 8 | (e.charCodeAt(h + 14) & 255) << 16 | (e.charCodeAt(h + 15) & 255) << 24, e.charCodeAt(h + 8) & 255 | (e.charCodeAt(h + 9) & 255) << 8 | (e.charCodeAt(h + 10) & 255) << 16 | (e.charCodeAt(h + 11) & 255) << 24], o = Fi(o, l), o = jr(o, 31), o = Fi(o, c), n = Ee(n, o), n = jr(n, 27), n = fn(n, r), n = fn(Fi(n, [0, 5]), [0, 1390208809]), a = Fi(a, c), a = jr(a, 33), a = Fi(a, l), r = Ee(r, a), r = jr(r, 31), r = fn(r, n), r = fn(Fi(r, [0, 5]), [0, 944331445]);
    switch (o = [0, 0], a = [0, 0], i) {
        case 15:
            a = Ee(a, Ti([0, e.charCodeAt(h + 14)], 48));
        case 14:
            a = Ee(a, Ti([0, e.charCodeAt(h + 13)], 40));
        case 13:
            a = Ee(a, Ti([0, e.charCodeAt(h + 12)], 32));
        case 12:
            a = Ee(a, Ti([0, e.charCodeAt(h + 11)], 24));
        case 11:
            a = Ee(a, Ti([0, e.charCodeAt(h + 10)], 16));
        case 10:
            a = Ee(a, Ti([0, e.charCodeAt(h + 9)], 8));
        case 9:
            a = Ee(a, [0, e.charCodeAt(h + 8)]), a = Fi(a, c), a = jr(a, 33), a = Fi(a, l), r = Ee(r, a);
        case 8:
            o = Ee(o, Ti([0, e.charCodeAt(h + 7)], 56));
        case 7:
            o = Ee(o, Ti([0, e.charCodeAt(h + 6)], 48));
        case 6:
            o = Ee(o, Ti([0, e.charCodeAt(h + 5)], 40));
        case 5:
            o = Ee(o, Ti([0, e.charCodeAt(h + 4)], 32));
        case 4:
            o = Ee(o, Ti([0, e.charCodeAt(h + 3)], 24));
        case 3:
            o = Ee(o, Ti([0, e.charCodeAt(h + 2)], 16));
        case 2:
            o = Ee(o, Ti([0, e.charCodeAt(h + 1)], 8));
        case 1:
            o = Ee(o, [0, e.charCodeAt(h)]), o = Fi(o, l), o = jr(o, 31), o = Fi(o, c), n = Ee(n, o)
    }
    return n = Ee(n, [0, e.length]), r = Ee(r, [0, e.length]), n = fn(n, r), r = fn(r, n), n = Qg(n), r = Qg(r), n = fn(n, r), r = fn(r, n), ("00000000" + (n[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (n[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (r[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (r[1] >>> 0).toString(16)).slice(-8)
}

function Gk(e) {
    var t;
    return Ud({
        name: e.name,
        message: e.message,
        stack: (t = e.stack) === null || t === void 0 ? void 0 : t.split(`
`)
    }, e)
}

function Hk(e, t) {
    for (var i = 0, s = e.length; i < s; ++i)
        if (e[i] === t) return !0;
    return !1
}

function Vk(e, t) {
    return !Hk(e, t)
}

function up(e) {
    return parseInt(e)
}

function ts(e) {
    return parseFloat(e)
}

function zs(e, t) {
    return typeof e == "number" && isNaN(e) ? t : e
}

function bs(e) {
    return e.reduce(function(t, i) {
        return t + (i ? 1 : 0)
    }, 0)
}

function Cy(e, t) {
    if (t === void 0 && (t = 1), Math.abs(t) >= 1) return Math.round(e / t) * t;
    var i = 1 / t;
    return Math.round(e * i) / i
}

function zk(e) {
    for (var t, i, s = "Unexpected syntax '" + e + "'", n = /^\s*([a-z-]*)(.*)$/i.exec(e), r = n[1] || void 0, o = {}, a = /([.:#][\w-]+|\[.+?\])/gi, l = function(d, f) {
            o[d] = o[d] || [], o[d].push(f)
        };;) {
        var c = a.exec(n[2]);
        if (!c) break;
        var h = c[0];
        switch (h[0]) {
            case ".":
                l("class", h.slice(1));
                break;
            case "#":
                l("id", h.slice(1));
                break;
            case "[": {
                var u = /^\[([\w-]+)([~|^$*]?=("(.*?)"|([\w-]+)))?(\s+[is])?\]$/.exec(h);
                if (u) l(u[1], (i = (t = u[4]) !== null && t !== void 0 ? t : u[5]) !== null && i !== void 0 ? i : "");
                else throw new Error(s);
                break
            }
            default:
                throw new Error(s)
        }
    }
    return [r, o]
}

function t0(e) {
    return e && typeof e == "object" && "message" in e ? e : {
        message: e
    }
}

function $k(e) {
    return typeof e != "function"
}

function jk(e, t) {
    var i = new Promise(function(s) {
        var n = Date.now();
        qg(e.bind(null, t), function() {
            for (var r = [], o = 0; o < arguments.length; o++) r[o] = arguments[o];
            var a = Date.now() - n;
            if (!r[0]) return s(function() {
                return {
                    error: t0(r[1]),
                    duration: a
                }
            });
            var l = r[1];
            if ($k(l)) return s(function() {
                return {
                    value: l,
                    duration: a
                }
            });
            s(function() {
                return new Promise(function(c) {
                    var h = Date.now();
                    qg(l, function() {
                        for (var u = [], d = 0; d < arguments.length; d++) u[d] = arguments[d];
                        var f = a + Date.now() - h;
                        if (!u[0]) return c({
                            error: t0(u[1]),
                            duration: f
                        });
                        c({
                            value: u[1],
                            duration: f
                        })
                    })
                })
            })
        })
    });
    return hp(i),
        function() {
            return i.then(function(n) {
                return n()
            })
        }
}

function Wk(e, t, i) {
    var s = Object.keys(e).filter(function(r) {
            return Vk(i, r)
        }),
        n = Array(s.length);
    return Jg(s, function(r, o) {
            n[o] = jk(e[r], t)
        }),
        function() {
            return an(this, void 0, void 0, function() {
                var o, a, l, c, h, u, d;
                return Fs(this, function(f) {
                    switch (f.label) {
                        case 0:
                            for (o = {}, a = 0, l = s; a < l.length; a++) c = l[a], o[c] = void 0;
                            h = Array(s.length), u = function() {
                                var p;
                                return Fs(this, function(m) {
                                    switch (m.label) {
                                        case 0:
                                            return p = !0, [4, Jg(s, function(g, y) {
                                                if (!h[y])
                                                    if (n[y]) {
                                                        var x = n[y]().then(function(v) {
                                                            return o[g] = v
                                                        });
                                                        hp(x), h[y] = x
                                                    } else p = !1
                                            })];
                                        case 1:
                                            return m.sent(), p ? [2, "break"] : [4, No(1)];
                                        case 2:
                                            return m.sent(), [2]
                                    }
                                })
                            }, f.label = 1;
                        case 1:
                            return [5, u()];
                        case 2:
                            if (d = f.sent(), d === "break") return [3, 4];
                            f.label = 3;
                        case 3:
                            return [3, 1];
                        case 4:
                            return [4, Promise.all(h)];
                        case 5:
                            return f.sent(), [2, o]
                    }
                })
            })
        }
}

function Ay() {
    var e = window,
        t = navigator;
    return bs(["MSCSSMatrix" in e, "msSetImmediate" in e, "msIndexedDB" in e, "msMaxTouchPoints" in t, "msPointerEnabled" in t]) >= 4
}

function Xk() {
    var e = window,
        t = navigator;
    return bs(["msWriteProfilerMark" in e, "MSStream" in e, "msLaunchUri" in t, "msSaveBlob" in t]) >= 3 && !Ay()
}

function dp() {
    var e = window,
        t = navigator;
    return bs(["webkitPersistentStorage" in t, "webkitTemporaryStorage" in t, t.vendor.indexOf("Google") === 0, "webkitResolveLocalFileSystemURL" in e, "BatteryManager" in e, "webkitMediaStream" in e, "webkitSpeechGrammar" in e]) >= 5
}

function il() {
    var e = window,
        t = navigator;
    return bs(["ApplePayError" in e, "CSSPrimitiveValue" in e, "Counter" in e, t.vendor.indexOf("Apple") === 0, "getStorageUpdates" in t, "WebKitMediaKeys" in e]) >= 4
}

function fp() {
    var e = window;
    return bs(["safari" in e, !("DeviceMotionEvent" in e), !("ongestureend" in e), !("standalone" in navigator)]) >= 3
}

function Yk() {
    var e, t, i = window;
    return bs(["buildID" in navigator, "MozAppearance" in ((t = (e = document.documentElement) === null || e === void 0 ? void 0 : e.style) !== null && t !== void 0 ? t : {}), "onmozfullscreenchange" in i, "mozInnerScreenX" in i, "CSSMozDocumentRule" in i, "CanvasCaptureMediaStream" in i]) >= 4
}

function Kk() {
    var e = window;
    return bs([!("MediaSettingsRange" in e), "RTCEncodedAudioFrame" in e, "" + e.Intl == "[object Intl]", "" + e.Reflect == "[object Reflect]"]) >= 3
}

function Zk() {
    var e = window;
    return bs(["DOMRectList" in e, "RTCPeerConnectionIceEvent" in e, "SVGGeometryElement" in e, "ontransitioncancel" in e]) >= 3
}

function qk() {
    if (navigator.platform === "iPad") return !0;
    var e = screen,
        t = e.width / e.height;
    return bs(["MediaSource" in window, !!Element.prototype.webkitRequestFullscreen, t > .65 && t < 1.53]) >= 2
}

function Jk() {
    var e = document;
    return e.fullscreenElement || e.msFullscreenElement || e.mozFullScreenElement || e.webkitFullscreenElement || null
}

function Qk() {
    var e = document;
    return (e.exitFullscreen || e.msExitFullscreen || e.mozCancelFullScreen || e.webkitExitFullscreen).call(e)
}

function Iy() {
    var e = dp(),
        t = Yk();
    if (!e && !t) return !1;
    var i = window;
    return bs(["onorientationchange" in i, "orientation" in i, e && !("SharedWorker" in i), t && /android/i.test(navigator.appVersion)]) >= 2
}

function tP() {
    var e = window,
        t = e.OfflineAudioContext || e.webkitOfflineAudioContext;
    if (!t) return -2;
    if (eP()) return -1;
    var i = 4500,
        s = 5e3,
        n = new t(1, s, 44100),
        r = n.createOscillator();
    r.type = "triangle", r.frequency.value = 1e4;
    var o = n.createDynamicsCompressor();
    o.threshold.value = -50, o.knee.value = 40, o.ratio.value = 12, o.attack.value = 0, o.release.value = .25, r.connect(o), o.connect(n.destination), r.start(0);
    var a = iP(n),
        l = a[0],
        c = a[1],
        h = l.then(function(u) {
            return sP(u.getChannelData(0).subarray(i))
        }, function(u) {
            if (u.name === "timeout" || u.name === "suspended") return -3;
            throw u
        });
    return hp(h),
        function() {
            return c(), h
        }
}

function eP() {
    return il() && !fp() && !Zk()
}

function iP(e) {
    var t = 3,
        i = 500,
        s = 500,
        n = 5e3,
        r = function() {},
        o = new Promise(function(a, l) {
            var c = !1,
                h = 0,
                u = 0;
            e.oncomplete = function(p) {
                return a(p.renderedBuffer)
            };
            var d = function() {
                    setTimeout(function() {
                        return l(e0("timeout"))
                    }, Math.min(s, u + n - Date.now()))
                },
                f = function() {
                    try {
                        switch (e.startRendering(), e.state) {
                            case "running":
                                u = Date.now(), c && d();
                                break;
                            case "suspended":
                                document.hidden || h++, c && h >= t ? l(e0("suspended")) : setTimeout(f, i);
                                break
                        }
                    } catch (p) {
                        l(p)
                    }
                };
            f(), r = function() {
                c || (c = !0, u > 0 && d())
            }
        });
    return [o, r]
}

function sP(e) {
    for (var t = 0, i = 0; i < e.length; ++i) t += Math.abs(e[i]);
    return t
}

function e0(e) {
    var t = new Error(e);
    return t.name = e, t
}

function My(e, t, i) {
    var s, n, r;
    return i === void 0 && (i = 50), an(this, void 0, void 0, function() {
        var o, a;
        return Fs(this, function(l) {
            switch (l.label) {
                case 0:
                    o = document, l.label = 1;
                case 1:
                    return o.body ? [3, 3] : [4, No(i)];
                case 2:
                    return l.sent(), [3, 1];
                case 3:
                    a = o.createElement("iframe"), l.label = 4;
                case 4:
                    return l.trys.push([4, , 10, 11]), [4, new Promise(function(c, h) {
                        var u = !1,
                            d = function() {
                                u = !0, c()
                            },
                            f = function(g) {
                                u = !0, h(g)
                            };
                        a.onload = d, a.onerror = f;
                        var p = a.style;
                        p.setProperty("display", "block", "important"), p.position = "absolute", p.top = "0", p.left = "0", p.visibility = "hidden", t && "srcdoc" in a ? a.srcdoc = t : a.src = "about:blank", o.body.appendChild(a);
                        var m = function() {
                            var g, y;
                            u || (((y = (g = a.contentWindow) === null || g === void 0 ? void 0 : g.document) === null || y === void 0 ? void 0 : y.readyState) === "complete" ? d() : setTimeout(m, 10))
                        };
                        m()
                    })];
                case 5:
                    l.sent(), l.label = 6;
                case 6:
                    return !((n = (s = a.contentWindow) === null || s === void 0 ? void 0 : s.document) === null || n === void 0) && n.body ? [3, 8] : [4, No(i)];
                case 7:
                    return l.sent(), [3, 6];
                case 8:
                    return [4, e(a, a.contentWindow)];
                case 9:
                    return [2, l.sent()];
                case 10:
                    return (r = a.parentNode) === null || r === void 0 || r.removeChild(a), [7];
                case 11:
                    return [2]
            }
        })
    })
}

function nP(e) {
    for (var t = zk(e), i = t[0], s = t[1], n = document.createElement(i ?? "div"), r = 0, o = Object.keys(s); r < o.length; r++) {
        var a = o[r],
            l = s[a].join(" ");
        a === "style" ? rP(n.style, l) : n.setAttribute(a, l)
    }
    return n
}

function rP(e, t) {
    for (var i = 0, s = t.split(";"); i < s.length; i++) {
        var n = s[i],
            r = /^\s*([\w-]+)\s*:\s*(.+?)(\s*!([\w-]+))?\s*$/.exec(n);
        if (r) {
            var o = r[1],
                a = r[2],
                l = r[4];
            e.setProperty(o, a, l || "")
        }
    }
}
var oP = "mmMwWLliI0O&1",
    aP = "48px",
    Wr = ["monospace", "sans-serif", "serif"],
    i0 = ["sans-serif-thin", "ARNO PRO", "Agency FB", "Arabic Typesetting", "Arial Unicode MS", "AvantGarde Bk BT", "BankGothic Md BT", "Batang", "Bitstream Vera Sans Mono", "Calibri", "Century", "Century Gothic", "Clarendon", "EUROSTILE", "Franklin Gothic", "Futura Bk BT", "Futura Md BT", "GOTHAM", "Gill Sans", "HELV", "Haettenschweiler", "Helvetica Neue", "Humanst521 BT", "Leelawadee", "Letter Gothic", "Levenim MT", "Lucida Bright", "Lucida Sans", "Menlo", "MS Mincho", "MS Outlook", "MS Reference Specialty", "MS UI Gothic", "MT Extra", "MYRIAD PRO", "Marlett", "Meiryo UI", "Microsoft Uighur", "Minion Pro", "Monotype Corsiva", "PMingLiU", "Pristina", "SCRIPTINA", "Segoe UI Light", "Serifa", "SimHei", "Small Fonts", "Staccato222 BT", "TRAJAN PRO", "Univers CE 55 Medium", "Vrinda", "ZWAdobeF"];

function lP() {
    return My(function(e, t) {
        var i = t.document,
            s = i.body;
        s.style.fontSize = aP;
        var n = i.createElement("div"),
            r = {},
            o = {},
            a = function(m) {
                var g = i.createElement("span"),
                    y = g.style;
                return y.position = "absolute", y.top = "0", y.left = "0", y.fontFamily = m, g.textContent = oP, n.appendChild(g), g
            },
            l = function(m, g) {
                return a("'" + m + "'," + g)
            },
            c = function() {
                return Wr.map(a)
            },
            h = function() {
                for (var m = {}, g = function(_) {
                        m[_] = Wr.map(function(C) {
                            return l(_, C)
                        })
                    }, y = 0, x = i0; y < x.length; y++) {
                    var v = x[y];
                    g(v)
                }
                return m
            },
            u = function(m) {
                return Wr.some(function(g, y) {
                    return m[y].offsetWidth !== r[g] || m[y].offsetHeight !== o[g]
                })
            },
            d = c(),
            f = h();
        s.appendChild(n);
        for (var p = 0; p < Wr.length; p++) r[Wr[p]] = d[p].offsetWidth, o[Wr[p]] = d[p].offsetHeight;
        return i0.filter(function(m) {
            return u(f[m])
        })
    })
}

function cP() {
    var e = navigator.plugins;
    if (!!e) {
        for (var t = [], i = 0; i < e.length; ++i) {
            var s = e[i];
            if (!!s) {
                for (var n = [], r = 0; r < s.length; ++r) {
                    var o = s[r];
                    n.push({
                        type: o.type,
                        suffixes: o.suffixes
                    })
                }
                t.push({
                    name: s.name,
                    description: s.description,
                    mimeTypes: n
                })
            }
        }
        return t
    }
}

function hP() {
    var e = !1,
        t, i, s = uP(),
        n = s[0],
        r = s[1];
    if (!dP(n, r)) t = i = "";
    else {
        e = fP(r), pP(n, r);
        var o = bu(n),
            a = bu(n);
        o !== a ? t = i = "unstable" : (i = o, mP(n, r), t = bu(n))
    }
    return {
        winding: e,
        geometry: t,
        text: i
    }
}

function uP() {
    var e = document.createElement("canvas");
    return e.width = 1, e.height = 1, [e, e.getContext("2d")]
}

function dP(e, t) {
    return !!(t && e.toDataURL)
}

function fP(e) {
    return e.rect(0, 0, 10, 10), e.rect(2, 2, 6, 6), !e.isPointInPath(5, 5, "evenodd")
}

function pP(e, t) {
    e.width = 240, e.height = 60, t.textBaseline = "alphabetic", t.fillStyle = "#f60", t.fillRect(100, 1, 62, 20), t.fillStyle = "#069", t.font = '11pt "Times New Roman"';
    var i = "Cwm fjordbank gly " + String.fromCharCode(55357, 56835);
    t.fillText(i, 2, 15), t.fillStyle = "rgba(102, 204, 0, 0.2)", t.font = "18pt Arial", t.fillText(i, 4, 45)
}

function mP(e, t) {
    e.width = 122, e.height = 110, t.globalCompositeOperation = "multiply";
    for (var i = 0, s = [
            ["#f2f", 40, 40],
            ["#2ff", 80, 40],
            ["#ff2", 60, 80]
        ]; i < s.length; i++) {
        var n = s[i],
            r = n[0],
            o = n[1],
            a = n[2];
        t.fillStyle = r, t.beginPath(), t.arc(o, a, 40, 0, Math.PI * 2, !0), t.closePath(), t.fill()
    }
    t.fillStyle = "#f9c", t.arc(60, 60, 60, 0, Math.PI * 2, !0), t.arc(60, 60, 20, 0, Math.PI * 2, !0), t.fill("evenodd")
}

function bu(e) {
    return e.toDataURL()
}

function gP() {
    var e = navigator,
        t = 0,
        i;
    e.maxTouchPoints !== void 0 ? t = up(e.maxTouchPoints) : e.msMaxTouchPoints !== void 0 && (t = e.msMaxTouchPoints);
    try {
        document.createEvent("TouchEvent"), i = !0
    } catch {
        i = !1
    }
    var s = "ontouchstart" in window;
    return {
        maxTouchPoints: t,
        touchEvent: i,
        touchStart: s
    }
}

function vP() {
    return navigator.oscpu
}

function _P() {
    var e = navigator,
        t = [],
        i = e.language || e.userLanguage || e.browserLanguage || e.systemLanguage;
    if (i !== void 0 && t.push([i]), Array.isArray(e.languages)) dp() && Kk() || t.push(e.languages);
    else if (typeof e.languages == "string") {
        var s = e.languages;
        s && t.push(s.split(","))
    }
    return t
}

function yP() {
    return window.screen.colorDepth
}

function bP() {
    return zs(ts(navigator.deviceMemory), void 0)
}

function xP() {
    var e = screen,
        t = function(s) {
            return zs(up(s), null)
        },
        i = [t(e.width), t(e.height)];
    return i.sort().reverse(), i
}
var wP = 2500,
    TP = 10,
    lc, xu;

function EP() {
    if (xu === void 0) {
        var e = function() {
            var t = Gd();
            Hd(t) ? xu = setTimeout(e, wP) : (lc = t, xu = void 0)
        };
        e()
    }
}

function SP() {
    var e = this;
    return EP(),
        function() {
            return an(e, void 0, void 0, function() {
                var t;
                return Fs(this, function(i) {
                    switch (i.label) {
                        case 0:
                            return t = Gd(), Hd(t) ? lc ? [2, Ey(lc)] : Jk() ? [4, Qk()] : [3, 2] : [3, 2];
                        case 1:
                            i.sent(), t = Gd(), i.label = 2;
                        case 2:
                            return Hd(t) || (lc = t), [2, t]
                    }
                })
            })
        }
}

function CP() {
    var e = this,
        t = SP();
    return function() {
        return an(e, void 0, void 0, function() {
            var i, s;
            return Fs(this, function(n) {
                switch (n.label) {
                    case 0:
                        return [4, t()];
                    case 1:
                        return i = n.sent(), s = function(r) {
                            return r === null ? null : Cy(r, TP)
                        }, [2, [s(i[0]), s(i[1]), s(i[2]), s(i[3])]]
                }
            })
        })
    }
}

function Gd() {
    var e = screen;
    return [zs(ts(e.availTop), null), zs(ts(e.width) - ts(e.availWidth) - zs(ts(e.availLeft), 0), null), zs(ts(e.height) - ts(e.availHeight) - zs(ts(e.availTop), 0), null), zs(ts(e.availLeft), null)]
}

function Hd(e) {
    for (var t = 0; t < 4; ++t)
        if (e[t]) return !1;
    return !0
}

function AP() {
    return zs(up(navigator.hardwareConcurrency), void 0)
}

function IP() {
    var e, t = (e = window.Intl) === null || e === void 0 ? void 0 : e.DateTimeFormat;
    if (t) {
        var i = new t().resolvedOptions().timeZone;
        if (i) return i
    }
    var s = -MP();
    return "UTC" + (s >= 0 ? "+" : "") + Math.abs(s)
}

function MP() {
    var e = new Date().getFullYear();
    return Math.max(ts(new Date(e, 0, 1).getTimezoneOffset()), ts(new Date(e, 6, 1).getTimezoneOffset()))
}

function RP() {
    try {
        return !!window.sessionStorage
    } catch {
        return !0
    }
}

function kP() {
    try {
        return !!window.localStorage
    } catch {
        return !0
    }
}

function PP() {
    if (!(Ay() || Xk())) try {
        return !!window.indexedDB
    } catch {
        return !0
    }
}

function LP() {
    return !!window.openDatabase
}

function OP() {
    return navigator.cpuClass
}

function DP() {
    var e = navigator.platform;
    return e === "MacIntel" && il() && !fp() ? qk() ? "iPad" : "iPhone" : e
}

function NP() {
    return navigator.vendor || ""
}

function FP() {
    for (var e = [], t = 0, i = ["chrome", "safari", "__crWeb", "__gCrWeb", "yandex", "__yb", "__ybro", "__firefox__", "__edgeTrackingPreventionStatistics", "webkit", "oprt", "samsungAr", "ucweb", "UCShellJava", "puffinDevice"]; t < i.length; t++) {
        var s = i[t],
            n = window[s];
        n && typeof n == "object" && e.push(s)
    }
    return e.sort()
}

function BP() {
    var e = document;
    try {
        e.cookie = "cookietest=1; SameSite=Strict;";
        var t = e.cookie.indexOf("cookietest=") !== -1;
        return e.cookie = "cookietest=1; SameSite=Strict; expires=Thu, 01-Jan-1970 00:00:01 GMT", t
    } catch {
        return !1
    }
}

function UP() {
    var e = atob;
    return {
        abpIndo: ["#Iklan-Melayang", "#Kolom-Iklan-728", "#SidebarIklan-wrapper", e("YVt0aXRsZT0iN25hZ2EgcG9rZXIiIGld"), '[title="ALIENBOLA" i]'],
        abpvn: ["#quangcaomb", e("Lmlvc0Fkc2lvc0Fkcy1sYXlvdXQ="), ".quangcao", e("W2hyZWZePSJodHRwczovL3I4OC52bi8iXQ=="), e("W2hyZWZePSJodHRwczovL3piZXQudm4vIl0=")],
        adBlockFinland: [".mainostila", e("LnNwb25zb3JpdA=="), ".ylamainos", e("YVtocmVmKj0iL2NsaWNrdGhyZ2guYXNwPyJd"), e("YVtocmVmXj0iaHR0cHM6Ly9hcHAucmVhZHBlYWsuY29tL2FkcyJd")],
        adBlockPersian: ["#navbar_notice_50", ".kadr", 'TABLE[width="140px"]', "#divAgahi", e("I2FkMl9pbmxpbmU=")],
        adBlockWarningRemoval: ["#adblock-honeypot", ".adblocker-root", ".wp_adblock_detect", e("LmhlYWRlci1ibG9ja2VkLWFk"), e("I2FkX2Jsb2NrZXI=")],
        adGuardAnnoyances: ['amp-embed[type="zen"]', ".hs-sosyal", "#cookieconsentdiv", 'div[class^="app_gdpr"]', ".as-oil"],
        adGuardBase: [".BetterJsPopOverlay", e("I2FkXzMwMFgyNTA="), e("I2Jhbm5lcmZsb2F0MjI="), e("I2FkLWJhbm5lcg=="), e("I2NhbXBhaWduLWJhbm5lcg==")],
        adGuardChinese: [e("LlppX2FkX2FfSA=="), e("YVtocmVmKj0iL29kMDA1LmNvbSJd"), e("YVtocmVmKj0iLmh0aGJldDM0LmNvbSJd"), ".qq_nr_lad", "#widget-quan"],
        adGuardFrench: [e("I2Jsb2NrLXZpZXdzLWFkcy1zaWRlYmFyLWJsb2NrLWJsb2Nr"), "#pavePub", e("LmFkLWRlc2t0b3AtcmVjdGFuZ2xl"), ".mobile_adhesion", ".widgetadv"],
        adGuardGerman: [e("LmJhbm5lcml0ZW13ZXJidW5nX2hlYWRfMQ=="), e("LmJveHN0YXJ0d2VyYnVuZw=="), e("LndlcmJ1bmcz"), e("YVtocmVmXj0iaHR0cDovL3d3dy5laXMuZGUvaW5kZXgucGh0bWw/cmVmaWQ9Il0="), e("YVtocmVmXj0iaHR0cHM6Ly93d3cudGlwaWNvLmNvbS8/YWZmaWxpYXRlSWQ9Il0=")],
        adGuardJapanese: ["#kauli_yad_1", e("YVtocmVmXj0iaHR0cDovL2FkMi50cmFmZmljZ2F0ZS5uZXQvIl0="), e("Ll9wb3BJbl9pbmZpbml0ZV9hZA=="), e("LmFkZ29vZ2xl"), e("LmFkX3JlZ3VsYXIz")],
        adGuardMobile: [e("YW1wLWF1dG8tYWRz"), e("LmFtcF9hZA=="), 'amp-embed[type="24smi"]', "#mgid_iframe1", e("I2FkX2ludmlld19hcmVh")],
        adGuardRussian: [e("YVtocmVmXj0iaHR0cHM6Ly9hZC5sZXRtZWFkcy5jb20vIl0="), e("LnJlY2xhbWE="), 'div[id^="smi2adblock"]', e("ZGl2W2lkXj0iQWRGb3hfYmFubmVyXyJd"), e("I2FkX3NxdWFyZQ==")],
        adGuardSocial: [e("YVtocmVmXj0iLy93d3cuc3R1bWJsZXVwb24uY29tL3N1Ym1pdD91cmw9Il0="), e("YVtocmVmXj0iLy90ZWxlZ3JhbS5tZS9zaGFyZS91cmw/Il0="), ".etsy-tweet", "#inlineShare", ".popup-social"],
        adGuardSpanishPortuguese: ["#barraPublicidade", "#Publicidade", "#publiEspecial", "#queTooltip", e("W2hyZWZePSJodHRwOi8vYWRzLmdsaXNwYS5jb20vIl0=")],
        adGuardTrackingProtection: ["#qoo-counter", e("YVtocmVmXj0iaHR0cDovL2NsaWNrLmhvdGxvZy5ydS8iXQ=="), e("YVtocmVmXj0iaHR0cDovL2hpdGNvdW50ZXIucnUvdG9wL3N0YXQucGhwIl0="), e("YVtocmVmXj0iaHR0cDovL3RvcC5tYWlsLnJ1L2p1bXAiXQ=="), "#top100counter"],
        adGuardTurkish: ["#backkapat", e("I3Jla2xhbWk="), e("YVtocmVmXj0iaHR0cDovL2Fkc2Vydi5vbnRlay5jb20udHIvIl0="), e("YVtocmVmXj0iaHR0cDovL2l6bGVuemkuY29tL2NhbXBhaWduLyJd"), e("YVtocmVmXj0iaHR0cDovL3d3dy5pbnN0YWxsYWRzLm5ldC8iXQ==")],
        bulgarian: [e("dGQjZnJlZW5ldF90YWJsZV9hZHM="), "#ea_intext_div", ".lapni-pop-over", "#xenium_hot_offers", e("I25ld0Fk")],
        easyList: [e("I0FEX0NPTlRST0xfMjg="), e("LnNlY29uZC1wb3N0LWFkcy13cmFwcGVy"), ".universalboxADVBOX03", e("LmFkdmVydGlzZW1lbnQtNzI4eDkw"), e("LnNxdWFyZV9hZHM=")],
        easyListChina: [e("YVtocmVmKj0iLndlbnNpeHVldGFuZy5jb20vIl0="), e("LmFwcGd1aWRlLXdyYXBbb25jbGljayo9ImJjZWJvcy5jb20iXQ=="), e("LmZyb250cGFnZUFkdk0="), "#taotaole", "#aafoot.top_box"],
        easyListCookie: ["#AdaCompliance.app-notice", ".text-center.rgpd", ".panel--cookie", ".js-cookies-andromeda", ".elxtr-consent"],
        easyListCzechSlovak: ["#onlajny-stickers", e("I3Jla2xhbW5pLWJveA=="), e("LnJla2xhbWEtbWVnYWJvYXJk"), ".sklik", e("W2lkXj0ic2tsaWtSZWtsYW1hIl0=")],
        easyListDutch: [e("I2FkdmVydGVudGll"), e("I3ZpcEFkbWFya3RCYW5uZXJCbG9jaw=="), ".adstekst", e("YVtocmVmXj0iaHR0cHM6Ly94bHR1YmUubmwvY2xpY2svIl0="), "#semilo-lrectangle"],
        easyListGermany: [e("I0FkX1dpbjJkYXk="), e("I3dlcmJ1bmdzYm94MzAw"), e("YVtocmVmXj0iaHR0cDovL3d3dy5yb3RsaWNodGthcnRlaS5jb20vP3NjPSJd"), e("I3dlcmJ1bmdfd2lkZXNreXNjcmFwZXJfc2NyZWVu"), e("YVtocmVmXj0iaHR0cDovL2xhbmRpbmcucGFya3BsYXR6a2FydGVpLmNvbS8/YWc9Il0=")],
        easyListItaly: [e("LmJveF9hZHZfYW5udW5jaQ=="), ".sb-box-pubbliredazionale", e("YVtocmVmXj0iaHR0cDovL2FmZmlsaWF6aW9uaWFkcy5zbmFpLml0LyJd"), e("YVtocmVmXj0iaHR0cHM6Ly9hZHNlcnZlci5odG1sLml0LyJd"), e("YVtocmVmXj0iaHR0cHM6Ly9hZmZpbGlhemlvbmlhZHMuc25haS5pdC8iXQ==")],
        easyListLithuania: [e("LnJla2xhbW9zX3RhcnBhcw=="), e("LnJla2xhbW9zX251b3JvZG9z"), e("aW1nW2FsdD0iUmVrbGFtaW5pcyBza3lkZWxpcyJd"), e("aW1nW2FsdD0iRGVkaWt1b3RpLmx0IHNlcnZlcmlhaSJd"), e("aW1nW2FsdD0iSG9zdGluZ2FzIFNlcnZlcmlhaS5sdCJd")],
        estonian: [e("QVtocmVmKj0iaHR0cDovL3BheTRyZXN1bHRzMjQuZXUiXQ==")],
        fanboyAnnoyances: ["#feedback-tab", "#taboola-below-article", ".feedburnerFeedBlock", ".widget-feedburner-counter", '[title="Subscribe to our blog"]'],
        fanboyAntiFacebook: [".util-bar-module-firefly-visible"],
        fanboyEnhancedTrackers: [".open.pushModal", "#issuem-leaky-paywall-articles-zero-remaining-nag", "#sovrn_container", 'div[class$="-hide"][zoompage-fontsize][style="display: block;"]', ".BlockNag__Card"],
        fanboySocial: [".td-tags-and-social-wrapper-box", ".twitterContainer", ".youtube-social", 'a[title^="Like us on Facebook"]', 'img[alt^="Share on Digg"]'],
        frellwitSwedish: [e("YVtocmVmKj0iY2FzaW5vcHJvLnNlIl1bdGFyZ2V0PSJfYmxhbmsiXQ=="), e("YVtocmVmKj0iZG9rdG9yLXNlLm9uZWxpbmsubWUiXQ=="), "article.category-samarbete", e("ZGl2LmhvbGlkQWRz"), "ul.adsmodern"],
        greekAdBlock: [e("QVtocmVmKj0iYWRtYW4ub3RlbmV0LmdyL2NsaWNrPyJd"), e("QVtocmVmKj0iaHR0cDovL2F4aWFiYW5uZXJzLmV4b2R1cy5nci8iXQ=="), e("QVtocmVmKj0iaHR0cDovL2ludGVyYWN0aXZlLmZvcnRobmV0LmdyL2NsaWNrPyJd"), "DIV.agores300", "TABLE.advright"],
        hungarian: ["#cemp_doboz", ".optimonk-iframe-container", e("LmFkX19tYWlu"), e("W2NsYXNzKj0iR29vZ2xlQWRzIl0="), "#hirdetesek_box"],
        iDontCareAboutCookies: ['.alert-info[data-block-track*="CookieNotice"]', ".ModuleTemplateCookieIndicator", ".o--cookies--container", ".cookie-msg-info-container", "#cookies-policy-sticky"],
        icelandicAbp: [e("QVtocmVmXj0iL2ZyYW1ld29yay9yZXNvdXJjZXMvZm9ybXMvYWRzLmFzcHgiXQ==")],
        latvian: [e("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiAxMjBweDsgaGVpZ2h0OiA0MHB4OyBvdmVyZmxvdzogaGlkZGVuOyBwb3NpdGlvbjogcmVsYXRpdmU7Il0="), e("YVtocmVmPSJodHRwOi8vd3d3LnNhbGlkemluaS5sdi8iXVtzdHlsZT0iZGlzcGxheTogYmxvY2s7IHdpZHRoOiA4OHB4OyBoZWlnaHQ6IDMxcHg7IG92ZXJmbG93OiBoaWRkZW47IHBvc2l0aW9uOiByZWxhdGl2ZTsiXQ==")],
        listKr: [e("YVtocmVmKj0iLy9hZC5wbGFuYnBsdXMuY28ua3IvIl0="), e("I2xpdmVyZUFkV3JhcHBlcg=="), e("YVtocmVmKj0iLy9hZHYuaW1hZHJlcC5jby5rci8iXQ=="), e("aW5zLmZhc3R2aWV3LWFk"), ".revenue_unit_item.dable"],
        listeAr: [e("LmdlbWluaUxCMUFk"), ".right-and-left-sponsers", e("YVtocmVmKj0iLmFmbGFtLmluZm8iXQ=="), e("YVtocmVmKj0iYm9vcmFxLm9yZyJd"), e("YVtocmVmKj0iZHViaXp6bGUuY29tL2FyLz91dG1fc291cmNlPSJd")],
        listeFr: [e("YVtocmVmXj0iaHR0cDovL3Byb21vLnZhZG9yLmNvbS8iXQ=="), e("I2FkY29udGFpbmVyX3JlY2hlcmNoZQ=="), e("YVtocmVmKj0id2Vib3JhbWEuZnIvZmNnaS1iaW4vIl0="), ".site-pub-interstitiel", 'div[id^="crt-"][data-criteo-id]'],
        officialPolish: ["#ceneo-placeholder-ceneo-12", e("W2hyZWZePSJodHRwczovL2FmZi5zZW5kaHViLnBsLyJd"), e("YVtocmVmXj0iaHR0cDovL2Fkdm1hbmFnZXIudGVjaGZ1bi5wbC9yZWRpcmVjdC8iXQ=="), e("YVtocmVmXj0iaHR0cDovL3d3dy50cml6ZXIucGwvP3V0bV9zb3VyY2UiXQ=="), e("ZGl2I3NrYXBpZWNfYWQ=")],
        ro: [e("YVtocmVmXj0iLy9hZmZ0cmsuYWx0ZXgucm8vQ291bnRlci9DbGljayJd"), 'a[href^="/magazin/"]', e("YVtocmVmXj0iaHR0cHM6Ly9ibGFja2ZyaWRheXNhbGVzLnJvL3Ryay9zaG9wLyJd"), e("YVtocmVmXj0iaHR0cHM6Ly9ldmVudC4ycGVyZm9ybWFudC5jb20vZXZlbnRzL2NsaWNrIl0="), e("YVtocmVmXj0iaHR0cHM6Ly9sLnByb2ZpdHNoYXJlLnJvLyJd")],
        ruAd: [e("YVtocmVmKj0iLy9mZWJyYXJlLnJ1LyJd"), e("YVtocmVmKj0iLy91dGltZy5ydS8iXQ=="), e("YVtocmVmKj0iOi8vY2hpa2lkaWtpLnJ1Il0="), "#pgeldiz", ".yandex-rtb-block"],
        thaiAds: ["a[href*=macau-uta-popup]", e("I2Fkcy1nb29nbGUtbWlkZGxlX3JlY3RhbmdsZS1ncm91cA=="), e("LmFkczMwMHM="), ".bumq", ".img-kosana"],
        webAnnoyancesUltralist: ["#mod-social-share-2", "#social-tools", e("LmN0cGwtZnVsbGJhbm5lcg=="), ".zergnet-recommend", ".yt.btn-link.btn-md.btn"]
    }
}

function GP(e) {
    var t = (e === void 0 ? {} : e).debug;
    return an(this, void 0, void 0, function() {
        var i, s, n, r, o, a;
        return Fs(this, function(l) {
            switch (l.label) {
                case 0:
                    return HP() ? (i = UP(), s = Object.keys(i), n = (a = []).concat.apply(a, s.map(function(c) {
                        return i[c]
                    })), [4, VP(n)]) : [2, void 0];
                case 1:
                    return r = l.sent(), t && zP(i, r), o = s.filter(function(c) {
                        var h = i[c],
                            u = bs(h.map(function(d) {
                                return r[d]
                            }));
                        return u > h.length * .6
                    }), o.sort(), [2, o]
            }
        })
    })
}

function HP() {
    return il() || Iy()
}

function VP(e) {
    var t;
    return an(this, void 0, void 0, function() {
        var i, s, n, r, l, o, a, l;
        return Fs(this, function(c) {
            switch (c.label) {
                case 0:
                    for (i = document, s = i.createElement("div"), n = new Array(e.length), r = {}, s0(s), l = 0; l < e.length; ++l) o = nP(e[l]), a = i.createElement("div"), s0(a), a.appendChild(o), s.appendChild(a), n[l] = o;
                    c.label = 1;
                case 1:
                    return i.body ? [3, 3] : [4, No(50)];
                case 2:
                    return c.sent(), [3, 1];
                case 3:
                    i.body.appendChild(s);
                    try {
                        for (l = 0; l < e.length; ++l) n[l].offsetParent || (r[e[l]] = !0)
                    } finally {
                        (t = s.parentNode) === null || t === void 0 || t.removeChild(s)
                    }
                    return [2, r]
            }
        })
    })
}

function s0(e) {
    e.style.setProperty("display", "block", "important")
}

function zP(e, t) {
    for (var i = "DOM blockers debug:\n```", s = 0, n = Object.keys(e); s < n.length; s++) {
        var r = n[s];
        i += `
` + r + ":";
        for (var o = 0, a = e[r]; o < a.length; o++) {
            var l = a[o];
            i += `
  ` + (t[l] ? "\u{1F6AB}" : "\u27A1\uFE0F") + " " + l
        }
    }
    console.log(i + "\n```")
}

function $P() {
    for (var e = 0, t = ["rec2020", "p3", "srgb"]; e < t.length; e++) {
        var i = t[e];
        if (matchMedia("(color-gamut: " + i + ")").matches) return i
    }
}

function jP() {
    if (n0("inverted")) return !0;
    if (n0("none")) return !1
}

function n0(e) {
    return matchMedia("(inverted-colors: " + e + ")").matches
}

function WP() {
    if (r0("active")) return !0;
    if (r0("none")) return !1
}

function r0(e) {
    return matchMedia("(forced-colors: " + e + ")").matches
}
var XP = 100;

function YP() {
    if (!!matchMedia("(min-monochrome: 0)").matches) {
        for (var e = 0; e <= XP; ++e)
            if (matchMedia("(max-monochrome: " + e + ")").matches) return e;
        throw new Error("Too high value")
    }
}

function KP() {
    if (Xr("no-preference")) return 0;
    if (Xr("high") || Xr("more")) return 1;
    if (Xr("low") || Xr("less")) return -1;
    if (Xr("forced")) return 10
}

function Xr(e) {
    return matchMedia("(prefers-contrast: " + e + ")").matches
}

function ZP() {
    if (o0("reduce")) return !0;
    if (o0("no-preference")) return !1
}

function o0(e) {
    return matchMedia("(prefers-reduced-motion: " + e + ")").matches
}

function qP() {
    if (a0("high")) return !0;
    if (a0("standard")) return !1
}

function a0(e) {
    return matchMedia("(dynamic-range: " + e + ")").matches
}
var ve = Math,
    ii = function() {
        return 0
    };

function JP() {
    var e = ve.acos || ii,
        t = ve.acosh || ii,
        i = ve.asin || ii,
        s = ve.asinh || ii,
        n = ve.atanh || ii,
        r = ve.atan || ii,
        o = ve.sin || ii,
        a = ve.sinh || ii,
        l = ve.cos || ii,
        c = ve.cosh || ii,
        h = ve.tan || ii,
        u = ve.tanh || ii,
        d = ve.exp || ii,
        f = ve.expm1 || ii,
        p = ve.log1p || ii,
        m = function(T) {
            return ve.pow(ve.PI, T)
        },
        g = function(T) {
            return ve.log(T + ve.sqrt(T * T - 1))
        },
        y = function(T) {
            return ve.log(T + ve.sqrt(T * T + 1))
        },
        x = function(T) {
            return ve.log((1 + T) / (1 - T)) / 2
        },
        v = function(T) {
            return ve.exp(T) - 1 / ve.exp(T) / 2
        },
        _ = function(T) {
            return (ve.exp(T) + 1 / ve.exp(T)) / 2
        },
        C = function(T) {
            return ve.exp(T) - 1
        },
        k = function(T) {
            return (ve.exp(2 * T) - 1) / (ve.exp(2 * T) + 1)
        },
        S = function(T) {
            return ve.log(1 + T)
        };
    return {
        acos: e(.12312423423423424),
        acosh: t(1e308),
        acoshPf: g(1e154),
        asin: i(.12312423423423424),
        asinh: s(1),
        asinhPf: y(1),
        atanh: n(.5),
        atanhPf: x(.5),
        atan: r(.5),
        sin: o(-1e300),
        sinh: a(1),
        sinhPf: v(1),
        cos: l(10.000000000123),
        cosh: c(1),
        coshPf: _(1),
        tan: h(-1e300),
        tanh: u(1),
        tanhPf: k(1),
        exp: d(1),
        expm1: f(1),
        expm1Pf: C(1),
        log1p: p(10),
        log1pPf: S(10),
        powPI: m(-100)
    }
}
var QP = "mmMwWLliI0fiflO&1",
    wu = {
        default: [],
        apple: [{
            font: "-apple-system-body"
        }],
        serif: [{
            fontFamily: "serif"
        }],
        sans: [{
            fontFamily: "sans-serif"
        }],
        mono: [{
            fontFamily: "monospace"
        }],
        min: [{
            fontSize: "1px"
        }],
        system: [{
            fontFamily: "system-ui"
        }]
    };

function t8() {
    return e8(function(e, t) {
        for (var i = {}, s = {}, n = 0, r = Object.keys(wu); n < r.length; n++) {
            var o = r[n],
                a = wu[o],
                l = a[0],
                c = l === void 0 ? {} : l,
                h = a[1],
                u = h === void 0 ? QP : h,
                d = e.createElement("span");
            d.textContent = u, d.style.whiteSpace = "nowrap";
            for (var f = 0, p = Object.keys(c); f < p.length; f++) {
                var m = p[f],
                    g = c[m];
                g !== void 0 && (d.style[m] = g)
            }
            i[o] = d, t.appendChild(e.createElement("br")), t.appendChild(d)
        }
        for (var y = 0, x = Object.keys(wu); y < x.length; y++) {
            var o = x[y];
            s[o] = i[o].getBoundingClientRect().width
        }
        return s
    })
}

function e8(e, t) {
    return t === void 0 && (t = 4e3), My(function(i, s) {
        var n = s.document,
            r = n.body,
            o = r.style;
        o.width = t + "px", o.webkitTextSizeAdjust = o.textSizeAdjust = "none", dp() ? r.style.zoom = "" + 1 / s.devicePixelRatio : il() && (r.style.zoom = "reset");
        var a = n.createElement("div");
        return a.textContent = Ey(Array(t / 20 << 0)).map(function() {
            return "word"
        }).join(" "), r.appendChild(a), e(n, r)
    }, '<!doctype html><html><head><meta name="viewport" content="width=device-width, initial-scale=1">')
}
var i8 = {
    fonts: lP,
    domBlockers: GP,
    fontPreferences: t8,
    audio: tP,
    screenFrame: CP,
    osCpu: vP,
    languages: _P,
    colorDepth: yP,
    deviceMemory: bP,
    screenResolution: xP,
    hardwareConcurrency: AP,
    timezone: IP,
    sessionStorage: RP,
    localStorage: kP,
    indexedDB: PP,
    openDatabase: LP,
    cpuClass: OP,
    platform: DP,
    plugins: cP,
    canvas: hP,
    touchSupport: gP,
    vendor: NP,
    vendorFlavors: FP,
    cookiesEnabled: BP,
    colorGamut: $P,
    invertedColors: jP,
    forcedColors: WP,
    monochrome: YP,
    contrast: KP,
    reducedMotion: ZP,
    hdr: qP,
    math: JP
};

function s8(e) {
    return Wk(i8, e, [])
}
var n8 = "$ if upgrade to Pro: https://fpjs.dev/pro";

function r8(e) {
    var t = o8(e),
        i = a8(t);
    return {
        score: t,
        comment: n8.replace(/\$/g, "" + i)
    }
}

function o8(e) {
    if (Iy()) return .4;
    if (il()) return fp() ? .5 : .3;
    var t = e.platform.value || "";
    return /^Win/.test(t) ? .6 : /^Mac/.test(t) ? .5 : .7
}

function a8(e) {
    return Cy(.99 + .01 * e, 1e-4)
}

function l8(e) {
    for (var t = "", i = 0, s = Object.keys(e).sort(); i < s.length; i++) {
        var n = s[i],
            r = e[n],
            o = r.error ? "error" : JSON.stringify(r.value);
        t += (t ? "|" : "") + n.replace(/([:|\\])/g, "\\$1") + ":" + o
    }
    return t
}

function c8(e) {
    return JSON.stringify(e, function(t, i) {
        return i instanceof Error ? Gk(i) : i
    }, 2)
}

function h8(e) {
    return Uk(l8(e))
}

function u8(e) {
    var t, i = r8(e);
    return {
        get visitorId() {
            return t === void 0 && (t = h8(this.components)), t
        },
        set visitorId(s) {
            t = s
        },
        confidence: i,
        components: e,
        version: Sy
    }
}

function d8(e) {
    return e === void 0 && (e = 50), Fk(e, e * 2)
}

function f8(e, t) {
    var i = Date.now();
    return {
        get: function(s) {
            return an(this, void 0, void 0, function() {
                var n, r, o;
                return Fs(this, function(a) {
                    switch (a.label) {
                        case 0:
                            return n = Date.now(), [4, e()];
                        case 1:
                            return r = a.sent(), o = u8(r), (t || s?.debug) && console.log("Copy the text below to get the debug data:\n\n```\nversion: " + o.version + `
userAgent: ` + navigator.userAgent + `
timeBetweenLoadAndGet: ` + (n - i) + `
visitorId: ` + o.visitorId + `
components: ` + c8(r) + "\n```"), [2, o]
                    }
                })
            })
        }
    }
}

function p8() {
    if (!(window.__fpjs_d_m || Math.random() >= .001)) try {
        var e = new XMLHttpRequest;
        e.open("get", "https://m1.openfpcdn.io/fingerprintjs/v" + Sy + "/npm-monitoring", !0), e.send()
    } catch (t) {
        console.error(t)
    }
}

function m8(e) {
    var t = e === void 0 ? {} : e,
        i = t.delayFallback,
        s = t.debug,
        n = t.monitoring,
        r = n === void 0 ? !0 : n;
    return an(this, void 0, void 0, function() {
        var o;
        return Fs(this, function(a) {
            switch (a.label) {
                case 0:
                    return r && p8(), [4, d8(i)];
                case 1:
                    return a.sent(), o = s8({
                        debug: s
                    }), [2, f8(o, s)]
            }
        })
    })
}
let ne = {
        writer: new oR(!1)
    },
    Bi;
m8().then(e => e.get()).then(e => {
    ne.bfp = e.visitorId
});
ne.isValid = () => Bi && Bi.readyState == WebSocket.OPEN;
ne.connect = e => {
    if (!ne.bfp) {
        setTimeout(() => ne.connect(e), 40);
        return
    }
    const t = e[0];
    console.log(`[${t}] connecting...`);
    let i;
    window.location.protocol == "https:" ? i = "wss://" : i = "ws://", Bi = new WebSocket(i + `${e[1]}`), Bi.binaryType = "arraybuffer", Bi.onopen = () => g8(t), Bi.onclose = () => v8(t), Bi.onerror = () => void 0, Bi.onmessage = s => D8(s)
};
ne.WORLD = null;
ne.SELF_ID = null;
ne.SERVER_CODE = null;
ne.PAUSE = null;
ne.INFO = null;
ne.close = (e, t) => {
    Bi && Bi.close(e, t)
};
ne.send = e => {
    if (ne.isValid())
        if (e)
            for (let t = 0; t < e; t++) Bi.send(new Uint8Array(ne.writer._b));
        else Bi.send(new Uint8Array(ne.writer._b));
    ne.writer._b = []
};

function g8(e) {
    ne.writer.writeStringUTF8(ne.bfp), ne.send(), console.log(`[${e}] connected.`)
}

function v8(e) {
    console.log(`[${e}] closed.`)
}

function _8(e) {
    const t = e.readUint8();
    U.toggleOpUnit(t)
}

function y8(e) {
    const t = e.readUint8();
    U.specMode = t, qe.jumping == 1 && (qe.jumping = 2)
}

function b8(e) {
    const [t, i] = cr(e.readUint16()), s = e.readStringUTF8(), n = e.readStringUTF8(), r = Pi.joinPlayer(t, i, s, n);
    e.readUint8() && (r.bfp = e.readStringUTF8(), r.enableChat = e.readUint8() == 1, r.notice = e.readStringUTF8())
}

function x8(e) {
    if (ne.PAUSE) return;
    ci.updateRecording();
    const t = e.readUint16();
    Gt.load.push(t);
    const i = performance.now(),
        s = vi(Gt.syncStamp, i, Er());

    function n() {
        const _ = e.readUint16();
        for (let C = 0; C < _; C++) {
            const k = e.readUint32(),
                S = e.readFloat32(),
                T = e.readFloat32(),
                L = e.readUint24();
            Me.preUpdate({
                coef: s,
                time: i,
                id: k,
                x: S,
                y: T,
                mass: L
            })
        }
    }

    function r() {
        const _ = e.readUint16();
        for (let C = 0; C < _; C++) {
            const k = e.readUint32(),
                S = e.readFloat32(),
                T = e.readFloat32();
            Me.preUpdate({
                coef: s,
                time: i,
                id: k,
                x: S,
                y: T
            })
        }
    }

    function o() {
        const _ = e.readUint16();
        for (let C = 0; C < _; C++) {
            const k = e.readUint32(),
                S = e.readUint24();
            Me.preUpdate({
                coef: s,
                time: i,
                id: k,
                mass: S
            })
        }
    }

    function a() {
        const _ = e.readUint16();
        for (let C = 0; C < _; C++) {
            const k = e.readUint32(),
                S = e.readUint32();
            Me.eat(i, k, S)
        }
    }

    function l() {
        const _ = e.readUint16();
        for (let C = 0; C < _; C++) {
            const k = e.readUint32();
            Me.remove(i, k)
        }
    }

    function c(_) {
        const C = e.readUint32(),
            k = e.readFloat32(),
            S = e.readFloat32(),
            T = e.readUint24(),
            L = e.readUint8() << 16 | e.readUint8() << 8 | e.readUint8(),
            [D, O] = cr(e.readUint16());
        Me.create({
            time: i,
            type: _,
            id: C,
            x: k,
            y: S,
            mass: T,
            color: L,
            pid: D,
            cid: O
        })
    }

    function h(_) {
        const C = e.readUint32(),
            k = e.readFloat32(),
            S = e.readFloat32(),
            T = e.readUint24(),
            L = e.readUint8() << 16 | e.readUint8() << 8 | e.readUint8(),
            [D, O] = cr(e.readUint16());
        Me.create({
            time: i,
            type: _,
            id: C,
            x: k,
            y: S,
            mass: T,
            color: L,
            pid: D,
            cid: O
        })
    }

    function u(_) {
        const C = e.readUint32(),
            k = e.readUint32(),
            S = e.readFloat32(),
            T = e.readUint24(),
            L = Me.getEntity(k),
            [D, O, K, P, N, W, V] = [L.ox, L.oy, L.or, L.nx, L.ny, L.nr, L.color],
            Q = D + K * Math.cos(S),
            pt = O + K * Math.sin(S),
            bt = P + W * Math.cos(S),
            ct = N + W * Math.sin(S);
        Me.create({
            time: i,
            type: _,
            id: C,
            x: Q,
            y: pt,
            mass: T,
            color: V
        }), Me.preUpdate({
            coef: s,
            time: i,
            id: C,
            x: bt,
            y: ct,
            mass: T
        })
    }

    function d(_) {
        const C = e.readUint32(),
            k = e.readFloat32(),
            S = e.readFloat32(),
            T = e.readUint24(),
            L = e.readUint8() << 16 | e.readUint8() << 8 | e.readUint8();
        Me.create({
            time: i,
            type: _,
            id: C,
            x: k,
            y: S,
            mass: T,
            color: L
        })
    }

    function f(_) {
        const C = e.readUint32(),
            k = e.readFloat32(),
            S = e.readFloat32(),
            T = e.readUint24();
        Me.create({
            time: i,
            type: _,
            id: C,
            x: k,
            y: S,
            mass: T
        })
    }

    function p() {
        const _ = [],
            C = e.readUint16();
        for (let k = 0; k < C; k++) {
            const [S, T] = cr(e.readUint16()), L = e.readFloat32(), D = e.readFloat32(), O = e.readUint16();
            _.push([S, T, L, D, O])
        }
        jt.miniMap.drawEntity(_)
    }

    function m() {
        const _ = [],
            C = e.readUint8();
        for (let T = 0; T < C; T++) {
            const [L, D] = cr(e.readUint16()), O = e.readFloat32();
            _.push([L, D, O])
        }
        jt.drawLeaderboard(_);
        const k = [],
            S = e.readUint8();
        for (let T = 0; T < S; T++) {
            const L = e.readUint8(),
                D = e.readUint16();
            k.push([L, D])
        }
        jt.drawTeamRankings(k)
    }

    function g() {
        let _ = e.readUint16(),
            C;
        for (; _ > 0; _--) {
            const k = e.readUint16(),
                S = e.readUint16();
            C = zt.get(k), C && (C.latency = S)
        }
        for (_ = e.readUint8(); _ > 0; _--) {
            const k = e.readUint16(),
                S = k >> 12,
                T = k & 4095;
            A.emit("updateRoomStatus", {
                index: S,
                players: T
            })
        }
    }

    function y() {
        Gt.lastSync = Gt.syncStamp, Gt.syncStamp = i, Me.sync(), jt.miniMap.drawViewport(), jt.gameStatus.updateStatus()
    }
    let x = e.readFloat32(),
        v = e.readFloat32();
    for (Cn.preUpdate(x, v, i);;) {
        const _ = e.readUint8();
        switch (_) {
            case 110:
                c(_);
                break;
            case 111:
                h(_);
                break;
            case 120:
                u(_);
                break;
            case 121:
            case 131:
                d(_);
                break;
            case 141:
            case 142:
                f(_);
                break;
            case 100:
                p();
                break;
            case 108:
                m();
                break;
            case 244:
                g();
                break
        }
        if (_ <= 31) {
            _ & 1 && n(), _ & 2 && r(), _ & 4 && o(), _ & 8 && a(), _ & 16 && l(), y();
            break
        }
    }
}

function w8(e) {
    ne.SELF_ID = e.readUint16(), ne.SERVER_CODE = e.readStringUTF8();
    const t = e.readStringUTF8();
    Ry(), console.log("[Server info]", t, "written in Rust");
    let i = e.readUint8();
    const s = [];
    for (; i > 0; i--) {
        const n = e.readStringUTF8(),
            r = e.readUint8(),
            o = e.readUint8();
        s.push([n, r, o])
    }
    ne.WORLD = s[0][0], A.emit("setRooms", s)
}

function T8(e) {
    ci.state == 2 ? ci.state = 0 : A.emit("initGame"), ne.PAUSE = !1;
    let t;
    const i = e.readStringUTF8();
    switch (i) {
        case "Rect": {
            t = {
                borderLeft: e.readFloat32(),
                borderRight: e.readFloat32(),
                borderTop: e.readFloat32(),
                borderBottom: e.readFloat32()
            };
            break
        }
        case "Octa": {
            t = [];
            for (var s = 0; s < 8; s++) {
                const l = e.readFloat32(),
                    c = e.readFloat32();
                t.push(l, c)
            }
            break
        }
    }
    t.type = i, jt.drawMap(t);
    const n = e.readUint16();
    for (let l = 0; l < n; l++) {
        const [c, h] = cr(e.readUint16()), u = e.readStringUTF8(), d = e.readStringUTF8(), f = Pi.joinPlayer(c, h, u, d);
        e.readUint8() && (f.bfp = e.readStringUTF8(), f.ping = e.readUint16(), f.activity = e.readUint8(), f.enableChat = e.readUint8() == 1, f.notice = e.readStringUTF8())
    }
    const r = e.readUint16();
    for (let l = 0; l < r; l++) {
        const c = e.readUint8(),
            h = e.readStringUTF8(),
            u = e.readUint8() << 16 | e.readUint8() << 8 | e.readUint8(),
            d = e.readUint16(),
            f = [];
        for (let p = 0; p < d; p++) {
            const m = e.readUint16();
            f.push(m)
        }
        Pi.joinTeam(c, h, u, f)
    }
    let o = [];
    const a = e.readUint8();
    for (let l = 0; l < a; l++) {
        const [c, h] = cr(e.readUint16()), u = e.readFloat32();
        o.push([c, h, u])
    }
    jt.drawLeaderboard(o), ne.SANDBOX = e.readUint8(), ne.DYNAMIC_COLLISION = e.readUint8(), ne.MAX_OU = e.readUint8(), A.emit("joinSelf", ne.SELF_ID), ne.INFO = e.readStringUTF8(), A.emit("updateChatState"), A.emit("updateWorldInfo"), A.emit("receiveChatMsg", {
        type: 4,
        id: 0,
        msg: `ANNOUNCEMENT: 
` + ne.INFO
    })
}

function E8(e) {
    let t;
    const i = e.readStringUTF8();
    switch (i) {
        case "Rect": {
            t = {
                borderLeft: e.readFloat32(),
                borderRight: e.readFloat32(),
                borderTop: e.readFloat32(),
                borderBottom: e.readFloat32()
            };
            break
        }
        case "Octa": {
            t = [];
            for (var s = 0; s < 8; s++) {
                const n = e.readFloat32(),
                    r = e.readFloat32();
                t.push(n, r)
            }
            break
        }
    }
    t.type = i, jt.drawMap(t)
}

function S8(e) {
    const t = e.readUint8(),
        i = e.readStringUTF8(),
        s = e.readUint8() << 16 | e.readUint8() << 8 | e.readUint8();
    Pi.joinTeam(t, i, s)
}

function C8(e) {
    const t = e.readUint16(),
        i = e.readUint8();
    Pi.bindPlayerTeam(t, i)
}

function A8(e) {
    const t = e.readUint16();
    Pi.disconnect(t)
}

function Ry() {
    setTimeout(() => {
        ne.writer.writeUint8(244), ne.send()
    }, H.ExtraLatency)
}

function I8(e) {
    const t = e.readUint16();
    zt.get(t).enableChat = !0
}

function M8(e) {
    const t = e.readUint16();
    zt.get(t).enableChat = !1
}

function R8(e) {
    const t = e.readFloat32(),
        i = e.readFloat32(),
        s = e.readUint32(),
        n = e.readUint16(),
        r = zt.get(n);
    r.block || (A.emit("signalHint", [r, s]), Me.create({
        type: 9,
        x: t,
        y: i,
        color: s
    }))
}

function k8(e) {
    const t = e.readUint16();
    zt.get(t).notice = e.readStringUTF8()
}

function P8(e) {
    const t = e.readUint8(),
        i = e.readUint16(),
        s = e.readStringUTF8();
    let n;
    t == 3 && (n = e.readUint16()), A.emit("receiveChatMsg", {
        type: t,
        id: i,
        msg: s,
        toId: n
    })
}

function L8(e) {
    const t = e.readUint16(),
        i = e.readUint8();
    zt.get(t).activity = i
}

function O8() {
    ne.writer.writeUint8(26).writeUint8(H.EnableChat)
}
A.on("updateChatState", O8);
A.on("sendPlayerNotice", e => {
    ne.writer.writeUint8(27).writeStringUTF8(e)
});

function D8({
    data: e
}) {
    if (e.byteLength === 0) {
        Ar.pong();
        return
    }
    const t = new rR(new DataView(e), 0, !1);
    switch (t.readUint8()) {
        case 3:
            setTimeout(() => {
                _8(t)
            }, H.ExtraLatency);
            break;
        case 4:
            y8(t);
            break;
        case 9:
            R8(t);
            break;
        case 10:
            b8(t);
            break;
        case 11:
            setTimeout(() => {
                x8(t)
            }, H.ExtraLatency);
            break;
        case 12:
            setTimeout(() => {
                T8(t)
            }, H.ExtraLatency);
            break;
        case 13:
            E8(t);
            break;
        case 14:
            S8(t);
            break;
        case 15:
            C8(t);
            break;
        case 16:
            A8(t);
            break;
        case 20:
            I8(t);
            break;
        case 21:
            M8(t);
            break;
        case 22:
            w8(t);
            break;
        case 23:
            k8(t);
            break;
        case 24:
            P8(t);
            break;
        case 31:
            L8(t);
            break;
        case 244:
            Ry();
            break
    }
}
var at = ne;
let Vd = null;
const be = {
        FeedNone: () => {
            U.state == 1 && (at.writer.writeUint8(1).writeUint8(0), at.send())
        },
        FeedOnce: () => {
            U.state == 1 && (at.writer.writeUint8(1).writeUint8(1), at.send())
        },
        MacroFeed: () => {
            U.state == 1 && (at.writer.writeUint8(1).writeUint8(2), at.send())
        },
        Split: (e = 1) => {
            U.state == 1 && (U.currentOpUnit.moveMode == 1 && Te.MoveChange.execute().end(), e === 4 && !Te.Pause.executed ? (at.writer.writeUint8(8).writeUint8(2).writeUint8(2).writeUint8(2).writeUint8(2), at.send()) : (at.writer.writeUint8(2).writeFloat32(jt.mouseX).writeFloat32(jt.mouseY), at.send(e)))
        },
        Pause: () => {
            U.pause = !0, at.writer.writeUint8(6).writeUint8(1), at.send()
        },
        Scatter: () => {
            U.state == 1 && (U.pause = !1, at.writer.writeUint8(6).writeUint8(3), at.send())
        },
        CancelPauseOrScatter: () => {
            U.state == 1 && (U.pause = !1, at.writer.writeUint8(6).writeUint8(2), at.send())
        },
        GetMass: () => {
            U.state == 1 && (at.writer.writeUint8(51), at.send())
        },
        LoseMass: () => {
            U.state == 1 && (at.writer.writeUint8(52), at.send())
        },
        Clear: () => {
            U.state == 1 && (at.writer.writeUint8(53), at.send())
        },
        ToggleOpUnit: () => {
            Te.ClickMove.end(), Te.MoveChange.end(), Te.Shift.end();
            const e = U.nextOpUnitIndex;
            at.writer.writeUint8(3).writeUint8(e | H.StopFeedingAfterSwitchingTab << 4), at.send()
        },
        Signal: () => {
            at.writer.writeUint8(9).writeFloat32(jt.mouseX).writeFloat32(jt.mouseY).writeUint32(Be(B.Signal[0])), at.send()
        },
        ClickMove: () => {
            if (U.state == 1) {
                if (performance.now() - Vd > 240) {
                    Te.MoveChange.execute();
                    return
                }
                U.pause = !1, U.setDestinationPoint(jt.mouseX, jt.mouseY), at.writer.writeUint8(6).writeUint8(0).writeFloat32(jt.mouseX).writeFloat32(jt.mouseY), at.send()
            }
        },
        MoveChange: () => {
            U.state == 1 && (U.pause = !1, U.targetOpUnit.moveMode = 0, at.writer.writeUint8(6).writeUint8(0), at.send())
        },
        Shift: () => {
            U.state == 1 && (U.pause = !1, at.writer.writeUint8(6).writeUint8(4), at.send())
        }
    },
    Te = {
        FeedOnce: new Vt(be.FeedOnce),
        MacroFeed: new Vt(() => {
            be.MacroFeed()
        }, null, () => {
            be.FeedNone()
        }),
        Split1X: new Vt(be.Split),
        Split2X: new Vt(() => be.Split(2)),
        Split3X: new Vt(() => be.Split(3)),
        Split4X: new Vt(() => be.Split(4)),
        Pause: new Vt(() => {
            const e = Te.Scatter;
            e.executed && clearInterval(e._interval), be.Pause()
        }, null, () => {
            Te.Scatter.executed ? be.Scatter() : Te.TogglePause.executed || be.CancelPauseOrScatter()
        }),
        TogglePause: new Vt(() => {
            if (Te.TogglePause.executed) return;
            const e = Te.Pause,
                t = Te.Scatter;
            U.pause && !e.executed ? t.executed ? be.Scatter() : be.CancelPauseOrScatter() : (t.executed && clearInterval(t._interval), be.Pause())
        }, null, null),
        Scatter: new Vt(() => {
            Te.Pause.executed || be.Scatter()
        }, null, () => {
            Te.Pause.executed || be.CancelPauseOrScatter()
        }),
        SwitchTab: new Vt(be.ToggleOpUnit),
        AutoSwitchTab: new Vt(() => {
            H.AutoSwitchTab ^= 1, A.emit(Ut.AutoSwitchTab)
        }),
        Toggle4TabMode: new Vt(() => {}),
        Respawn: new Vt(() => {}),
        ShowCursorLine: new Vt(() => {
            H.ShowCursorLine ^= 1, A.emit(Ut.ShowCursorLine)
        }),
        ShowEnemyHint: new Vt(() => {
            H.ShowEnemyHint ^= 1, A.emit(Ut.ShowEnemyHint)
        }),
        ShowMassMarker: new Vt(() => {
            H.ShowMassMarker ^= 1, A.emit(Ut.ShowMassMarker)
        }),
        ShowSplitOrderMarker: new Vt(() => {
            H.ShowSplitOrderMarker ^= 1, A.emit(Ut.ShowSplitOrderMarker)
        }),
        ShowAutosplitAlert: new Vt(() => {
            H.ShowAutosplitAlert ^= 1, A.emit(Ut.ShowAutosplitAlert)
        }),
        IncreaseMass: new Vt(be.GetMass, be.GetMass),
        DecreaseMass: new Vt(be.LoseMass, be.LoseMass),
        ClearSmallCells: new Vt(be.Clear),
        QuickCapture: new Vt(() => {
            A.emit("quickCapture")
        }),
        ShowNick: new Vt(() => {
            H.ShowNick ^= 1, A.emit(Ut.ShowNick)
        }),
        ShowMass: new Vt(() => {
            H.ShowMass ^= 1, A.emit(Ut.ShowMass)
        }),
        ShowSkin: new Vt(() => {
            H.ShowSkin ^= 1, A.emit(Ut.ShowSkin)
        }),
        ShowFood: new Vt(() => {
            H.ShowFood ^= 1, A.emit(Ut.ShowFood)
        }),
        ShowMinimap: new Vt(() => {
            H.ShowMinimap ^= 1, A.emit(Ut.ShowMinimap)
        }),
        ShowLeaderboard: new Vt(() => {
            H.ShowLeaderboard ^= 1, A.emit(Ut.ShowLeaderboard)
        }),
        ShowTeamRankings: new Vt(() => {
            H.ShowTeamRankings ^= 1, A.emit(Ut.ShowTeamRankings)
        }),
        ShowPerfStatus: new Vt(() => {
            H.ShowPerfStatus ^= 1, A.emit(Ut.ShowPerfStatus)
        }),
        ShowGameStatus: new Vt(() => {
            H.ShowGameStatus ^= 1, A.emit(Ut.ShowGameStatus)
        }),
        ShowChatRoom: new Vt(() => {
            H.ShowChatRoom ^= 1, A.emit(Ut.ShowChatRoom)
        }),
        ShowReplayBar: new Vt(() => {
            H.ShowReplayBar ^= 1, A.emit(Ut.ShowReplayBar)
        }),
        Signal: new Vt(be.Signal),
        ClickMove: new Vt(be.ClickMove, be.ClickMove, null),
        MoveChange: new Vt(be.MoveChange),
        Shift: new Vt(be.Shift)
    },
    $a = new Vt(e => {
        if (at.writer.writeUint8(4), U.specTarget = null, U.state || (U.state = 2), e == 0) U.specTarget = null, at.writer.writeUint16(0);
        else if (e) {
            if (U.specMode = 1, U.specTarget = zt.get(e), U.specTarget.isBot) {
                U.specTarget = null, at.writer._b = [];
                return
            }
            at.writer.writeUint16(e)
        }
        at.send()
    });

function N8(e) {
    if (e.repeat || !e.code) return;
    const {
        code: t
    } = e;
    (t === "Tab" || e.altKey) && e.preventDefault();
    const i = yo(e);
    if (U.state == 1) {
        if (wh.state) return;
        Object.entries(bi).forEach(([s, n]) => {
            i == n && Te[s].execute()
        })
    } else U.state >= 2 && (i === "Q" ? A.emit("spectate", !0) : Object.entries(bi).forEach(([s, n]) => {
        i == n && Te[s].execute()
    }))
}

function F8(e) {
    const t = yo(e);
    if (U.state == 1) {
        if (wh.state) return;
        Object.entries(bi).forEach(([i, s]) => {
            t == s && Te[i].end()
        })
    } else U.state >= 2 && Object.entries(bi).forEach(([i, s]) => {
        t == s && Te[i].end()
    })
}

function B8({
    button: e,
    timeStamp: t
}) {
    const i = tl[e];
    if (U.state === 1 || i == "Signal") {
        if (i == "None") return;
        if (i == "ClickMove") {
            const s = t;
            Te.ClickMove.execute(), s - Vd < 240 && Gt.gamemode == "Poineer" && Te.Shift.execute().end(), Vd = s
        } else Te[i].execute()
    }
}

function U8({
    button: e
}) {
    const t = tl[e];
    if (U.state === 1 || t == "Signal") {
        if (t == "None") return;
        t == "ClickMove" ? (Te.ClickMove.end(), Te.MoveChange.end(), Te.Shift.end()) : Te[t].end()
    }
}

function G8({
    button: e
}) {}

function H8() {
    $a.end();
    for (let e = 0; e < bi.length - 1; e++)
        for (let t = 0; t < bi[e].length; t++) bi[e][t].executed && Te[e][t].end()
}
A.on("changeRoom", e => {
    at.WORLD = e, at.writer.writeUint8(23).writeStringUTF8(e), at.send()
});
A.on("spectate", e => {
    U.specMode != 2 && e ? $a.execute(0).end() : $a.execute().end()
});
A.on("selectSpectate", e => {
    e == 0 ? $a.execute().end() : $a.execute(e).end()
});
A.on("moveCameraTo", ({
    x: e,
    y: t
}) => {
    U.state >= 2 && (at.writer.writeUint8(4), at.writer.writeFloat32(e), at.writer.writeFloat32(t), at.send())
});
A.on("clearEvent", H8);
A.on("toggleOpUnit", be.ToggleOpUnit);
class V8 {
    constructor(t) {
        I(this, "renderer", ma({
            width: innerWidth,
            height: innerHeight,
            antialias: H.Antialias,
            resolution: H.Resolution,
            autoDensity: !0,
            backgroundAlpha: 0,
            hello: !0
        }));
        I(this, "subRenderer", ma({
            width: innerWidth,
            height: innerHeight,
            antialias: H.Antialias,
            resolution: H.Resolution,
            autoDensity: !0,
            backgroundAlpha: 0
        }));
        I(this, "antialias", H.Antialias);
        I(this, "ticker", Gt);
        I(this, "oScale");
        I(this, "nScale");
        I(this, "zoomInterval");
        const i = document.querySelector(t),
            {
                main_canvas: s,
                sub_canvas: n,
                screen: r
            } = this;
        ba.position.set(r.width / 2, r.height / 2), A.on("focusGameCanvas", () => this.focus()), A.on(Ut.Resolution, () => {
            this.renderer.resolution = H.Resolution, this.subRenderer.resolution = H.Resolution, this.resize()
        }), A.on(Ut.Antialias, () => {
            this.antialias != H.Antialias && (this.antialias = H.Antialias, o.removeChild(this.main_canvas), o.removeChild(this.sub_canvas), this.renderer.destroy(!0), this.subRenderer.destroy(!0), this.renderer = ma({
                width: innerWidth,
                height: innerHeight,
                antialias: H.Antialias,
                resolution: H.Resolution,
                autoDensity: !0,
                backgroundAlpha: 0
            }), this.subRenderer = ma({
                width: innerWidth,
                height: innerHeight,
                antialias: H.Antialias,
                resolution: H.Resolution,
                autoDensity: !0,
                backgroundAlpha: 0
            }), Gt.renderer = this.renderer, Gt.subRenderer = this.subRenderer, this.main_canvas.style.position = "absolute", this.sub_canvas.style.position = "absolute", o.appendChild(this.main_canvas), o.appendChild(this.sub_canvas))
        }), window.onbeforeunload = () => this.destroy(), window.addEventListener("resize", () => this.resize()), document.addEventListener("mousemove", h => this.mousemove(h));
        const o = document.createElement("div");
        this.view = o, o.id = "game_canvas", o.addEventListener("wheel", h => this.zoom(h), {
            passive: !0
        }), o.addEventListener("keydown", N8), o.addEventListener("keyup", F8), o.addEventListener("mousedown", B8), o.addEventListener("mouseup", U8), o.addEventListener("dblclick", G8), o.tabIndex = -1, s.style.position = "absolute", n.style.position = "absolute", Gt.renderer = this.renderer, Gt.subRenderer = this.subRenderer, o.appendChild(s), o.appendChild(n), i.appendChild(o), this.renderer.hitArea = this.screen, this.subRenderer.hitArea = this.screen;
        const a = h => {
            Gt.eventReaction = !1, s.dispatchEvent(new PointerEvent("pointerdown", {
                button: h.button,
                pointerType: h.pointerType,
                clientX: h.clientX,
                clientY: h.clientY,
                isPrimary: !0
            })), Gt.eventReaction || A.emit("selectSpectate", 0)
        };
        n.addEventListener("mousedown", a), n.addEventListener("touchstart", a), this.delta = 0;
        const l = () => {
            requestAnimationFrame(l), this.updateUIFrame()
        };
        l();
        const c = () => {
            requestAnimationFrame(c), this.updateMainFrame()
        };
        c()
    }
    get main_canvas() {
        return this.renderer.view
    }
    get screen() {
        return this.renderer.screen
    }
    get sub_canvas() {
        return this.subRenderer.view
    }
    get zoomed() {
        return Math.abs(this.oScale / this.nScale - 1) < 1e-5
    }
    updateMainFrame() {
        let t = performance.now();
        A.emit("sendMousePos", t);
        let i = performance.now(),
            s = 0,
            n = this.delta * s;
        Cn.update_linear(t + n), t = performance.now(), Me.update_linear(t + n), Gt.lastFrame = t, this.renderer.render(ba), this.delta = (this.delta + performance.now() - t) / 2, i = performance.now() - i, Gt.statistics.push(i)
    }
    updateUIFrame() {
        let t = performance.now();
        qe.update(t), Ar.updatePerf(t), this.subRenderer.render(jt), U.drawCursorLine()
    }
    focus() {
        this.view.focus()
    }
    resize() {
        this.renderer.resize(innerWidth, innerHeight), this.subRenderer.resize(innerWidth, innerHeight), jt.resize(this.screen.width / 2, this.screen.height / 2)
    }
    zoom({
        deltaY: t
    }) {
        cancelAnimationFrame(this.zoomInterval);
        const i = H.ZoomSpeed * 1.05;
        this.oScale = ba.scale.x, this.nScale || (this.nScale = this.oScale);
        const s = this.nScale * .618 + this.oScale * .382;
        this.nScale = t > 0 ? s / i : s * i, this.nScale = Math.max(Math.min(this.nScale, 1.35), .0075);
        let n = () => {
            if (this.zoomed) this.oScale = this.nScale;
            else {
                const r = 1 - .8875 ** (60 / Math.max(Gt.fps, 60));
                this.oScale = Ze(this.oScale, this.nScale, r), this.zoomInterval = requestAnimationFrame(n)
            }
            ba.scale.set(this.oScale), Me.deploy(), U.drawCursorLine()
        };
        this.zoomInterval = requestAnimationFrame(n)
    }
    mousemove({
        pageX: t,
        pageY: i
    }) {
        wh.state || (t || i) && (Gt.mouseX = t, Gt.mouseY = i)
    }
    destroy() {
        jt.destroy(), this.renderer.destroy(!0)
    }
}
const z8 = {
        play: "\u5F00\u59CB",
        spectate: "\u89C2\u6218",
        server: "\u670D\u52A1\u5668",
        settings: "\u8BBE\u7F6E",
        servers: ["\u5927\u962A", "\u4E1C\u4EAC", "\u672C\u5730"],
        servers2: ["EA", "EA-S", "NA"]
    },
    $8 = {
        play: "\u958B\u59CB",
        spectate: "\u89C0\u6230",
        server: "\u4F3A\u670D\u5668",
        settings: "\u8A2D\u7F6E",
        servers: ["\u5927\u962A", "\u6771\u4EAC", "\u672C\u5730"],
        servers2: ["EA", "EA-S", "NA"]
    },
    j8 = {
        play: "\u958B\u59CB",
        spectate: "\u89B3\u6226",
        server: "\u30B5\u30FC\u30D0\u30FC",
        settings: "\u8A2D\u5B9A",
        servers: ["\u5927\u962A", "\u6771\u4EAC", "\u958B\u767A\u8005\u306E\u307F"],
        servers2: ["EA", "EA-S", "NA"]
    },
    W8 = {
        play: "PLAY",
        spectate: "SPECTATE",
        server: "SERVER",
        settings: "SETTINGS",
        servers: ["Osaka", "Tokyo", "DEV-ONLY"],
        servers2: ["EA", "EA-S", "NA"]
    };
var X8 = {
    zh_CN: z8,
    zh: $8,
    ja: j8,
    en: W8
};
const Y8 = {
        name: "common-select",
        props: {
            class: String,
            selected: {
                type: Number,
                default: 0
            },
            options: {
                type: Array,
                default: []
            }
        },
        setup(e, {
            emit: t
        }) {
            const i = ft(null),
                s = Ft(() => e.options.length * -38.5 + "px"),
                n = Ft(() => e.selected * -38.5 + "px"),
                r = ft("(0deg)");
            let o = !1;

            function a() {
                i.value.classList.contains("open") || i.value.classList.add("open"), i.value.style.cssText = "--t:" + s.value, r.value = "(180deg)"
            }

            function l() {
                o || (i.value.classList.remove("open"), i.value.style.cssText = "--t: 32.5px", r.value = "(0deg)", A.emit("focusGameCanvas"))
            }

            function c(h) {
                h !== e.selected && (t("change", h), o = !0, setTimeout(() => {
                    i.value.classList.remove("open"), o = !1, l()
                }, 240))
            }
            return Ve(() => {
                i.value.classList.add(e.class), i.value.style.cssText = "--t: 32.5px"
            }), {
                o: s,
                t: n,
                r,
                menu: i,
                open: a,
                close: l,
                change: c
            }
        }
    },
    K8 = e => (gs("data-v-a7030bc6"), e = e(), vs(), e),
    Z8 = K8(() => b("path", {
        d: "M533.333333 465.066667L358.4 640 298.666667 580.266667l234.666666-234.666667 234.666667 234.666667-64 59.733333-170.666667-174.933333z"
    }, null, -1)),
    q8 = [Z8],
    J8 = ["onClick"];

function Q8(e, t, i, s, n, r) {
    return st(), nt("div", {
        class: "select-menu",
        ref: "menu",
        tabindex: "-1",
        onBlur: t[1] || (t[1] = (...o) => s.close && s.close(...o))
    }, [b("div", {
        class: "select-button",
        style: $t({
            "--t": s.t
        }),
        onClick: t[0] || (t[0] = (...o) => s.open && s.open(...o))
    }, [(st(), nt("svg", {
        class: "select-status",
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "25",
        height: "25",
        fill: "#707070",
        style: $t({
            transform: "rotateZ" + s.r
        })
    }, q8, 4)), b("ul", null, [(st(!0), nt(Dt, null, Jt(i.options, (o, a) => (st(), nt("li", {
        key: a
    }, Ot(o), 1))), 128))])], 4), b("ul", null, [(st(!0), nt(Dt, null, Jt(i.options, (o, a) => (st(), nt("li", {
        key: a,
        onClick: l => s.change(a)
    }, Ot(o), 9, J8))), 128))])], 544)
}
var tL = ue(Y8, [
    ["render", Q8],
    ["__scopeId", "data-v-a7030bc6"]
]);
const eL = {
        name: "list",
        props: {
            class: String,
            selected: {
                type: Number,
                default: 0
            },
            options: {
                type: Array,
                default: []
            }
        },
        setup(e, {
            emit: t
        }) {
            const i = ft(null);
            A.on("updateRoomStatus", ({
                index: r,
                players: o
            }) => {
                e.options[r][1] = o
            });

            function s(r) {
                r !== e.selected && t("change", r)
            }

            function n(r) {
                return r == e.selected ? "rgba(64, 64, 64, 0.75)" : "transparent"
            }
            return Ve(() => {
                i.value.classList.add(e.class)
            }), {
                change: s,
                checkColor: n,
                list: i
            }
        }
    },
    iL = {
        class: "room-list",
        ref: "list"
    },
    sL = {
        class: "list-inner"
    },
    nL = ["onClick"],
    rL = {
        class: "room-name"
    },
    oL = {
        class: "room-players"
    };

function aL(e, t, i, s, n, r) {
    return st(), nt("div", iL, [b("ul", sL, [(st(!0), nt(Dt, null, Jt(i.options, (o, a) => (st(), nt("li", {
        key: a,
        style: $t({
            "background-color": s.checkColor(a)
        }),
        onClick: l => s.change(a)
    }, [b("div", rL, Ot(o[0]), 1), b("div", oL, Ot(o[1] + "/" + o[2]), 1)], 12, nL))), 128))])], 512)
}
var lL = ue(eL, [
    ["render", aL],
    ["__scopeId", "data-v-78404f50"]
]);
const cL = {
        name: "multibox-avatar",
        setup(e, {
            emit: t
        }) {
            const i = ft(null);

            function s(o, a, l, c) {
                o.onmouseover = () => {
                    o.isClick || o.classList.add(a)
                }, o.onmouseout = () => {
                    o.isClick || o.classList.remove(a)
                }, o.onclick = h => {
                    t("change", o.value), Array.from(i.value.children).forEach(u => {
                        c && u.classList.remove(c), u.classList.remove(a), u.classList.remove(l), u.isClick = !1
                    }), o.isClick = !0, o.classList.add(l)
                }
            }

            function n(o, a, l = 0) {
                for (i.value.removeAttribute("style"); i.value.hasChildNodes();) i.value.removeChild(i.value.firstChild);
                switch (o) {
                    case 1: {
                        i.value.style.backgroundImage = `url(${a[0][1]})`;
                        break
                    }
                    case 2: {
                        const c = document.createElement("div");
                        c.value = 0, c.classList.add("slice"), c.style.position = "static", c.style.left = "0%", c.style.transformOrigin = "50% 100%", c.style.transform = "rotate(-45deg)";
                        const h = document.createElement("div");
                        h.classList.add("slice-content"), h.style.position = "absolute", h.style.left = "0%", h.style.transform = "rotate(45deg)", h.style.backgroundImage = `url(${a[0][1]})`, c.appendChild(h);
                        const u = c.cloneNode();
                        u.value = 1, u.style.transformOrigin = "50% 0%", u.style.transform = "rotate(-45deg)";
                        const d = h.cloneNode();
                        d.style.right = "0%", d.style.bottom = "0%", d.style.backgroundImage = `url(${a[1][1]})`, u.appendChild(d), s(c, "slice-mouseover-1", "slice-click-1", "slice-click-2"), s(u, "slice-mouseover-2", "slice-click-2", "slice-click-1"), i.value.appendChild(c), i.value.appendChild(u);
                        const f = Array.from(i.value.children)[l];
                        f.isClick = !0, f.classList.add(`slice-click-${parseInt(l)+1}`);
                        break
                    }
                    case 3: {
                        const c = document.createElement("div");
                        c.value = 0, c.classList.add("slice"), c.style.transform = "rotate(30deg) skew(-30deg)";
                        const h = document.createElement("div");
                        h.classList.add("slice-content"), h.style.backgroundImage = `url(${a[0][1]})`, h.style.transform = "rotate(0deg) skew(30deg)", c.appendChild(h);
                        const u = c.cloneNode();
                        u.value = 1, u.style.transform = "rotate(150deg) skew(-30deg)";
                        const d = h.cloneNode();
                        d.style.backgroundImage = `url(${a[1][1]})`, d.style.transform = "skew(30deg) rotate(-150deg)", u.appendChild(d);
                        const f = c.cloneNode();
                        f.value = 2, f.style.transform = "rotate(-90deg) skew(-30deg)";
                        const p = h.cloneNode();
                        p.style.backgroundImage = `url(${a[2][1]})`, p.style.transform = "skew(30deg) rotate(-240deg)", f.appendChild(p), s(c, "slice-mouseover", "slice-click"), s(u, "slice-mouseover", "slice-click"), s(f, "slice-mouseover", "slice-click"), i.value.appendChild(c), i.value.appendChild(u), i.value.appendChild(f);
                        const m = Array.from(i.value.children)[l];
                        m.isClick = !0, m.classList.add("slice-click");
                        break
                    }
                    case 4: {
                        const c = document.createElement("div");
                        c.value = 0, c.classList.add("slice"), c.style.transform = "rotate(45deg)";
                        const h = document.createElement("div");
                        h.classList.add("slice-content"), h.style.backgroundImage = `url(${a[0][1]})`, h.style.transform = "rotate(-45deg)", c.appendChild(h), c.onclick = this.sliceClick;
                        const u = c.cloneNode();
                        u.value = 1, u.style.transform = "rotate(135deg)";
                        const d = h.cloneNode();
                        d.style.backgroundImage = `url(${a[1][1]})`, d.style.transform = "rotate(-135deg)", u.appendChild(d);
                        const f = c.cloneNode();
                        f.value = 2, f.style.transform = "rotate(225deg)";
                        const p = h.cloneNode();
                        p.style.backgroundImage = `url(${a[2][1]})`, p.style.transform = "rotate(-225deg)", f.appendChild(p);
                        const m = c.cloneNode();
                        m.value = 3, m.style.transform = "rotate(315deg)";
                        const g = h.cloneNode();
                        g.style.backgroundImage = `url(${a[3][1]})`, g.style.transform = "rotate(-315deg)", m.appendChild(g), s(c, "slice-mouseover", "slice-click"), s(u, "slice-mouseover", "slice-click"), s(f, "slice-mouseover", "slice-click"), s(m, "slice-mouseover", "slice-click"), i.value.appendChild(c), i.value.appendChild(u), i.value.appendChild(f), i.value.appendChild(m);
                        const y = Array.from(i.value.children)[l];
                        y.isClick = !0, y.classList.add("slice-click");
                        break
                    }
                }
            }

            function r(o, a) {
                i.value.hasChildNodes() ? Array.from(i.value.children)[o].firstChild.style.backgroundImage = `url(${a})` : i.value.style.backgroundImage = `url(${a})`
            }
            return {
                avatar: i,
                sliceChange: n,
                contentChange: r
            }
        }
    },
    hL = {
        id: "avatar"
    },
    uL = b("div", {
        id: "avatar-base"
    }, null, -1),
    dL = {
        id: "avatar-inner",
        ref: "avatar"
    };

function fL(e, t, i, s, n, r) {
    return st(), nt("div", hL, [uL, b("div", dL, null, 512)])
}
var pL = ue(cL, [
    ["render", fL]
]);
const xa = ft(null),
    es = _i(Zf),
    Fo = ft(qf),
    tr = Ft(() => es[Fo.value]),
    Ni = ft(Kf),
    fr = ft(0),
    ir = Ft(() => tr.value[1]),
    ca = Ft(() => ir.value[fr.value]);
let ky = !0;

function Py(e) {
    ky = !0, Fo.value = e, fr.value = 0, xa.value.sliceChange(Ni.value, ir.value, fr.value), localStorage.setItem("profile_index", Fo.value)
}

function l0(e) {
    const t = Fo.value;
    let i = t + e === es.length ? 0 : t + e === -1 ? es.length - 1 : t + e;
    Py(i)
}
const mL = {
        name: "main-menu",
        components: {
            list: lL,
            "common-select": tL,
            "multibox-avatar": pL
        },
        props: {
            menuState: Boolean
        },
        setup(e, {
            emit: t
        }) {
            const i = Ft(() => X8[yi("locale").value]),
                s = ft(0),
                n = ft(Jf),
                r = ft(1),
                o = ft(0),
                a = _i([]),
                l = Ft(() => (e.menuState || (r.value = 1), e.menuState)),
                c = Ft(() => location.host.split(".")[0].includes("nano") ? i.value.servers2 : i.value.servers),
                h = Ft(() => location.host.split(".")[0].includes("nano") ? WM : jM),
                u = Ft({
                    get: () => tr.value[0][0],
                    set: W => tr.value[0][0] = W
                }),
                d = Ft({
                    get: () => tr.value[0][1],
                    set: W => tr.value[0][1] = W
                }),
                f = Ft({
                    get: () => ca.value[0],
                    set: W => ca.value[0] = W
                }),
                p = Ft({
                    get: () => ca.value[1],
                    set: W => ca.value[1] = W
                });
            Ft(() => ({
                tag: u.value,
                code: d.value,
                nick: f.value,
                skin: p.value
            }));

            function m(W) {
                fr.value = W
            }

            function g(W) {
                Ni.value = Math.max(Math.min(Ni.value + W, 4), 1), Ni.value == 3 && (Ni.value += W), xa.value.sliceChange(Ni.value, ir.value, fr.value), localStorage.setItem("unit_num", Ni.value)
            }

            function y() {
                localStorage.setItem("profile_data", JSON.stringify(es))
            }

            function x() {
                xa.value.contentChange(fr.value, ca.value[1]), localStorage.setItem("profile_data", JSON.stringify(es))
            }

            function v() {
                r.value == 1 ? l0(1) : r.value == 2 && (s.value + 20 <= es.length ? s.value += 10 : s.value = 0)
            }

            function _() {
                r.value == 1 ? l0(-1) : r.value == 2 && (s.value - 10 >= 0 ? s.value -= 10 : s.value = es.length - 10)
            }

            function C(W) {
                r.value == W ? r.value = 1 : (r.value = W, A.emit("switchSettings", !1))
            }
            const k = ft(H.HideCode);

            function S() {
                k.value ^= 1, H.HideCode = k.value, localStorage.setItem("gconfig_data", JSON.stringify(H))
            }

            function T(W) {
                o.value = 0, a.length = 0, n.value = W, localStorage.setItem("server", W), A.emit("changeServer", [c.value[W], h.value[W]]), A.emit("clearChatMsg", 0)
            }

            function L(W) {
                o.value = W, A.emit("changeRoom", a[W][0]), A.emit("clearChatMsg", 1)
            }

            function D() {
                if (at.writer.writeUint8(7).writeStringUTF8(u.value).writeStringUTF8(d.value), Ni.value == 1) {
                    const W = ir.value[0];
                    for (let V = 0; V < 4; V++) at.writer.writeUint8(V).writeStringUTF8(W[0]).writeStringUTF8(W[1])
                } else if (Ni.value == 2)
                    for (let W = 0; W < 4; W++) {
                        const V = ir.value[W % 2];
                        at.writer.writeUint8(W).writeStringUTF8(V[0]).writeStringUTF8(V[1])
                    } else ir.value.forEach((W, V) => {
                        at.writer.writeUint8(V).writeStringUTF8(W[0]).writeStringUTF8(W[1])
                    });
                at.send(), ky && O(tr.value[2])
            }

            function O(W) {
                typeof W < "u" && (tr.value[2] = W), localStorage.setItem("profile_data", JSON.stringify(es)), at.writer.writeUint8(27).writeStringUTF8(W), at.send()
            }

            function K() {
                !at.isValid() || ci.state || (A.emit("sendProfile"), U.state !== 1 && (A.emit("play"), at.writer.writeUint8(5), at.send(), U.score = 0), localStorage.setItem("profile_data", JSON.stringify(es)), localStorage.setItem("profile_index", Fo.value), localStorage.setItem("unit_num", Ni.value), A.emit("menuHide"), A.emit("switchMenu", !1))
            }

            function P() {
                ci.state || (A.emit("sendProfile"), U.state !== 1 && (U.state = 2, A.emit("spectate")), A.emit("menuHide"), localStorage.setItem("profile_data", JSON.stringify(es)), localStorage.setItem("profile_index", Fo.value), localStorage.setItem("unit_num", Ni.value), A.emit("switchMenu", !1))
            }

            function N() {
                r.value = 1, A.emit("switchSettings")
            }
            return zv(() => {
                at.connect([c.value[n.value], h.value[n.value]])
            }), Ve(() => {
                const W = () => {
                    const V = document.activeElement.classList;
                    !V.contains("menu-input") && !V.contains("select-menu") && A.emit("focusGameCanvas")
                };
                document.getElementById("menu").addEventListener("mouseleave", W), xa.value.sliceChange(Ni.value, ir.value, fr.value)
            }), A.on("setRooms", W => {
                a.length = 0, a.push(...W)
            }), A.on("quickStart", () => {
                U.state != 1 ? K() : H.AutoSwitchTab || (console.trace(), A.emit("toggleOpUnit"))
            }), A.on("sendProfile", D), A.on("sendNotice", O), {
                t: i,
                avatar: xa,
                showMenu: l,
                panelState: r,
                baseProfileListIndex: s,
                serverIndex: n,
                profileData: es,
                roomIndex: o,
                serverOpt: c,
                roomOpt: a,
                tag: u,
                code: d,
                nick: f,
                skin: p,
                avatarChange: m,
                multiboxChange: g,
                setProfileData: y,
                preLoadAvatar: x,
                turnTo: Py,
                pageUp: _,
                pageDown: v,
                setting: N,
                hideCode: k,
                hide: S,
                switchPanel: C,
                changeServer: T,
                changeRoom: L,
                play: K,
                spectate: P
            }
        }
    },
    gL = {
        id: "menu",
        action: "javascript:;"
    },
    vL = {
        id: "avatar-panel"
    },
    _L = ih('<div id="avatar-background"><div id="avatar-rect"></div><div id="avatar-tra"><div id="avatar-tra-border1"></div><div id="avatar-tra-border2"></div></div><div id="avatar-po"></div><div id="avatar-tri"></div></div>', 1),
    yL = ih('<div id="pl-btn-tri"></div><div id="pl-btn-border1"></div><div id="pl-btn-border2"></div><svg id="profile-list-icon" viewBox="0 0 200 200" xmlns="http://www.w3.org/2000/svg" width="16" height="16"><image id="image0" width="200" height="200" x="0" y="0" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAMgAAADIAgMAAADQNkYNAAAABGdBTUEAALGPC/xhBQAAACBjSFJN AAB6JQAAgIMAAPn/AACA6QAAdTAAAOpgAAA6mAAAF2+SX8VGAAAADFBMVEUwkP////8wkP/////v ZWcRAAAAAnRSTlMAAHaTzTgAAAABYktHRAH/Ai3eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJ TUUH5gwHEy0FGs40zgAAAGVJREFUaN7t1rENgDAMRUEvmX2YJ1MiOggJogkyyr3S0rVfjtppi6M6 KBBkaRKnriSaEARBEARBEARBspJeCILcSb9SEARZmLQlJ4/ThyAzybjU5M0NQRAEQRAEmUe++foQ 5CdkBxMfY5eXB6OaAAAAJXRFWHRkYXRlOmNyZWF0ZQAyMDIyLTEyLTA3VDE5OjQ1OjA0KzAwOjAw dsMd+wAAACV0RVh0ZGF0ZTptb2RpZnkAMjAyMi0xMi0wN1QxOTo0NTowNCswMDowMAeepUcAAAAo dEVYdGRhdGU6dGltZXN0YW1wADIwMjItMTItMDdUMTk6NDU6MDUrMDA6MDD2/I8sAAAAAElFTkSu QmCC"></image></svg>', 4),
    bL = [yL],
    xL = b("div", {
        id: "mac-btn-border1"
    }, null, -1),
    wL = ih('<div id="multibox-cut-btn"><div id="mc-btn-tri1"></div><div id="mc-btn-tri2"></div><svg id="multibox-cut-icon" viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="14" height="14" fill="var(--main-theme-color)" transform="translate(0,0.75)"><path d="M117.734106 458.213254 906.212134 458.213254C925.995765 458.213254 959.972 482.279754 959.972 511.97312 959.972 541.666486 925.995765 565.732986 906.212134 565.732986L117.734106 565.732986C97.950475 565.732986 63.97424 541.666486 63.97424 511.97312 63.97424 482.279754 97.950475 458.213254 117.734106 458.213254Z"></path></svg></div>', 1),
    TL = b("div", {
        id: "ma-btn-tri1"
    }, null, -1),
    EL = b("div", {
        id: "ma-btn-tri2"
    }, null, -1),
    SL = b("svg", {
        id: "multibox-add-icon",
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "16",
        height: "16",
        fill: "var(--main-theme-color)",
        transform: "translate(0,-1.5)"
    }, [b("path", {
        d: "M911.244448 452.317713 563.184241 452.317713 563.184241 104.274902c0-27.465538-22.254863-49.720402-49.721425-49.720402-27.465538 0-49.719378 22.254863-49.719378 49.720402l0 348.043834L115.715977 452.318736c-27.465538 0-49.720402 22.254863-49.720402 49.721425 0 27.465538 22.254863 49.720402 49.720402 49.720402l348.028485 0 0 348.010065c0 27.467585 22.25384 49.722448 49.719378 49.722448 27.466562 0 49.721425-22.254863 49.721425-49.722448L563.185264 551.760562l348.060207 0c27.466562 0 49.720402-22.254863 49.720402-49.720402C960.96485 474.572576 938.71101 452.317713 911.244448 452.317713z"
    })], -1),
    CL = [TL, EL, SL],
    AL = b("div", {
        id: "mouse-blocker1"
    }, null, -1),
    IL = b("div", {
        id: "mouse-blocker2"
    }, null, -1),
    ML = {
        class: "center-panel"
    },
    RL = b("div", {
        class: "center-panel-bg"
    }, [b("div", {
        class: "center-panel-rect"
    }), b("div", {
        class: "center-panel-tra1"
    }), b("div", {
        class: "center-panel-tra2"
    })], -1),
    kL = b("div", {
        class: "center-panel-pup-bg"
    }, null, -1),
    PL = b("svg", {
        class: "center-panel-pup-icon",
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "23",
        height: "23",
        fill: "var(--main-theme-color)"
    }, [b("path", {
        d: "M512.00988746 141.21142578c10.45623779 0 19.24145531 3.50024414 26.37542748 10.71331811l259.5421145 259.55200196C805.03668189 418.58105492 808.63085938 427.33660865 808.63085938 437.84228516c0 10.60949731-3.53485132 19.46887183-10.56994606 26.46936011-7.02026391 7.00543237-15.88952661 10.60949731-26.50891137 10.60949731-10.44140625 0-19.22167969-3.60900903-26.35565185-10.71331811L549.09863305 267.79370094V845.7097168c0 10.19915748-3.62384057 18.94976782-10.89624071 26.16284179-7.23284888 7.31195068-15.97357177 10.91601563-26.2122798 10.91601563-10.23376465 0-18.959656-3.60900903-26.22216796-10.91601563-7.24273705-7.21307397-10.87646508-15.96862769-10.87646508-26.16284179V267.79370094l-196.10760522 196.41906761C271.65484619 471.31213355 262.87951684 474.92114258 252.41833496 474.92114258c-10.61938477 0-19.45898438-3.60900903-26.4990232-10.60949731C218.86444068 457.31115699 215.36914062 448.45178247 215.36914062 437.84228516c0-10.50567651 3.55462623-19.26123023 10.69354248-26.36553931l259.53717042-259.55200196C492.7288816 144.71166992 501.52398658 141.21142578 511.97033691 141.21142578h0.03955055z"
    })], -1),
    LL = [kL, PL],
    OL = b("div", {
        class: "center-panel-pdown-bg"
    }, null, -1),
    DL = b("svg", {
        class: "center-panel-pdown-icon",
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "23",
        height: "23",
        fill: "var(--main-theme-color)"
    }, [b("path", {
        d: "M511.99011254 141.21142578c10.23376465 0 18.95471191 3.60900903 26.2122798 10.81713891 7.25262451 7.20812988 10.86657691 15.96862769 10.86657763 26.2666626v577.89129615l196.1619873-196.43884254c7.099365-7.00543237 15.90435815-10.61444068 26.34082031-10.61444139 10.61938477 0 19.43426538 3.50518822 26.51385474 10.51062059 7.04498291 7.10430908 10.54522705 15.96862769 10.54522706 26.57318092 0 10.40679908-3.54473877 19.16235352-10.69354248 26.37542748l-259.55694604 259.48278761C531.23156714 879.28833008 522.44635033 882.78857422 512.00988746 882.78857422c-10.45623779 0-19.24145531-3.50024414-26.3704834-10.71331811l-259.55200195-259.48278761C218.94848656 605.37939453 215.36914062 596.62384009 215.36914062 586.21704102c0-10.60949731 3.52496314-19.46887183 10.56994606-26.57318092C232.99395776 552.63842773 241.82861328 549.12829614 252.44799805 549.12829614c10.42163062 0 19.2167356 3.60900903 26.36553931 10.61444068l196.1125493 196.43884253V178.29522729c0-10.30297828 3.60900903-19.05853271 10.88635255-26.2666626C493.05517555 144.81549073 501.80084252 141.21142578 512.02966309 141.21142578h-0.03955055z"
    })], -1),
    NL = [OL, DL],
    FL = {
        id: "profile-list-container"
    },
    BL = ["onClick"],
    UL = b("div", {
        class: "profile-skin-base"
    }, null, -1),
    GL = {
        class: "profile-nick"
    },
    HL = {
        id: "profile-editor"
    },
    VL = b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "20",
        height: "20",
        fill: "var(--main-theme-color)",
        transform: "translate(3.5,0.5)"
    }, [b("path", {
        d: "M227.2 709.7l42.5-42.5c-11.1-8.7-21.9-17.8-32.5-27.1-50-44.5-87.5-89.3-105.9-113.1 18.5-23.8 55.8-68.6 105.9-113.1 64.9-57.6 165.2-126.2 274.7-126.2 39.5 0 77.7 8.9 113.5 23L671 265c-53.8-24.7-107.3-37-159.2-37-57.3 0-116.6 15.2-176.1 45.3-46.6 23.4-93.4 56-139.3 96.8C119.3 438.9 71.6 507 69.5 509.8c-7.1 10.3-7.1 24 0 34.2 2 2.8 49.6 71 127.1 139.8 10 8.8 20.2 17.5 30.6 25.9z m600-339.7c-18.2-16.2-37.2-31.6-56.8-46l97.1-97.2c12.4-12.5 12.4-32.6 0-45.1l2.7 2.7c-6-6-14-9.3-22.5-9.3-8.4 0-16.5 3.3-22.4 9.3L213.7 797.2c-12.4 12.5-12.4 32.6 0 45.1l-2.7-2.7c6 6 14.1 9.3 22.5 9.3s16.5-3.5 22.5-9.4l66-66.1c4.7 2.5 9.3 5 14 7.3 59.5 30 118.8 45.3 176.1 45.3s116.6-15.2 176.1-45.3c46.6-23.4 93.4-56 139.2-96.8 77.3-68.9 125-137 127.1-139.9 7.1-10.3 7.1-24 0-34.2-2.3-2.8-50-70.9-127.3-139.8z m-181 156.9c0 74.2-60.3 134.6-134.3 134.6-22.6 0-44.1-5.7-62.7-15.6L630.7 464c10.2 19.4 15.5 40.9 15.5 62.9z m140.4 113c-64.9 57.6-165.2 126.2-274.7 126.2-51.5 0-100.9-15.2-145.7-37.3l39.4-39.4c31.6 20.8 68.5 31.9 106.3 31.9 107 0 194-87.2 194-194.4 0-39.3-11.7-75.8-31.8-106.5l53.4-53.5c20.5 14.5 40.2 30.1 59.1 46.9 50 44.4 87.5 89.3 105.9 113.1-18.4 23.7-55.9 68.7-105.9 113zM511.9 392.4c9.9 0 19.6 1.1 28.9 3.1l47.3-47.3c-24.1-10.4-49.9-15.6-76.1-15.6-107 0-194 87.2-194 194.4 0 27.1 5.6 52.9 15.6 76.2l47.3-47.3c-2.1-9.5-3.1-19.2-3.1-28.9-0.2-74.3 60-134.6 134.1-134.6z"
    })], -1),
    zL = [VL],
    $L = ["placeholder", "disabled"],
    jL = {
        id: "world-panel"
    },
    WL = b("div", {
        id: "world-panel-bg"
    }, [b("div", {
        id: "world-panel-rect"
    }), b("div", {
        id: "world-panel-tra"
    }), b("div", {
        id: "world-panel-po"
    })], -1),
    XL = b("div", {
        id: "menu-play-bg"
    }, null, -1),
    YL = {
        class: "menu-big-text"
    },
    KL = b("div", {
        id: "menu-setting-bg"
    }, null, -1),
    ZL = b("svg", {
        id: "setting-icon",
        width: "24",
        height: "24",
        viewBox: "0 0 16 16",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "var(--main-theme-color)"
    }, [b("path", {
        "fill-rule": "evenodd",
        d: "M8.837 1.626c-.246-.835-1.428-.835-1.674 0l-.094.319A1.873 1.873 0 0 1 4.377 3.06l-.292-.16c-.764-.415-1.6.42-1.184 1.185l.159.292a1.873 1.873 0 0 1-1.115 2.692l-.319.094c-.835.246-.835 1.428 0 1.674l.319.094a1.873 1.873 0 0 1 1.115 2.693l-.16.291c-.415.764.42 1.6 1.185 1.184l.292-.159a1.873 1.873 0 0 1 2.692 1.116l.094.318c.246.835 1.428.835 1.674 0l.094-.319a1.873 1.873 0 0 1 2.693-1.115l.291.16c.764.415 1.6-.42 1.184-1.185l-.159-.291a1.873 1.873 0 0 1 1.116-2.693l.318-.094c.835-.246.835-1.428 0-1.674l-.319-.094a1.873 1.873 0 0 1-1.115-2.692l.16-.292c.415-.764-.42-1.6-1.185-1.184l-.291.159A1.873 1.873 0 0 1 8.93 1.945l-.094-.319zm-2.633-.283c.527-1.79 3.065-1.79 3.592 0l.094.319a.873.873 0 0 0 1.255.52l.292-.16c1.64-.892 3.434.901 2.54 2.541l-.159.292a.873.873 0 0 0 .52 1.255l.319.094c1.79.527 1.79 3.065 0 3.592l-.319.094a.873.873 0 0 0-.52 1.255l.16.292c.893 1.64-.902 3.434-2.541 2.54l-.292-.159a.873.873 0 0 0-1.255.52l-.094.319c-.527 1.79-3.065 1.79-3.592 0l-.094-.319a.873.873 0 0 0-1.255-.52l-.292.16c-1.64.893-3.433-.902-2.54-2.541l.159-.292a.873.873 0 0 0-.52-1.255l-.319-.094c-1.79-.527-1.79-3.065 0-3.592l.319-.094a.873.873 0 0 0 .52-1.255l-.16-.292c-.892-1.64.902-3.433 2.541-2.54l.292.159a.873.873 0 0 0 1.255-.52l.094-.319z"
    }), b("path", {
        "fill-rule": "evenodd",
        d: "M8 5.754a2.246 2.246 0 1 0 0 4.492 2.246 2.246 0 0 0 0-4.492zM4.754 8a3.246 3.246 0 1 1 6.492 0 3.246 3.246 0 0 1-6.492 0z"
    })], -1),
    qL = [KL, ZL],
    JL = b("div", {
        id: "menu-spec-bg"
    }, null, -1),
    QL = {
        class: "menu-big-text"
    };

function tO(e, t, i, s, n, r) {
    const o = se("multibox-avatar"),
        a = se("list"),
        l = se("common-select");
    return ee((st(), nt("div", gL, [b("div", vL, [_L, b("div", {
        id: "profile-list-btn",
        onClick: t[0] || (t[0] = c => s.switchPanel(2))
    }, bL), xL, b("div", {
        id: "mac-btn-border2",
        onClick: t[1] || (t[1] = c => s.multiboxChange(-1))
    }), wL, b("div", {
        id: "multibox-add-btn",
        onClick: t[2] || (t[2] = c => s.multiboxChange(1))
    }, CL), AL, IL, X(o, {
        id: "avatar",
        ref: "avatar",
        onChange: s.avatarChange
    }, null, 8, ["onChange"])]), b("div", ML, [RL, b("div", {
        class: "center-panel-pup",
        onClick: t[3] || (t[3] = (...c) => s.pageUp && s.pageUp(...c))
    }, LL), b("div", {
        class: "center-panel-pdown",
        onClick: t[4] || (t[4] = (...c) => s.pageDown && s.pageDown(...c))
    }, NL), ee(b("div", FL, [(st(!0), nt(Dt, null, Jt(s.profileData.slice(0 + s.baseProfileListIndex, 10 + s.baseProfileListIndex), (c, h) => (st(), nt("div", {
        class: "profile-unit",
        key: h,
        onClick: u => s.turnTo(h + s.baseProfileListIndex)
    }, [UL, b("div", {
        class: "profile-skin",
        style: $t({
            "background-image": `url(${c[1][0][1]})`
        })
    }, null, 4), b("div", GL, [b("p", null, Ot(c[1][0][0] ? c[1][0][0] : " "), 1)])], 8, BL))), 128))], 512), [
        [ye, s.panelState == 2]
    ]), ee(b("div", HL, [ee(b("input", {
        id: "menu-tag",
        class: "rounded-0 form-control menu-input",
        type: "text",
        placeholder: "Tag",
        maxlength: "16",
        size: "16",
        "onUpdate:modelValue": t[5] || (t[5] = c => s.tag = c),
        onChange: t[6] || (t[6] = (...c) => s.setProfileData && s.setProfileData(...c))
    }, null, 544), [
        [nr, s.tag]
    ]), ee(b("input", {
        id: "menu-nick",
        class: "rounded-0 form-control menu-input",
        type: "text",
        placeholder: "Nick",
        maxlength: "16",
        size: "16",
        "onUpdate:modelValue": t[7] || (t[7] = c => s.nick = c),
        onChange: t[8] || (t[8] = (...c) => s.setProfileData && s.setProfileData(...c))
    }, null, 544), [
        [nr, s.nick]
    ]), b("div", {
        id: "code-blocker",
        onClick: t[9] || (t[9] = (...c) => s.hide && s.hide(...c))
    }, zL), ee(b("input", {
        id: "menu-code",
        class: "rounded-0 form-control menu-input",
        type: "text",
        placeholder: s.hideCode ? "" : "Code",
        maxlength: "16",
        size: "16",
        disabled: s.hideCode,
        "onUpdate:modelValue": t[10] || (t[10] = c => s.code = c),
        onChange: t[11] || (t[11] = (...c) => s.setProfileData && s.setProfileData(...c))
    }, null, 40, $L), [
        [nr, s.code]
    ]), ee(b("input", {
        id: "menu-skin",
        class: "rounded-0 form-control menu-input",
        type: "text",
        placeholder: "Skin URL",
        maxlength: "128",
        "onUpdate:modelValue": t[12] || (t[12] = c => s.skin = c),
        onChange: t[13] || (t[13] = (...c) => s.preLoadAvatar && s.preLoadAvatar(...c))
    }, null, 544), [
        [nr, s.skin]
    ])], 512), [
        [ye, s.panelState == 1]
    ])]), b("div", jL, [WL, X(a, {
        id: "select-gamemode",
        selected: s.roomIndex,
        options: s.roomOpt,
        onChange: s.changeRoom
    }, null, 8, ["selected", "options", "onChange"]), X(l, {
        id: "menu-servers",
        selected: s.serverIndex,
        options: s.serverOpt,
        onChange: s.changeServer
    }, null, 8, ["selected", "options", "onChange"])]), b("div", {
        id: "menu-play",
        onClick: t[14] || (t[14] = (...c) => s.play && s.play(...c))
    }, [XL, b("div", YL, Ot(s.t.play), 1)]), b("div", {
        id: "menu-setting",
        onClick: t[15] || (t[15] = (...c) => s.setting && s.setting(...c))
    }, qL), b("div", {
        id: "menu-spec",
        onClick: t[16] || (t[16] = (...c) => s.spectate && s.spectate(...c))
    }, [JL, b("div", QL, Ot(s.t.spectate), 1)])], 512)), [
        [ye, s.showMenu]
    ])
}
var eO = ue(mL, [
    ["render", tO]
]);
const iO = {
        content: [
            [
                ["\u961F\u6807", "\u9690\u85CF", "\u666E\u901A", "\u53CC\u884C"], "\u540D\u5B57", "\u8D28\u91CF", "\u76AE\u80A4", "\u98DF\u7269", ["\u523A\u7403\u98CE\u683C", "\u5C16\u9510", "\u5706\u5F62"], "\u5149\u6807\u7EBF", "\u654C\u6211\u533A\u5206", "\u8D28\u91CF\u6307\u793A", "\u5206\u88C2\u987A\u5E8F\u6307\u793A", "\u81EA\u52A8\u5206\u88C2\u63D0\u793A", ["\u5C04\u523A\u63D0\u793A", "\u5173\u95ED", "\u6570\u5B57", "\u586B\u5145"]
            ],
            [
                ["\u52A8\u753B\u5EF6\u8FDF", "50", "275", "1"],
                ["\u7F51\u7EDC\u5EF6\u8FDF", "0", "80", "1"],
                ["\u89C6\u91CE\u5EF6\u8FDF", "100", "800", "5"],
                ["\u7F29\u653E\u901F\u5EA6", "1.05", "1.40", "0.01"], "\u663E\u73B0", "\u6D88\u5931", "\u541E\u566C"
            ],
            [
                ["\u753B\u9762\u8D28\u91CF", "50", "800", "5"],
                ["\u5206\u8FA8\u7387", "0.75", "2", "0.05"], "\u6297\u952F\u9F7F", "\u7EB9\u7406\u6620\u5C04"
            ],
            [
                ["\u5FEB\u901F\u5F55\u5236\u65F6\u957F", "0", "60", "5"], "\u53CC\u5F00\u81EA\u52A8\u5207\u6362", "\u53CC\u5F00\u5207\u6362\u65F6\u4E2D\u65AD\u5410\u7403", "\u663E\u793A\u83DC\u5355\u65F6\u505C\u6B62\u79FB\u52A8", "\u6B7B\u4EA1\u663E\u793A\u83DC\u5355", "\u7A33\u5B9A\u89C2\u6218\u955C\u5934"
            ],
            ["\u5C0F\u5730\u56FE", "\u6392\u884C\u699C", "\u961F\u4F0D\u6392\u884C", "\u6027\u80FD\u72B6\u6001", "\u6E38\u620F\u72B6\u6001", "\u804A\u5929\u5BA4", "\u56DE\u653E\u9762\u677F", ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"],
                ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"],
                ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"],
                ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"],
                ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"], "\u81EA\u52A8\u9690\u85CF"
            ]
        ],
        display: {
            name: "\u663E\u793A",
            divide: {
                basic: "\u57FA\u7840",
                assistance: "\u8F85\u52A9",
                importance: "\u91CD\u8981",
                animation: "\u52A8\u753B"
            }
        },
        graphics: {
            name: "\u56FE\u50CF",
            divide: {
                basic: "\u57FA\u7840"
            }
        },
        HUD: {
            divide: {
                display: "\u663E\u793A",
                minimap: "\u5C0F\u5730\u56FE",
                leaderboard: "\u6392\u884C\u699C",
                teamRanking: "\u961F\u4F0D\u6392\u884C",
                performance: "\u6027\u80FD\u72B6\u6001",
                gamestatus: "\u6E38\u620F\u72B6\u6001",
                chatroom: "\u804A\u5929\u5BA4"
            }
        },
        gameplay: {
            name: "\u6E38\u620F",
            divide: {
                basic: "\u57FA\u790E",
                language: "\u8BED\u8A00"
            }
        }
    },
    sO = {
        content: [
            [
                ["\u968A\u6A19", "\u96B1\u85CF", "\u666E\u901A", "\u96D9\u884C"], "\u540D\u5B57", "\u8CEA\u91CF", "\u76AE\u819A", "\u98DF\u7269", ["\u523A\u7403\u98A8\u683C", "\u5C16\u92B3", "\u5713\u5F62"], "\u5149\u6A19\u7DDA", "\u6575\u6211\u5340\u5206", "\u8CEA\u91CF\u6307\u793A", "\u5206\u88C2\u9806\u5E8F\u6307\u793A", "\u81EA\u52D5\u5206\u88C2\u63D0\u793A", ["\u5C04\u523A\u63D0\u793A", "\u95DC\u9589", "\u6578\u5B57", "\u586B\u5145"]
            ],
            [
                ["\u52D5\u756B\u5EF6\u9072", "50", "275", "1"],
                ["\u7DB2\u7D61\u5EF6\u9072", "0", "80", "1"],
                ["\u8996\u91CE\u5EF6\u9072", "100", "800", "5"],
                ["\u7E2E\u653E\u901F\u5EA6", "1.05", "1.40", "0.01"], "\u986F\u73FE", "\u6D88\u5931", "\u541E\u566C"
            ],
            [
                ["\u756B\u9762\u8CEA\u91CF", "50", "800", "5"],
                ["\u89E3\u6790\u5EA6", "0.75", "2", "0.05"], "\u6297\u92F8\u9F52", "\u7D0B\u7406\u6620\u5C04"
            ],
            [
                ["\u5FEB\u901F\u9304\u88FD\u6642\u9577", "0", "60", "5"], "\u96D9\u958B\u81EA\u52D5\u5207\u63DB", "\u96D9\u958B\u5207\u63DB\u6642\u4E2D\u65B7\u5410\u7403", "\u986F\u793A\u9078\u55AE\u6642\u505C\u6B62\u79FB\u52D5", "\u6B7B\u4EA1\u986F\u793A\u9078\u55AE", "\u7A69\u5B9A\u89C0\u6230\u93E1\u982D"
            ],
            ["\u5C0F\u5730\u5716", "\u6392\u884C\u699C", "\u968A\u4F0D\u6392\u884C", "\u6027\u80FD\u72C0\u614B", "\u904A\u6232\u72C0\u614B", "\u804A\u5929\u5BA4", "\u56DE\u653E\u9762\u677F", ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"],
                ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"],
                ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"],
                ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"],
                ["\u5C3A\u5BF8", "0.75", "1.25", "0.05"], "\u81EA\u52D5\u96B1\u85CF"
            ]
        ],
        display: {
            name: "\u986F\u793A",
            divide: {
                basic: "\u57FA\u790E",
                assistance: "\u8F14\u52A9",
                importance: "\u91CD\u8981",
                animation: "\u52D5\u756B"
            }
        },
        graphics: {
            name: "\u5716\u50CF",
            divide: {
                basic: "\u57FA\u790E"
            }
        },
        HUD: {
            divide: {
                display: "\u986F\u793A",
                minimap: "\u5C0F\u5730\u5716",
                leaderboard: "\u6392\u884C\u699C",
                teamRanking: "\u968A\u4F0D\u6392\u884C",
                performance: "\u6027\u80FD\u72C0\u614B",
                gamestatus: "\u904A\u6232\u72C0\u614B",
                chatroom: "\u804A\u5929\u5BA4"
            }
        },
        gameplay: {
            name: "\u904A\u6232",
            divide: {
                basic: "\u57FA\u790E",
                language: "\u8A9E\u8A00"
            }
        }
    },
    nO = {
        content: [
            [
                ["\u30BF\u30B0", "\u96A0\u3059", "\u901A\u5E38", "\u4E8C\u884C"], "\u540D\u524D", "\u8CEA\u91CF", "\u30B9\u30AD\u30F3", "\u98DF\u7269", ["\u68D8\u306E\u69D8\u5F0F", "\u92ED\u3044", "\u5186\u5F62"], "\u30AB\u30FC\u30BD\u30EB\u7DDA", "\u6575\u5473\u65B9\u533A\u5225", "\u8CEA\u91CF\u30DE\u30FC\u30AB\u30FC", "\u5206\u88C2\u9806\u5E8F\u30DE\u30FC\u30AB\u30FC", "\u81EA\u7136\u5206\u88C2\u30A2\u30E9\u30FC\u30C8", ["\u68D8\u6253\u3061\u30D2\u30F3\u30C8", "\u7121\u3057", "\u6570", "\u6E80\u305F\u3059"]
            ],
            [
                ["\u88DC\u9593\u9045\u5EF6", "50", "275", "1"],
                ["\u8FFD\u52A0\u30EC\u30A4\u30C6\u30F3\u30B7", "0", "80", "1"],
                ["\u30AB\u30E1\u30E9\u9045\u5EF6", "100", "800", "5"],
                ["\u30BA\u30FC\u30E0\u901F\u5EA6", "1.05", "1.40", "0.01"], "\u51FA\u73FE", "\u6D88\u5931", "\u5438\u53CE"
            ],
            [
                ["\u753B\u8CEA", "50", "800", "5"],
                ["\u89E3\u50CF\u5EA6", "0.75", "2", "0.05"], "\u30A2\u30F3\u30C1\u30A8\u30A4\u30EA\u30A2\u30B9", "\u30DF\u30C3\u30D7\u30DE\u30C3\u30D7"
            ],
            [
                ["\u30AD\u30E3\u30D7\u30C1\u30E3\u6642\u9593", "0", "60", "5"], "\u30BF\u30D6\u81EA\u52D5\u5207\u66FF", "\u30BF\u30D6\u5207\u66FF\u5F8C\u990C\u767A\u5C04\u505C\u6B62", "\u30E1\u30CB\u30E5\u30FC\u8868\u793A\u5F8C\u505C\u6B62", "\u6B7B\u4EA1\u5F8C\u30E1\u30CB\u30E5\u30FC\u8868\u793A", "\u5B89\u5B9A\u5316\u89B3\u6226\u30AB\u30E1\u30E9"
            ],
            ["\u30DF\u30CB\u30DE\u30C3\u30D7", "\u30EA\u30FC\u30C0\u30FC\u30DC\u30FC\u30C9", "\u30C1\u30FC\u30E0\u30E9\u30F3\u30AD\u30F3\u30B0", "\u6027\u80FD\u72B6\u614B", "\u30B2\u30FC\u30E0\u72B6\u614B", "\u30C1\u30E3\u30C3\u30C8\u30EB\u30FC\u30E0", "\u30EA\u30D7\u30EC\u30A4\u30D0\u30FC", ["\u30B5\u30A4\u30BA", "0.75", "1.25", "0.05"],
                ["\u30B5\u30A4\u30BA", "0.75", "1.25", "0.05"],
                ["\u30B5\u30A4\u30BA", "0.75", "1.25", "0.05"],
                ["\u30B5\u30A4\u30BA", "0.75", "1.25", "0.05"],
                ["\u30B5\u30A4\u30BA", "0.75", "1.25", "0.05"], "\u81EA\u52D5\u3067\u96A0\u3059"
            ]
        ],
        display: {
            name: "\u8868\u793A",
            divide: {
                basic: "\u57FA\u672C",
                assistance: "\u30A2\u30B7\u30B9\u30BF\u30F3\u30B9",
                importance: "\u91CD\u8981",
                animation: "\u30A2\u30CB\u30E1\u30FC\u30B7\u30E7\u30F3"
            }
        },
        graphics: {
            name: "\u30B0\u30E9\u30D5\u30A3\u30C3\u30AF",
            divide: {
                basic: "\u57FA\u672C"
            }
        },
        HUD: {
            divide: {
                display: "\u8868\u793A",
                minimap: "\u30DF\u30CB\u30DE\u30C3\u30D7",
                leaderboard: "\u30EA\u30FC\u30C0\u30FC\u30DC\u30FC\u30C9",
                teamRanking: "\u30C1\u30FC\u30E0\u30E9\u30F3\u30AD\u30F3\u30B0",
                performance: "\u30D1\u30D5\u30A9\u30FC\u30DE\u30F3\u30B9\u72B6\u614B",
                gamestatus: "\u30B2\u30FC\u30E0\u72B6\u614B",
                chatroom: "\u30C1\u30E3\u30C3\u30C8\u30EB\u30FC\u30E0"
            }
        },
        gameplay: {
            name: "\u30B2\u30FC\u30E0",
            divide: {
                basic: "\u57FA\u672C",
                language: "\u8A00\u8A9E"
            }
        }
    },
    rO = {
        content: [
            [
                ["Tag", "Hide", "Normal", "Parallel"], "Nick", "Mass", "Skin", "Food", ["Virus Style", "Sharp", "Round"], "Cursor Line", "Enemy Hint", "Mass Marker", "Split Order Marker", "Autosplit Alert", ["Shooting Hint", "Off", "Num", "Fill"]
            ],
            [
                ["Animation Delay", "50", "275", "1"],
                ["Extra Latency", "0", "80", "1"],
                ["Camera Delay", "100", "800", "5"],
                ["Zoom Speed", "1.05", "1.40", "0.01"], "Appearance Animation", "Disappearance Animation", "Absorption Animation"
            ],
            [
                ["Quality", "50", "800", "5"],
                ["Resolution", "0.75", "2", "0.05"], "Antialias", "Mipmap"
            ],
            [
                ["Capture Time", "0", "60", "5"], "Auto Switch Tab", "Stop Feeding After Switching Tab", "Pause After Opening Menu", "Show Menu After Death", "Stable Spectating Camera"
            ],
            ["Minimap", "Leaderboard", "Team Rankings", "Performance Status", "Game Status", "Chat Room", "Replay Bar", ["Size", "0.75", "1.25", "0.05"],
                ["Size", "0.75", "1.25", "0.05"],
                ["Size", "0.75", "1.25", "0.05"],
                ["Size", "0.75", "1.25", "0.05"],
                ["Size", "0.75", "1.25", "0.05"], "Auto Hide"
            ]
        ],
        display: {
            name: "DISPLAY",
            divide: {
                basic: "BASIC",
                assistance: "ASSISTANCE",
                importance: "IMPORTANCE",
                animation: "ANIMATION"
            }
        },
        graphics: {
            name: "GRAPHICS",
            divide: {
                basic: "BASIC"
            }
        },
        HUD: {
            divide: {
                display: "DISPLAY",
                minimap: "MINIMAP",
                leaderboard: "LEADERBOARD",
                teamRanking: "TEAM RANKING",
                performance: "PERFORMANCE STATUS",
                gamestatus: "GAME STATUS",
                chatroom: "CHAT ROOM"
            }
        },
        gameplay: {
            name: "GAMEPLAY",
            divide: {
                basic: "BASIC",
                mouse: "MOUSE",
                language: "LANGUAGE"
            }
        }
    };
var oO = {
    zh_CN: iO,
    zh: sO,
    ja: nO,
    en: rO
};
const aO = {
        name: "common-select",
        props: {
            class: String,
            selected: {
                type: Number,
                default: 0
            },
            options: {
                type: Array,
                default: []
            }
        },
        setup(e, {
            emit: t
        }) {
            const i = ft(null),
                s = Ft(() => -1 + e.selected * -37.9625 + "px");

            function n() {
                i.value.classList.contains("open") || i.value.classList.add("open")
            }

            function r() {
                i.value.classList.remove("open")
            }

            function o(a) {
                a !== e.selected && (t("change", a), setTimeout(() => i.value.classList.remove("open"), 350))
            }
            return Ve(() => i.value.classList.add(e.class)), {
                t: s,
                menu: i,
                open: n,
                close: r,
                change: o
            }
        }
    },
    lO = e => (gs("data-v-1bcab658"), e = e(), vs(), e),
    cO = {
        "data-menu": ""
    },
    hO = ["value", "selected"],
    uO = {
        class: "select-button"
    },
    dO = lO(() => b("em", null, null, -1)),
    fO = ["onClick"];

function pO(e, t, i, s, n, r) {
    return st(), nt("div", {
        class: "select-menu rounded-0",
        ref: "menu",
        tabindex: "-1",
        style: $t({
            "--t": s.t
        }),
        onClick: t[0] || (t[0] = (...o) => s.open && s.open(...o)),
        onBlur: t[1] || (t[1] = (...o) => s.close && s.close(...o))
    }, [b("select", cO, [(st(!0), nt(Dt, null, Jt(i.options, (o, a) => (st(), nt("option", {
        key: a,
        value: a,
        selected: i.selected === a
    }, Ot(o), 9, hO))), 128))]), b("div", uO, [dO, b("ul", null, [(st(!0), nt(Dt, null, Jt(i.options, (o, a) => (st(), nt("li", {
        key: a
    }, Ot(o), 1))), 128))])]), b("ul", null, [(st(!0), nt(Dt, null, Jt(i.options, (o, a) => (st(), nt("li", {
        key: a,
        onClick: l => s.change(a)
    }, Ot(o), 9, fO))), 128))])], 36)
}
var pp = ue(aO, [
    ["render", pO],
    ["__scopeId", "data-v-1bcab658"]
]);
const mO = {
        back: "\u8FD4\u56DE"
    },
    gO = {
        back: "\u8FD4\u56DE"
    },
    vO = {
        back: "\u623B\u308B"
    },
    _O = {
        back: "BACK"
    };
var yO = {
    zh_CN: mO,
    zh: gO,
    ja: vO,
    en: _O
};
const bO = {
        name: "sub-nav",
        props: {
            tabs: Array
        },
        setup(e, {
            emit: t
        }) {
            const i = Ft(() => yO[yi("locale").value]);

            function s() {
                A.emit("switchSettings")
            }

            function n(r, o) {
                r.forEach(a => {
                    document.getElementById(a.href).classList.remove("show", "active")
                }), document.getElementById(r[o].href).classList.add("show", "active"), r[o].func && r[o].func()
            }
            return {
                t: i,
                back: s,
                click: n
            }
        }
    },
    xO = {
        class: "nav nav-tabs container-nav"
    },
    wO = ["onClick"];

function TO(e, t, i, s, n, r) {
    return st(), nt("nav", xO, [(st(!0), nt(Dt, null, Jt(i.tabs, (o, a) => (st(), nt("a", {
        class: Ai(["nav-item nav-link", i.tabs[a].active ? "active" : ""]),
        "data-bs-toggle": "tab",
        key: a,
        onClick: l => s.click(i.tabs, a)
    }, Ot(i.tabs[a].text), 11, wO))), 128)), b("a", {
        class: "nav-link nav-back",
        onClick: t[0] || (t[0] = (...o) => s.back && s.back(...o))
    }, Ot(s.t.back), 1)])
}
var mp = ue(bO, [
    ["render", TO],
    ["__scopeId", "data-v-2aadac40"]
]);
const EO = {
        reset: "\u91CD\u7F6E",
        save: "\u4FDD\u5B58"
    },
    SO = {
        reset: "\u91CD\u7F6E",
        save: "\u4FDD\u5B58"
    },
    CO = {
        reset: "\u30EA\u30BB\u30C3\u30C8",
        save: "\u30BB\u30FC\u30D6"
    },
    AO = {
        reset: "RESET",
        save: "SAVE"
    };
var IO = {
    zh_CN: EO,
    zh: SO,
    ja: CO,
    en: AO
};
const MO = {
        name: "button-group",
        props: {
            reset: {
                type: Boolean,
                default: !1
            },
            save: {
                type: Boolean,
                default: !1
            }
        },
        setup(e, {
            emit: t
        }) {
            const i = Ft(() => IO[yi("locale").value]);

            function s() {
                t("onReset")
            }

            function n() {
                t("onSave")
            }
            return {
                t: i,
                resetFuc: s,
                saveFuc: n
            }
        }
    },
    RO = {
        class: "fixed-bottom btngroup"
    };

function kO(e, t, i, s, n, r) {
    return st(), nt("div", RO, [ee(b("button", {
        class: "btn btn-dark",
        onClick: t[0] || (t[0] = (...o) => s.resetFuc && s.resetFuc(...o))
    }, Ot(s.t.reset), 513), [
        [ye, i.reset]
    ]), ee(b("button", {
        class: "btn btn-dark",
        onClick: t[1] || (t[1] = (...o) => s.saveFuc && s.saveFuc(...o))
    }, Ot(s.t.save), 513), [
        [ye, i.save]
    ])])
}
var gp = ue(MO, [
    ["render", kO],
    ["__scopeId", "data-v-4b2abf57"]
]);
const PO = {
        name: "deviding-line",
        props: {
            name: {
                type: String,
                default: " "
            }
        },
        setup(e) {
            const t = Ft(() => {
                    const s = encodeURIComponent(e.name).match(/%[89ABab]/g);
                    return (e.name.length + (s ? s.length : 0)) * 2.8 + 8
                }),
                i = Ft(() => (100 - t.value) / 2);
            return {
                spanLen: t,
                hrLen: i
            }
        }
    },
    LO = {
        class: "divide"
    };

function OO(e, t, i, s, n, r) {
    return st(), nt("div", LO, [b("hr", {
        style: $t({
            flex: s.hrLen
        })
    }, null, 4), b("span", {
        style: $t({
            flex: s.spanLen
        })
    }, Ot(i.name), 5), b("hr", {
        style: $t({
            flex: s.hrLen
        })
    }, null, 4)])
}
var vp = ue(PO, [
    ["render", OO],
    ["__scopeId", "data-v-020771af"]
]);
const DO = {
        name: "setting-switch",
        props: {
            name: String,
            val: Number
        },
        setup(e, {
            emit: t
        }) {
            const i = ft(null);

            function s() {
                t("changeVal", i.value.checked ? 1 : 0)
            }
            return {
                switchEl: i,
                change: s
            }
        }
    },
    NO = e => (gs("data-v-5886baf5"), e = e(), vs(), e),
    FO = {
        class: "switch-row"
    },
    BO = {
        class: "switch-option"
    },
    UO = {
        class: "switch-box"
    },
    GO = {
        class: "switch-label"
    },
    HO = ["checked"],
    VO = NO(() => b("span", {
        class: "switch-slider"
    }, null, -1));

function zO(e, t, i, s, n, r) {
    return st(), nt("div", FO, [b("div", BO, [b("span", null, Ot(i.name), 1)]), b("div", UO, [b("label", GO, [b("input", {
        type: "checkbox",
        ref: "switchEl",
        checked: i.val,
        onChange: t[0] || (t[0] = (...o) => s.change && s.change(...o))
    }, null, 40, HO), VO])])])
}
var Ly = ue(DO, [
    ["render", zO],
    ["__scopeId", "data-v-5886baf5"]
]);
const $O = {
        name: "setting-radio",
        props: {
            id: String,
            name: String,
            checked: Number,
            options: Array
        },
        setup(e, {
            emit: t
        }) {
            function i(s) {
                t("changeVal", Number(s.target.value))
            }
            return {
                change: i
            }
        }
    },
    jO = {
        class: "radio-row"
    },
    WO = {
        class: "radio-name"
    },
    XO = ["id", "value", "checked"],
    YO = ["for"];

function KO(e, t, i, s, n, r) {
    return st(), nt("div", jO, [b("div", WO, Ot(i.name), 1), (st(!0), nt(Dt, null, Jt(i.options, (o, a) => (st(), nt("div", {
        class: "radio-btn",
        key: a
    }, [b("input", {
        type: "radio",
        id: `radio-${i.id}-${a}`,
        value: a,
        checked: i.checked === a,
        onChange: t[0] || (t[0] = (...l) => s.change && s.change(...l))
    }, null, 40, XO), b("label", {
        for: `radio-${i.id}-${a}`
    }, Ot(o), 9, YO)]))), 128))])
}
var ZO = ue($O, [
    ["render", KO],
    ["__scopeId", "data-v-90b973d0"]
]);
const qO = {
        props: {
            name: String,
            min: String,
            max: String,
            step: String,
            val: Number
        },
        setup(e, {
            emit: t
        }) {
            const i = ft(null),
                s = ft(null),
                n = ft(null);

            function r(l) {
                const h = `${(l-e.min)/(e.max-e.min)*90}%`;
                i.value.style.width = h
            }

            function o() {
                let l = Number(n.value.value);
                /^[0-9]\d*$/.test(l) ? (l = l < e.min ? e.min : l > e.max ? e.max : l, a(l)) : n.value.value = s.value.value
            }

            function a(l) {
                t("changeVal", Number(l))
            }
            return Aa(() => e.val, (l, c) => r(l)), Ve(() => {
                r(e.val)
            }), Pr(() => {
                r(e.val)
            }), {
                selection: i,
                slider: s,
                valEl: n,
                checkStyle: r,
                checkVal: o,
                change: a
            }
        }
    },
    JO = {
        class: "slider-row"
    },
    QO = {
        class: "slider-name"
    },
    tD = {
        class: "slider-input"
    },
    eD = ["value"],
    iD = {
        class: "slider-box"
    },
    sD = {
        ref: "selection",
        class: "slider-selection"
    },
    nD = {
        class: "slider-track"
    },
    rD = ["min", "max", "step", "value"];

function oD(e, t, i, s, n, r) {
    return st(), nt("div", JO, [b("label", QO, Ot(i.name), 1), b("div", tD, [b("input", {
        ref: "valEl",
        type: "text",
        class: "rounded-0 form-control",
        tabindex: "-1",
        value: i.val,
        onBlur: t[0] || (t[0] = (...o) => s.checkVal && s.checkVal(...o))
    }, null, 40, eD)]), b("div", iD, [b("div", sD, null, 512), b("div", nD, [b("input", {
        ref: "slider",
        class: "slider",
        type: "range",
        min: i.min,
        max: i.max,
        step: i.step,
        value: i.val,
        onInput: t[1] || (t[1] = o => s.change(o.target.value))
    }, null, 40, rD)])])])
}
var Oy = ue(qO, [
    ["render", oD],
    ["__scopeId", "data-v-be681c4e"]
]);
const aD = {
        name: "gamesetting-pane",
        components: {
            "common-select": pp,
            "sub-nav": mp,
            "btn-group": gp,
            "dividing-line": vp,
            "setting-switch": Ly,
            "setting-radio": ZO,
            "setting-slider": Oy
        },
        setup() {
            const e = ft(Vs),
                t = yi("locale"),
                i = ["\u7B80\u4F53\u4E2D\u6587", "\u7E41\u9AD4\u4E2D\u6587", "\u65E5\u672C\u8A9E", "English"],
                s = Ft(() => oO[t.value]),
                n = Ft(() => [{
                    href: "gamesetting-display-tab",
                    text: s.value.display.name,
                    active: !0
                }, {
                    href: "gamesetting-graphics-tab",
                    text: s.value.graphics.name
                }, {
                    href: "gamesetting-gameplay-tab",
                    text: s.value.gameplay.name
                }, {
                    href: "gamesetting-hud-tab",
                    text: "HUD"
                }]),
                r = new Map;
            let o = 0,
                a = 0;
            const l = s.value.content;
            Object.keys(Md).forEach(f => {
                const p = l[o];
                if (!(o >= l.length)) {
                    if (a < p.length) r.set(o + "-" + a, f);
                    else {
                        if (o++, a = 0, o >= l.length) return;
                        r.set(o + "-" + a, f)
                    }
                    a++
                }
            });
            const c = (f, p) => H[r.get(f + "-" + p)];

            function h(f) {
                t.value = Pc[f], e.value = f, localStorage.setItem("locale", f)
            }

            function u(f, p, m) {
                const g = r.get(f + "-" + p);
                H[g] = m, A.emit(Ut[g]), localStorage.setItem("gconfig", JSON.stringify(H))
            }

            function d(f) {
                for (let p = 0; p < l[f].length; p++) {
                    const m = r.get(f + "-" + p);
                    H[m] = Md[m], A.emit(Ut[m])
                }
                localStorage.setItem("gconfig", JSON.stringify(H))
            }
            return {
                tabs: n,
                localeIndex: e,
                localeOpt: i,
                t: s,
                localeChange: h,
                value: c,
                change: u,
                reset: d
            }
        }
    },
    Dy = e => (gs("data-v-c48775c0"), e = e(), vs(), e),
    lD = {
        class: "tab-pane active",
        id: "setting-gamesetting"
    },
    cD = {
        class: "tab-content"
    },
    hD = {
        class: "tab-pane active",
        id: "gamesetting-display-tab"
    },
    uD = {
        class: "container-inline"
    },
    dD = {
        class: "container-col"
    },
    fD = {
        class: "container-col"
    },
    pD = {
        class: "tab-pane",
        id: "gamesetting-graphics-tab"
    },
    mD = {
        class: "container-inline"
    },
    gD = {
        class: "container-col"
    },
    vD = Dy(() => b("div", {
        class: "container-col"
    }, null, -1)),
    _D = {
        class: "tab-pane",
        id: "gamesetting-gameplay-tab"
    },
    yD = {
        class: "container-inline"
    },
    bD = {
        class: "container-col"
    },
    xD = {
        class: "container-col"
    },
    wD = {
        class: "tab-pane",
        id: "gamesetting-hud-tab"
    },
    TD = {
        class: "container-inline"
    },
    ED = {
        class: "container-col"
    },
    SD = {
        class: "container-col"
    },
    CD = Dy(() => b("div", {
        class: "filler"
    }, null, -1));

function AD(e, t, i, s, n, r) {
    const o = se("sub-nav"),
        a = se("dividing-line"),
        l = se("setting-radio"),
        c = se("btn-group"),
        h = se("setting-slider"),
        u = se("setting-switch"),
        d = se("common-select");
    return st(), nt("div", lD, [X(o, {
        tabs: s.tabs
    }, null, 8, ["tabs"]), b("div", cD, [b("div", hD, [b("div", uD, [b("div", dD, [X(a, {
        name: s.t.display.divide.basic
    }, null, 8, ["name"]), X(l, {
        id: "tag-style",
        name: s.t.content[0][0][0],
        checked: s.value(0, 0),
        options: [s.t.content[0][0][1], s.t.content[0][0][2], s.t.content[0][0][3]],
        onChangeVal: t[0] || (t[0] = f => s.change(0, 0, f))
    }, null, 8, ["name", "checked", "options"]), (st(), nt(Dt, null, Jt(4, (f, p) => X(De("setting-switch"), {
        key: p,
        name: s.t.content[0][p + 1],
        val: s.value(0, p + 1),
        onChangeVal: m => s.change(0, p + 1, m)
    }, null, 8, ["name", "val", "onChangeVal"])), 64)), X(l, {
        id: "virus-style",
        name: s.t.content[0][5][0],
        checked: s.value(0, 5),
        options: [s.t.content[0][5][1], s.t.content[0][5][2]],
        onChangeVal: t[1] || (t[1] = f => s.change(0, 5, f))
    }, null, 8, ["name", "checked", "options"]), X(a, {
        name: s.t.display.divide.assistance
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(5, (f, p) => X(De("setting-switch"), {
        key: p + 6,
        name: s.t.content[0][p + 6],
        val: s.value(0, p + 6),
        onChangeVal: m => s.change(0, p + 6, m)
    }, null, 8, ["name", "val", "onChangeVal"])), 64)), X(l, {
        id: "shoot-hint",
        name: s.t.content[0][11][0],
        checked: s.value(0, 11),
        options: [s.t.content[0][11][1], s.t.content[0][11][2], s.t.content[0][11][3]],
        onChangeVal: t[2] || (t[2] = f => s.change(0, 11, f))
    }, null, 8, ["name", "checked", "options"])]), b("div", fD, [X(a, {
        name: s.t.display.divide.importance
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(4, (f, p) => X(De("setting-slider"), {
        key: p,
        name: s.t.content[1][p][0],
        min: s.t.content[1][p][1],
        max: s.t.content[1][p][2],
        step: s.t.content[1][p][3],
        val: s.value(1, p),
        onChangeVal: m => s.change(1, p, m)
    }, null, 8, ["name", "min", "max", "step", "val", "onChangeVal"])), 64)), X(a, {
        name: s.t.display.divide.animation
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(3, (f, p) => X(De("setting-switch"), {
        key: p + 4,
        name: s.t.content[1][p + 4],
        val: s.value(1, p + 4),
        onChangeVal: m => s.change(1, p + 4, m)
    }, null, 8, ["name", "val", "onChangeVal"])), 64))])]), X(c, {
        reset: !0,
        onOnReset: t[3] || (t[3] = f => (s.reset(0), s.reset(1)))
    })]), b("div", pD, [b("div", mD, [b("div", gD, [X(a, {
        name: s.t.graphics.divide.basic
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[2][0][0],
        min: s.t.content[2][0][1],
        max: s.t.content[2][0][2],
        step: s.t.content[2][0][3],
        val: s.value(2, 0),
        onChangeVal: t[4] || (t[4] = f => s.change(2, 0, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), X(h, {
        name: s.t.content[2][1][0],
        min: s.t.content[2][1][1],
        max: s.t.content[2][1][2],
        step: s.t.content[2][1][3],
        val: s.value(2, 1),
        onChangeVal: t[5] || (t[5] = f => s.change(2, 1, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), (st(), nt(Dt, null, Jt(2, (f, p) => X(De("setting-switch"), {
        key: p + 4,
        name: s.t.content[2][p + 2],
        val: s.value(2, p + 2),
        onChangeVal: m => s.change(2, p + 2, m)
    }, null, 8, ["name", "val", "onChangeVal"])), 64))]), vD]), X(c, {
        reset: !0,
        onOnReset: t[6] || (t[6] = f => s.reset(2))
    })]), b("div", _D, [b("div", yD, [b("div", bD, [X(a, {
        name: s.t.gameplay.divide.basic
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[3][0][0],
        min: s.t.content[3][0][1],
        max: s.t.content[3][0][2],
        step: s.t.content[3][0][3],
        val: s.value(3, 0),
        onChangeVal: t[7] || (t[7] = f => s.change(3, 0, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), (st(), nt(Dt, null, Jt(5, (f, p) => X(u, {
        is: "setting-switch",
        key: p,
        name: s.t.content[3][p + 1],
        val: s.value(3, p + 1),
        onChangeVal: m => s.change(3, p + 1, m)
    }, null, 8, ["name", "val", "onChangeVal"])), 64))]), b("div", xD, [X(a, {
        name: s.t.gameplay.divide.language
    }, null, 8, ["name"]), X(d, {
        class: Ai("select-lang"),
        selected: s.localeIndex,
        options: s.localeOpt,
        onChange: s.localeChange
    }, null, 8, ["selected", "options", "onChange"])])]), X(c, {
        reset: !0,
        onOnReset: t[8] || (t[8] = f => s.reset(3))
    })]), b("div", wD, [b("div", TD, [b("div", ED, [X(a, {
        name: s.t.HUD.divide.display
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(7, (f, p) => X(De("setting-switch"), {
        key: p,
        name: s.t.content[4][p],
        val: s.value(4, p),
        onChangeVal: m => s.change(4, p, m)
    }, null, 8, ["name", "val", "onChangeVal"])), 64))]), b("div", SD, [X(a, {
        name: s.t.HUD.divide.minimap
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[4][7][0],
        min: s.t.content[4][7][1],
        max: s.t.content[4][7][2],
        step: s.t.content[4][7][3],
        val: s.value(4, 7),
        onChangeVal: t[9] || (t[9] = f => s.change(4, 7, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), X(a, {
        name: s.t.HUD.divide.leaderboard
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[4][8][0],
        min: s.t.content[4][8][1],
        max: s.t.content[4][8][2],
        step: s.t.content[4][8][3],
        val: s.value(4, 8),
        onChangeVal: t[10] || (t[10] = f => s.change(4, 8, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), X(a, {
        name: s.t.HUD.divide.teamRanking
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[4][9][0],
        min: s.t.content[4][9][1],
        max: s.t.content[4][9][2],
        step: s.t.content[4][9][3],
        val: s.value(4, 9),
        onChangeVal: t[11] || (t[11] = f => s.change(4, 9, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), X(a, {
        name: s.t.HUD.divide.performance
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[4][10][0],
        min: s.t.content[4][10][1],
        max: s.t.content[4][10][2],
        step: s.t.content[4][10][3],
        val: s.value(4, 10),
        onChangeVal: t[12] || (t[12] = f => s.change(4, 10, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), X(a, {
        name: s.t.HUD.divide.gamestatus
    }, null, 8, ["name"]), X(h, {
        name: s.t.content[4][11][0],
        min: s.t.content[4][11][1],
        max: s.t.content[4][11][2],
        step: s.t.content[4][11][3],
        val: s.value(4, 11),
        onChangeVal: t[13] || (t[13] = f => s.change(4, 11, f))
    }, null, 8, ["name", "min", "max", "step", "val"]), X(a, {
        name: s.t.HUD.divide.chatroom
    }, null, 8, ["name"]), X(u, {
        name: s.t.content[4][12],
        val: s.value(4, 12),
        onChangeVal: t[14] || (t[14] = f => s.change(4, 12, f))
    }, null, 8, ["name", "val"]), CD])]), X(c, {
        reset: !0,
        onOnReset: t[15] || (t[15] = f => s.reset(4))
    })])])])
}
var ID = ue(aD, [
    ["render", AD],
    ["__scopeId", "data-v-c48775c0"]
]);
const MD = {
        content: [
            ["\u5410\u7403", "\u5FEB\u901F\u5410\u7403", "\u5206\u88C2 1X", "\u5206\u88C2 2X", "\u5206\u88C2 3X", "\u5206\u88C2 4X", "\u505C\u6B62", "\u505C\u6B62(\u5207\u6362)", "\u6563\u5F00", "\u53CC\u5F00\u5207\u6362", "\u53CC\u5F00\u81EA\u52A8\u5207\u6362", "\u56DB\u5F00\u6A21\u5F0F\u5207\u6362", "\u590D\u6D3B", "\u5149\u6807\u7EBF", "\u654C\u6211\u533A\u5206", "\u8D28\u91CF\u6307\u793A", "\u5206\u88C2\u987A\u5E8F\u6307\u793A", "\u81EA\u52A8\u5206\u88C2\u63D0\u793A", "\u589E\u52A0\u8D28\u91CF", "\u51CF\u5C11\u8D28\u91CF", "\u6E05\u7406\u591A\u4F59\u7EC6\u80DE", "\u5FEB\u901F\u5F55\u5236"],
            ["\u540D\u5B57", "\u8D28\u91CF", "\u76AE\u80A4", "\u98DF\u7269", "\u5C0F\u5730\u56FE", "\u6392\u884C\u699C", "\u961F\u4F0D\u6392\u884C", "\u6027\u80FD\u72B6\u6001", "\u6E38\u620F\u72B6\u6001", "\u804A\u5929\u5BA4", "\u56DE\u653E\u9762\u677F"]
        ],
        gameplay: {
            name: "\u6E38\u620F\u4E2D",
            divide: {
                control: "\u63A7\u5236",
                assistance: "\u8F85\u52A9",
                sandbox: "\u6C99\u76D2",
                other: "\u5176\u4ED6"
            }
        },
        display: {
            name: "\u663E\u793A",
            divide: {
                entity: "\u5B9E\u4F53"
            }
        },
        command: {
            name: "\u6307\u4EE4"
        },
        mouse: {
            name: "\u9F20\u6807",
            content: ["\u5DE6\u952E", "\u4E2D\u952E", "\u53F3\u952E", "\u4FA7\u952E\u4E00", "\u4FA7\u952E\u4E8C"],
            values: ["\u5410\u7403", "\u5FEB\u901F\u5410\u7403", "\u5206\u88C2 1X", "\u5206\u88C2 2X", "\u5206\u88C2 3X", "\u5206\u88C2 4X", "\u505C\u6B62", "\u70B9\u51FB\u79FB\u52A8", "\u4FE1\u53F7", "\u53CC\u5F00\u5207\u6362", "\u589E\u52A0\u8D28\u91CF", "\u51CF\u5C11\u8D28\u91CF", "\u6E05\u7406\u591A\u4F59\u7EC6\u80DE"],
            signalHint: "\u53D1\u9001\u4E86\u4E00\u4E2A\u4FE1\u53F7"
        }
    },
    RD = {
        content: [
            ["\u5410\u7403", "\u5FEB\u901F\u5410\u7403", "\u5206\u88C2 1X", "\u5206\u88C2 2X", "\u5206\u88C2 3X", "\u5206\u88C2 4X", "\u505C\u6B62", "\u505C\u6B62(\u5207\u63DB)", "\u6563\u958B", "\u96D9\u958B\u5207\u63DB", "\u96D9\u958B\u81EA\u52D5\u5207\u63DB", "\u56DB\u958B\u6A21\u5F0F\u5207\u63DB", "\u590D\u6D3B", "\u5149\u6A19\u7DDA", "\u6575\u6211\u5340\u5206", "\u8CEA\u91CF\u6307\u793A", "\u5206\u88C2\u9806\u5E8F\u6307\u793A", "\u81EA\u52D5\u5206\u88C2\u63D0\u793A", "\u589E\u52A0\u8CEA\u91CF", "\u6E1B\u5C11\u8CEA\u91CF", "\u6E05\u7406\u591A\u9918\u7D30\u80DE", "\u5FEB\u901F\u9304\u88FD"],
            ["\u540D\u5B57", "\u8CEA\u91CF", "\u76AE\u819A", "\u98DF\u7269", "\u5C0F\u5730\u5716", "\u6392\u884C\u699C", "\u968A\u4F0D\u6392\u884C", "\u6027\u80FD\u72C0\u614B", "\u904A\u6232\u72C0\u614B", "\u804A\u5929\u5BA4", "\u56DE\u653E\u9762\u677F"]
        ],
        gameplay: {
            name: "\u904A\u6232\u4E2D",
            divide: {
                control: "\u63A7\u5236",
                assistance: "\u8F14\u52A9",
                sandbox: "\u6C99\u76D2",
                other: "\u5176\u4ED6"
            }
        },
        display: {
            name: "\u986F\u793A",
            divide: {
                entity: "\u5BE6\u9AD4"
            }
        },
        command: {
            name: "\u6307\u4EE4"
        },
        mouse: {
            name: "\u6ED1\u9F20",
            content: ["\u5DE6\u9375", "\u4E2D\u9375", "\u53F3\u9375", "\u5074\u9375\u4E00", "\u5074\u9375\u4E8C"],
            values: ["\u5410\u7403", "\u5FEB\u901F\u5410\u7403", "\u5206\u88C2 1X", "\u5206\u88C2 2X", "\u5206\u88C2 3X", "\u5206\u88C2 4X", "\u505C\u6B62", "\u9EDE\u64CA\u79FB\u52D5", "\u4FE1\u865F", "\u96D9\u958B\u5207\u63DB", "\u589E\u52A0\u8CEA\u91CF", "\u6E1B\u5C11\u8CEA\u91CF", "\u6E05\u7406\u591A\u9918\u7D30\u80DE"],
            signalHint: "\u767C\u9001\u4E86\u4E00\u500B\u4FE1\u865F"
        }
    },
    kD = {
        content: [
            ["\u990C\u5358\u767A", "\u990C\u9023\u5C04", "\u5206\u88C2 1X", "\u5206\u88C2 2X", "\u5206\u88C2 3X", "\u5206\u88C2 4X", "\u305D\u306E\u5834\u3067\u505C\u6B62", "\u305D\u306E\u5834\u3067\u505C\u6B62(\u30C8\u30B0\u30EB)", "\u7D30\u80DE\u3092\u5206\u6563\u3059\u308B", "\u30BF\u30D6\u5207\u66FF", "\u30BF\u30D6\u81EA\u52D5\u5207\u66FF", "4\u30BF\u30D6\u30E2\u30FC\u30C9\u5207\u66FF", "\u518D\u751F", "\u30AB\u30FC\u30BD\u30EB\u7DDA", "\u6575\u5473\u65B9\u533A\u5225", "\u8CEA\u91CF\u30DE\u30FC\u30AB\u30FC", "\u5206\u88C2\u9806\u5E8F\u30DE\u30FC\u30AB\u30FC", "\u81EA\u7136\u5206\u88C2\u30A2\u30E9\u30FC\u30C8", "\u8CEA\u91CF\u5897\u52A0", "\u8CEA\u91CF\u6E1B\u5C11", "\u5C0F\u3055\u3044\u7D30\u80DE\u3092\u6D88\u3059", "\u30AF\u30A4\u30C3\u30AF\u30AD\u30E3\u30D7\u30C1\u30E3"],
            ["\u540D\u524D", "\u8CEA\u91CF", "\u30B9\u30AD\u30F3", "\u98DF\u7269", "\u30DF\u30CB\u30DE\u30C3\u30D7", "\u30EA\u30FC\u30C0\u30FC\u30DC\u30FC\u30C9", "\u30C1\u30FC\u30E0\u30E9\u30F3\u30AD\u30F3\u30B0", "\u6027\u80FD\u72B6\u614B", "\u30B2\u30FC\u30E0\u72B6\u614B", "\u30C1\u30E3\u30C3\u30C8\u30EB\u30FC\u30E0", "\u30EA\u30D7\u30EC\u30A4\u30D0\u30FC"]
        ],
        gameplay: {
            name: "\u30B2\u30FC\u30E0\u4E2D",
            divide: {
                control: "\u30B3\u30F3\u30C8\u30ED\u30FC\u30EB",
                assistance: "\u30A2\u30B7\u30B9\u30BF\u30F3\u30B9",
                sandbox: "\u30B5\u30F3\u30C9\u30DC\u30C3\u30AF\u30B9",
                other: "\u305D\u306E\u4ED6"
            }
        },
        display: {
            name: "\u8868\u793A",
            divide: {
                entity: "\u5B9F\u4F53"
            }
        },
        command: {
            name: "\u30B3\u30DE\u30F3\u30C9"
        },
        mouse: {
            name: "\u30DE\u30A6\u30B9",
            content: ["\u5DE6\u30DC\u30BF\u30F3", "\u4E2D\u30DC\u30BF\u30F3", "\u53F3\u30DC\u30BF\u30F3", "\u30B5\u30A4\u30C9\u30DC\u30BF\u30F3\u4E00", "\u30B5\u30A4\u30C9\u30DC\u30BF\u30F3\u4E8C"],
            values: ["\u990C\u5358\u767A", "\u990C\u9023\u5C04", "\u5206\u88C2 1X", "\u5206\u88C2 2X", "\u5206\u88C2 3X", "\u5206\u88C2 4X", "\u305D\u306E\u5834\u3067\u505C\u6B62", "\u30AF\u30EA\u30C3\u30AF\u79FB\u52D5", "\u4FE1\u53F7", "\u30BF\u30D6\u5207\u66FF", "\u8CEA\u91CF\u5897\u52A0", "\u8CEA\u91CF\u6E1B\u5C11", "\u5C0F\u3055\u3044\u7D30\u80DE\u3092\u6D88\u3059"],
            signalHint: "\u306F\u4FE1\u53F7\u3092\u9001\u3063\u305F"
        }
    },
    PD = {
        content: [
            ["Feed Once", "Macro Feed", "Split 1X", "Split 2X", "Split 3X", "Split 4X", "Pause", "Pause (Toggle)", "Scatter Cells", "Switch Tab", "Auto Switch Tab", "Switch 4-Tab mode", "Respawn", "Cursor Line", "Enemy Hint", "Mass Marker", "Split Order Marker", "Autosplit Alert", "Increase Mass", "Decrease Mass", "Clear small cells", "Quick Capture"],
            ["Nick", "Mass", "Skin", "Food", "Minimap", "Leaderboard", "Team Ranking", "Performance Status", "Game Status", "Chat Room", "Replay Bar"]
        ],
        gameplay: {
            name: "GAMEPLAY",
            divide: {
                control: "CONTROL",
                assistance: "ASSISTANCE",
                sandbox: "SANDBOX",
                other: "OTHER"
            }
        },
        display: {
            name: "DISPLAY",
            divide: {
                entity: "ENTITY"
            }
        },
        command: {
            name: "COMMAND"
        },
        mouse: {
            name: "MOUSE",
            content: ["Left Button", "Middle Button", "Right Button", "Side Button \u2160", "Side Button \u2161"],
            values: ["Feed Once", "Macro Feed", "Split 1X", "Split 2X", "Split 3X", "Split 4X", "Pause", "Click Move", "Signal", "Switch Tab", "Increase Mass", "Decrease Mass", "Clear small cells"],
            signalHint: "sent out a signal"
        }
    };
var Ny = {
    zh_CN: MD,
    zh: RD,
    ja: kD,
    en: PD
};
const LD = {
        name: "setting-hotkey",
        props: {
            name: String,
            defVal: {
                type: String,
                default: ""
            },
            val: String
        },
        setup(e, {
            emit: t
        }) {
            const i = ft(null);

            function s({
                target: r
            }) {
                t("focus", r)
            }

            function n() {
                i.value.style.fontSize = i.value.value.indexOf("Num") === 0 || i.value.value.indexOf("Control") === 0 || i.value.value.indexOf("Alt") === 0 ? ".8rem" : "1rem"
            }
            return Ve(() => n()), Pr(() => n()), {
                input: i,
                focus: s
            }
        }
    },
    OD = {
        class: "hotkey-row"
    },
    DD = {
        class: "hotkey-name"
    },
    ND = {
        class: "hotkey-default"
    },
    FD = {
        class: "hotkey-input"
    },
    BD = ["value"];

function UD(e, t, i, s, n, r) {
    return st(), nt("div", OD, [b("div", DD, Ot(i.name), 1), b("div", ND, Ot(i.defVal), 1), b("div", FD, [b("input", {
        class: "form-control rounded-0",
        type: "text",
        maxlength: "0",
        ref: "input",
        value: i.val,
        onFocus: t[0] || (t[0] = (...o) => s.focus && s.focus(...o))
    }, null, 40, BD)])])
}
var GD = ue(LD, [
    ["render", UD],
    ["__scopeId", "data-v-0f607577"]
]);
const HD = {
        name: "command-hotkey",
        props: {
            val: String,
            command: String
        },
        setup(e, {
            emit: t
        }) {
            const i = ft(null),
                s = ft(null);

            function n({
                target: a
            }) {
                t("focus", a)
            }

            function r() {
                i.value.style.fontSize = i.value.value.indexOf("Num") === 0 || i.value.value.indexOf("Control") === 0 || i.value.value.indexOf("Alt") === 0 ? ".8rem" : "1rem"
            }

            function o() {
                t("changeVal", s.value.value)
            }
            return Ve(() => r()), Pr(() => r()), {
                keyInput: i,
                commandInput: s,
                focus: n,
                change: o
            }
        }
    },
    VD = {
        class: "hotkey-row"
    },
    zD = {
        class: "hotkey-command"
    },
    $D = ["value"],
    jD = {
        class: "hotkey-input"
    },
    WD = ["value"];

function XD(e, t, i, s, n, r) {
    return st(), nt("div", VD, [b("div", zD, [b("input", {
        class: "form-control rounded-0",
        type: "text",
        maxlength: "64",
        size: "64",
        ref: "commandInput",
        value: i.command,
        onChange: t[0] || (t[0] = (...o) => s.change && s.change(...o))
    }, null, 40, $D)]), b("div", jD, [b("input", {
        class: "form-control rounded-0",
        type: "text",
        maxlength: "0",
        ref: "keyInput",
        value: i.val,
        onFocus: t[1] || (t[1] = (...o) => s.focus && s.focus(...o))
    }, null, 40, WD)])])
}
var YD = ue(HD, [
    ["render", XD],
    ["__scopeId", "data-v-06928186"]
]);
const KD = {
        none: "\u65E0"
    },
    ZD = {
        none: "\u7121"
    },
    qD = {
        none: "\u7121\u3057"
    },
    JD = {
        none: "None"
    };
var QD = {
    zh_CN: KD,
    zh: ZD,
    ja: qD,
    en: JD
};
const t7 = {
        name: "setting-select",
        components: {
            "common-select": pp
        },
        props: {
            name: {
                type: String,
                default: ""
            },
            selected: Number,
            options: {
                type: Array,
                default: []
            }
        },
        setup(e, {
            emit: t
        }) {
            const i = Ft(() => QD[yi("locale").value]);

            function s(n) {
                t("changeVal", n)
            }
            return {
                t: i,
                change: s
            }
        }
    },
    e7 = {
        class: "select-row"
    },
    i7 = {
        class: "select-name"
    };

function s7(e, t, i, s, n, r) {
    const o = se("common-select");
    return st(), nt("div", e7, [b("div", i7, Ot(i.name), 1), X(o, {
        class: Ai("desc-select"),
        selected: i.selected,
        options: [s.t.none, ...i.options],
        onChange: s.change
    }, null, 8, ["selected", "options", "onChange"])])
}
var n7 = ue(t7, [
    ["render", s7],
    ["__scopeId", "data-v-8576c920"]
]);
const r7 = {
        name: "hotkey-pane",
        components: {
            "sub-nav": mp,
            "btn-group": gp,
            "dividing-line": vp,
            "setting-hotkey": GD,
            "command-hotkey": YD,
            "setting-select": n7
        },
        setup() {
            const e = Ft(() => Ny[yi("locale").value]),
                t = Ft(() => [{
                    href: "hotkey-gameplay-tab",
                    text: e.value.gameplay.name,
                    active: !0
                }, {
                    href: "hotkey-display-tab",
                    text: e.value.display.name
                }, {
                    href: "hotkey-mouse-tab",
                    text: e.value.mouse.name
                }]),
                i = _i({}),
                s = _i(bi),
                n = _i(tl),
                r = new Map;
            Object.keys(s).forEach(v => {
                i[v] = s[v]
            });
            let o = 0,
                a = 0;
            const l = e.value.content;
            Object.keys(bi).forEach(v => {
                const _ = l[o];
                a < _.length || (o++, a = 0), r.set(o + "-" + a, v), a++
            });
            const c = (v, _) => i[r.get(v + "-" + _)],
                h = (v, _) => sc[r.get(v + "-" + _)],
                u = (v, _, C) => i[r.get(v + "-" + _)] = C;

            function d(v, _, C) {
                C.addEventListener("keydown", k => {
                    k.preventDefault();
                    const S = yo(k);
                    switch (S) {
                        case "Escape":
                        case "Enter":
                        case "NumpadEnter":
                            break;
                        case "Backspace": {
                            u(v, _, "");
                            break
                        }
                        default:
                            (function() {
                                for (let T = 0; T < 2; T++)
                                    for (let L = 0; c(T, L); L++) {
                                        const D = v == 0 && _ >= 13 && _ <= 17 || v == 1,
                                            O = T == 0 && L >= 13 && L <= 17 || T == 1;
                                        if (!(D && O) && S === c(T, L)) {
                                            u(T, L, "");
                                            return
                                        }
                                    }
                            })(), u(v, _, S)
                    }
                }), C.addEventListener("keyup", () => {
                    C.blur()
                })
            }
            const f = ["None", "FeedOnce", "MacroFeed", "Split1X", "Split2X", "Split3X", "Split4X", "Pause", "ClickMove", "Signal", "SwitchTab", "IncreaseMass", "DecreaseMass", "ClearSmallCells"],
                p = v => f.indexOf(n[v]);

            function m(v, _) {
                n[v] = f[_], localStorage.setItem("mouse_map", JSON.stringify(n))
            }

            function g() {
                for (let v = 0; v < 5; v++) n[v] = G1[v];
                localStorage.setItem("mouse_map", JSON.stringify(n))
            }

            function y() {
                Object.keys(s).forEach(v => {
                    s[v] = sc[v]
                }), Object.keys(i).forEach(v => {
                    i[v] = sc[v]
                }), localStorage.setItem("key_map", JSON.stringify(s))
            }

            function x() {
                Object.keys(s).forEach(v => {
                    s[v] = i[v]
                }), localStorage.setItem("key_map", JSON.stringify(s))
            }
            return Ve(() => {
                A.on("hotkeyCheck", () => {
                    Object.keys(s).forEach(v => {
                        i[v] = s[v]
                    })
                })
            }), {
                t: e,
                tabs: t,
                mouseMap: n,
                defVal: h,
                cache: c,
                selected: p,
                setMouse: m,
                resetMouse: g,
                convert: U1,
                focus: d,
                reset: y,
                save: x
            }
        }
    },
    o7 = e => (gs("data-v-042c43d8"), e = e(), vs(), e),
    a7 = {
        class: "tab-pane",
        id: "setting-hotkey"
    },
    l7 = {
        class: "tab-content"
    },
    c7 = {
        class: "tab-pane active",
        id: "hotkey-gameplay-tab"
    },
    h7 = {
        class: "container-inline hotkey-inline"
    },
    u7 = {
        class: "container-col"
    },
    d7 = {
        class: "container-col"
    },
    f7 = o7(() => b("div", {
        class: "filler"
    }, null, -1)),
    p7 = {
        class: "tab-pane",
        id: "hotkey-display-tab"
    },
    m7 = {
        class: "container-inline hotkey-inline"
    },
    g7 = {
        class: "container-col"
    },
    v7 = {
        class: "container-col"
    },
    _7 = {
        class: "tab-pane",
        id: "hotkey-mouse-tab"
    },
    y7 = {
        class: "container-inline hotkey-inline"
    },
    b7 = {
        class: "container-col"
    },
    x7 = {
        class: "container-col"
    };

function w7(e, t, i, s, n, r) {
    const o = se("sub-nav"),
        a = se("dividing-line"),
        l = se("btn-group");
    return st(), nt("div", a7, [X(o, {
        tabs: s.tabs
    }, null, 8, ["tabs"]), b("div", l7, [b("div", c7, [b("div", h7, [b("div", u7, [X(a, {
        name: s.t.gameplay.divide.control
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(11, (c, h) => X(De("setting-hotkey"), {
        key: h,
        name: s.t.content[0][h],
        defVal: s.convert(s.defVal(0, h)),
        val: s.convert(s.cache(0, h)),
        onFocus: u => s.focus(0, h, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64)), (st(), nt(Dt, null, Jt(1, (c, h) => X(De("setting-hotkey"), {
        key: h,
        name: s.t.content[0][h + 12],
        defVal: s.convert(s.defVal(0, h + 12)),
        val: s.convert(s.cache(0, h + 12)),
        onFocus: u => s.focus(0, h + 12, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64))]), b("div", d7, [X(a, {
        name: s.t.gameplay.divide.assistance
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(5, (c, h) => X(De("setting-hotkey"), {
        key: h + 13,
        name: s.t.content[0][h + 13],
        defVal: s.convert(s.defVal(0, h + 13)),
        val: s.convert(s.cache(0, h + 13)),
        onFocus: u => s.focus(0, h + 13, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64)), X(a, {
        name: s.t.gameplay.divide.sandbox
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(3, (c, h) => X(De("setting-hotkey"), {
        key: h + 18,
        name: s.t.content[0][h + 18],
        defVal: s.convert(s.defVal(0, h + 18)),
        val: s.convert(s.cache(0, h + 18)),
        onFocus: u => s.focus(0, h + 18, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64)), X(a, {
        name: s.t.gameplay.divide.other
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(1, (c, h) => X(De("setting-hotkey"), {
        key: h + 21,
        name: s.t.content[0][h + 21],
        defVal: s.convert(s.defVal(0, h + 21)),
        val: s.convert(s.cache(0, h + 21)),
        onFocus: u => s.focus(0, h + 21, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64)), f7])]), X(l, {
        reset: !0,
        save: !0,
        onOnReset: s.reset,
        onOnSave: s.save
    }, null, 8, ["onOnReset", "onOnSave"])]), b("div", p7, [b("div", m7, [b("div", g7, [X(a, {
        name: s.t.display.divide.entity
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(4, (c, h) => X(De("setting-hotkey"), {
        key: h,
        name: s.t.content[1][h],
        defVal: s.convert(s.defVal(1, h)),
        val: s.convert(s.cache(1, h)),
        onFocus: u => s.focus(1, h, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64))]), b("div", v7, [X(a, {
        name: "HUD"
    }), (st(), nt(Dt, null, Jt(7, (c, h) => X(De("setting-hotkey"), {
        key: h + 4,
        name: s.t.content[1][h + 4],
        defVal: s.convert(s.defVal(1, h + 4)),
        val: s.convert(s.cache(1, h + 4)),
        onFocus: u => s.focus(1, h + 4, u)
    }, null, 8, ["name", "defVal", "val", "onFocus"])), 64))])]), X(l, {
        reset: !0,
        save: !0,
        onOnReset: s.reset,
        onOnSave: s.save
    }, null, 8, ["onOnReset", "onOnSave"])]), b("div", _7, [b("div", y7, [b("div", b7, [X(a), (st(), nt(Dt, null, Jt(3, (c, h) => X(De("setting-select"), {
        key: h,
        style: $t({
            marginTop: 48 * h + "px"
        }),
        name: s.t.mouse.content[h],
        selected: s.selected(h),
        options: s.t.mouse.values,
        onChangeVal: u => s.setMouse(h, u)
    }, null, 8, ["style", "name", "selected", "options", "onChangeVal"])), 64))]), b("div", x7, [X(a), (st(), nt(Dt, null, Jt(2, (c, h) => X(De("setting-select"), {
        key: h,
        style: $t({
            marginTop: 48 * h + "px"
        }),
        name: s.t.mouse.content[h + 3],
        selected: s.selected(h + 3),
        options: s.t.mouse.values,
        onChangeVal: u => s.setMouse(h + 3, u)
    }, null, 8, ["style", "name", "selected", "options", "onChangeVal"])), 64))])]), X(l, {
        reset: !0,
        style: {
            zIndex: 0
        },
        onOnReset: t[0] || (t[0] = c => s.resetMouse())
    })])])])
}
var T7 = ue(r7, [
    ["render", w7],
    ["__scopeId", "data-v-042c43d8"]
]);
const E7 = {
        content: [
            ["\u5410\u7403", "\u98DF\u7269", "\u7EFF\u523A", "\u7EA2\u523A", "\u6587\u672C", "\u6587\u672C\u63CF\u8FB9", "\u7EC6\u80DE", "\u76AE\u80A4", "\u76AE\u80A4\u586B\u5145", "\u5149\u6807\u7EBF", "\u8D28\u91CF\u6307\u793A", "\u5206\u88C2\u987A\u5E8F\u6307\u793A", "\u81EA\u52A8\u5206\u88C2\u63D0\u793A", "\u76EE\u7684\u5730\u70B9", "\u4FE1\u53F7"],
            ["\u5750\u6807\u5B57\u4F53", "\u5750\u6807\u7F51\u683C", "\u8FB9\u754C", "\u8FB9\u754C\u53D1\u5149", "\u80CC\u666F\u8272", "\u80CC\u666F\u56FE"],
            ["\u5750\u6807\u5B57\u4F53", "\u5750\u6807\u7F51\u683C", "\u80CC\u666F\u8272", "\u5B9A\u4F4D\u7EBF", "\u89C6\u91CE", "\u5B9E\u4F53", "\u5B9E\u4F53\u4FE1\u606F", "\u80CC\u666F", "\u80CC\u666F", "\u80CC\u666F"]
        ],
        playerType: ["\u4E2A\u4EBA", "\u961F\u4F0D", "\u654C\u4EBA", "\u6240\u6709"],
        display: {
            name: "\u663E\u793A",
            divide: {
                basic: "\u57FA\u7840",
                player: "\u73A9\u5BB6",
                assistance: "\u8F85\u52A9"
            }
        },
        map: {
            name: "\u5730\u56FE",
            divide: {
                basic: "\u57FA\u7840"
            }
        },
        HUD: {
            divide: {
                minimap: "\u5C0F\u5730\u56FE",
                leaderboard: "\u6392\u884C\u699C",
                teamRankings: "\u961F\u4F0D\u6392\u884C",
                perfPanel: "\u6027\u80FD\u72B6\u6001"
            }
        },
        menu: {
            name: "\u83DC\u5355"
        }
    },
    S7 = {
        content: [
            ["\u5410\u7403", "\u98DF\u7269", "\u7DA0\u523A", "\u7D05\u523A", "\u6587\u672C", "\u6587\u672C\u63CF\u908A", "\u7D30\u80DE", "\u76AE\u819A", "\u76AE\u819A\u586B\u5145", "\u5149\u6A19\u7DDA", "\u8CEA\u91CF\u6307\u793A", "\u5206\u88C2\u9806\u5E8F\u6307\u793A", "\u81EA\u52D5\u5206\u88C2\u63D0\u793A", "\u76EE\u7684\u5730\u9EDE", "\u4FE1\u865F"],
            ["\u5750\u6A19\u5B57\u9AD4", "\u5750\u6A19\u7DB2\u683C", "\u908A\u754C", "\u908A\u754C\u767C\u5149", "\u80CC\u666F\u8272", "\u80CC\u666F\u5716"],
            ["\u5750\u6A19\u5B57\u9AD4", "\u5750\u6A19\u7DB2\u683C", "\u80CC\u666F\u8272", "\u5B9A\u4F4D\u7DDA", "\u8996\u91CE", "\u5BE6\u9AD4", "\u5BE6\u9AD4\u4FE1\u606F", "\u80CC\u666F", "\u80CC\u666F", "\u80CC\u666F"]
        ],
        playerType: ["\u500B\u4EBA", "\u968A\u4F0D", "\u6575\u4EBA", "\u6240\u6709"],
        display: {
            name: "\u986F\u793A",
            divide: {
                basic: "\u57FA\u790E",
                player: "\u73A9\u5BB6",
                assistance: "\u8F14\u52A9"
            }
        },
        map: {
            name: "\u5730\u5716",
            divide: {
                basic: "\u57FA\u790E"
            }
        },
        HUD: {
            divide: {
                minimap: "\u5C0F\u5730\u5716",
                leaderboard: "\u6392\u884C\u699C",
                teamRankings: "\u968A\u4F0D\u6392\u884C",
                perfPanel: "\u6027\u80FD\u72C0\u614B"
            }
        },
        menu: {
            name: "\u9078\u55AE"
        }
    },
    C7 = {
        content: [
            ["\u990C", "\u98DF\u7269", "\u68D8", "\u8D64\u68D8", "\u6587\u5B57", "\u6587\u5B57\u306E\u56F2\u3044", "\u7D30\u80DE", "\u30B9\u30AD\u30F3", "\u30B9\u30AD\u30F3\u3067\u6E80\u305F\u3059", "\u30AB\u30FC\u30BD\u30EB\u7DDA", "\u8CEA\u91CF\u30DE\u30FC\u30AB\u30FC", "\u5206\u88C2\u9806\u5E8F\u30DE\u30FC\u30AB\u30FC", "\u81EA\u7136\u5206\u88C2\u30A2\u30E9\u30FC\u30C8", "\u76EE\u7684\u5730\u70B9", "\u4FE1\u53F7"],
            ["\u5EA7\u6A19\u30D5\u30A9\u30F3\u30C8", "\u5EA7\u6A19\u30B0\u30EA\u30C3\u30C9", "\u67A0", "\u67A0\u767A\u5149", "\u80CC\u666F", "\u80CC\u666F\u753B\u50CF"],
            ["\u5EA7\u6A19\u30D5\u30A9\u30F3\u30C8", "\u5EA7\u6A19\u30B0\u30EA\u30C3\u30C9", "\u80CC\u666F", "\u30ED\u30B1\u30FC\u30B7\u30E7\u30F3\u30E9\u30A4\u30F3", "\u8996\u91CE", "\u5B9F\u4F53", "\u5B9F\u4F53\u60C5\u5831", "\u80CC\u666F", "\u80CC\u666F", "\u80CC\u666F"]
        ],
        playerType: ["\u500B\u4EBA", "\u30C1\u30FC\u30E0", "\u6575", "\u5168\u3066"],
        display: {
            name: "\u8868\u793A",
            divide: {
                basic: "\u57FA\u672C",
                player: "\u30D7\u30EC\u30A4\u30E4\u30FC",
                assistance: "\u30A2\u30B7\u30B9\u30BF\u30F3\u30B9"
            }
        },
        map: {
            name: "\u30DE\u30C3\u30D7",
            divide: {
                basic: "\u57FA\u672C"
            }
        },
        HUD: {
            divide: {
                minimap: "\u30DF\u30CB\u30DE\u30C3\u30D7",
                leaderboard: "\u30EA\u30FC\u30C0\u30FC\u30DC\u30FC\u30C9",
                teamRankings: "\u30C1\u30FC\u30E0\u30E9\u30F3\u30AD\u30F3\u30B0",
                perfPanel: "\u6027\u80FD\u72B6\u614B"
            }
        },
        menu: {
            name: "\u30E1\u30CB\u30E5\u30FC"
        }
    },
    A7 = {
        content: [
            ["Ejected Cell", "Food", "Virus", "Red Virus", "Text", "Text Stroke", "Cell", "Skin", "Skin Fill", "Cursor Line", "Mass Marker", "Split Order Marker", "Autosplit Alert", "Destination Point", "Signal"],
            ["Coords Font", "Coords Grid", "Border", "Border Glow", "Background", "Image"],
            ["Coords Font", "Coords Grid", "Background", "Location Line", "View", "Entity", "Entity Information", "Background", "Background", "Background"]
        ],
        playerType: ["Self", "Team", "Enemy", "All"],
        display: {
            name: "DISPLAY",
            divide: {
                basic: "BASIC",
                player: "PLAYER",
                assistance: "ASSISTANCE"
            }
        },
        map: {
            name: "MAP",
            divide: {
                basic: "BASIC"
            }
        },
        HUD: {
            divide: {
                minimap: "MINIMAP",
                leaderboard: "LEADERBOARD",
                teamRankings: "TEAM RANKING",
                perfPanel: "PERFORMANCE PANEL"
            }
        },
        menu: {
            name: "MENU"
        }
    };
var I7 = {
    zh_CN: E7,
    zh: S7,
    ja: C7,
    en: A7
};
const M7 = {
        name: "picker-button",
        props: {
            name: String
        }
    },
    R7 = {
        class: "picker-button"
    },
    k7 = {
        class: "btn btn-dark rounded-0"
    };

function P7(e, t, i, s, n, r) {
    return st(), nt("div", R7, [b("button", k7, Ot(i.name), 1)])
}
var L7 = ue(M7, [
    ["render", P7],
    ["__scopeId", "data-v-6e4feacd"]
]);
const O7 = {
        default: "\u9ED8\u8BA4",
        size: "\u5927\u5C0F",
        teamColor: "\u4F7F\u7528\u961F\u4F0D\u989C\u8272",
        bgUrl: "\u80CC\u666F\u56FE\u94FE\u63A5"
    },
    D7 = {
        default: "\u9ED8\u8A8D",
        size: "\u5927\u5C0F",
        teamColor: "\u4F7F\u7528\u968A\u4F0D\u984F\u8272",
        bgUrl: "\u80CC\u666F\u5716\u93C8\u63A5"
    },
    N7 = {
        default: "\u30C7\u30D5\u30A9\u30EB\u30C8",
        size: "\u30B5\u30A4\u30BA",
        teamColor: "\u30C1\u30FC\u30E0\u30AB\u30E9\u30FC",
        bgUrl: "\u80CC\u666F\u306EURL"
    },
    F7 = {
        default: "Default",
        size: "Size",
        teamColor: "Use team color",
        bgUrl: "Background Image URL"
    };
var B7 = {
    zh_CN: O7,
    zh: D7,
    ja: N7,
    en: F7
};
/*!
 * iro.js v5.3.1
 * 2016-2020 James Daniel
 * Licensed under MPL 2.0
 * github.com/jaames/iro.js
 */
var Pe, Dc, Fy, zd, By, An = {},
    _p = [],
    U7 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i;

function En(e, t) {
    for (var i in t) e[i] = t[i];
    return e
}

function Uy(e) {
    var t = e.parentNode;
    t && t.removeChild(e)
}

function Lt(e, t, i) {
    var s, n, r, o, a = arguments;
    if (t = En({}, t), arguments.length > 3)
        for (i = [i], s = 3; s < arguments.length; s++) i.push(a[s]);
    if (i != null && (t.children = i), e != null && e.defaultProps != null)
        for (n in e.defaultProps) t[n] === void 0 && (t[n] = e.defaultProps[n]);
    return o = t.key, (r = t.ref) != null && delete t.ref, o != null && delete t.key, $d(e, t, o, r)
}

function $d(e, t, i, s) {
    var n = {
        type: e,
        props: t,
        key: i,
        ref: s,
        __k: null,
        __p: null,
        __b: 0,
        __e: null,
        l: null,
        __c: null,
        constructor: void 0
    };
    return Pe.vnode && Pe.vnode(n), n
}

function Eh(e) {
    return e.children
}

function G7(e) {
    if (e == null || typeof e == "boolean") return null;
    if (typeof e == "string" || typeof e == "number") return $d(null, e, null, null);
    if (e.__e != null || e.__c != null) {
        var t = $d(e.type, e.props, e.key, null);
        return t.__e = e.__e, t
    }
    return e
}

function bo(e, t) {
    this.props = e, this.context = t
}

function Nc(e, t) {
    if (t == null) return e.__p ? Nc(e.__p, e.__p.__k.indexOf(e) + 1) : null;
    for (var i; t < e.__k.length; t++)
        if ((i = e.__k[t]) != null && i.__e != null) return i.__e;
    return typeof e.type == "function" ? Nc(e) : null
}

function Gy(e) {
    var t, i;
    if ((e = e.__p) != null && e.__c != null) {
        for (e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++)
            if ((i = e.__k[t]) != null && i.__e != null) {
                e.__e = e.__c.base = i.__e;
                break
            } return Gy(e)
    }
}

function Tu(e) {
    (!e.__d && (e.__d = !0) && Dc.push(e) === 1 || zd !== Pe.debounceRendering) && (zd = Pe.debounceRendering, (Pe.debounceRendering || Fy)(H7))
}

function H7() {
    var e, t, i, s, n, r, o, a;
    for (Dc.sort(function(l, c) {
            return c.__v.__b - l.__v.__b
        }); e = Dc.pop();) e.__d && (i = void 0, s = void 0, r = (n = (t = e).__v).__e, o = t.__P, a = t.u, t.u = !1, o && (i = [], s = bp(o, n, En({}, n), t.__n, o.ownerSVGElement !== void 0, null, i, a, r ?? Nc(n)), Vy(i, n), s != r && Gy(n)))
}

function Hy(e, t, i, s, n, r, o, a, l) {
    var c, h, u, d, f, p, m, g = i && i.__k || _p,
        y = g.length;
    if (a == An && (a = r != null ? r[0] : y ? Nc(i, 0) : null), c = 0, t.__k = yp(t.__k, function(x) {
            if (x != null) {
                if (x.__p = t, x.__b = t.__b + 1, (u = g[c]) === null || u && x.key == u.key && x.type === u.type) g[c] = void 0;
                else
                    for (h = 0; h < y; h++) {
                        if ((u = g[h]) && x.key == u.key && x.type === u.type) {
                            g[h] = void 0;
                            break
                        }
                        u = null
                    }
                if (d = bp(e, x, u = u || An, s, n, r, o, null, a, l), (h = x.ref) && u.ref != h && (m || (m = [])).push(h, x.__c || d, x), d != null) {
                    if (p == null && (p = d), x.l != null) d = x.l, x.l = null;
                    else if (r == u || d != a || d.parentNode == null) {
                        t: if (a == null || a.parentNode !== e) e.appendChild(d);
                            else {
                                for (f = a, h = 0;
                                    (f = f.nextSibling) && h < y; h += 2)
                                    if (f == d) break t;
                                e.insertBefore(d, a)
                            }t.type == "option" && (e.value = "")
                    }
                    a = d.nextSibling, typeof t.type == "function" && (t.l = d)
                }
            }
            return c++, x
        }), t.__e = p, r != null && typeof t.type != "function")
        for (c = r.length; c--;) r[c] != null && Uy(r[c]);
    for (c = y; c--;) g[c] != null && $y(g[c], g[c]);
    if (m)
        for (c = 0; c < m.length; c++) zy(m[c], m[++c], m[++c])
}

function yp(e, t, i) {
    if (i == null && (i = []), e == null || typeof e == "boolean") t && i.push(t(null));
    else if (Array.isArray(e))
        for (var s = 0; s < e.length; s++) yp(e[s], t, i);
    else i.push(t ? t(G7(e)) : e);
    return i
}

function V7(e, t, i, s, n) {
    var r;
    for (r in i) r in t || h0(e, r, null, i[r], s);
    for (r in t) n && typeof t[r] != "function" || r === "value" || r === "checked" || i[r] === t[r] || h0(e, r, t[r], i[r], s)
}

function c0(e, t, i) {
    t[0] === "-" ? e.setProperty(t, i) : e[t] = typeof i == "number" && U7.test(t) === !1 ? i + "px" : i ?? ""
}

function h0(e, t, i, s, n) {
    var r, o, a, l, c;
    if (!((t = n ? t === "className" ? "class" : t : t === "class" ? "className" : t) === "key" || t === "children"))
        if (t === "style")
            if (r = e.style, typeof i == "string") r.cssText = i;
            else {
                if (typeof s == "string" && (r.cssText = "", s = null), s)
                    for (o in s) i && o in i || c0(r, o, "");
                if (i)
                    for (a in i) s && i[a] === s[a] || c0(r, a, i[a])
            }
    else t[0] === "o" && t[1] === "n" ? (l = t !== (t = t.replace(/Capture$/, "")), c = t.toLowerCase(), t = (c in e ? c : t).slice(2), i ? (s || e.addEventListener(t, u0, l), (e.t || (e.t = {}))[t] = i) : e.removeEventListener(t, u0, l)) : t !== "list" && t !== "tagName" && t !== "form" && !n && t in e ? e[t] = i ?? "" : typeof i != "function" && t !== "dangerouslySetInnerHTML" && (t !== (t = t.replace(/^xlink:?/, "")) ? i == null || i === !1 ? e.removeAttributeNS("http://www.w3.org/1999/xlink", t.toLowerCase()) : e.setAttributeNS("http://www.w3.org/1999/xlink", t.toLowerCase(), i) : i == null || i === !1 ? e.removeAttribute(t) : e.setAttribute(t, i))
}

function u0(e) {
    return this.t[e.type](Pe.event ? Pe.event(e) : e)
}

function bp(e, t, i, s, n, r, o, a, l, c) {
    var h, u, d, f, p, m, g, y, x, v, _ = t.type;
    if (t.constructor !== void 0) return null;
    (h = Pe.__b) && h(t);
    try {
        t: if (typeof _ == "function") {
            if (y = t.props, x = (h = _.contextType) && s[h.__c], v = h ? x ? x.props.value : h.__p : s, i.__c ? g = (u = t.__c = i.__c).__p = u.__E : ("prototype" in _ && _.prototype.render ? t.__c = u = new _(y, v) : (t.__c = u = new bo(y, v), u.constructor = _, u.render = $7), x && x.sub(u), u.props = y, u.state || (u.state = {}), u.context = v, u.__n = s, d = u.__d = !0, u.__h = []), u.__s == null && (u.__s = u.state), _.getDerivedStateFromProps != null && En(u.__s == u.state ? u.__s = En({}, u.__s) : u.__s, _.getDerivedStateFromProps(y, u.__s)), d) _.getDerivedStateFromProps == null && u.componentWillMount != null && u.componentWillMount(), u.componentDidMount != null && o.push(u);
            else {
                if (_.getDerivedStateFromProps == null && a == null && u.componentWillReceiveProps != null && u.componentWillReceiveProps(y, v), !a && u.shouldComponentUpdate != null && u.shouldComponentUpdate(y, u.__s, v) === !1) {
                    for (u.props = y, u.state = u.__s, u.__d = !1, u.__v = t, t.__e = l != null ? l !== i.__e ? l : i.__e : null, t.__k = i.__k, h = 0; h < t.__k.length; h++) t.__k[h] && (t.__k[h].__p = t);
                    break t
                }
                u.componentWillUpdate != null && u.componentWillUpdate(y, u.__s, v)
            }
            for (f = u.props, p = u.state, u.context = v, u.props = y, u.state = u.__s, (h = Pe.__r) && h(t), u.__d = !1, u.__v = t, u.__P = e, h = u.render(u.props, u.state, u.context), t.__k = yp(h != null && h.type == Eh && h.key == null ? h.props.children : h), u.getChildContext != null && (s = En(En({}, s), u.getChildContext())), d || u.getSnapshotBeforeUpdate == null || (m = u.getSnapshotBeforeUpdate(f, p)), Hy(e, t, i, s, n, r, o, l, c), u.base = t.__e; h = u.__h.pop();) u.__s && (u.state = u.__s), h.call(u);
            d || f == null || u.componentDidUpdate == null || u.componentDidUpdate(f, p, m), g && (u.__E = u.__p = null)
        } else t.__e = z7(i.__e, t, i, s, n, r, o, c);
        (h = Pe.diffed) && h(t)
    }
    catch (C) {
        Pe.__e(C, t, i)
    }
    return t.__e
}

function Vy(e, t) {
    for (var i; i = e.pop();) try {
        i.componentDidMount()
    } catch (s) {
        Pe.__e(s, i.__v)
    }
    Pe.__c && Pe.__c(t)
}

function z7(e, t, i, s, n, r, o, a) {
    var l, c, h, u, d = i.props,
        f = t.props;
    if (n = t.type === "svg" || n, e == null && r != null) {
        for (l = 0; l < r.length; l++)
            if ((c = r[l]) != null && (t.type === null ? c.nodeType === 3 : c.localName === t.type)) {
                e = c, r[l] = null;
                break
            }
    }
    if (e == null) {
        if (t.type === null) return document.createTextNode(f);
        e = n ? document.createElementNS("http://www.w3.org/2000/svg", t.type) : document.createElement(t.type), r = null
    }
    return t.type === null ? d !== f && (r != null && (r[r.indexOf(e)] = null), e.data = f) : t !== i && (r != null && (r = _p.slice.call(e.childNodes)), h = (d = i.props || An).dangerouslySetInnerHTML, u = f.dangerouslySetInnerHTML, a || (u || h) && (u && h && u.__html == h.__html || (e.innerHTML = u && u.__html || "")), V7(e, f, d, n, a), t.__k = t.props.children, u || Hy(e, t, i, s, t.type !== "foreignObject" && n, r, o, An, a), a || ("value" in f && f.value !== void 0 && f.value !== e.value && (e.value = f.value == null ? "" : f.value), "checked" in f && f.checked !== void 0 && f.checked !== e.checked && (e.checked = f.checked))), e
}

function zy(e, t, i) {
    try {
        typeof e == "function" ? e(t) : e.current = t
    } catch (s) {
        Pe.__e(s, i)
    }
}

function $y(e, t, i) {
    var s, n, r;
    if (Pe.unmount && Pe.unmount(e), (s = e.ref) && zy(s, null, t), i || typeof e.type == "function" || (i = (n = e.__e) != null), e.__e = e.l = null, (s = e.__c) != null) {
        if (s.componentWillUnmount) try {
            s.componentWillUnmount()
        } catch (o) {
            Pe.__e(o, t)
        }
        s.base = s.__P = null
    }
    if (s = e.__k)
        for (r = 0; r < s.length; r++) s[r] && $y(s[r], t, i);
    n != null && Uy(n)
}

function $7(e, t, i) {
    return this.constructor(e, i)
}

function j7(e, t, i) {
    var s, n, r;
    Pe.__p && Pe.__p(e, t), n = (s = i === By) ? null : i && i.__k || t.__k, e = Lt(Eh, null, [e]), r = [], bp(t, s ? t.__k = e : (i || t).__k = e, n || An, An, t.ownerSVGElement !== void 0, i && !s ? [i] : n ? null : _p.slice.call(t.childNodes), r, !1, i || An, s), Vy(r, e)
}
Pe = {}, bo.prototype.setState = function(e, t) {
    var i = this.__s !== this.state && this.__s || (this.__s = En({}, this.state));
    (typeof e != "function" || (e = e(i, this.props))) && En(i, e), e != null && this.__v && (this.u = !1, t && this.__h.push(t), Tu(this))
}, bo.prototype.forceUpdate = function(e) {
    this.__v && (e && this.__h.push(e), this.u = !0, Tu(this))
}, bo.prototype.render = Eh, Dc = [], Fy = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, zd = Pe.debounceRendering, Pe.__e = function(e, t, i) {
    for (var s; t = t.__p;)
        if ((s = t.__c) && !s.__p) try {
            if (s.constructor && s.constructor.getDerivedStateFromError != null) s.setState(s.constructor.getDerivedStateFromError(e));
            else {
                if (s.componentDidCatch == null) continue;
                s.componentDidCatch(e)
            }
            return Tu(s.__E = s)
        } catch (n) {
            e = n
        }
    throw e
}, By = An;

function d0(e, t) {
    for (var i = 0; i < t.length; i++) {
        var s = t[i];
        s.enumerable = s.enumerable || !1, s.configurable = !0, "value" in s && (s.writable = !0), Object.defineProperty(e, s.key, s)
    }
}

function W7(e, t, i) {
    return t && d0(e.prototype, t), i && d0(e, i), e
}

function pi() {
    return pi = Object.assign || function(e) {
        for (var t = arguments, i = 1; i < arguments.length; i++) {
            var s = t[i];
            for (var n in s) Object.prototype.hasOwnProperty.call(s, n) && (e[n] = s[n])
        }
        return e
    }, pi.apply(this, arguments)
}
var X7 = "[-\\+]?\\d+%?",
    Y7 = "[-\\+]?\\d*\\.\\d+%?",
    pr = "(?:" + Y7 + ")|(?:" + X7 + ")",
    jy = "[\\s|\\(]+(" + pr + ")[,|\\s]+(" + pr + ")[,|\\s]+(" + pr + ")\\s*\\)?",
    Wy = "[\\s|\\(]+(" + pr + ")[,|\\s]+(" + pr + ")[,|\\s]+(" + pr + ")[,|\\s]+(" + pr + ")\\s*\\)?",
    K7 = new RegExp("rgb" + jy),
    Z7 = new RegExp("rgba" + Wy),
    q7 = new RegExp("hsl" + jy),
    J7 = new RegExp("hsla" + Wy),
    Sh = "^(?:#?|0x?)",
    mr = "([0-9a-fA-F]{1})",
    gr = "([0-9a-fA-F]{2})",
    Q7 = new RegExp(Sh + mr + mr + mr + "$"),
    tN = new RegExp(Sh + mr + mr + mr + mr + "$"),
    eN = new RegExp(Sh + gr + gr + gr + "$"),
    iN = new RegExp(Sh + gr + gr + gr + gr + "$"),
    sN = 2e3,
    nN = 4e4,
    zl = Math.log,
    Yr = Math.round,
    ha = Math.floor;

function Oi(e, t, i) {
    return Math.min(Math.max(e, t), i)
}

function di(e, t) {
    var i = e.indexOf("%") > -1,
        s = parseFloat(e);
    return i ? t / 100 * s : s
}

function fi(e) {
    return parseInt(e, 16)
}

function $n(e) {
    return e.toString(16).padStart(2, "0")
}
var co = function() {
        function e(i, s) {
            this.$ = {
                h: 0,
                s: 0,
                v: 0,
                a: 1
            }, i && this.set(i), this.onChange = s, this.initialValue = pi({}, this.$)
        }
        var t = e.prototype;
        return t.set = function(s) {
            if (typeof s == "string") /^(?:#?|0x?)[0-9a-fA-F]{3,8}$/.test(s) ? this.hexString = s : /^rgba?/.test(s) ? this.rgbString = s : /^hsla?/.test(s) && (this.hslString = s);
            else if (typeof s == "object") s instanceof e ? this.hsv = s.hsv : typeof s == "object" && "r" in s && "g" in s && "b" in s ? this.rgb = s : typeof s == "object" && "h" in s && "s" in s && "v" in s ? this.hsv = s : typeof s == "object" && "h" in s && "s" in s && "l" in s && (this.hsl = s);
            else throw new Error("Invalid color value")
        }, t.setChannel = function(s, n, r) {
            var o;
            this[s] = pi({}, this[s], (o = {}, o[n] = r, o))
        }, t.reset = function() {
            this.hsva = this.initialValue
        }, t.clone = function() {
            return new e(this)
        }, t.unbind = function() {
            this.onChange = void 0
        }, e.hsvToRgb = function(s) {
            var n = s.h / 60,
                r = s.s / 100,
                o = s.v / 100,
                a = ha(n),
                l = n - a,
                c = o * (1 - r),
                h = o * (1 - l * r),
                u = o * (1 - (1 - l) * r),
                d = a % 6,
                f = [o, h, c, c, u, o][d],
                p = [u, o, o, h, c, c][d],
                m = [c, c, u, o, o, h][d];
            return {
                r: Oi(f * 255, 0, 255),
                g: Oi(p * 255, 0, 255),
                b: Oi(m * 255, 0, 255)
            }
        }, e.rgbToHsv = function(s) {
            var n = s.r / 255,
                r = s.g / 255,
                o = s.b / 255,
                a = Math.max(n, r, o),
                l = Math.min(n, r, o),
                c = a - l,
                h = 0,
                u = a,
                d = a === 0 ? 0 : c / a;
            switch (a) {
                case l:
                    h = 0;
                    break;
                case n:
                    h = (r - o) / c + (r < o ? 6 : 0);
                    break;
                case r:
                    h = (o - n) / c + 2;
                    break;
                case o:
                    h = (n - r) / c + 4;
                    break
            }
            return {
                h: h * 60 % 360,
                s: Oi(d * 100, 0, 100),
                v: Oi(u * 100, 0, 100)
            }
        }, e.hsvToHsl = function(s) {
            var n = s.s / 100,
                r = s.v / 100,
                o = (2 - n) * r,
                a = o <= 1 ? o : 2 - o,
                l = a < 1e-9 ? 0 : n * r / a;
            return {
                h: s.h,
                s: Oi(l * 100, 0, 100),
                l: Oi(o * 50, 0, 100)
            }
        }, e.hslToHsv = function(s) {
            var n = s.l * 2,
                r = s.s * (n <= 100 ? n : 200 - n) / 100,
                o = n + r < 1e-9 ? 0 : 2 * r / (n + r);
            return {
                h: s.h,
                s: Oi(o * 100, 0, 100),
                v: Oi((n + r) / 2, 0, 100)
            }
        }, e.kelvinToRgb = function(s) {
            var n = s / 100,
                r, o, a;
            return n < 66 ? (r = 255, o = -155.25485562709179 - .44596950469579133 * (o = n - 2) + 104.49216199393888 * zl(o), a = n < 20 ? 0 : -254.76935184120902 + .8274096064007395 * (a = n - 10) + 115.67994401066147 * zl(a)) : (r = 351.97690566805693 + .114206453784165 * (r = n - 55) - 40.25366309332127 * zl(r), o = 325.4494125711974 + .07943456536662342 * (o = n - 50) - 28.0852963507957 * zl(o), a = 255), {
                r: Oi(ha(r), 0, 255),
                g: Oi(ha(o), 0, 255),
                b: Oi(ha(a), 0, 255)
            }
        }, e.rgbToKelvin = function(s) {
            for (var n = s.r, r = s.b, o = .4, a = sN, l = nN, c; l - a > o;) {
                c = (l + a) * .5;
                var h = e.kelvinToRgb(c);
                h.b / h.r >= r / n ? l = c : a = c
            }
            return c
        }, W7(e, [{
            key: "hsv",
            get: function() {
                var s = this.$;
                return {
                    h: s.h,
                    s: s.s,
                    v: s.v
                }
            },
            set: function(s) {
                var n = this.$;
                if (s = pi({}, n, s), this.onChange) {
                    var r = {
                        h: !1,
                        v: !1,
                        s: !1,
                        a: !1
                    };
                    for (var o in n) r[o] = s[o] != n[o];
                    this.$ = s, (r.h || r.s || r.v || r.a) && this.onChange(this, r)
                } else this.$ = s
            }
        }, {
            key: "hsva",
            get: function() {
                return pi({}, this.$)
            },
            set: function(s) {
                this.hsv = s
            }
        }, {
            key: "hue",
            get: function() {
                return this.$.h
            },
            set: function(s) {
                this.hsv = {
                    h: s
                }
            }
        }, {
            key: "saturation",
            get: function() {
                return this.$.s
            },
            set: function(s) {
                this.hsv = {
                    s
                }
            }
        }, {
            key: "value",
            get: function() {
                return this.$.v
            },
            set: function(s) {
                this.hsv = {
                    v: s
                }
            }
        }, {
            key: "alpha",
            get: function() {
                return this.$.a
            },
            set: function(s) {
                this.hsv = pi({}, this.hsv, {
                    a: s
                })
            }
        }, {
            key: "kelvin",
            get: function() {
                return e.rgbToKelvin(this.rgb)
            },
            set: function(s) {
                this.rgb = e.kelvinToRgb(s)
            }
        }, {
            key: "red",
            get: function() {
                var s = this.rgb;
                return s.r
            },
            set: function(s) {
                this.rgb = pi({}, this.rgb, {
                    r: s
                })
            }
        }, {
            key: "green",
            get: function() {
                var s = this.rgb;
                return s.g
            },
            set: function(s) {
                this.rgb = pi({}, this.rgb, {
                    g: s
                })
            }
        }, {
            key: "blue",
            get: function() {
                var s = this.rgb;
                return s.b
            },
            set: function(s) {
                this.rgb = pi({}, this.rgb, {
                    b: s
                })
            }
        }, {
            key: "rgb",
            get: function() {
                var s = e.hsvToRgb(this.$),
                    n = s.r,
                    r = s.g,
                    o = s.b;
                return {
                    r: Yr(n),
                    g: Yr(r),
                    b: Yr(o)
                }
            },
            set: function(s) {
                this.hsv = pi({}, e.rgbToHsv(s), {
                    a: s.a === void 0 ? 1 : s.a
                })
            }
        }, {
            key: "rgba",
            get: function() {
                return pi({}, this.rgb, {
                    a: this.alpha
                })
            },
            set: function(s) {
                this.rgb = s
            }
        }, {
            key: "hsl",
            get: function() {
                var s = e.hsvToHsl(this.$),
                    n = s.h,
                    r = s.s,
                    o = s.l;
                return {
                    h: Yr(n),
                    s: Yr(r),
                    l: Yr(o)
                }
            },
            set: function(s) {
                this.hsv = pi({}, e.hslToHsv(s), {
                    a: s.a === void 0 ? 1 : s.a
                })
            }
        }, {
            key: "hsla",
            get: function() {
                return pi({}, this.hsl, {
                    a: this.alpha
                })
            },
            set: function(s) {
                this.hsl = s
            }
        }, {
            key: "rgbString",
            get: function() {
                var s = this.rgb;
                return "rgb(" + s.r + ", " + s.g + ", " + s.b + ")"
            },
            set: function(s) {
                var n, r, o, a, l = 1;
                if ((n = K7.exec(s)) ? (r = di(n[1], 255), o = di(n[2], 255), a = di(n[3], 255)) : (n = Z7.exec(s)) && (r = di(n[1], 255), o = di(n[2], 255), a = di(n[3], 255), l = di(n[4], 1)), n) this.rgb = {
                    r,
                    g: o,
                    b: a,
                    a: l
                };
                else throw new Error("Invalid rgb string")
            }
        }, {
            key: "rgbaString",
            get: function() {
                var s = this.rgba;
                return "rgba(" + s.r + ", " + s.g + ", " + s.b + ", " + s.a + ")"
            },
            set: function(s) {
                this.rgbString = s
            }
        }, {
            key: "hexString",
            get: function() {
                var s = this.rgb;
                return "#" + $n(s.r) + $n(s.g) + $n(s.b)
            },
            set: function(s) {
                var n, r, o, a, l = 255;
                if ((n = Q7.exec(s)) ? (r = fi(n[1]) * 17, o = fi(n[2]) * 17, a = fi(n[3]) * 17) : (n = tN.exec(s)) ? (r = fi(n[1]) * 17, o = fi(n[2]) * 17, a = fi(n[3]) * 17, l = fi(n[4]) * 17) : (n = eN.exec(s)) ? (r = fi(n[1]), o = fi(n[2]), a = fi(n[3])) : (n = iN.exec(s)) && (r = fi(n[1]), o = fi(n[2]), a = fi(n[3]), l = fi(n[4])), n) this.rgb = {
                    r,
                    g: o,
                    b: a,
                    a: l / 255
                };
                else throw new Error("Invalid hex string")
            }
        }, {
            key: "hex8String",
            get: function() {
                var s = this.rgba;
                return "#" + $n(s.r) + $n(s.g) + $n(s.b) + $n(ha(s.a * 255))
            },
            set: function(s) {
                this.hexString = s
            }
        }, {
            key: "hslString",
            get: function() {
                var s = this.hsl;
                return "hsl(" + s.h + ", " + s.s + "%, " + s.l + "%)"
            },
            set: function(s) {
                var n, r, o, a, l = 1;
                if ((n = q7.exec(s)) ? (r = di(n[1], 360), o = di(n[2], 100), a = di(n[3], 100)) : (n = J7.exec(s)) && (r = di(n[1], 360), o = di(n[2], 100), a = di(n[3], 100), l = di(n[4], 1)), n) this.hsl = {
                    h: r,
                    s: o,
                    l: a,
                    a: l
                };
                else throw new Error("Invalid hsl string")
            }
        }, {
            key: "hslaString",
            get: function() {
                var s = this.hsla;
                return "hsl(" + s.h + ", " + s.s + "%, " + s.l + "%, " + s.a + ")"
            },
            set: function(s) {
                this.hslString = s
            }
        }]), e
    }(),
    rN = {
        sliderShape: "bar",
        sliderType: "value",
        minTemperature: 2200,
        maxTemperature: 11e3
    };

function xp(e) {
    var t, i = e.width,
        s = e.sliderSize,
        n = e.borderWidth,
        r = e.handleRadius,
        o = e.padding,
        a = e.sliderShape,
        l = e.layoutDirection === "horizontal";
    return s = (t = s) != null ? t : o * 2 + r * 2 + n * 2, a === "circle" ? {
        handleStart: e.padding + e.handleRadius,
        handleRange: i - o * 2 - r * 2 - n * 2,
        width: i,
        height: i,
        cx: i / 2,
        cy: i / 2,
        radius: i / 2 - n / 2
    } : {
        handleStart: s / 2,
        handleRange: i - s,
        radius: s / 2,
        x: 0,
        y: 0,
        width: l ? s : i,
        height: l ? i : s
    }
}

function oN(e, t) {
    var i = t.hsva,
        s = t.rgb;
    switch (e.sliderType) {
        case "red":
            return s.r / 2.55;
        case "green":
            return s.g / 2.55;
        case "blue":
            return s.b / 2.55;
        case "alpha":
            return i.a * 100;
        case "kelvin":
            var n = e.minTemperature,
                r = e.maxTemperature,
                o = r - n,
                a = (t.kelvin - n) / o * 100;
            return Math.max(0, Math.min(a, 100));
        case "hue":
            return i.h /= 3.6;
        case "saturation":
            return i.s;
        case "value":
        default:
            return i.v
    }
}

function aN(e, t, i) {
    var s = xp(e),
        n = s.handleRange,
        r = s.handleStart,
        o;
    e.layoutDirection === "horizontal" ? o = -1 * i + n + r : o = t - r, o = Math.max(Math.min(o, n), 0);
    var a = Math.round(100 / n * o);
    switch (e.sliderType) {
        case "kelvin":
            var l = e.minTemperature,
                c = e.maxTemperature,
                h = c - l;
            return l + h * (a / 100);
        case "alpha":
            return a / 100;
        case "hue":
            return a * 3.6;
        case "red":
        case "blue":
        case "green":
            return a * 2.55;
        default:
            return a
    }
}

function lN(e, t) {
    var i = xp(e),
        s = i.width,
        n = i.height,
        r = i.handleRange,
        o = i.handleStart,
        a = e.layoutDirection === "horizontal",
        l = oN(e, t),
        c = a ? s / 2 : n / 2,
        h = o + l / 100 * r;
    return a && (h = -1 * h + r + o * 2), {
        x: a ? c : h,
        y: a ? h : c
    }
}

function cN(e, t) {
    var i = t.hsv,
        s = t.rgb;
    switch (e.sliderType) {
        case "red":
            return [
                [0, "rgb(" + 0 + "," + s.g + "," + s.b + ")"],
                [100, "rgb(" + 255 + "," + s.g + "," + s.b + ")"]
            ];
        case "green":
            return [
                [0, "rgb(" + s.r + "," + 0 + "," + s.b + ")"],
                [100, "rgb(" + s.r + "," + 255 + "," + s.b + ")"]
            ];
        case "blue":
            return [
                [0, "rgb(" + s.r + "," + s.g + "," + 0 + ")"],
                [100, "rgb(" + s.r + "," + s.g + "," + 255 + ")"]
            ];
        case "alpha":
            return [
                [0, "rgba(" + s.r + "," + s.g + "," + s.b + ",0)"],
                [100, "rgb(" + s.r + "," + s.g + "," + s.b + ")"]
            ];
        case "kelvin":
            for (var n = [], r = e.minTemperature, o = e.maxTemperature, a = 8, l = o - r, c = r, h = 0; c < o; c += l / a, h += 1) {
                var u = co.kelvinToRgb(c),
                    d = u.r,
                    f = u.g,
                    p = u.b;
                n.push([100 / a * h, "rgb(" + d + "," + f + "," + p + ")"])
            }
            return n;
        case "hue":
            return [
                [0, "#f00"],
                [16.666, "#ff0"],
                [33.333, "#0f0"],
                [50, "#0ff"],
                [66.666, "#00f"],
                [83.333, "#f0f"],
                [100, "#f00"]
            ];
        case "saturation":
            var m = co.hsvToHsl({
                    h: i.h,
                    s: 0,
                    v: i.v
                }),
                g = co.hsvToHsl({
                    h: i.h,
                    s: 100,
                    v: i.v
                });
            return [
                [0, "hsl(" + m.h + "," + m.s + "%," + m.l + "%)"],
                [100, "hsl(" + g.h + "," + g.s + "%," + g.l + "%)"]
            ];
        case "value":
        default:
            var y = co.hsvToHsl({
                h: i.h,
                s: i.s,
                v: 100
            });
            return [
                [0, "#000"],
                [100, "hsl(" + y.h + "," + y.s + "%," + y.l + "%)"]
            ]
    }
}

function hN(e) {
    var t = e.layoutDirection === "horizontal";
    return {
        x1: "0%",
        y1: t ? "100%" : "0%",
        x2: t ? "0%" : "100%",
        y2: "0%"
    }
}

function wp(e) {
    var t = e.width / 2;
    return {
        width: e.width,
        radius: t - e.borderWidth,
        cx: t,
        cy: t
    }
}

function Tp(e, t, i) {
    var s = e.wheelAngle,
        n = e.wheelDirection;
    return !i && n === "clockwise" || i && n === "anticlockwise" ? t = (i ? 180 : 360) - (s - t) : t = s + t, (t % 360 + 360) % 360
}

function uN(e, t) {
    var i = t.hsv,
        s = wp(e),
        n = s.cx,
        r = s.cy,
        o = e.width / 2 - e.padding - e.handleRadius - e.borderWidth,
        a = (180 + Tp(e, i.h, !0)) * (Math.PI / 180),
        l = i.s / 100 * o,
        c = e.wheelDirection === "clockwise" ? -1 : 1;
    return {
        x: n + l * Math.cos(a) * c,
        y: r + l * Math.sin(a) * c
    }
}

function f0(e, t, i) {
    var s = wp(e),
        n = s.cx,
        r = s.cy,
        o = e.width / 2 - e.padding - e.handleRadius - e.borderWidth;
    t = n - t, i = r - i;
    var a = Tp(e, Math.atan2(-i, -t) * (180 / Math.PI)),
        l = Math.min(Math.sqrt(t * t + i * i), o);
    return {
        h: Math.round(a),
        s: Math.round(100 / o * l)
    }
}

function Ep(e) {
    var t = e.width,
        i = e.boxHeight,
        s = e.padding,
        n = e.handleRadius;
    return {
        width: t,
        height: i ?? t,
        radius: s + n
    }
}

function p0(e, t, i) {
    var s = Ep(e),
        n = s.width,
        r = s.height,
        o = s.radius,
        a = o,
        l = n - o * 2,
        c = r - o * 2,
        h = (t - a) / l * 100,
        u = (i - a) / c * 100;
    return {
        s: Math.max(0, Math.min(h, 100)),
        v: Math.max(0, Math.min(100 - u, 100))
    }
}

function dN(e, t) {
    var i = Ep(e),
        s = i.width,
        n = i.height,
        r = i.radius,
        o = t.hsv,
        a = r,
        l = s - r * 2,
        c = n - r * 2;
    return {
        x: a + o.s / 100 * l,
        y: a + (c - o.v / 100 * c)
    }
}

function fN(e, t) {
    var i = t.hue;
    return [
        [
            [0, "#fff"],
            [100, "hsl(" + i + ",100%,50%)"]
        ],
        [
            [0, "rgba(0,0,0,0)"],
            [100, "#000"]
        ]
    ]
}
var Eu;

function In(e) {
    Eu || (Eu = document.getElementsByTagName("base"));
    var t = window.navigator.userAgent,
        i = /^((?!chrome|android).)*safari/i.test(t),
        s = /iPhone|iPod|iPad/i.test(t),
        n = window.location;
    return (i || s) && Eu.length > 0 ? n.protocol + "//" + n.host + n.pathname + n.search + e : e
}

function pN(e, t, i, s, n) {
    var r = n - s <= 180 ? 0 : 1;
    s *= Math.PI / 180, n *= Math.PI / 180;
    var o = e + i * Math.cos(n),
        a = t + i * Math.sin(n),
        l = e + i * Math.cos(s),
        c = t + i * Math.sin(s);
    return "M " + o + " " + a + " A " + i + " " + i + " 0 " + r + " 0 " + l + " " + c
}

function Xy(e, t, i, s) {
    for (var n = 0; n < s.length; n++) {
        var r = s[n].x - t,
            o = s[n].y - i,
            a = Math.sqrt(r * r + o * o);
        if (a < e.handleRadius) return n
    }
    return null
}
var mN = {
        width: 300,
        height: 300,
        color: "#fff",
        colors: [],
        padding: 6,
        layoutDirection: "vertical",
        borderColor: "#fff",
        borderWidth: 0,
        handleRadius: 8,
        handleSvg: null,
        handleProps: {
            x: 0,
            y: 0
        },
        wheelLightness: !0,
        wheelAngle: 0,
        wheelDirection: "anticlockwise",
        sliderSize: null,
        sliderMargin: 12,
        boxHeight: null
    },
    m0 = ["mousemove", "touchmove", "mouseup", "touchend"],
    Ch = function(e) {
        function t(i) {
            e.call(this, i), this.uid = (Math.random() + 1).toString(36).substring(5)
        }
        return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.render = function(s) {
            var n = this.handleEvent.bind(this),
                r = {
                    onMouseDown: n,
                    ontouchstart: n
                },
                o = s.layoutDirection === "horizontal",
                a = s.margin === null ? s.sliderMargin : s.margin,
                l = {
                    overflow: "visible",
                    display: o ? "inline-block" : "block"
                };
            return s.index > 0 && (l[o ? "marginLeft" : "marginTop"] = a), Lt(Eh, null, s.children(this.uid, r, l))
        }, t.prototype.handleEvent = function(s) {
            var n = this,
                r = this.props.onInput,
                o = this.base.getBoundingClientRect();
            s.preventDefault();
            var a = s.touches ? s.changedTouches[0] : s,
                l = a.clientX - o.left,
                c = a.clientY - o.top;
            switch (s.type) {
                case "mousedown":
                case "touchstart":
                    m0.forEach(function(h) {
                        document.addEventListener(h, n, {
                            passive: !1
                        })
                    }), r(l, c, 0);
                    break;
                case "mousemove":
                case "touchmove":
                    r(l, c, 1);
                    break;
                case "mouseup":
                case "touchend":
                    r(l, c, 2), m0.forEach(function(h) {
                        document.removeEventListener(h, n)
                    });
                    break
            }
        }, t
    }(bo);

function Ir(e) {
    var t = e.r,
        i = e.url;
    return Lt("svg", {
        className: "IroHandle IroHandle--" + e.index + " " + (e.isActive ? "IroHandle--isActive" : ""),
        x: e.x,
        y: e.y,
        style: {
            overflow: "visible"
        }
    }, i && Lt("use", Object.assign({
        xlinkHref: In(i)
    }, e.props)), !i && Lt("circle", {
        r: t,
        fill: "none",
        "stroke-width": 2,
        stroke: "#000"
    }), !i && Lt("circle", {
        r: t - 2,
        fill: e.fill,
        "stroke-width": 2,
        stroke: "#fff"
    }))
}
Ir.defaultProps = {
    fill: "none",
    x: 0,
    y: 0,
    r: 8,
    url: null,
    props: {
        x: 0,
        y: 0
    }
};

function Fc(e) {
    var t = e.activeIndex,
        i = t !== void 0 && t < e.colors.length ? e.colors[t] : e.color,
        s = xp(e),
        n = s.width,
        r = s.height,
        o = s.radius,
        a = lN(e, i),
        l = cN(e, i),
        c = e.sliderType === "alpha";

    function h(u, d, f) {
        var p = aN(e, u, d);
        e.parent.inputActive = !0, i[e.sliderType] = p, e.onInput(f, e.id)
    }
    return Lt(Ch, Object.assign({}, e, {
        onInput: h
    }), function(u, d, f) {
        return Lt("svg", Object.assign({}, d, {
            className: "IroSlider",
            width: n,
            height: r,
            style: f
        }), Lt("defs", null, Lt("linearGradient", Object.assign({
            id: "g" + u
        }, hN(e)), l.map(function(p) {
            var m = p[0],
                g = p[1];
            return Lt("stop", {
                offset: m + "%",
                "stop-color": g
            })
        })), c && Lt("pattern", {
            id: "b" + u,
            width: "8",
            height: "8",
            patternUnits: "userSpaceOnUse"
        }, Lt("rect", {
            x: "0",
            y: "0",
            width: "8",
            height: "8",
            fill: "#fff"
        }), Lt("rect", {
            x: "0",
            y: "0",
            width: "4",
            height: "4",
            fill: "#ccc"
        }), Lt("rect", {
            x: "4",
            y: "4",
            width: "4",
            height: "4",
            fill: "#ccc"
        })), c && Lt("pattern", {
            id: "f" + u,
            width: "100%",
            height: "100%"
        }, Lt("rect", {
            x: "0",
            y: "0",
            width: "100%",
            height: "100%",
            fill: "url(" + In("#b" + u) + ")"
        }), Lt("rect", {
            x: "0",
            y: "0",
            width: "100%",
            height: "100%",
            fill: "url(" + In("#g" + u) + ")"
        }))), Lt("rect", {
            className: "IroSliderBg",
            rx: o,
            ry: o,
            x: e.borderWidth / 2,
            y: e.borderWidth / 2,
            width: n - e.borderWidth,
            height: r - e.borderWidth,
            "stroke-width": e.borderWidth,
            stroke: e.borderColor,
            fill: "url(" + In((c ? "#f" : "#g") + u) + ")"
        }), Lt(Ir, {
            isActive: !0,
            index: i.index,
            r: e.handleRadius,
            url: e.handleSvg,
            props: e.handleProps,
            x: a.x,
            y: a.y
        }))
    })
}
Fc.defaultProps = Object.assign({}, rN);

function gN(e) {
    var t = Ep(e),
        i = t.width,
        s = t.height,
        n = t.radius,
        r = e.colors,
        o = e.parent,
        a = e.activeIndex,
        l = a !== void 0 && a < e.colors.length ? e.colors[a] : e.color,
        c = fN(e, l),
        h = r.map(function(d) {
            return dN(e, d)
        });

    function u(d, f, p) {
        if (p === 0) {
            var m = Xy(e, d, f, h);
            m !== null ? o.setActiveColor(m) : (o.inputActive = !0, l.hsv = p0(e, d, f), e.onInput(p, e.id))
        } else p === 1 && (o.inputActive = !0, l.hsv = p0(e, d, f));
        e.onInput(p, e.id)
    }
    return Lt(Ch, Object.assign({}, e, {
        onInput: u
    }), function(d, f, p) {
        return Lt("svg", Object.assign({}, f, {
            className: "IroBox",
            width: i,
            height: s,
            style: p
        }), Lt("defs", null, Lt("linearGradient", {
            id: "s" + d,
            x1: "0%",
            y1: "0%",
            x2: "100%",
            y2: "0%"
        }, c[0].map(function(m) {
            var g = m[0],
                y = m[1];
            return Lt("stop", {
                offset: g + "%",
                "stop-color": y
            })
        })), Lt("linearGradient", {
            id: "l" + d,
            x1: "0%",
            y1: "0%",
            x2: "0%",
            y2: "100%"
        }, c[1].map(function(m) {
            var g = m[0],
                y = m[1];
            return Lt("stop", {
                offset: g + "%",
                "stop-color": y
            })
        })), Lt("pattern", {
            id: "f" + d,
            width: "100%",
            height: "100%"
        }, Lt("rect", {
            x: "0",
            y: "0",
            width: "100%",
            height: "100%",
            fill: "url(" + In("#s" + d) + ")"
        }), Lt("rect", {
            x: "0",
            y: "0",
            width: "100%",
            height: "100%",
            fill: "url(" + In("#l" + d) + ")"
        }))), Lt("rect", {
            className: "IroBoxBg",
            rx: n,
            ry: n,
            x: e.borderWidth / 2,
            y: e.borderWidth / 2,
            width: i - e.borderWidth,
            height: s - e.borderWidth,
            "stroke-width": e.borderWidth,
            stroke: e.borderColor,
            fill: "url(" + In("#f" + d) + ")"
        }), r.filter(function(m) {
            return m !== l
        }).map(function(m) {
            return Lt(Ir, {
                isActive: !1,
                index: m.index,
                fill: m.hslString,
                r: e.handleRadius,
                url: e.handleSvg,
                props: e.handleProps,
                x: h[m.index].x,
                y: h[m.index].y
            })
        }), Lt(Ir, {
            isActive: !0,
            index: l.index,
            fill: l.hslString,
            r: e.handleRadius,
            url: e.handleSvg,
            props: e.handleProps,
            x: h[l.index].x,
            y: h[l.index].y
        }))
    })
}
var vN = Array.apply(null, {
    length: 360
}).map(function(e, t) {
    return t
});

function Yy(e) {
    var t = wp(e),
        i = t.width,
        s = t.radius,
        n = t.cx,
        r = t.cy,
        o = e.colors,
        a = e.borderWidth,
        l = e.parent,
        c = e.color,
        h = c.hsv,
        u = o.map(function(f) {
            return uN(e, f)
        });

    function d(f, p, m) {
        if (m === 0) {
            var g = Xy(e, f, p, u);
            g !== null ? l.setActiveColor(g) : (l.inputActive = !0, c.hsv = f0(e, f, p), e.onInput(m, e.id))
        } else m === 1 && (l.inputActive = !0, c.hsv = f0(e, f, p));
        e.onInput(m, e.id)
    }
    return Lt(Ch, Object.assign({}, e, {
        onInput: d
    }), function(f, p, m) {
        return Lt("svg", Object.assign({}, p, {
            className: "IroWheel",
            width: i,
            height: i,
            style: m
        }), Lt("defs", null, Lt("radialGradient", {
            id: f
        }, Lt("stop", {
            offset: "0%",
            "stop-color": "#fff"
        }), Lt("stop", {
            offset: "100%",
            "stop-color": "#fff",
            "stop-opacity": "0"
        }))), Lt("g", {
            className: "IroWheelHue",
            "stroke-width": s,
            fill: "none"
        }, vN.map(function(g) {
            return Lt("path", {
                key: g,
                d: pN(n, r, s / 2, g, g + 1.5),
                stroke: "hsl(" + Tp(e, g) + ", 100%, 50%)"
            })
        })), Lt("circle", {
            className: "IroWheelSaturation",
            cx: n,
            cy: r,
            r: s,
            fill: "url(" + In("#" + f) + ")"
        }), e.wheelLightness && Lt("circle", {
            className: "IroWheelLightness",
            cx: n,
            cy: r,
            r: s,
            fill: "#000",
            opacity: 1 - h.v / 100
        }), Lt("circle", {
            className: "IroWheelBorder",
            cx: n,
            cy: r,
            r: s,
            fill: "none",
            stroke: e.borderColor,
            "stroke-width": a
        }), o.filter(function(g) {
            return g !== c
        }).map(function(g) {
            return Lt(Ir, {
                isActive: !1,
                index: g.index,
                fill: g.hslString,
                r: e.handleRadius,
                url: e.handleSvg,
                props: e.handleProps,
                x: u[g.index].x,
                y: u[g.index].y
            })
        }), Lt(Ir, {
            isActive: !0,
            index: c.index,
            fill: c.hslString,
            r: e.handleRadius,
            url: e.handleSvg,
            props: e.handleProps,
            x: u[c.index].x,
            y: u[c.index].y
        }))
    })
}

function _N(e) {
    var t = function(i, s) {
        var n, r = document.createElement("div");
        j7(Lt(e, Object.assign({}, {
            ref: function(a) {
                return n = a
            }
        }, s)), r);

        function o() {
            var a = i instanceof Element ? i : document.querySelector(i);
            a.appendChild(n.base), n.onMount(a)
        }
        return document.readyState !== "loading" ? o() : document.addEventListener("DOMContentLoaded", o), n
    };
    return t.prototype = e.prototype, Object.assign(t, e), t.__component = e, t
}
var Ky = function(e) {
    function t(i) {
        var s = this;
        e.call(this, i), this.colors = [], this.inputActive = !1, this.events = {}, this.activeEvents = {}, this.deferredEvents = {}, this.id = i.id;
        var n = i.colors.length > 0 ? i.colors : [i.color];
        n.forEach(function(r) {
            return s.addColor(r)
        }), this.setActiveColor(0), this.state = Object.assign({}, i, {
            color: this.color,
            colors: this.colors,
            layout: i.layout
        })
    }
    return e && (t.__proto__ = e), t.prototype = Object.create(e && e.prototype), t.prototype.constructor = t, t.prototype.addColor = function(s, n) {
        n === void 0 && (n = this.colors.length);
        var r = new co(s, this.onColorChange.bind(this));
        this.colors.splice(n, 0, r), this.colors.forEach(function(o, a) {
            return o.index = a
        }), this.state && this.setState({
            colors: this.colors
        }), this.deferredEmit("color:init", r)
    }, t.prototype.removeColor = function(s) {
        var n = this.colors.splice(s, 1)[0];
        n.unbind(), this.colors.forEach(function(r, o) {
            return r.index = o
        }), this.state && this.setState({
            colors: this.colors
        }), n.index === this.color.index && this.setActiveColor(0), this.emit("color:remove", n)
    }, t.prototype.setActiveColor = function(s) {
        this.color = this.colors[s], this.state && this.setState({
            color: this.color
        }), this.emit("color:setActive", this.color)
    }, t.prototype.setColors = function(s) {
        var n = this;
        this.colors.forEach(function(r) {
            return r.unbind()
        }), this.colors = [], s.forEach(function(r) {
            return n.addColor(r)
        }), this.setActiveColor(0), this.emit("color:setAll", this.colors)
    }, t.prototype.on = function(s, n) {
        var r = this,
            o = this.events;
        (Array.isArray(s) ? s : [s]).forEach(function(a) {
            (o[a] || (o[a] = [])).push(n), r.deferredEvents[a] && (r.deferredEvents[a].forEach(function(l) {
                n.apply(null, l)
            }), r.deferredEvents[a] = [])
        })
    }, t.prototype.off = function(s, n) {
        var r = this;
        (Array.isArray(s) ? s : [s]).forEach(function(o) {
            var a = r.events[o];
            a && a.splice(a.indexOf(n), 1)
        })
    }, t.prototype.emit = function(s) {
        for (var n = this, r = [], o = arguments.length - 1; o-- > 0;) r[o] = arguments[o + 1];
        var a = this.activeEvents,
            l = a.hasOwnProperty(s) ? a[s] : !1;
        if (!l) {
            a[s] = !0;
            var c = this.events[s] || [];
            c.forEach(function(h) {
                return h.apply(n, r)
            }), a[s] = !1
        }
    }, t.prototype.deferredEmit = function(s) {
        for (var n, r = [], o = arguments.length - 1; o-- > 0;) r[o] = arguments[o + 1];
        var a = this.deferredEvents;
        (n = this).emit.apply(n, [s].concat(r)), (a[s] || (a[s] = [])).push(r)
    }, t.prototype.setOptions = function(s) {
        this.setState(Object.assign({}, this.state, s))
    }, t.prototype.resize = function(s) {
        this.setOptions({
            width: s
        })
    }, t.prototype.reset = function() {
        this.colors.forEach(function(s) {
            return s.reset()
        }), this.setState({
            colors: this.colors
        })
    }, t.prototype.onMount = function(s) {
        this.el = s, this.deferredEmit("mount", this)
    }, t.prototype.onColorChange = function(s, n) {
        this.setState({
            color: this.color
        }), this.inputActive && (this.inputActive = !1, this.emit("input:change", s, n)), this.emit("color:change", s, n)
    }, t.prototype.emitInputEvent = function(s, n) {
        s === 0 ? this.emit("input:start", this.color, n) : s === 1 ? this.emit("input:move", this.color, n) : s === 2 && this.emit("input:end", this.color, n)
    }, t.prototype.render = function(s, n) {
        var r = this,
            o = n.layout;
        if (!Array.isArray(o)) {
            switch (o) {
                default:
                    o = [{
                        component: Yy
                    }, {
                        component: Fc
                    }]
            }
            n.transparency && o.push({
                component: Fc,
                options: {
                    sliderType: "alpha"
                }
            })
        }
        return Lt("div", {
            class: "IroColorPicker",
            id: n.id,
            style: {
                display: n.display
            }
        }, o.map(function(a, l) {
            var c = a.component,
                h = a.options;
            return Lt(c, Object.assign({}, n, h, {
                ref: void 0,
                onInput: r.emitInputEvent.bind(r),
                parent: r,
                index: l
            }))
        }))
    }, t
}(bo);
Ky.defaultProps = Object.assign({}, mN, {
    colors: [],
    display: "block",
    id: null,
    layout: "default",
    margin: null
});
var yN = _N(Ky),
    jd;
(function(e) {
    e.version = "5.3.1", e.Color = co, e.ColorPicker = yN,
        function(t) {
            t.h = Lt, t.ComponentBase = Ch, t.Handle = Ir, t.Slider = Fc, t.Wheel = Yy, t.Box = gN
        }(e.ui || (e.ui = {}))
})(jd || (jd = {}));
var $l = jd;
const bN = {
        name: "color-picker",
        props: {
            currTheme: String
        },
        components: {
            "theme-slider": Oy,
            "theme-switch": Ly
        },
        setup(e, {
            emit: t
        }) {
            const i = Ft(() => B7[yi("locale").value]);
            let s = null;
            const n = ft(null),
                r = ft(""),
                o = ft(1),
                a = Ft(() => r.value.slice(1)),
                l = Ft(() => ({
                    backgroundColor: r.value,
                    opacity: o.value
                }));
            let c = !1;
            const h = ft(!1),
                u = ft(""),
                d = ft(!1),
                f = ft(null),
                p = ft("25"),
                m = ft("0"),
                g = ft(!1),
                y = ft(null);
            let x = null;

            function v(P) {
                const N = parseInt(P, 16);
                return {
                    r: N >> 16 & 255,
                    g: N >> 8 & 255,
                    b: N & 255
                }
            }

            function _({
                target: P
            }) {
                const {
                    value: N
                } = P;
                /^#([a-fA-F\d]{6}|[a-fA-F\d]{3})$/.test(N) ? s.color.set({
                    ...v(N.slice(1)),
                    a: o.value
                }) : P.value = r.value
            }

            function C() {
                t("regain")
            }

            function k(P) {
                f.value = P, L()
            }

            function S(P) {
                y.value = y.value & 3 | P << 2, L()
            }

            function T({
                target: P
            }) {
                const {
                    value: N
                } = P;
                /^(0(\.\d{1,2})?|1(\.0{1,2})?)$/.test(N) ? s.color.setChannel("rgba", "a", N) : P.value = o.value
            }

            function L() {
                if (!x || c) return;
                const P = B[x];
                g.value ? t("changeVal", [a.value, o.value, f.value, y.value]) : d.value ? t("changeVal", [a.value, o.value, f.value, P[3]]) : h.value ? t("changeVal", [a.value, o.value, u.value]) : t("changeVal", [a.value, o.value])
            }

            function D({
                hexString: P,
                alpha: N
            }) {
                o.value = N, (r.value || P !== "#ffffff") && (r.value = P), L()
            }

            function O() {
                t("changeVal", [a.value, o.value, u.value])
            }

            function K(P) {
                c = !0, x = P;
                const N = B[P];
                P == "BackgroundImage" ? (h.value = !0, u.value = N[2]) : h.value = !1, N.length == 4 ? (d.value = !0, f.value = N[2]) : d.value = !1, N[3] & 2 ? m.value = "10" : m.value = "0", N[3] & 1 ? (g.value = !0, y.value = N[3]) : g.value = !1;
                const [W, V] = N;
                W ? (r.value = `#${W}`, o.value = V, s.color.set({
                    ...v(W),
                    a: V
                })) : (r.value = W, o.value = V, s.color.set({
                    r: 255,
                    g: 255,
                    b: 255,
                    a: V
                })), c = !1
            }
            return Ve(() => {
                s = new $l.ColorPicker(n.value, {
                    width: 205,
                    padding: -2,
                    margin: 36,
                    handleRadius: 9,
                    layoutDirection: "horizontal",
                    layout: [{
                        component: $l.ui.Wheel,
                        options: {
                            borderWidth: 1
                        }
                    }, {
                        component: $l.ui.Slider,
                        options: {
                            sliderType: "value"
                        }
                    }, {
                        component: $l.ui.Slider,
                        options: {
                            sliderType: "alpha"
                        }
                    }]
                }), s.on("color:change", D)
            }), {
                t: i,
                pickerEl: n,
                hex: r,
                alpha: o,
                showBgUrl: h,
                url: u,
                style: l,
                showSize: d,
                size: f,
                max: p,
                min: m,
                showSwitch: g,
                teamColor: y,
                regain: C,
                hexCheck: _,
                alphaCheck: T,
                sizeCheck: k,
                switchCheck: S,
                backgroundChange: O,
                bind: K
            }
        }
    },
    xN = {
        class: "color-picker"
    },
    wN = {
        class: "picker-container"
    },
    TN = {
        ref: "pickerEl"
    },
    EN = {
        class: "picker-input"
    },
    SN = ["value"],
    CN = ["value"],
    AN = {
        class: "picker-input"
    },
    IN = ["placeholder"];

function MN(e, t, i, s, n, r) {
    const o = se("theme-slider"),
        a = se("theme-switch");
    return st(), nt("div", xN, [b("button", {
        class: "btn btn-dark rounded-0 default-btn",
        onClick: t[0] || (t[0] = (...l) => s.regain && s.regain(...l))
    }, Ot(s.t.default), 1), b("div", wN, [b("div", TN, null, 512)]), b("div", EN, [b("div", {
        class: "color-preview",
        style: $t(s.style)
    }, null, 4), b("input", {
        class: "rounded-0 form-control menu-input hex-input",
        type: "text",
        value: s.hex,
        onBlur: t[1] || (t[1] = (...l) => s.hexCheck && s.hexCheck(...l))
    }, null, 40, SN), b("input", {
        class: "rounded-0 form-control menu-input alpha-input",
        type: "text",
        value: s.alpha,
        onBlur: t[2] || (t[2] = (...l) => s.alphaCheck && s.alphaCheck(...l))
    }, null, 40, CN)]), ee(b("div", AN, [ee(b("input", {
        class: "rounded-0 form-control menu-input background-input",
        type: "text",
        placeholder: s.t.bgUrl,
        maxlength: "128",
        "onUpdate:modelValue": t[3] || (t[3] = l => s.url = l),
        onBlur: t[4] || (t[4] = (...l) => s.backgroundChange && s.backgroundChange(...l))
    }, null, 40, IN), [
        [nr, s.url]
    ])], 512), [
        [ye, s.showBgUrl]
    ]), ee(X(o, {
        class: "theme-slider",
        name: s.t.size,
        min: s.min,
        max: s.max,
        step: "0.5",
        val: s.size,
        onChangeVal: t[5] || (t[5] = l => s.sizeCheck(l))
    }, null, 8, ["name", "min", "max", "step", "val"]), [
        [ye, s.showSize]
    ]), ee(X(a, {
        class: "theme-switch",
        name: s.t.teamColor,
        val: s.teamColor & 4,
        onChangeVal: t[6] || (t[6] = l => s.switchCheck(l))
    }, null, 8, ["name", "val"]), [
        [ye, s.showSwitch]
    ])])
}
var RN = ue(bN, [
    ["render", MN],
    ["__scopeId", "data-v-e190b4ce"]
]);
const kN = {
        name: "theme-radio",
        props: {
            id: String,
            checked: Number,
            options: Array
        },
        setup(e, {
            emit: t
        }) {
            function i(s) {
                t("changeVal", Number(s.target.value))
            }
            return {
                change: i
            }
        }
    },
    PN = {
        class: "radio-row"
    },
    LN = {
        class: "radio-box"
    },
    ON = ["id", "value", "checked"],
    DN = ["for"];

function NN(e, t, i, s, n, r) {
    return st(), nt("div", PN, [b("div", LN, [(st(!0), nt(Dt, null, Jt(i.options, (o, a) => (st(), nt("div", {
        class: "radio-btn",
        key: a
    }, [b("input", {
        type: "radio",
        id: "radio-" + i.id + a,
        value: a,
        checked: i.checked === a,
        onChange: t[0] || (t[0] = (...l) => s.change && s.change(...l))
    }, null, 40, ON), b("label", {
        for: "radio-" + i.id + a
    }, Ot(o), 9, DN)]))), 128))])])
}
var FN = ue(kN, [
    ["render", NN],
    ["__scopeId", "data-v-6e5a62d6"]
]);
const BN = {
        name: "theme-pane",
        components: {
            "common-select": pp,
            "sub-nav": mp,
            "btn-group": gp,
            "dividing-line": vp,
            "picker-button": L7,
            "color-picker": RN,
            "theme-radio": FN
        },
        setup() {
            const e = Ft(() => I7[yi("locale").value]),
                t = Ft(() => [{
                    href: "theme-entity-tab",
                    text: e.value.display.name,
                    func: () => f(0),
                    active: !0
                }, {
                    href: "theme-background-tab",
                    text: e.value.map.name,
                    func: () => f(1)
                }, {
                    href: "theme-hud-tab",
                    text: "HUD",
                    func: () => f(2)
                }]),
                i = ft(0);

            function s(y) {
                i.value = y, f(0, y * 2 + 6)
            }
            const n = ft(-1),
                r = _i([0, 0, 0, 0]),
                o = ft(null),
                a = new Map;
            let l = 0,
                c = 0;
            const h = e.value.content;
            Object.keys(nc).forEach(y => {
                const x = h[l],
                    v = l == 0 ? 24 : x.length;
                c < v || (l++, c = 0), a.set(l + "-" + c, y), c++
            });
            const u = ft(null);

            function d(y, x) {
                return {
                    backgroundColor: n.value === y && r[y] === x ? "var(--slider-selection-color)" : "rgba(20, 20, 20, 0.15)"
                }
            }

            function f(y, x) {
                n.value = y, arguments.length === 2 ? r[y] = x : x = r[y], u.value = a.get(y + "-" + x), o.value.bind(u.value)
            }

            function p(y) {
                const x = u.value;
                B[x] = y, A.emit(Ht[x]), localStorage.setItem("theme_data", JSON.stringify(B))
            }

            function m() {
                const y = u.value;
                B[y] = nc[y], A.emit(Ht[y]), localStorage.setItem("theme_data", JSON.stringify(B)), o.value.bind(u.value)
            }

            function g() {
                const y = n.value,
                    x = h[y],
                    v = y == 0 ? 23 : x.length;
                for (let _ = 0; _ < v; _++) {
                    const C = a.get(y + "-" + _);
                    console.log(C), B[C] = nc[C], A.emit(Ht[C])
                }
                localStorage.setItem("theme_data", JSON.stringify(B)), o.value.bind(u.value)
            }
            return Ve(() => f(0, 0)), {
                t: e,
                tabs: t,
                playerType: i,
                playerTypeChange: s,
                picker: o,
                currTheme: u,
                backgroundColor: d,
                coordChange: f,
                change: p,
                regain: m,
                reset: g
            }
        }
    },
    Sp = e => (gs("data-v-7a02e428"), e = e(), vs(), e),
    UN = {
        class: "tab-pane",
        id: "setting-theme"
    },
    GN = {
        class: "tab-content"
    },
    HN = {
        class: "tab-pane active",
        id: "theme-entity-tab"
    },
    VN = {
        class: "container-inline"
    },
    zN = {
        class: "container-col picker-col"
    },
    $N = Sp(() => b("div", {
        class: "container-col picker-col"
    }, null, -1)),
    jN = {
        class: "tab-pane",
        id: "theme-background-tab"
    },
    WN = {
        class: "container-inline"
    },
    XN = {
        class: "container-col picker-col"
    },
    YN = Sp(() => b("div", {
        class: "container-col picker-col"
    }, null, -1)),
    KN = {
        class: "tab-pane",
        id: "theme-hud-tab"
    },
    ZN = {
        class: "container-inline"
    },
    qN = {
        class: "container-col picker-col"
    },
    JN = Sp(() => b("div", {
        class: "container-col picker-col"
    }, null, -1));

function QN(e, t, i, s, n, r) {
    const o = se("sub-nav"),
        a = se("dividing-line"),
        l = se("theme-radio"),
        c = se("btn-group"),
        h = se("picker-button"),
        u = se("color-picker");
    return st(), nt("div", UN, [X(o, {
        tabs: s.tabs
    }, null, 8, ["tabs"]), b("div", GN, [b("div", HN, [b("div", VN, [b("div", zN, [X(a, {
        name: s.t.display.divide.basic
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(6, (d, f) => X(De("picker-button"), {
        style: $t(s.backgroundColor(0, f)),
        key: f,
        name: s.t.content[0][f],
        onClick: p => s.coordChange(0, f)
    }, null, 8, ["style", "name", "onClick"])), 64)), X(a, {
        name: s.t.display.divide.player
    }, null, 8, ["name"]), X(l, {
        id: "tPlayerType",
        checked: s.playerType,
        options: s.t.playerType,
        onChangeVal: s.playerTypeChange
    }, null, 8, ["checked", "options", "onChangeVal"]), (st(), nt(Dt, null, Jt(3, (d, f) => X(De("picker-button"), {
        style: $t(s.backgroundColor(0, f + 6 + s.playerType * 3)),
        key: f + 6 + s.playerType * 3,
        name: s.t.content[0][f + 6],
        onClick: p => s.coordChange(0, f + 6 + s.playerType * 3)
    }, null, 8, ["style", "name", "onClick"])), 64)), X(a, {
        name: s.t.display.divide.assistance
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(6, (d, f) => X(De("picker-button"), {
        style: $t(s.backgroundColor(0, f + 18)),
        key: f + 18,
        name: s.t.content[0][f + 9],
        onClick: p => s.coordChange(0, f + 18)
    }, null, 8, ["style", "name", "onClick"])), 64))]), $N]), X(c, {
        reset: !0,
        onOnReset: s.reset
    }, null, 8, ["onOnReset"])]), b("div", jN, [b("div", WN, [b("div", XN, [X(a, {
        name: s.t.map.divide.basic
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(6, (d, f) => X(De("picker-button"), {
        style: $t(s.backgroundColor(1, f)),
        key: f,
        name: s.t.content[1][f],
        onClick: p => s.coordChange(1, f)
    }, null, 8, ["style", "name", "onClick"])), 64))]), YN]), X(c, {
        reset: !0,
        onOnReset: s.reset
    }, null, 8, ["onOnReset"])]), b("div", KN, [b("div", ZN, [b("div", qN, [X(a, {
        name: s.t.HUD.divide.minimap
    }, null, 8, ["name"]), (st(), nt(Dt, null, Jt(7, (d, f) => X(De("picker-button"), {
        style: $t(s.backgroundColor(2, f)),
        key: f,
        name: s.t.content[2][f],
        onClick: p => s.coordChange(2, f)
    }, null, 8, ["style", "name", "onClick"])), 64)), X(a, {
        name: s.t.HUD.divide.leaderboard
    }, null, 8, ["name"]), X(h, {
        style: $t(s.backgroundColor(2, 7)),
        name: s.t.content[2][7],
        onClick: t[0] || (t[0] = d => s.coordChange(2, 7))
    }, null, 8, ["style", "name"]), X(a, {
        name: s.t.HUD.divide.teamRankings
    }, null, 8, ["name"]), X(h, {
        style: $t(s.backgroundColor(2, 8)),
        name: s.t.content[2][8],
        onClick: t[1] || (t[1] = d => s.coordChange(2, 8))
    }, null, 8, ["style", "name"]), X(a, {
        name: s.t.HUD.divide.perfPanel
    }, null, 8, ["name"]), X(h, {
        style: $t(s.backgroundColor(2, 9)),
        name: s.t.content[2][9],
        onClick: t[2] || (t[2] = d => s.coordChange(2, 9))
    }, null, 8, ["style", "name"])]), JN]), X(c, {
        reset: !0,
        onOnReset: s.reset
    }, null, 8, ["onOnReset"])])]), X(u, {
        ref: "picker",
        currTheme: s.currTheme,
        onChangeVal: s.change,
        onRegain: s.regain
    }, null, 8, ["currTheme", "onChangeVal", "onRegain"])])
}
var t9 = ue(BN, [
    ["render", QN],
    ["__scopeId", "data-v-7a02e428"]
]);
const e9 = {
        name: "setting-menu",
        components: {
            "gamesetting-pane": ID,
            "hotkey-pane": T7,
            "theme-pane": t9
        },
        setup() {
            function e(t) {
                document.getElementById("setting-gamesetting").classList.remove("show", "active"), document.getElementById("setting-hotkey").classList.remove("show", "active"), document.getElementById("setting-theme").classList.remove("show", "active"), document.getElementById(t).classList.add("show", "active")
            }
            return {
                click: e
            }
        }
    },
    Zy = e => (gs("data-v-2a52a778"), e = e(), vs(), e),
    i9 = {
        id: "setting-menu",
        action: "javascript:;"
    },
    s9 = {
        class: "nav setting-nav"
    },
    n9 = Zy(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        fill: "var(--main-theme-color)"
    }, [b("path", {
        d: "M800 128c57.6 32 96 83.2 121.6 140.8 12.8 32 25.6 64 32 96 12.8 32 19.2 70.4 25.6 108.8 6.4 38.4 12.8 70.4 12.8 108.8 0 32 6.4 70.4 6.4 102.4 0 25.6-6.4 51.2-19.2 76.8-38.4 76.8-121.6 102.4-198.4 64-25.6-12.8-38.4-25.6-51.2-44.8-12.8-19.2-25.6-32-32-51.2-19.2-38.4-44.8-70.4-76.8-89.6-57.6-38.4-160-38.4-217.6 0-32 19.2-51.2 51.2-76.8 89.6-6.4 19.2-19.2 38.4-32 51.2-12.8 19.2-32 32-51.2 44.8-108.8 51.2-211.2-25.6-217.6-140.8 0-32 0-70.4 6.4-102.4 0-32 6.4-70.4 12.8-108.8 0-38.4 12.8-70.4 19.2-108.8 6.4-32 19.2-64 32-96 32-57.6 70.4-108.8 128-140.8 76.8-44.8 147.2-38.4 217.6-32 25.6 0 44.8 6.4 70.4 6.4 25.6 0 44.8 0 70.4-6.4 76.8-6.4 140.8-12.8 217.6 32zM454.4 492.8c-12.8 0-25.6-12.8-25.6-19.2 6.4-12.8 12.8-25.6 25.6-25.6h115.2c12.8 0 25.6 12.8 25.6 25.6s-12.8 19.2-25.6 19.2H454.4z m0-204.8c-12.8 0-25.6-12.8-25.6-19.2 0-12.8 12.8-25.6 25.6-25.6h115.2c12.8 0 25.6 12.8 25.6 25.6s-12.8 19.2-25.6 19.2H454.4z m-153.6-25.6c0-12.8 12.8-25.6 19.2-25.6 12.8 0 25.6 12.8 25.6 25.6v83.2h83.2c12.8 0 19.2 6.4 19.2 19.2 0 12.8-12.8 25.6-25.6 25.6H345.6v83.2c0 12.8-12.8 25.6-25.6 25.6s-19.2-12.8-19.2-25.6V390.4H224c-12.8 0-19.2-12.8-19.2-25.6s12.8-25.6 19.2-25.6h83.2V262.4h-6.4z m403.2 0c19.2 0 38.4 19.2 38.4 38.4s-19.2 38.4-38.4 38.4-38.4-19.2-38.4-38.4 19.2-38.4 38.4-38.4z m-25.6 102.4c0 19.2-19.2 38.4-38.4 38.4s-38.4-19.2-38.4-38.4 19.2-38.4 38.4-38.4c19.2 6.4 38.4 19.2 38.4 38.4z m25.6 32c19.2 0 38.4 19.2 38.4 38.4s-19.2 38.4-38.4 38.4-38.4-19.2-38.4-38.4c0-25.6 19.2-38.4 38.4-38.4z m102.4-32c0 19.2-19.2 38.4-38.4 38.4s-38.4-19.2-38.4-38.4 19.2-38.4 38.4-38.4c25.6 6.4 38.4 19.2 38.4 38.4zM761.6 192c-57.6-32-115.2-25.6-172.8-19.2H512c-25.6 0-51.2 0-76.8-6.4-64 0-121.6-6.4-172.8 25.6-44.8 25.6-76.8 64-96 108.8-12.8 25.6-19.2 57.6-32 83.2-6.4 32-12.8 70.4-19.2 102.4-6.4 32-6.4 64-12.8 102.4 0 32-6.4 64 0 96 0 19.2 6.4 32 12.8 44.8 25.6 57.6 89.6 51.2 128 6.4 0-12.8 12.8-32 19.2-44.8 25.6-51.2 57.6-89.6 96-115.2 83.2-57.6 217.6-57.6 300.8 0 38.4 25.6 70.4 64 96 115.2 6.4 12.8 19.2 32 25.6 38.4 38.4 44.8 102.4 51.2 128-6.4 6.4-12.8 12.8-25.6 12.8-44.8V582.4c0-32-6.4-64-12.8-102.4-6.4-32-12.8-64-25.6-102.4-6.4-32-19.2-64-32-89.6-12.8-32-44.8-70.4-89.6-96z",
        fill: "",
        "p-id": "31375"
    })], -1)),
    r9 = [n9],
    o9 = Zy(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        fill: "var(--main-theme-color)",
        width: "24",
        height: "24"
    }, [b("path", {
        d: "M870.108 408.615 870.108 307.646 769.139 307.646l0 100.969L870.108 408.615zM870.108 562.453 870.108 461.484 769.139 461.484l0 100.969L870.108 562.453zM716.27 408.615 716.27 307.646 615.301 307.646l0 100.969L716.27 408.615zM716.27 562.453 716.27 461.484 615.301 461.484l0 100.969L716.27 562.453zM716.27 769.212 716.27 665.832 307.625 665.832l0 103.379L716.27 769.211zM254.756 408.615 254.756 307.646 153.787 307.646l0 100.969L254.756 408.615zM254.756 562.453 254.756 461.484 153.787 461.484l0 100.969L254.756 562.453zM307.676 461.535l0 100.969 100.969 0L408.645 461.535 307.676 461.535zM307.676 307.697l0 100.969 100.969 0L408.645 307.697 307.676 307.697zM461.514 461.535l0 100.969 100.969 0L562.483 461.535 461.514 461.535zM461.514 307.697l0 100.969 100.969 0L562.483 307.697 461.514 307.697zM923.028 153.859c27.246 0 50.886 10.017 70.919 30.05s30.05 43.673 30.05 70.919l0 514.383c0 27.246-10.017 50.886-30.05 70.919s-43.673 30.05-70.919 30.05L100.969 870.18c-27.246 0-50.886-10.017-70.919-30.05S0 796.458 0 769.212L0 254.828c0-27.246 10.017-50.886 30.05-70.919s43.673-30.05 70.919-30.05L923.028 153.859z"
    })], -1)),
    a9 = [o9],
    l9 = ih('<svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" fill="var(--main-theme-color)" width="24" height="24" data-v-2a52a778><path d="M517.78756813 963.02833313c-248.20624839 0-450.14412281-201.93786116-450.14412292-450.14412274s201.93786116-450.14412281 450.14412292-450.14412293 450.14412281 201.93786116 450.14412269 450.14412293c0 110.01201254-54.54782202 174.46299818-176.8584166 208.99548464-18.13438105 5.1444977-34.40386711 7.25053268-56.09117547 7.25053245-7.3469941 0-15.54605323-0.24115299-25.04729943-0.67521515a469.43601209 469.43601209 0 0 0-20.4493977-0.51445125c-36.55813255 0-45.46455228 5.56250078-59.16180948 26.09228721-12.13781811 18.19868433-15.41743385 34.01803535 3.68154668 61.05883651 1.55942577 2.21856863 3.05100963 4.38890686 5.11233931 6.97723435l5.56250076 7.29876343c17.10547892 22.47505743 31.49401053 45.49671041 19.9349601 79.64335214l-1.89704011 5.59464564-3.42430764 4.8229824C629.53584301 961.27598479 594.40853004 963.02833313 517.78756813 963.02833313z m0-819.90536181c-203.88313189 0-369.76123919 165.87810694-369.76123914 369.76123907s165.87810694 369.76123919 369.76123914 369.76123899c37.2976513 0 55.09443111-0.90028283 64.30630705-2.79732269-0.41798999-0.57875404-0.90028283-1.18966641-1.38258884-1.81665161l-5.53034276-7.25053241a322.01381491 322.01381491 0 0 1-6.88077321-9.3726402c-36.23660395-51.26820641-37.89249105-102.4238655-4.87119975-151.95579598 34.24310269-51.34858158 75.05799728-61.89481598 126.04034521-61.894816 7.45952764 0 15.43350624 0.22506734 24.05055567 0.61089915 26.68711402 1.17359408 39.86990654 0.83597968 55.65711286-3.64937491 88.51762698-24.98299647 118.35575041-58.18112471 118.35575039-131.63500434 0.01607252-203.88313189-165.84594893-369.76123919-369.74516662-369.76123907z" data-v-2a52a778></path><path d="M300.75380167 440.53962147m-56.26802518 0a56.26801236 56.26801236 0 1 0 112.53603734 0 56.26801236 56.26801236 0 1 0-112.53603734 0Z" data-v-2a52a778></path><path d="M734.82133467 440.53962147m-56.26801214 0a56.26801236 56.26801236 0 1 0 112.53603733 0 56.26801236 56.26801236 0 1 0-112.53603733 0Z" data-v-2a52a778></path><path d="M429.3664027 295.85044411m-56.26801231 0a56.26801236 56.26801236 0 1 0 112.53602443 0 56.26801236 56.26801236 0 1 0-112.53602443 0Z" data-v-2a52a778></path><path d="M606.2087337 295.85044411m-56.26801201 0a56.26801236 56.26801236 0 1 0 112.5360242 0 56.26801236 56.26801236 0 1 0-112.5360242 0Z" data-v-2a52a778></path></svg>', 1),
    c9 = [l9],
    h9 = {
        class: "tab-content setting-container"
    };

function u9(e, t, i, s, n, r) {
    const o = se("gamesetting-pane"),
        a = se("hotkey-pane"),
        l = se("theme-pane");
    return st(), nt("div", i9, [b("nav", s9, [b("a", {
        class: "nav-link active",
        onClick: t[0] || (t[0] = c => s.click("setting-gamesetting")),
        "data-bs-toggle": "pill"
    }, r9), b("a", {
        class: "nav-link",
        onClick: t[1] || (t[1] = c => s.click("setting-hotkey")),
        "data-bs-toggle": "pill"
    }, a9), b("a", {
        class: "nav-link",
        onClick: t[2] || (t[2] = c => s.click("setting-theme")),
        "data-bs-toggle": "pill"
    }, c9)]), b("div", h9, [X(o), X(a), X(l)])])
}
var d9 = ue(e9, [
    ["render", u9],
    ["__scopeId", "data-v-2a52a778"]
]);
const f9 = {
        global: "\u5168\u670D",
        all: "\u5168\u90E8",
        team: "\u961F\u4F0D",
        server: "\u670D\u52A1\u5668"
    },
    p9 = {
        global: "\u5168\u670D",
        all: "\u5168\u90E8",
        team: "\u968A\u4F0D",
        server: "\u4F3A\u670D\u5668"
    },
    m9 = {
        global: "\u30B0\u30ED\u30FC\u30D0\u30EB",
        all: "\u5168\u3066",
        team: "\u30C1\u30FC\u30E0",
        server: "\u30B5\u30FC\u30D0\u30FC"
    },
    g9 = {
        global: "GLOBAL",
        all: "ALL",
        team: "TEAM",
        server: "SERVER"
    };
var qy = {
    zh_CN: f9,
    zh: p9,
    ja: m9,
    en: g9
};
const v9 = {
        name: "chat-text",
        props: {
            time: String,
            type: Number,
            nick: String,
            msg: String,
            skin: String,
            player: Object
        },
        setup(e) {
            const t = Ft(() => e.type == 4),
                i = e.type != 4,
                s = Ft(() => {
                    const n = qy[yi("locale").value],
                        r = o => "[" + o + "]";
                    return [r(n.global), r(n.all), r(n.team), r(n.private), n.server]
                });
            return {
                emitter: A,
                showType: t,
                nonServer: i,
                displayTypes: s
            }
        }
    },
    _9 = {
        class: "chat-text"
    },
    y9 = {
        class: "chat-time"
    },
    b9 = {
        class: "chat-msg"
    };

function x9(e, t, i, s, n, r) {
    return st(), nt("p", _9, [b("span", y9, Ot(i.time), 1), ee(b("span", {
        class: "chat-skin",
        style: $t({
            "background-image": i.skin
        }),
        onClick: t[0] || (t[0] = o => s.emitter.emit("checkPlayer", i.player))
    }, null, 4), [
        [ye, i.skin]
    ]), ee(b("span", {
        class: "chat-type"
    }, Ot(s.displayTypes[i.type]), 513), [
        [ye, s.showType]
    ]), ee(b("span", {
        class: "chat-nick"
    }, Ot(" " + i.nick + " "), 513), [
        [ye, s.nonServer]
    ]), b("span", b9, Ot(i.msg), 1)])
}
var w9 = ue(v9, [
    ["render", x9],
    ["__scopeId", "data-v-7bc95e5d"]
]);
const T9 = {
        name: "common-select",
        props: {
            class: String,
            selected: {
                type: Number,
                default: 0
            },
            options: {
                type: Array,
                default: []
            }
        },
        setup(e, {
            emit: t
        }) {
            const i = ft(null),
                s = Ft(() => e.options.length * -32.5 + "px"),
                n = Ft(() => e.selected * -32.5 + "px"),
                r = ft("(0deg)");
            let o = !1;

            function a() {
                i.value.classList.contains("open") || i.value.classList.add("open"), i.value.style.cssText = "--t:" + s.value, r.value = "(180deg)"
            }

            function l() {
                o || (i.value.classList.remove("open"), i.value.style.cssText = "--t: 32.5px", r.value = "(0deg)")
            }

            function c(h) {
                h !== e.selected && (t("change", h), o = !0, setTimeout(() => {
                    i.value.classList.remove("open"), o = !1, l()
                }, 240))
            }
            return Ve(() => {
                i.value.classList.add(e.class), i.value.style.cssText = "--t: 32.5px"
            }), {
                o: s,
                t: n,
                r,
                menu: i,
                open: a,
                close: l,
                change: c
            }
        }
    },
    E9 = e => (gs("data-v-e30b3338"), e = e(), vs(), e),
    S9 = {
        "data-menu": ""
    },
    C9 = ["value", "selected"],
    A9 = E9(() => b("path", {
        d: "M533.333333 465.066667L358.4 640 298.666667 580.266667l234.666666-234.666667 234.666667 234.666667-64 59.733333-170.666667-174.933333z"
    }, null, -1)),
    I9 = [A9],
    M9 = ["onClick"];

function R9(e, t, i, s, n, r) {
    return st(), nt("div", {
        class: "select-menu rounded-0",
        ref: "menu",
        tabindex: "-1",
        onBlur: t[1] || (t[1] = (...o) => s.close && s.close(...o))
    }, [b("select", S9, [(st(!0), nt(Dt, null, Jt(i.options, (o, a) => (st(), nt("option", {
        key: a,
        value: a,
        selected: i.selected === a
    }, Ot(o), 9, C9))), 128))]), b("div", {
        class: "select-button",
        style: $t({
            "--t": s.t
        }),
        onClick: t[0] || (t[0] = (...o) => s.open && s.open(...o))
    }, [(st(), nt("svg", {
        class: "select-status",
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        fill: "#707070",
        style: $t({
            transform: "rotateZ" + s.r
        })
    }, I9, 4)), b("ul", null, [(st(!0), nt(Dt, null, Jt(i.options, (o, a) => (st(), nt("li", {
        key: a
    }, Ot(o), 1))), 128))])], 4), b("ul", null, [(st(!0), nt(Dt, null, Jt(i.options, (o, a) => (st(), nt("li", {
        key: a,
        onClick: l => s.change(a)
    }, Ot(o), 9, M9))), 128))])], 544)
}
var Jy = ue(T9, [
    ["render", R9],
    ["__scopeId", "data-v-e30b3338"]
]);
const k9 = {
        name: "chat-input",
        components: {
            "common-select": Jy
        },
        props: {
            type: Number,
            toId: Number
        },
        setup(e, {
            emit: t
        }) {
            const i = ft(null),
                s = ft(0),
                n = ft(""),
                r = new Vt(() => {
                    if (s.value ^= 1, !s.value) {
                        if (document.querySelector("canvas").focus(), n.value) {
                            if (at.SANDBOX && n.value == "/tp") {
                                U.tp ^= 1;
                                const u = `INFO: 
TP mode ` + (U.tp ? "enabled" : "disabled");
                                A.emit("receiveChatMsg", {
                                    type: 4,
                                    id: 0,
                                    msg: u
                                })
                            } else n.value.charAt(0) == "/" ? (at.writer.writeUint8(25).writeStringUTF8(n.value), at.send()) : e.type == 3 ? (at.writer.writeUint8(24).writeUint8(3).writeStringUTF8(n.value).writeUint16(e.toId), at.send()) : e.type != 0 && (at.writer.writeUint8(24).writeUint8(e.type).writeStringUTF8(n.value), at.send());
                            n.value = ""
                        }
                        a()
                    }
                });

            function o() {
                t("show")
            }

            function a() {
                t("hide"), s.value = 0, A.emit("focusGameCanvas")
            }
            let l = !1;

            function c(u) {
                if (l) return;
                const {
                    code: d
                } = u;
                (d === "Enter" || d === "NumpadEnter") && r.execute(), d === "Tab" && u.preventDefault()
            }

            function h(u) {
                if (l) return;
                const {
                    code: d
                } = u;
                (d === "Enter" || d === "NumpadEnter") && r.end(), d === "Tab" && u.preventDefault()
            }
            return Ve(() => {
                document.addEventListener("keydown", c), document.addEventListener("keyup", h), document.addEventListener("compositionstart", () => l = !0), document.addEventListener("compositionend", () => l = !1)
            }), Pr(() => {
                s.value === 1 && i.value.focus()
            }), {
                emitter: A,
                input: i,
                inputState: s,
                msg: n,
                focus: o,
                blur: a
            }
        }
    },
    P9 = {
        key: 0,
        id: "chat-input"
    };

function L9(e, t, i, s, n, r) {
    return s.inputState ? (st(), nt("div", P9, [ee(b("input", {
        class: "btn-dark rounded-0 form-control",
        type: "text",
        maxlength: "256",
        size: "256",
        ref: "input",
        "onUpdate:modelValue": t[0] || (t[0] = o => s.msg = o),
        onFocus: t[1] || (t[1] = (...o) => s.focus && s.focus(...o))
    }, null, 544), [
        [nr, s.msg]
    ])])) : FS("", !0)
}
var O9 = ue(k9, [
    ["render", L9],
    ["__scopeId", "data-v-6677b75f"]
]);
const D9 = {
        name: "notice-input",
        setup(e) {
            const t = ft("");
            A.on("syncNotice", l => {
                t.value = U.notice
            }), A.on("saveEdition", () => {
                A.emit("sendNotice", t.value)
            });

            function i() {
                document.addEventListener("keydown", n), document.addEventListener("keyup", r), document.addEventListener("compositionstart", o), document.addEventListener("compositionend", a)
            }

            function s() {
                document.removeEventListener("keydown", n), document.removeEventListener("keyup", r), document.removeEventListener("compositionstart", o), document.removeEventListener("compositionend", a)
            }

            function n(l) {
                const {
                    code: c
                } = l;
                c === "Tab" && l.preventDefault()
            }

            function r(l) {
                const {
                    code: c
                } = l;
                c === "Tab" && l.preventDefault()
            }

            function o(l) {
                document.removeEventListener("keydown", n), document.removeEventListener("keyup", r)
            }

            function a(l) {
                document.addEventListener("keydown", n), document.addEventListener("keyup", r)
            }
            return {
                msg: t,
                focus: i,
                blur: s,
                compositionstart: o,
                compositionend: a
            }
        }
    },
    N9 = {
        class: "chat-input"
    };

function F9(e, t, i, s, n, r) {
    return st(), nt("div", N9, [ee(b("textarea", {
        class: "btn-dark rounded-0 form-control",
        type: "text",
        maxlength: "256",
        size: "256",
        "onUpdate:modelValue": t[0] || (t[0] = o => s.msg = o),
        onFocus: t[1] || (t[1] = (...o) => s.focus && s.focus(...o)),
        onBlur: t[2] || (t[2] = (...o) => s.blur && s.blur(...o))
    }, null, 544), [
        [nr, s.msg]
    ])])
}
var B9 = ue(D9, [
    ["render", F9],
    ["__scopeId", "data-v-547ea6a2"]
]);
const ja = ft(0),
    Cp = Ft(() => {
        const e = [];
        return zt.size && (zt.forEach(t => {
            if (!t.isBot && t.enableChat) {
                if (ja.value && !t.isTeammate) return;
                e.push(t)
            }
        }), zt.forEach(t => {
            if (!t.isBot && !t.enableChat) {
                if (ja.value && !t.isTeammate) return;
                e.push(t)
            }
        })), e
    }),
    Ap = Ft(() => {
        let e = 0;
        return zt.forEach(t => {
            if (t.activity) {
                if (ja.value && !t.isTeammate) return;
                e += 1
            }
        }), e
    }),
    Qy = Ft(() => Cp.value.length - Ap.value),
    U9 = {
        name: "chat-menu",
        components: {
            "notice-input": B9
        },
        props: {
            player: Object,
            options: Array
        },
        setup(e) {
            const t = ft(!1),
                i = Ft(() => {
                    const f = e.player;
                    return f ? f.id == U.id : !1
                }),
                s = ft(!1);

            function n(f) {
                e.player.block = !0, xn.push(f.bfp), localStorage.setItem("blocked_users", JSON.stringify(xn))
            }

            function r(f) {
                e.player.block = !1, xn.splice(xn.indexOf(f.bfp), 1), localStorage.setItem("blocked_users", JSON.stringify(xn))
            }

            function o() {
                H.EnableChat ^= 1;
                const f = document.getElementById("chat-switch");
                H.EnableChat ? f.style.fill = "#33FF33" : f.style.fill = "#CC0000", A.emit("updateChatState"), localStorage.setItem("gconfig", JSON.stringify(H))
            }

            function a() {
                A.emit("syncNotice"), t.value = !0
            }

            function l() {
                A.emit("saveEdition"), t.value = !1
            }

            function c() {
                t.value = !1
            }

            function h(f) {
                ja.value = f
            }

            function u(f) {
                return f.enableChat ? "#33FF33" : "#CC0000"
            }

            function d(f) {
                const p = f.latency - 75,
                    m = f.latency - 125,
                    g = f.latency - 200,
                    y = Math.max(Math.min(p / (125 - 75), 1), 0),
                    x = Math.max(Math.min(m / (200 - 125), 1), 0),
                    v = Math.max(Math.min(g / (300 - 200), 1), 0),
                    _ = 255 * y - 51 * x - 102 * v << 16 | 255 * (1 - x) << 8 | 0;
                return Qa(_)
            }
            return Ve(() => {
                const f = document.getElementById("chat-switch");
                H.EnableChat ? f.style.fill = "#33FF33" : f.style.fill = "#CC0000"
            }), Pr(() => {}), {
                emitter: A,
                editing: t,
                isSelf: i,
                inputNotice: s,
                block: n,
                unblock: r,
                checkSkin: lo,
                changeChatUsability: o,
                editNotice: a,
                saveEdition: l,
                cancelEdition: c,
                play: Ap,
                spec: Qy,
                listType: ja,
                list: Cp,
                changeListType: h,
                getOnlineColor: u,
                getLatencyColor: d
            }
        }
    },
    ln = e => (gs("data-v-82e9339a"), e = e(), vs(), e),
    G9 = {
        id: "chat-menu"
    },
    H9 = {
        class: "player-profile"
    },
    V9 = {
        class: "player-avatar-border"
    },
    z9 = {
        id: "btn-group-1"
    },
    $9 = ln(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "22",
        height: "22",
        fill: "var(--main-theme-color)",
        transform: "translate(0,0)"
    }, [b("path", {
        d: "M896 832h-246.4L512 960.48 374.4 832H128a96 96 0 0 1-96-96V160a96 96 0 0 1 96-96h768a96 96 0 0 1 96 96v576a96 96 0 0 1-96 96z m32-672a32 32 0 0 0-32-32H128a32 32 0 0 0-32 32v576a32 32 0 0 0 32 32h275.616L512 869.152 620.352 768H896a32 32 0 0 0 32-32V160z m-192 352a64 64 0 1 1 64-64 64 64 0 0 1-64 64z m-224 0a64 64 0 1 1 64-64 64 64 0 0 1-64 64z m-224 0a64 64 0 1 1 64-64 64 64 0 0 1-64 64z"
    })], -1)),
    j9 = [$9],
    W9 = ln(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "19",
        height: "19",
        fill: "var(--main-theme-color)",
        transform: "translate(0,0)"
    }, [b("path", {
        d: "M512 12.624658C235.660274 12.624658 11.221918 238.465753 11.221918 513.40274c0 276.339726 224.438356 500.778082 500.778082 500.778082 276.339726 0 500.778082-224.438356 500.778082-500.778082C1012.778082 238.465753 788.339726 12.624658 512 12.624658z m0 70.136986c106.608219 0 203.39726 39.276712 277.742466 102.4L183.758904 792.547945c-64.526027-75.747945-102.4-172.536986-102.4-277.742466 0-238.465753 193.578082-432.043836 430.641096-432.043835z m0 861.282192c-106.608219 0-203.39726-39.276712-277.742466-102.4l605.983562-605.983562c64.526027 75.747945 102.4 172.536986 102.4 277.742466 0 238.465753-193.578082 430.641096-430.641096 430.641096z"
    })], -1)),
    X9 = [W9],
    Y9 = ln(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "22",
        height: "22",
        fill: "var(--main-theme-color)",
        transform: "translate(0,-0.5)"
    }, [b("path", {
        d: "M922.8 338.3c-22.5-53.2-54.7-101-95.7-142s-88.8-73.2-142-95.7C630 77.3 571.5 65.5 511.2 65.5c-60.3 0-118.8 11.8-173.9 35.1-53.2 22.5-101 54.7-142 95.7s-73.2 88.8-95.7 142c-23.3 55.1-35.1 113.6-35.1 173.9S76.3 631 99.6 686.1c22.5 53.2 54.7 101 95.7 142s88.8 73.2 142 95.7c55.1 23.3 113.6 35.1 173.9 35.1 60.3 0 118.8-11.8 173.9-35.1 53.2-22.5 101-54.7 142-95.7s73.2-88.8 95.7-142c23.3-55.1 35.1-113.6 35.1-173.9s-11.8-118.8-35.1-173.9z m-141 444.5c-72.3 72.3-168.4 112.1-270.6 112.1s-198.3-39.8-270.6-112.1c-72.3-72.3-112.1-168.4-112.1-270.6 0-102.2 39.8-198.3 112.1-270.6 72.3-72.3 168.4-112.1 270.6-112.1s198.3 39.8 270.6 112.1S893.9 410 893.9 512.2c0 102.2-39.8 198.4-112.1 270.6z"
    }), b("path", {
        d: "M766.9 385.5c-12.5-12.5-32.8-12.5-45.3 0L449 658.2 302.2 511.5c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3l169.4 169.4c12.5 12.5 32.8 12.5 45.3 0L767 430.8c12.4-12.6 12.4-32.8-0.1-45.3z"
    })], -1)),
    K9 = [Y9],
    Z9 = {
        id: "btn-group-2"
    },
    q9 = ln(() => b("svg", {
        id: "chat-switch",
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "22",
        height: "22",
        transform: "translate(0,-0.5)"
    }, [b("path", {
        d: "M561.312102 68.191078l-98.624205 0 0 493.121024 98.624205 0L561.312102 68.191078zM799.735283 174.951591l-69.77618 69.77618c77.420277 63.36619 127.225613 159.27761 127.225613 267.271206 0 190.590779-154.592914 345.184717-345.184717 345.184717S166.815283 702.590779 166.815283 512c0-107.993596 49.805336-203.905016 127.225613-267.271206l-69.77618-69.77618C129.0911 256.316713 68.191078 376.884696 68.191078 512c0 245.080811 198.72811 443.808922 443.808922 443.808922s443.808922-198.72811 443.808922-443.808922C955.808922 376.884696 894.907876 256.316713 799.735283 174.951591z"
    })], -1)),
    J9 = [q9],
    Q9 = ln(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "22",
        height: "22",
        fill: "var(--main-theme-color)",
        transform: "translate(0,0)"
    }, [b("path", {
        d: "M927.692008 304.704873c17.665497 0 31.937622 14.37193 31.937622 31.937622v586.853801c0 17.665497-14.272125 31.937622-31.937622 31.937622h-828.382066c-17.665497 0-31.937622-14.272125-31.937622-31.937622v-586.853801c0-17.665497 14.272125-31.937622 31.937622-31.937622h156.793762c8.683041 0 17.066667-3.493177 23.05497-9.780896L490.545809 75.153216c12.575439-13.074464 33.434698-13.074464 46.010136 0l211.28733 219.770761c6.088109 6.287719 14.37193 9.780897 23.054971 9.780896h156.793762z m-564.397661 0h300.413255L513.500975 152.801559 363.294347 304.704873z m532.460039 63.875244h-764.506823v522.978557h764.506823v-522.978557z m-592.842105 148.809357c-19.761404 0-35.929825-14.37193-35.929825-31.937622s16.168421-31.937622 35.929825-31.937622h401.615594c19.761404 0 35.929825 14.37193 35.929825 31.937622s-16.168421 31.937622-35.929825 31.937622H302.912281zM797.047173 591.844055c19.761404 0 35.929825 14.37193 35.929825 31.937621s-16.168421 31.937622-35.929825 31.937622H210.392982c-19.761404 0-35.929825-14.37193-35.929824-31.937622s16.168421-31.937622 35.929824-31.937621h586.654191zM298.121637 730.872515c19.761404 0 35.929825 14.37193 35.929825 31.937621s-16.168421 31.937622-35.929825 31.937622h-83.037816c-19.761404 0-35.929825-14.37193-35.929825-31.937622s16.168421-31.937622 35.929825-31.937621h83.037816z m494.134893-0.299416c19.761404 0 35.929825 14.37193 35.929825 31.937622s-16.168421 31.937622-35.929825 31.937622H424.674464c-19.761404 0-35.929825-14.37193-35.929825-31.937622s16.168421-31.937622 35.929825-31.937622h367.582066z"
    })], -1)),
    tF = [Q9],
    eF = {
        id: "btn-group-3"
    },
    iF = ln(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "22",
        height: "22",
        fill: "var(--main-theme-color)",
        transform: "translate(0,-0.5)"
    }, [b("path", {
        d: "M377.8 832.3c-12.5 0-25-4.8-34.5-14.3L76.5 551.2c-19.1-19.1-19.1-50 0-69.1 19.1-19.1 50-19.1 69.1 0L412.4 749c19.1 19.1 19.1 50 0 69.1-9.6 9.5-22.1 14.2-34.6 14.2z"
    }), b("path", {
        d: "M377.8 832.3c-12.5 0-25-4.8-34.5-14.3-19.1-19.1-19.1-50 0-69.1L877 215.3c19.1-19.1 50-19.1 69.1 0s19.1 50 0 69.1L412.4 818c-9.6 9.6-22.1 14.3-34.6 14.3z"
    })], -1)),
    sF = [iF],
    nF = ln(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "20",
        height: "20",
        fill: "var(--main-theme-color)",
        transform: "translate(-1,0.5)"
    }, [b("path", {
        d: "M839.68 899.072c-13.312 0-26.624-5.12-36.864-15.36l-655.36-675.84c-19.456-20.48-18.944-52.736 1.024-72.192 20.48-19.456 52.736-18.944 72.192 1.024l655.36 675.84c19.456 20.48 18.944 52.736-1.024 72.192-9.728 9.728-22.528 14.336-35.328 14.336z"
    }), b("path", {
        d: "M174.08 888.832c-13.312 0-26.624-5.12-36.864-15.36-19.456-20.48-18.944-52.736 1.024-72.192l675.84-655.36c20.48-19.456 52.736-18.944 72.192 1.024 19.456 20.48 18.944 52.736-1.024 72.192l-675.84 655.36c-9.728 9.728-22.528 14.336-35.328 14.336z"
    })], -1)),
    rF = [nF],
    oF = {
        class: "scroll-box"
    },
    aF = {
        class: "player-nick"
    },
    lF = {
        class: "player-notice"
    },
    cF = {
        id: "player-list"
    },
    hF = {
        class: "player-list-top"
    },
    uF = ln(() => b("div", {
        class: "player-list-top-fill"
    }, null, -1)),
    dF = {
        class: "player-list-inner"
    },
    fF = {
        class: "player-list-item"
    },
    pF = ["onClick"],
    mF = ln(() => b("path", {
        d: "M514.048 128q79.872 0 149.504 30.208t121.856 82.432 82.432 122.368 30.208 150.016q0 78.848-30.208 148.48t-82.432 121.856-121.856 82.432-149.504 30.208-149.504-30.208-121.856-82.432-82.432-121.856-30.208-148.48q0-79.872 30.208-150.016t82.432-122.368 121.856-82.432 149.504-30.208z"
    }, null, -1)),
    gF = [mF],
    vF = {
        class: "item-nick"
    };

function _F(e, t, i, s, n, r) {
    const o = se("notice-input");
    return st(), nt("div", G9, [b("div", H9, [b("div", V9, [b("div", {
        class: "player-avatar",
        style: $t({
            backgroundImage: s.checkSkin(i.player)
        })
    }, null, 4), ee(b("div", z9, [b("button", {
        class: "btn rounded-0 first-btn chat-menu-btn",
        type: "button",
        onClick: t[0] || (t[0] = a => s.emitter.emit("openDM"))
    }, j9), ee(b("button", {
        class: "btn rounded-0 second-btn chat-menu-btn",
        type: "button",
        onClick: t[1] || (t[1] = a => s.block(i.player))
    }, X9, 512), [
        [ye, i.player && !i.player.block]
    ]), ee(b("button", {
        class: "btn rounded-0 second-btn chat-menu-btn",
        type: "button",
        onClick: t[2] || (t[2] = a => s.unblock(i.player))
    }, K9, 512), [
        [ye, i.player && i.player.block]
    ])], 512), [
        [ye, !s.editing && !s.isSelf && i.player]
    ]), ee(b("div", Z9, [b("button", {
        class: "btn rounded-0 first-btn chat-menu-btn",
        type: "button",
        onClick: t[3] || (t[3] = a => s.changeChatUsability())
    }, J9), b("button", {
        class: "btn rounded-0 second-btn chat-menu-btn",
        type: "button",
        onClick: t[4] || (t[4] = a => s.editNotice())
    }, tF)], 512), [
        [ye, !s.editing && s.isSelf]
    ]), ee(b("div", eF, [b("button", {
        class: "btn rounded-0 first-btn chat-menu-btn",
        type: "button",
        onClick: t[5] || (t[5] = a => s.saveEdition())
    }, sF), b("button", {
        class: "btn rounded-0 second-btn chat-menu-btn",
        type: "button",
        onClick: t[6] || (t[6] = a => s.cancelEdition())
    }, rF)], 512), [
        [ye, s.editing]
    ])]), ee(b("div", oF, [ee(b("p", {
        class: "player-tag"
    }, Ot(i.player ? i.player.tag : ""), 513), [
        [ye, i.player && i.player.tag]
    ]), b("p", aF, Ot(i.player ? i.player.nick : ""), 1), b("p", lF, Ot(i.player ? i.player.notice : ""), 1)], 512), [
        [ye, !s.editing]
    ]), ee(X(o, {
        class: Ai("notice-input")
    }, null, 512), [
        [ye, s.editing]
    ])]), b("div", cF, [b("div", hF, [b("div", {
        class: Ai("list-option" + (s.listType == 0 ? " active" : "")),
        onClick: t[7] || (t[7] = a => s.changeListType(0))
    }, Ot(i.options[0]), 3), b("div", {
        class: Ai("list-option" + (s.listType == 1 ? " active" : "")),
        onClick: t[8] || (t[8] = a => s.changeListType(1))
    }, Ot(i.options[1]), 3), uF]), b("ul", dF, [(st(!0), nt(Dt, null, Jt(s.list, (a, l) => (st(), nt("li", {
        key: l
    }, [ee(b("div", fF, [b("div", {
        class: "skin-card",
        style: $t({
            "background-image": s.checkSkin(a)
        }),
        onClick: c => s.emitter.emit("checkPlayer", a)
    }, null, 12, pF), (st(), nt("svg", {
        class: "online-state",
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "10",
        height: "10",
        transform: "translate(0,-1.5)",
        style: $t({
            fill: s.getOnlineColor(a)
        })
    }, gF, 4)), b("div", vF, Ot(a.tagNick), 1), b("div", {
        class: "item-latency",
        style: $t({
            color: s.getLatencyColor(a)
        })
    }, Ot(a.latency), 5)], 512), [
        [ye, a.enableChat]
    ])]))), 128))])])])
}
var yF = ue(U9, [
    ["render", _F],
    ["__scopeId", "data-v-82e9339a"]
]);
const bF = {
        name: "chat-room",
        components: {
            "chat-text": w9,
            "chat-input": O9,
            "chat-menu": yF,
            "common-select": Jy
        },
        setup() {
            const e = ft(null),
                t = ft(H.ShowChatRoom),
                i = Ft(() => zt.size ? zt.get(U.id) : null),
                s = ft(null),
                n = ft(null),
                r = Ft(() => {
                    let J = [];
                    return zt.forEach(wt => {
                        wt.msg.length && wt.enableChat && wt != n.value && J.push(wt)
                    }), J
                }),
                o = Ft(() => {
                    let J = [];
                    if (zt.size) {
                        let wt = i.value;
                        zt.forEach(Tt => {
                            Tt.nick != "Bot" && Tt.team == wt.team && Tt.enableChat && Tt.id != wt.id && J.push(Tt)
                        })
                    }
                    return J
                }),
                a = ft(!1);

            function l(J) {
                s.value = J, g(0)
            }
            A.on("checkPlayer", l);
            const c = ft({
                    left: "-235px",
                    opacity: 1,
                    transition: "0"
                }),
                h = ft(null);
            let u = null;
            const d = Ft(() => {
                const J = h.value;
                if (!J) return "";
                const wt = J.msg.length;
                return J.msg[wt - 1][4]
            });
            A.on("receiveChatMsg", ({
                type: J,
                id: wt,
                msg: Tt,
                toId: Bt
            }) => {
                if (J == 3)
                    if (Bt == U.id) {
                        let kt = zt.get(wt);
                        if (kt.block) return;
                        if (kt.msg.push([mu(), 3, kt.tag + kt.nick, lo(kt), Tt, kt]), K.value || (n.value = kt), u && clearTimeout(u), f.value == 3 && n.value == kt) {
                            C();
                            return
                        }
                        c.value = {
                            left: "-235px",
                            opacity: 1,
                            transition: "0s"
                        }, u = setTimeout(() => {
                            h.value = kt, c.value = {
                                left: "2px",
                                transition: "0.2s"
                            }, u = setTimeout(() => {
                                c.value = {
                                    left: "-10px",
                                    opacity: 0,
                                    transition: "0.125s"
                                }
                            }, 2e3)
                        }, 50)
                    } else {
                        let kt = zt.get(Bt);
                        kt.msg.push([mu(), 3, U.tag + U.nick, lo(U), Tt, kt]), C()
                    }
            });
            const f = ft(2),
                p = J => f.value == J ? "chat-room-label active" : "chat-room-label",
                m = Ft(() => {
                    const J = qy[yi("locale").value];
                    return [J.all, J.team, J.private]
                });

            function g(J) {
                switch (a.value = !1, O(J), J) {
                    case 0: {
                        a.value = !0;
                        break
                    }
                    case 1:
                        document.getElementById("clabel-all").style.boxShadow = null;
                        break;
                    case 2:
                        document.getElementById("clabel-team").style.boxShadow = null;
                        break;
                    case 3: {
                        f.value == J && Q();
                        break
                    }
                }
                f.value = J, J != 3 && n.value && !n.value.msg.length && !r.value.length && (n.value = null)
            }
            const y = ft(null),
                x = [],
                v = _i([]),
                _ = ft(f.value);

            function C() {
                const J = y.value;
                J.scroll(0, J.scrollHeight)
            }

            function k() {
                t.value = H.ShowChatRoom, St()
            }
            let S;

            function T({
                type: J,
                id: wt,
                msg: Tt
            }) {
                if (J == 3) return;
                let Bt, kt, re;
                wt === 0 ? Bt = "" : (re = zt.get(wt), Bt = re.tagNick, kt = lo(re));
                const Xt = [mu(), J, Bt, kt, Tt, re];
                x.push(Xt), (f.value == J || J == 4) && fa(() => {
                    fa(() => {
                        C()
                    })
                }), J == 1 && f.value != 1 ? document.getElementById("clabel-all").style.boxShadow = "inset 0 0 2.5px 0.1px var(--main-theme-color)" : J == 2 && f.value != 2 && (document.getElementById("clabel-team").style.boxShadow = "inset 0 0 2.5px 0.1px var(--main-theme-color)");
                let ce = S.length - 1;
                for (; ce >= 0; ce--)
                    if (Xt[1] == S[ce]) {
                        v.push(Xt), St();
                        return
                    } St()
            }

            function L() {
                x.length = 0, v.length = 0
            }

            function D(J) {
                at.writer.writeUint8(24).writeUint8(2).writeStringUTF8(J), at.send(), St()
            }

            function O(J) {
                switch (_.value = J, J) {
                    case 0:
                        return;
                    case 1:
                        S = [1, 4];
                        break;
                    case 2:
                        S = [2, 4];
                        break;
                    case 3:
                        return
                }
                v.length = 0, fa(() => x.forEach(wt => {
                    let Tt = S.length - 1;
                    for (; Tt >= 0; Tt--)
                        if (wt[1] == S[Tt]) {
                            v.push(wt);
                            return
                        }
                })), St()
            }
            const K = Ft(() => {
                    const J = n.value;
                    let wt = !1;
                    return J && (wt = J.enableChat), fa(() => {
                        !wt && r.value.length && (n.value = r.value[0])
                    }), wt
                }),
                P = ft(!1),
                N = ft("(-180deg)"),
                W = Ft(() => P.value ? 0 : -2 - 4 * 29 + "px"),
                V = Ft(() => P.value ? 1 : 0);

            function Q() {
                !r.value.length || (N.value = "(0deg)", P.value = !0, document.getElementById("clabel-private").classList.add("open"), document.getElementById("interlocutor-skin").style.opacity = 0, document.getElementById("list-hint").style.opacity = 1)
            }

            function pt() {
                N.value = "(-180deg)", P.value = !1, document.getElementById("clabel-private").classList.remove("open"), document.getElementById("interlocutor-skin").style.opacity = null, document.getElementById("list-hint").style.opacity = null
            }

            function bt(J) {
                n.value = J
            }
            let ct, gt;

            function xt() {
                clearTimeout(gt), clearTimeout(ct), e.value.style.opacity = 1, e.value.style.display = "block"
            }

            function It() {
                H.AutoHideChatRoom === 1 && (ct = setTimeout(() => {
                    e.value.style.opacity = 0, gt = setTimeout(() => {
                        e.value.style.opacity == 0 && (e.value.style.display = "none")
                    }, 1e3)
                }, 3e3))
            }

            function St() {
                xt(), It()
            }
            return Ve(() => {
                const J = e.value;
                J.style.userSelect = "none", J.addEventListener("mouseenter", () => {
                    J.style.userSelect = "auto", xt()
                }), J.addEventListener("mouseleave", () => {
                    J.style.userSelect = "none", !P.value && A.emit("focusGameCanvas")
                }), O(_.value), It()
            }), A.on("joinSelf", () => {
                s.value = U
            }), A.on(Ut.ShowChatRoom, k), A.on(Ut.AutoHideChatRoom, St), A.on("receiveChatMsg", T), A.on("clearChatMsg", L), A.on("sendQuickMsg", D), A.on("initGame", () => {
                s.value = null, n.value = null
            }), A.on("openDM", () => {
                g(3), n.value = s.value
            }), {
                box: e,
                boxState: t,
                chosenPlayer: s,
                interlocutor: n,
                dm: r,
                team: o,
                inMenu: a,
                nPlayer: h,
                nStyle: c,
                latestDM: d,
                checkSkin: lo,
                lbOpt: m,
                labelClass: p,
                click: g,
                container: y,
                displayType: _,
                displayMsg: v,
                changeDisplayType: O,
                fadeIn: xt,
                fadeOut: It,
                showDM: K,
                r: N,
                t: W,
                o: V,
                openDMList: Q,
                closeDMList: pt,
                changeInterlocutor: bt,
                list: Cp,
                play: Ap,
                spec: Qy
            }
        }
    },
    sl = e => (gs("data-v-36e688fb"), e = e(), vs(), e),
    xF = {
        id: "chat-room",
        ref: "box"
    },
    wF = {
        class: "notification-msg"
    },
    TF = {
        class: "chat-room-top"
    },
    EF = sl(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "20",
        height: "20",
        fill: "var(--main-theme-color)",
        transform: "translate(-0.5,-1.5)"
    }, [b("path", {
        d: "M341.333333 170.666667h554.666667v85.333333H341.333333V170.666667z m-213.333333-21.333334h128v128H128v-128z m0 298.666667h128v128H128v-128z m0 298.666667h128v128H128v-128zM341.333333 469.333333h554.666667v85.333334H341.333333v-85.333334z m0 298.666667h554.666667v85.333333H341.333333v-85.333333z"
    })], -1)),
    SF = [EF],
    CF = sl(() => b("path", {
        d: "M533.333333 465.066667L358.4 640 298.666667 580.266667l234.666666-234.666667 234.666667 234.666667-64 59.733333-170.666667-174.933333z"
    }, null, -1)),
    AF = [CF],
    IF = {
        id: "dm-list-outer"
    },
    MF = {
        class: "dm-list-item"
    },
    RF = ["title", "onClick"],
    kF = {
        id: "chat-room-outer"
    },
    PF = {
        class: "chat-room-inner tab-content box-container"
    },
    LF = {
        class: "scroll-container",
        ref: "container"
    },
    OF = {
        class: "player-info"
    },
    DF = {
        class: "player-play"
    },
    NF = sl(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "18",
        height: "18",
        fill: "var(--main-theme-color)",
        transform: "translate(2,-1.5)"
    }, [b("path", {
        d: "M512 96C282.624 96 96 282.624 96 512s186.624 416 416 416 416-186.624 416-416S741.376 96 512 96z m0 768C317.92 864 160 706.08 160 512S317.92 160 512 160s352 157.92 352 352-157.92 352-352 352z"
    }), b("path", {
        d: "M466.816 324.96a32 32 0 0 0-50.816 25.888v339.776a32 32 0 0 0 50.816 25.856l233.6-169.888a32 32 0 0 0 0-51.776l-233.6-169.856z"
    })], -1)),
    FF = {
        class: "player-spec"
    },
    BF = sl(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "18",
        height: "18",
        fill: "var(--main-theme-color)",
        transform: "translate(2,-1.5)"
    }, [b("path", {
        d: "M512 277.333333c242.432 0 384 195.541333 384 234.666667 0 39.125333-141.568 234.666667-384 234.666667S128 551.125333 128 512C128 472.874667 269.568 277.333333 512 277.333333zM512 341.333333a170.666667 170.666667 0 1 0 0 341.333334 170.666667 170.666667 0 0 0 0-341.333334z"
    }), b("path", {
        d: "M512 512m-128 0a128 128 0 1 0 256 0 128 128 0 1 0-256 0Z"
    })], -1)),
    UF = {
        class: "player-total"
    },
    GF = sl(() => b("svg", {
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "18",
        height: "18",
        fill: "var(--main-theme-color)",
        transform: "translate(2,-1.5)"
    }, [b("path", {
        d: "M261.7 522.6h0.2c19.3 0 35-15.7 35-35s-15.7-35-35-35c-31.9 0-58.8-37.7-58.8-82.4s26.9-82.4 58.8-82.4c19.3 0 35-15.7 35-35s-15.7-35-35-35c-35.4 0-69.5 17.3-93.7 47.5-22.6 28.4-35.1 65.6-35.1 104.9s12.5 76.5 35.1 104.9c0.6 0.8 1.3 1.6 2 2.4-22.9 13.2-43.4 31-61.1 53.2-38.3 48-59.5 111.4-59.5 178.4 0 19.3 15.7 35 35 35s35-15.7 35-35c0-51.2 15.7-99.1 44.1-134.7 26.6-33.3 61.3-51.7 97.7-51.7 0.2 0 0.3-0.1 0.3-0.1zM914.8 530.7c-17.7-22.2-38.2-40-61.1-53.2 0.7-0.8 1.3-1.6 2-2.4 22.6-28.4 35.1-65.6 35.1-104.9s-12.5-76.5-35.1-104.9c-24.1-30.2-58.3-47.5-93.7-47.5-19.3 0-35 15.7-35 35s15.7 35 35 35c31.9 0 58.8 37.7 58.8 82.4s-26.9 82.4-58.8 82.4c-19.3 0-35 15.7-35 35s15.7 35 35 35H762.3c36.4 0 71.1 18.4 97.7 51.7 28.5 35.6 44.1 83.5 44.1 134.7 0 19.3 15.7 35 35 35s35-15.7 35-35c0.2-67-21-130.3-59.3-178.3z"
    }), b("path", {
        d: "M747.4 541c-30.9-30.8-66.9-54.7-106.1-70.8 40.3-34.7 65.8-86 65.8-143.2 0-104.2-84.8-188.9-188.9-188.9-104.2 0-188.9 84.8-188.9 188.9 0 57 25.4 108.2 65.4 142.9C355.2 486 318.9 510 287.8 541c-61.2 61.1-95.1 142.4-95.5 228.9V850.8c0 19.3 15.7 35 35 35h580.5c19.3 0 35-15.7 35-35v-80.2-0.8c-0.3-86.4-34.2-167.6-95.4-228.8zM518.2 208.1c65.6 0 118.9 53.4 118.9 118.9s-53.4 118.9-118.9 118.9S399.3 392.6 399.3 327s53.4-118.9 118.9-118.9z m254.7 607.8H262.3v-44.6-0.6c0.2-140.5 114.8-254.8 255.3-254.8s255 114.3 255.3 254.8v45.2z"
    })], -1));

function HF(e, t, i, s, n, r) {
    const o = se("chat-menu"),
        a = se("chat-input");
    return st(), nt(Dt, null, [ee(b("div", xF, [b("div", {
        id: "dm-notification",
        style: $t(s.nStyle)
    }, [b("div", {
        class: "notification-avatar",
        style: $t({
            "background-image": s.checkSkin(s.nPlayer)
        })
    }, null, 4), b("div", wF, Ot(s.latestDM), 1)], 4), b("nav", TF, [b("div", {
        class: Ai(s.labelClass(0)),
        id: "clabel-menu",
        onClick: t[0] || (t[0] = l => s.click(0))
    }, SF, 2), b("div", {
        class: Ai(s.labelClass(1)),
        id: "clabel-all",
        onClick: t[1] || (t[1] = l => s.click(1))
    }, Ot(" " + s.lbOpt[0] + " "), 3), b("div", {
        class: Ai(s.labelClass(2)),
        id: "clabel-team",
        onClick: t[2] || (t[2] = l => s.click(2))
    }, Ot(" " + s.lbOpt[1] + " "), 3), b("div", {
        class: Ai(s.labelClass(3)),
        id: "clabel-private",
        tabindex: "-1",
        style: $t({
            paddingRight: "1px",
            display: s.showDM ? "block" : "none"
        }),
        onClick: t[3] || (t[3] = l => s.click(3)),
        onBlur: t[4] || (t[4] = (...l) => s.closeDMList && s.closeDMList(...l))
    }, [(st(), nt("svg", {
        id: "list-hint",
        viewBox: "0 0 1024 1024",
        xmlns: "http://www.w3.org/2000/svg",
        width: "24",
        height: "24",
        fill: "#707070",
        style: $t({
            transform: "rotateZ" + s.r,
            opacity: s.dm.length ? null : 0
        })
    }, AF, 4)), b("div", {
        id: "interlocutor-skin",
        style: $t({
            backgroundImage: s.checkSkin(s.interlocutor),
            opacity: s.dm.length ? null : 1
        })
    }, null, 4), b("div", IF, [b("ul", {
        id: "dm-list-inner",
        style: $t({
            marginTop: s.t,
            opacity: s.o
        })
    }, [(st(!0), nt(Dt, null, Jt(s.dm, (l, c) => (st(), nt("li", {
        key: c
    }, [b("div", MF, [b("div", {
        class: "item-skin",
        title: l.tagNick,
        style: $t({
            "background-image": s.checkSkin(l)
        }),
        onClick: h => s.changeInterlocutor(l)
    }, null, 12, RF)])]))), 128))], 4)])], 38)]), b("div", kF, [ee(b("div", PF, [b("div", LF, [(st(!0), nt(Dt, null, Jt(s.displayType == 3 ? s.interlocutor.msg : s.displayMsg, (l, c) => (st(), If(De("chat-text"), {
        key: c,
        time: l[0],
        type: l[1],
        nick: l[2],
        skin: l[3],
        msg: l[4],
        player: l[5]
    }, null, 8, ["time", "type", "nick", "skin", "msg", "player"]))), 128))], 512)], 512), [
        [ye, !s.inMenu]
    ]), ee(X(o, {
        player: s.chosenPlayer,
        options: s.lbOpt
    }, null, 8, ["player", "options"]), [
        [ye, s.inMenu]
    ])]), b("div", OF, [b("div", DF, [NF, po(" " + Ot(s.play), 1)]), b("div", FF, [BF, po(" " + Ot(s.spec), 1)]), b("div", UF, [GF, po(" " + Ot(s.list.length), 1)])])], 512), [
        [ye, s.boxState]
    ]), X(a, {
        type: s.displayType,
        toId: s.interlocutor ? s.interlocutor.id : 0,
        onShow: s.fadeIn,
        onHide: s.fadeOut
    }, null, 8, ["type", "toId", "onShow", "onHide"])], 64)
}
var VF = ue(bF, [
    ["render", HF],
    ["__scopeId", "data-v-36e688fb"]
]);
const zF = {
    name: "hint",
    setup() {
        const e = Ft(() => Ny[yi("locale").value]),
            t = ft(null),
            i = ft(null);
        let s;
        A.on("signalHint", ([o, a]) => {
            clearTimeout(s), t.value = o, i.value = Qa(a);
            const l = document.getElementById("signal-hint");
            l.style.visibility = "visible", l.style.transition = "opacity 0.35s", l.style.opacity = 1, s = setTimeout(() => {
                l.style.transition = "0.75s", l.style.opacity = 0, l.style.visibility = "hidden"
            }, 1600)
        });
        const n = ft(null),
            r = ft(null);
        return A.on("endMainPacket", () => {
            if (U.state < 2) {
                n.value = null;
                return
            }
            if (U.specMode == 2) {
                let a;
                zt.forEach(l => {
                    l.isBot || (!a || l.totalMass > a.totalMass) && (a = l)
                }), n.value = a
            } else U.specMode == 1 ? n.value = null : U.specMode == 0 && (n.value = U.specTarget);
            const o = n.value;
            o && (r.value = o.nick + "\u2014" + (o.totalMass / 1e3).toFixed(1) + "K")
        }), {
            emitter: A,
            t: e,
            sender: t,
            hintColor: i,
            specTarget: n,
            specInfo: r,
            checkSkin: lo
        }
    }
};

function $F(e, t, i, s, n, r) {
    return st(), nt(Dt, null, [b("div", {
        id: "signal-hint",
        onClick: t[0] || (t[0] = o => s.emitter.emit("checkPlayer", s.sender))
    }, [b("div", {
        id: "signal-color",
        style: $t({
            boxShadow: "0 0 16px 4px " + s.hintColor
        })
    }, null, 4), b("div", {
        id: "sender-avatar",
        style: $t({
            backgroundImage: s.checkSkin(s.sender)
        })
    }, null, 4), po(" " + Ot((s.sender ? s.sender.nick : "") + " " + s.t.mouse.signalHint), 1)]), ee(b("div", {
        id: "spec-hint",
        onClick: t[1] || (t[1] = o => s.emitter.emit("checkPlayer", s.specTarget))
    }, [b("div", {
        id: "spec-avatar",
        style: $t({
            backgroundImage: s.checkSkin(s.specTarget)
        })
    }, null, 4), po(" " + Ot(s.specInfo), 1)], 512), [
        [ye, s.specTarget && s.specTarget.cellCount]
    ])], 64)
}
var jF = ue(zF, [
    ["render", $F],
    ["__scopeId", "data-v-5d08d3b5"]
]);
const WF = {
    name: "home",
    components: {
        "main-menu": eO,
        "setting-menu": d9,
        "chat-room": VF,
        "replay-bar": wh,
        hint: jF
    },
    setup() {
        const e = ft(!1),
            t = ft(!0),
            i = new Vt(() => {
                !t.value && !e.value ? s() : n()
            });

        function s() {
            A.emit("clearEvent"), document.body.querySelector("canvas").blur(), H.PauseAfterOpeningMenu && (at.writer.writeUint8(6).writeUint8(1), at.send()), t.value = !0
        }

        function n() {
            if (A.emit("focusGameCanvas"), e.value) {
                e.value = !1;
                return
            }
            U.pause && (at.writer.writeUint8(6).writeUint8(2), at.send()), t.value = !1
        }

        function r(u) {
            typeof u < "u" ? e.value = u : e.value ^= 1, e.value && (t.value = !1, A.emit("hotkeyCheck"))
        }

        function o() {
            !t.value && H.ShowMenuAfterDeath && (n(), s())
        }
        const a = new Vt(() => {
            A.emit("quickStart")
        });

        function l(u) {
            const d = yo(u);
            d === "Escape" ? i.execute() : d === bi.Respawn && U.currentOpUnit.cellCount == 0 && (u.preventDefault(), u.stopImmediatePropagation(), a.execute())
        }

        function c(u) {
            const d = yo(u);
            d === "Escape" ? i.end() : d === bi.Respawn && a.end()
        }

        function h(u) {
            yo(u) === bi.Respawn && u.stopPropagation()
        }
        return Ve(() => {}), document.addEventListener("mousedown", u => {
            u.button > 2 && u.preventDefault()
        }), document.addEventListener("mouseup", u => {
            u.button > 2 && u.preventDefault()
        }), document.addEventListener("keydown", l), document.addEventListener("keyup", c), A.on("switchMenu", u => {
            u ? s() : n()
        }), A.on("switchSettings", r), A.on("menuHide", n), A.on("death", o), {
            menuState: t,
            settingsState: e,
            menuShow: s,
            menuHide: n,
            switchSettings: r,
            checkBubble: h
        }
    }
};

function XF(e, t, i, s, n, r) {
    const o = se("main-menu"),
        a = se("setting-menu"),
        l = se("chat-room"),
        c = se("replay-bar"),
        h = se("hint");
    return st(), nt("div", {
        onKeydown: t[0] || (t[0] = (...u) => s.checkBubble && s.checkBubble(...u))
    }, [X(o, {
        ref: "menuEl",
        menuState: s.menuState
    }, null, 8, ["menuState"]), ee(X(a, null, null, 512), [
        [ye, s.settingsState]
    ]), X(l), X(c), X(h)], 32)
}
var YF = ue(WF, [
    ["render", XF]
]);
const KF = {
    name: "App",
    components: {
        home: YF
    },
    setup() {
        Uv("locale", ft(JM));

        function e(i) {
            ((i.ctrlKey === !0 || i.metaKey === !0) && (i.code === "Minus" || i.code === "Equal") || i.code === "NumpadAdd" || i.code === "NumpadSubtract") && i.preventDefault()
        }

        function t(i) {
            (i.ctrlKey || i.metaKey) && i.preventDefault()
        }
        window.oncontextmenu = () => !1, document.addEventListener("keydown", e), document.addEventListener("wheel", t, {
            passive: !1
        })
    }
};

function ZF(e, t, i, s, n, r) {
    const o = se("home");
    return st(), If(o)
}
var qF = ue(KF, [
    ["render", ZF]
]);
A.on("startClient", () => {
    const e = "#app";
    SC(qF).mount(e), new V8(e)
});